"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _context, _ipfs;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpfsPinning = void 0;
const ipfs_http_client_1 = __importDefault(require("ipfs-http-client"));
const FROM_CONTEXT = '__context';
class IpfsPinning {
    constructor(connectionString, context) {
        _context.set(this, void 0);
        _ipfs.set(this, void 0);
        if (connectionString == 'ipfs+context') {
            this.ipfsAddress = FROM_CONTEXT;
        }
        else {
            const url = new URL(connectionString);
            const ipfsHost = url.hostname;
            const ipfsPort = parseInt(url.port, 10) || 5001;
            const protocol = url.protocol
                .replace('ipfs+http:', 'http')
                .replace('ipfs+https:', 'https')
                .replace('ipfs+context:', FROM_CONTEXT);
            if (protocol === FROM_CONTEXT) {
                this.ipfsAddress = FROM_CONTEXT;
            }
            else {
                this.ipfsAddress = `${protocol}://${ipfsHost}:${ipfsPort}`;
            }
        }
        __classPrivateFieldSet(this, _context, context);
    }
    get ipfs() {
        return __classPrivateFieldGet(this, _ipfs);
    }
    async open() {
        if (this.ipfsAddress === FROM_CONTEXT) {
            __classPrivateFieldSet(this, _ipfs, __classPrivateFieldGet(this, _context).ipfs);
        }
        else {
            __classPrivateFieldSet(this, _ipfs, ipfs_http_client_1.default({
                url: this.ipfsAddress
            }));
        }
    }
    async close() {
    }
    async pin(cid) {
        await __classPrivateFieldGet(this, _ipfs).pin.add(cid, { recursive: false });
    }
    async unpin(cid) {
        await __classPrivateFieldGet(this, _ipfs).pin.rm(cid);
    }
}
exports.IpfsPinning = IpfsPinning;
_context = new WeakMap(), _ipfs = new WeakMap();
IpfsPinning.designator = 'ipfs';
//# sourceMappingURL=ipfs-pinning.js.map
import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_joi_browser_min
} from "./chunk-JOA72Z5J.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/@web3-onboard/walletconnect/dist/index.js
var import_dist7 = __toESM(require_dist());
var import_dist8 = __toESM(require_dist2());
var import_dist9 = __toESM(require_dist3());

// node_modules/@web3-onboard/walletconnect/dist/validation.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_joi = __toESM(require_joi_browser_min(), 1);
var wcOptions = import_joi.default.object({
  handleUri: import_joi.default.func().optional(),
  version: import_joi.default.number().optional().custom((value, helpers) => {
    if (value === 1) {
      console.warn("Version 1 of WalletConnect has been fully deprecated. This version of @web3-onboard/walletconnect only supports version 2");
    } else if (value !== 2 && value !== void 0) {
      return helpers.error("any.invalid", {
        message: "Invalid version number. This version of @web3-onboard/walletconnect only supports version 2"
      });
    }
    return value;
  }, "Custom version validation"),
  projectId: import_joi.default.string().messages({
    "any.required": `WalletConnect version 2 requires a projectId. Please visit https://cloud.walletconnect.com to get one.`
  }),
  dappUrl: import_joi.default.string().optional().custom((value, helpers) => {
    if (!value) {
      return helpers.message({
        message: "It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection.",
        type: "any.custom"
      });
    }
    return value;
  }, "Custom dappUrl validation"),
  requiredChains: import_joi.default.array().items(import_joi.default.number()).optional(),
  optionalChains: import_joi.default.array().items(import_joi.default.number()).optional(),
  qrModalOptions: import_joi.default.object().optional(),
  additionalRequiredMethods: import_joi.default.array().items(import_joi.default.string()).optional(),
  additionalOptionalMethods: import_joi.default.array().items(import_joi.default.string()).optional()
});
var validate = (validator, data) => {
  const result = validator.validate(data);
  return result.error ? result : null;
};
var validateWCInitOptions = (data) => {
  return validate(wcOptions, data);
};

// node_modules/@web3-onboard/walletconnect/dist/walletConnect.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var methods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "personal_sign",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v4",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain"
];
function walletConnect(options) {
  if (!options.projectId) {
    throw new Error("WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one.");
  }
  if (!options.dappUrl) {
    console.warn(`It is strongly recommended to supply a dappUrl to the WalletConnect init object as it is required by some wallets (i.e. MetaMask) to allow connection.`);
  }
  const { projectId, handleUri, requiredChains, optionalChains, qrModalOptions, additionalRequiredMethods, additionalOptionalMethods, dappUrl } = options;
  let instance;
  return () => {
    return {
      label: "WalletConnect",
      getIcon: async () => (await import("./icon-P5YBYASQ.js")).default,
      getInterface: async ({ chains, EventEmitter, appMetadata }) => {
        const { ProviderRpcError, ProviderRpcErrorCode } = await import("./dist-NN3PWSNU.js");
        const { default: EthereumProvider, REQUIRED_METHODS } = await import("./index.es-NBPQ4S4X.js");
        const { Subject, fromEvent } = await import("./esm5-XSMOUEXI.js");
        const { takeUntil, take } = await import("./operators-WEDYJCU4.js");
        const getMetaData = () => {
          if (!appMetadata)
            return void 0;
          const url = dappUrl || appMetadata.explore || "";
          !url && !url.length && console.warn(`It is strongly recommended to supply a dappUrl as it is required by some wallets (i.e. MetaMask) to allow connection.`);
          const wcMetaData = {
            name: appMetadata.name,
            description: appMetadata.description || "",
            url,
            icons: []
          };
          if (appMetadata.icon !== void 0 && appMetadata.icon.length) {
            wcMetaData.icons = [appMetadata.icon];
          }
          if (appMetadata.logo !== void 0 && appMetadata.logo.length) {
            wcMetaData.icons = wcMetaData.icons.length ? [...wcMetaData.icons, appMetadata.logo] : [appMetadata.logo];
          }
          return wcMetaData;
        };
        const requiredChainsParsed = Array.isArray(requiredChains) && requiredChains.length && requiredChains.every((num) => !isNaN(num)) ? (
          // @ts-ignore
          // Required as WC package does not support hex numbers
          requiredChains.map((chainID) => parseInt(chainID))
        ) : [];
        const optionalChainsParsed = Array.isArray(optionalChains) && optionalChains.length && optionalChains.every((num) => !isNaN(num)) ? (
          // @ts-ignore
          // Required as WC package does not support hex numbers
          optionalChains.map((chainID) => parseInt(chainID))
        ) : chains.map(({ id }) => parseInt(id, 16));
        const requiredMethodsSet = new Set(additionalRequiredMethods && Array.isArray(additionalRequiredMethods) ? [...additionalRequiredMethods, ...REQUIRED_METHODS] : REQUIRED_METHODS);
        const requiredMethods = Array.from(requiredMethodsSet);
        const optionalMethods = additionalOptionalMethods && Array.isArray(additionalOptionalMethods) ? [...additionalOptionalMethods, ...methods] : methods;
        const connector = await EthereumProvider.init({
          projectId,
          chains: requiredChainsParsed,
          // default to mainnet
          methods: requiredMethods,
          optionalChains: optionalChainsParsed,
          optionalMethods,
          showQrModal: true,
          rpcMap: chains.map(({ id, rpcUrl }) => ({ id, rpcUrl })).reduce((rpcMap, { id, rpcUrl }) => {
            rpcMap[parseInt(id, 16)] = rpcUrl || "";
            return rpcMap;
          }, {}),
          metadata: getMetaData(),
          qrModalOptions
        });
        const emitter = new EventEmitter();
        class EthProvider {
          constructor({ connector: connector2, chains: chains2 }) {
            this.emit = emitter.emit.bind(emitter);
            this.on = emitter.on.bind(emitter);
            this.removeListener = emitter.removeListener.bind(emitter);
            this.connector = connector2;
            this.chains = chains2;
            this.disconnected$ = new Subject();
            fromEvent(this.connector, "accountsChanged", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: (payload) => {
                const accounts = Array.isArray(payload) ? payload : [payload];
                this.emit("accountsChanged", accounts);
              },
              error: console.warn
            });
            fromEvent(this.connector, "chainChanged", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: (chainId) => {
                const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                this.emit("chainChanged", hexChainId);
              },
              error: console.warn
            });
            fromEvent(this.connector, "session_delete", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe({
              next: () => {
                this.emit("accountsChanged", []);
                this.disconnected$.next(true);
                typeof localStorage !== "undefined" && localStorage.removeItem("walletconnect");
              },
              error: console.warn
            });
            this.disconnect = () => {
              if (this.connector.session) {
                this.connector.disconnect();
                instance = null;
              }
            };
            if (options && handleUri) {
              fromEvent(this.connector, "display_uri", (payload) => payload).pipe(takeUntil(this.disconnected$)).subscribe(async (uri) => {
                try {
                  handleUri && await handleUri(uri);
                } catch (error) {
                  throw `An error occurred when handling the URI. Error: ${error}`;
                }
              });
            }
            const checkForSession = () => {
              const session = this.connector.session;
              instance = session;
              if (session) {
                this.emit("accountsChanged", this.connector.accounts);
                this.emit("chainChanged", this.connector.chainId);
              }
            };
            checkForSession();
            this.request = async ({ method, params }) => {
              if (method === "eth_chainId") {
                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;
              }
              if (method === "eth_requestAccounts") {
                return new Promise(async (resolve, reject) => {
                  fromEvent(this.connector, "connect", (payload) => payload).pipe(take(1)).subscribe({
                    next: ({ chainId }) => {
                      this.emit("accountsChanged", this.connector.accounts);
                      const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;
                      this.emit("chainChanged", hexChainId);
                      resolve(this.connector.accounts);
                    },
                    error: reject
                  });
                  if (!this.connector.session) {
                    await this.connector.connect().catch((err) => {
                      console.error("err creating new session: ", err);
                      reject(new ProviderRpcError({
                        code: 4001,
                        message: "User rejected the request."
                      }));
                    });
                  } else {
                    const accounts = this.connector.accounts;
                    const chainId = this.connector.chainId;
                    instance = this.connector.session;
                    const hexChainId = `0x${chainId.toString(16)}`;
                    this.emit("chainChanged", hexChainId);
                    return resolve(accounts);
                  }
                });
              }
              if (method === "eth_selectAccounts") {
                throw new ProviderRpcError({
                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,
                  message: `The Provider does not support the requested method: ${method}`
                });
              }
              if (method == "wallet_switchEthereumChain") {
                if (!params) {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                const chainIdObj = params[0];
                if (!chainIdObj.hasOwnProperty("chainId") || typeof chainIdObj["chainId"] === "undefined") {
                  throw new ProviderRpcError({
                    code: ProviderRpcErrorCode.INVALID_PARAMS,
                    message: `The Provider requires a chainId to be passed in as an argument`
                  });
                }
                return this.connector.request({
                  method: "wallet_switchEthereumChain",
                  params: [
                    {
                      chainId: chainIdObj.chainId
                    }
                  ]
                });
              }
              return this.connector.request({
                method,
                params
              });
            };
          }
        }
        return {
          provider: new EthProvider({ chains, connector }),
          instance
        };
      }
    };
  };
}
var walletConnect_default = walletConnect;

// node_modules/@web3-onboard/walletconnect/dist/index.js
var isHexString = (value) => {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  return true;
};
function initWalletConnect(options) {
  if (!options) {
    throw new Error(`WalletConnect requires an initialization object to be passed - see the official docs for an example: https://onboard.blocknative.com/docs/wallets/walletconnect`);
  }
  if (options) {
    const error = validateWCInitOptions(options);
    if (error) {
      throw error;
    }
  }
  return walletConnect_default(options);
}
var dist_default = initWalletConnect;

export {
  isHexString,
  dist_default
};
//# sourceMappingURL=chunk-ZTSKQ3OA.js.map

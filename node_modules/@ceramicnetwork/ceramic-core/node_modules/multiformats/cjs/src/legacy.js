'use strict';

var bytes = require('./bytes.js');
var CID = require('cids');
var buffer = require('buffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var CID__default = /*#__PURE__*/_interopDefaultLegacy(CID);

const legacy = (multiformats, name) => {
  const toLegacy = obj => {
    if (CID__default['default'].isCID(obj)) {
      return obj;
    }
    const cid = multiformats.CID.asCID(obj);
    if (cid) {
      const {version, multihash: {buffer: buffer$1, byteOffset, byteLength}} = cid;
      const {name} = multiformats.multicodec.get(cid.code);
      const multihash = buffer.Buffer.from(buffer$1, byteOffset, byteLength);
      return new CID__default['default'](version, name, buffer.Buffer.from(multihash));
    }
    if (bytes.isBinary(obj)) return buffer.Buffer.from(obj);
    if (obj && typeof obj === 'object') {
      for (const [key, value] of Object.entries(obj)) {
        obj[key] = toLegacy(value);
      }
    }
    return obj;
  };
  const fromLegacy = obj => {
    const cid = multiformats.CID.asCID(obj);
    if (cid) return cid;
    if (bytes.isBinary(obj)) return bytes.coerce(obj);
    if (obj && typeof obj === 'object') {
      for (const [key, value] of Object.entries(obj)) {
        obj[key] = fromLegacy(value);
      }
    }
    return obj;
  };
  const format = multiformats.multicodec.get(name);
  const serialize = o => buffer.Buffer.from(format.encode(fromLegacy(o)));
  const deserialize = b => toLegacy(format.decode(bytes.coerce(b)));
  const cid = async (buff, opts) => {
    const defaults = {
      cidVersion: 1,
      hashAlg: 'sha2-256'
    };
    const {cidVersion, hashAlg} = {
      ...defaults,
      ...opts
    };
    const hash = await multiformats.multihash.hash(buff, hashAlg);
    return new CID__default['default'](cidVersion, name, buffer.Buffer.from(hash));
  };
  const resolve = (buff, path) => {
    let value = format.decode(buff);
    path = path.split('/').filter(x => x);
    while (path.length) {
      value = value[path.shift()];
      if (typeof value === 'undefined') throw new Error('Not found');
      if (CID__default['default'].isCID(value)) {
        return {
          value,
          remainderPath: path.join('/')
        };
      }
    }
    return {
      value
    };
  };
  const _tree = function* (value, path = []) {
    if (typeof value === 'object') {
      for (const [key, val] of Object.entries(value)) {
        yield ['', ...path, key].join('/');
        if (typeof val === 'object' && !buffer.Buffer.isBuffer(val) && !CID__default['default'].isCID(val)) {
          yield* _tree(val, [...path, key]);
        }
      }
    }
  };
  const tree = buff => {
    return _tree(format.decode(buff));
  };
  const codec = format.code;
  const defaultHashAlg = 'sha2-256';
  const util = {
    serialize,
    deserialize,
    cid
  };
  const resolver = {
    resolve,
    tree
  };
  return {
    defaultHashAlg,
    codec,
    util,
    resolver
  };
};

module.exports = legacy;

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDoctypeHandler = void 0;
const didJwt = __importStar(require("did-jwt"));
const base64url_1 = __importDefault(require("base64url"));
const fast_json_patch_1 = __importDefault(require("fast-json-patch"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const tile_doctype_1 = require("./tile-doctype");
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const DOCTYPE = 'tile';
class TileDoctypeHandler {
    get name() {
        return DOCTYPE;
    }
    get doctype() {
        return tile_doctype_1.TileDoctype;
    }
    async create(params, context, opts) {
        return tile_doctype_1.TileDoctype.create(params, context, opts);
    }
    async applyRecord(record, cid, context, state) {
        if (state == null) {
            return this._applyGenesis(record, cid, context);
        }
        if (record.proof) {
            const proofRecord = (await context.ipfs.dag.get(record.proof)).value;
            return this._applyAnchor(record, proofRecord, cid, state);
        }
        return this._applySigned(record, cid, state, context);
    }
    async _applyGenesis(record, cid, context) {
        let payload = record;
        const isSigned = ceramic_common_1.DoctypeUtils.isSignedRecord(record);
        if (isSigned) {
            payload = (await context.ipfs.dag.get(record.link)).value;
            await this._verifySignature(record, context, payload.header.controllers[0]);
        }
        else if (payload.data !== null) {
            throw Error('Genesis record with contents should always be signed');
        }
        return {
            doctype: DOCTYPE,
            content: payload.data,
            metadata: payload.header,
            signature: isSigned ? ceramic_common_1.SignatureStatus.SIGNED : ceramic_common_1.SignatureStatus.GENESIS,
            anchorStatus: ceramic_common_1.AnchorStatus.NOT_REQUESTED,
            log: [cid]
        };
    }
    async _applySigned(record, cid, state, context) {
        var _a;
        await this._verifySignature(record, context, state.metadata.controllers[0]);
        const payload = (await context.ipfs.dag.get(record.link)).value;
        if (!payload.id.equals(state.log[0])) {
            throw new Error(`Invalid docId ${payload.id}, expected ${state.log[0]}`);
        }
        const nextState = lodash_clonedeep_1.default(state);
        nextState.signature = ceramic_common_1.SignatureStatus.SIGNED;
        nextState.anchorStatus = ceramic_common_1.AnchorStatus.NOT_REQUESTED;
        const nonce = payload.header.nonce;
        const squash = nonce > 0 && state.next;
        if (squash) {
            nextState.log[nextState.log.length - 1] = cid;
            nextState.next = {
                content: fast_json_patch_1.default.applyPatch(state.next.content, payload.data).newDocument
            };
        }
        else {
            nextState.log.push(cid);
            nextState.next = {
                content: fast_json_patch_1.default.applyPatch(state.content, payload.data).newDocument
            };
        }
        let nextMetadata = nextState.metadata;
        if ((_a = payload.header) === null || _a === void 0 ? void 0 : _a.controllers) {
            nextState.next.metadata = { ...nextMetadata, controllers: payload.header.controllers };
            nextMetadata = nextState.next.metadata;
        }
        if (nonce) {
            nextState.next.metadata = { ...nextMetadata, nonce: nonce };
        }
        return nextState;
    }
    async _applyAnchor(record, proof, cid, state) {
        var _a, _b;
        state.log.push(cid);
        let content = state.content;
        let metadata = state.metadata;
        if ((_a = state.next) === null || _a === void 0 ? void 0 : _a.content) {
            content = state.next.content;
            delete state.next.content;
        }
        if ((_b = state.next) === null || _b === void 0 ? void 0 : _b.metadata) {
            metadata = state.next.metadata;
            delete state.next.metadata;
        }
        delete state.next;
        return {
            ...state, content, metadata, anchorStatus: ceramic_common_1.AnchorStatus.ANCHORED, anchorProof: proof,
        };
    }
    async _verifySignature(record, context, did) {
        const { payload, signatures } = record;
        const { signature, protected: _protected } = signatures[0];
        const decodedHeader = JSON.parse(base64url_1.default.decode(_protected));
        const { kid } = decodedHeader;
        if (!kid.startsWith(did)) {
            throw new Error(`Signature was made with wrong DID. Expected: ${did}, got: ${kid}`);
        }
        const { publicKey } = await context.resolver.resolve(kid);
        const jws = [_protected, payload, signature].join('.');
        try {
            await this.verifyJWS(jws, publicKey);
        }
        catch (e) {
            throw new Error('Invalid signature for signed record. ' + e);
        }
    }
    async verifyJWS(jws, pubkeys) {
        await didJwt.verifyJWS(jws, pubkeys);
    }
}
exports.TileDoctypeHandler = TileDoctypeHandler;
//# sourceMappingURL=tile-doctype-handler.js.map
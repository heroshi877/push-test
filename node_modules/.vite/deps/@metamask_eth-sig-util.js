import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_dist as require_dist4
} from "./chunk-WEDMEPBS.js";
import "./chunk-P3I2NXDV.js";
import "./chunk-Y5AIFJKZ.js";
import {
  require_nacl_fast,
  require_nacl_util
} from "./chunk-WQ42LN3A.js";
import {
  require_lib
} from "./chunk-XTGAQBSB.js";
import "./chunk-D4NVBJN6.js";
import {
  require_bn
} from "./chunk-7LYDIDA4.js";
import "./chunk-D2UFQSSP.js";
import "./chunk-LPS2SYRB.js";
import "./chunk-KLW5T4S3.js";
import "./chunk-644CRGRM.js";
import "./chunk-FI2GMLQC.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/@metamask/eth-sig-util/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
    var ethereumjs_util_1 = require_dist4();
    var ethjs_util_1 = require_lib();
    function padWithZeroes(hexString, targetLength) {
      if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
      }
      if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
      }
      return String.prototype.padStart.call(hexString, targetLength, "0");
    }
    exports.padWithZeroes = padWithZeroes;
    function isNullish(value) {
      return value === null || value === void 0;
    }
    exports.isNullish = isNullish;
    function legacyToBuffer(value) {
      return typeof value === "string" && !ethjs_util_1.isHexString(value) ? Buffer.from(value) : ethereumjs_util_1.toBuffer(value);
    }
    exports.legacyToBuffer = legacyToBuffer;
    function concatSig(v, r, s) {
      const rSig = ethereumjs_util_1.fromSigned(r);
      const sSig = ethereumjs_util_1.fromSigned(s);
      const vSig = ethereumjs_util_1.bufferToInt(v);
      const rStr = padWithZeroes(ethereumjs_util_1.toUnsigned(rSig).toString("hex"), 64);
      const sStr = padWithZeroes(ethereumjs_util_1.toUnsigned(sSig).toString("hex"), 64);
      const vStr = ethjs_util_1.stripHexPrefix(ethjs_util_1.intToHex(vSig));
      return ethereumjs_util_1.addHexPrefix(rStr.concat(sStr, vStr));
    }
    exports.concatSig = concatSig;
    function recoverPublicKey(messageHash, signature) {
      const sigParams = ethereumjs_util_1.fromRpcSig(signature);
      return ethereumjs_util_1.ecrecover(messageHash, sigParams.v, sigParams.r, sigParams.s);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function normalize(input) {
      if (!input) {
        return void 0;
      }
      if (typeof input === "number") {
        const buffer = ethereumjs_util_1.toBuffer(input);
        input = ethereumjs_util_1.bufferToHex(buffer);
      }
      if (typeof input !== "string") {
        let msg = "eth-sig-util.normalize() requires hex string or integer input.";
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
      }
      return ethereumjs_util_1.addHexPrefix(input.toLowerCase());
    }
    exports.normalize = normalize;
  }
});

// node_modules/@metamask/eth-sig-util/dist/personal-sign.js
var require_personal_sign = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/personal-sign.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
    var ethereumjs_util_1 = require_dist4();
    var utils_1 = require_utils();
    function personalSign({ privateKey, data }) {
      if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const message = utils_1.legacyToBuffer(data);
      const msgHash = ethereumjs_util_1.hashPersonalMessage(message);
      const sig = ethereumjs_util_1.ecsign(msgHash, privateKey);
      const serialized = utils_1.concatSig(ethereumjs_util_1.toBuffer(sig.v), sig.r, sig.s);
      return serialized;
    }
    exports.personalSign = personalSign;
    function recoverPersonalSignature({ data, signature }) {
      if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      const sender = ethereumjs_util_1.publicToAddress(publicKey);
      const senderHex = ethereumjs_util_1.bufferToHex(sender);
      return senderHex;
    }
    exports.recoverPersonalSignature = recoverPersonalSignature;
    function extractPublicKey({ data, signature }) {
      if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      return `0x${publicKey.toString("hex")}`;
    }
    exports.extractPublicKey = extractPublicKey;
    function getPublicKeyFor(message, signature) {
      const messageHash = ethereumjs_util_1.hashPersonalMessage(utils_1.legacyToBuffer(message));
      return utils_1.recoverPublicKey(messageHash, signature);
    }
  }
});

// node_modules/ethereumjs-abi/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ethereumjs-abi/lib/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var utils = require_dist4();
    var BN = require_bn();
    var ABI = function() {
    };
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    ABI.eventID = function(name, types) {
      var sig = name + "(" + types.map(elementaryName).join(",") + ")";
      return utils.keccak256(Buffer.from(sig));
    };
    ABI.methodID = function(name, types) {
      return ABI.eventID(name, types).slice(0, 4);
    };
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexPrefixed(arg)) {
          return new BN(utils.stripHexPrefix(arg), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function parseSignature(sig) {
      var tmp = /^(\w+)\((.*)\)$/.exec(sig);
      if (tmp.length !== 3) {
        throw new Error("Invalid method signature");
      }
      var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
      if (args !== null && args.length === 3) {
        return {
          method: tmp[1],
          args: args[1].split(","),
          retargs: args[2].split(",")
        };
      } else {
        var params = tmp[2].split(",");
        if (params.length === 1 && params[0] === "") {
          params = [];
        }
        return {
          method: tmp[1],
          args: params
        };
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i in arg) {
          ret.push(encodeSingle(type, arg[i]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, utils.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function decodeSingle(parsedType, data, offset) {
      if (typeof parsedType === "string") {
        parsedType = parseType(parsedType);
      }
      var size, num, ret, i;
      if (parsedType.name === "address") {
        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, "be", 20).toString("hex");
      } else if (parsedType.name === "bool") {
        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();
      } else if (parsedType.name === "string") {
        var bytes = decodeSingle(parsedType.rawType, data, offset);
        return Buffer.from(bytes, "utf8").toString();
      } else if (parsedType.isArray) {
        ret = [];
        size = parsedType.size;
        if (parsedType.size === "dynamic") {
          offset = decodeSingle("uint256", data, offset).toNumber();
          size = decodeSingle("uint256", data, offset).toNumber();
          offset = offset + 32;
        }
        for (i = 0; i < size; i++) {
          var decoded = decodeSingle(parsedType.subArray, data, offset);
          ret.push(decoded);
          offset += parsedType.subArray.memoryUsage;
        }
        return ret;
      } else if (parsedType.name === "bytes") {
        offset = decodeSingle("uint256", data, offset).toNumber();
        size = decodeSingle("uint256", data, offset).toNumber();
        return data.slice(offset + 32, offset + 32 + size);
      } else if (parsedType.name.startsWith("bytes")) {
        return data.slice(offset, offset + parsedType.size);
      } else if (parsedType.name.startsWith("uint")) {
        num = new BN(data.slice(offset, offset + 32), 16, "be");
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("int")) {
        num = new BN(data.slice(offset, offset + 32), 16, "be").fromTwos(256);
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("ufixed")) {
        size = new BN(2).pow(new BN(parsedType.size[1]));
        num = decodeSingle("uint256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      } else if (parsedType.name.startsWith("fixed")) {
        size = new BN(2).pow(new BN(parsedType.size[1]));
        num = decodeSingle("int256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      }
      throw new Error("Unsupported or invalid type: " + parsedType.name);
    }
    function parseType(type) {
      var size;
      var ret;
      if (isArray(type)) {
        size = parseTypeArray(type);
        var subArray = type.slice(0, type.lastIndexOf("["));
        subArray = parseType(subArray);
        ret = {
          isArray: true,
          name: type,
          size,
          memoryUsage: size === "dynamic" ? 32 : subArray.memoryUsage * size,
          subArray
        };
        return ret;
      } else {
        var rawType;
        switch (type) {
          case "address":
            rawType = "uint160";
            break;
          case "bool":
            rawType = "uint8";
            break;
          case "string":
            rawType = "bytes";
            break;
        }
        ret = {
          rawType,
          name: type,
          memoryUsage: 32
        };
        if (type.startsWith("bytes") && type !== "bytes" || type.startsWith("uint") || type.startsWith("int")) {
          ret.size = parseTypeN(type);
        } else if (type.startsWith("ufixed") || type.startsWith("fixed")) {
          ret.size = parseTypeNxM(type);
        }
        if (type.startsWith("bytes") && type !== "bytes" && (ret.size < 1 || ret.size > 32)) {
          throw new Error("Invalid bytes<N> width: " + ret.size);
        }
        if ((type.startsWith("uint") || type.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
          throw new Error("Invalid int/uint<N> width: " + ret.size);
        }
        return ret;
      }
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    ABI.rawEncode = function(types, values) {
      var output = [];
      var data = [];
      var headLength = 0;
      types.forEach(function(type2) {
        if (isArray(type2)) {
          var size = parseTypeArray(type2);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];
        var cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    };
    ABI.rawDecode = function(types, data) {
      var ret = [];
      data = Buffer.from(data);
      var offset = 0;
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var parsed = parseType(type, data, offset);
        var decoded = decodeSingle(parsed, data, offset);
        offset += parsed.memoryUsage;
        ret.push(decoded);
      }
      return ret;
    };
    ABI.simpleEncode = function(method) {
      var args = Array.prototype.slice.call(arguments).slice(1);
      var sig = parseSignature(method);
      if (args.length !== sig.args.length) {
        throw new Error("Argument count mismatch");
      }
      return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
    };
    ABI.simpleDecode = function(method, data) {
      var sig = parseSignature(method);
      if (!sig.retargs) {
        throw new Error("No return values in method");
      }
      return ABI.rawDecode(sig.retargs, data);
    };
    function stringify(type, value) {
      if (type.startsWith("address") || type.startsWith("bytes")) {
        return "0x" + value.toString("hex");
      } else {
        return value.toString();
      }
    }
    ABI.stringify = function(types, values) {
      var ret = [];
      for (var i in types) {
        var type = types[i];
        var value = values[i];
        if (/^[^\[]+\[.*\]$/.test(type)) {
          value = value.map(function(item) {
            return stringify(type, item);
          }).join(", ");
        } else {
          value = stringify(type, value);
        }
        ret.push(value);
      }
      return ret;
    };
    ABI.solidityHexValue = function(type, value, bitsize) {
      var size, num;
      if (isArray(type)) {
        var subType = type.replace(/\[.*?\]/, "");
        if (!isArray(subType)) {
          var arraySize = parseTypeArray(type);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error("Elements exceed array size: " + arraySize);
          }
        }
        var arrayValues = value.map(function(v) {
          return ABI.solidityHexValue(subType, v, 256);
        });
        return Buffer.concat(arrayValues);
      } else if (type === "bytes") {
        return value;
      } else if (type === "string") {
        return Buffer.from(value, "utf8");
      } else if (type === "bool") {
        bitsize = bitsize || 8;
        var padding = Array(bitsize / 4).join("0");
        return Buffer.from(value ? padding + "1" : padding + "0", "hex");
      } else if (type === "address") {
        var bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return utils.setLengthLeft(value, bytesize);
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(value, size);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    ABI.solidityPack = function(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var ret = [];
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];
        ret.push(ABI.solidityHexValue(type, value, null));
      }
      return Buffer.concat(ret);
    };
    ABI.soliditySHA3 = function(types, values) {
      return utils.keccak256(ABI.solidityPack(types, values));
    };
    ABI.soliditySHA256 = function(types, values) {
      return utils.sha256(ABI.solidityPack(types, values));
    };
    ABI.solidityRIPEMD160 = function(types, values) {
      return utils.ripemd160(ABI.solidityPack(types, values), true);
    };
    function isNumeric(c) {
      return c >= "0" && c <= "9";
    }
    ABI.fromSerpent = function(sig) {
      var ret = [];
      for (var i = 0; i < sig.length; i++) {
        var type = sig[i];
        if (type === "s") {
          ret.push("bytes");
        } else if (type === "b") {
          var tmp = "bytes";
          var j = i + 1;
          while (j < sig.length && isNumeric(sig[j])) {
            tmp += sig[j] - "0";
            j++;
          }
          i = j - 1;
          ret.push(tmp);
        } else if (type === "i") {
          ret.push("int256");
        } else if (type === "a") {
          ret.push("int256[]");
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return ret;
    };
    ABI.toSerpent = function(types) {
      var ret = [];
      for (var i = 0; i < types.length; i++) {
        var type = types[i];
        if (type === "bytes") {
          ret.push("s");
        } else if (type.startsWith("bytes")) {
          ret.push("b" + parseTypeN(type));
        } else if (type === "int256") {
          ret.push("i");
        } else if (type === "int256[]") {
          ret.push("a");
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return ret.join("");
    };
    module.exports = ABI;
  }
});

// node_modules/ethereumjs-abi/index.js
var require_ethereumjs_abi = __commonJS({
  "node_modules/ethereumjs-abi/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = require_lib2();
  }
});

// node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js
var require_sign_typed_data = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
    var ethereumjs_util_1 = require_dist4();
    var ethereumjs_abi_1 = require_ethereumjs_abi();
    var utils_1 = require_utils();
    var SignTypedDataVersion;
    (function(SignTypedDataVersion2) {
      SignTypedDataVersion2["V1"] = "V1";
      SignTypedDataVersion2["V3"] = "V3";
      SignTypedDataVersion2["V4"] = "V4";
    })(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
    exports.TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    function validateVersion(version, allowedVersions) {
      if (!Object.keys(SignTypedDataVersion).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
      } else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(", ")}`);
      }
    }
    function encodeField(types, name, type, value, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      if (types[type] !== void 0) {
        return [
          "bytes32",
          version === SignTypedDataVersion.V4 && value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : ethereumjs_util_1.keccak(encodeData(type, value, types, version))
        ];
      }
      if (value === void 0) {
        throw new Error(`missing value for field ${name} of type ${type}`);
      }
      if (type === "bytes") {
        return ["bytes32", ethereumjs_util_1.keccak(value)];
      }
      if (type === "string") {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return ["bytes32", ethereumjs_util_1.keccak(value)];
      }
      if (type.lastIndexOf("]") === type.length - 1) {
        if (version === SignTypedDataVersion.V3) {
          throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
        }
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
          "bytes32",
          ethereumjs_util_1.keccak(ethereumjs_abi_1.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [type, value];
    }
    function encodeData(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const encodedTypes = ["bytes32"];
      const encodedValues = [hashType(primaryType, types)];
      for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion.V3 && data[field.name] === void 0) {
          continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return ethereumjs_abi_1.rawEncode(encodedTypes, encodedValues);
    }
    function encodeType(primaryType, types) {
      let result = "";
      const unsortedDeps = findTypeDependencies(primaryType, types);
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        const children = types[type];
        if (!children) {
          throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies(primaryType, types, results = /* @__PURE__ */ new Set()) {
      [primaryType] = primaryType.match(/^\w*/u);
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
      }
      return results;
    }
    function hashStruct(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      return ethereumjs_util_1.keccak(encodeData(primaryType, data, types, version));
    }
    function hashType(primaryType, types) {
      return ethereumjs_util_1.keccak(encodeType(primaryType, types));
    }
    function sanitizeData(data) {
      const sanitizedData = {};
      for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
          sanitizedData[key] = data[key];
        }
      }
      if ("types" in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
      }
      return sanitizedData;
    }
    function eip712Hash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const sanitizedData = sanitizeData(typedData);
      const parts = [Buffer.from("1901", "hex")];
      parts.push(hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, version));
      if (sanitizedData.primaryType !== "EIP712Domain") {
        parts.push(hashStruct(
          // TODO: Validate that this is a string, so this type cast can be removed.
          sanitizedData.primaryType,
          sanitizedData.message,
          sanitizedData.types,
          version
        ));
      }
      return ethereumjs_util_1.keccak(Buffer.concat(parts));
    }
    exports.TypedDataUtils = {
      encodeData,
      encodeType,
      findTypeDependencies,
      hashStruct,
      hashType,
      sanitizeData,
      eip712Hash
    };
    function typedSignatureHash(typedData) {
      const hashBuffer = _typedSignatureHash(typedData);
      return ethereumjs_util_1.bufferToHex(hashBuffer);
    }
    exports.typedSignatureHash = typedSignatureHash;
    function _typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !("length" in typedData) || !typedData.length) {
        throw error;
      }
      const data = typedData.map(function(e) {
        if (e.type !== "bytes") {
          return e.value;
        }
        return utils_1.legacyToBuffer(e.value);
      });
      const types = typedData.map(function(e) {
        return e.type;
      });
      const schema = typedData.map(function(e) {
        if (!e.name) {
          throw error;
        }
        return `${e.type} ${e.name}`;
      });
      return ethereumjs_abi_1.soliditySHA3(["bytes32", "bytes32"], [
        ethereumjs_abi_1.soliditySHA3(new Array(typedData.length).fill("string"), schema),
        ethereumjs_abi_1.soliditySHA3(types, data)
      ]);
    }
    function signTypedData({ privateKey, data, version }) {
      validateVersion(version);
      if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(privateKey)) {
        throw new Error("Missing private key parameter");
      }
      const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const sig = ethereumjs_util_1.ecsign(messageHash, privateKey);
      return utils_1.concatSig(ethereumjs_util_1.toBuffer(sig.v), sig.r, sig.s);
    }
    exports.signTypedData = signTypedData;
    function recoverTypedSignature({ data, signature, version }) {
      validateVersion(version);
      if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(signature)) {
        throw new Error("Missing signature parameter");
      }
      const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const publicKey = utils_1.recoverPublicKey(messageHash, signature);
      const sender = ethereumjs_util_1.publicToAddress(publicKey);
      return ethereumjs_util_1.bufferToHex(sender);
    }
    exports.recoverTypedSignature = recoverTypedSignature;
  }
});

// node_modules/@metamask/eth-sig-util/dist/encryption.js
var require_encryption = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/encryption.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
    var nacl = __importStar(require_nacl_fast());
    var naclUtil = __importStar(require_nacl_util());
    var utils_1 = require_utils();
    function encrypt({ publicKey, data, version }) {
      if (utils_1.isNullish(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(version)) {
        throw new Error("Missing version parameter");
      }
      switch (version) {
        case "x25519-xsalsa20-poly1305": {
          if (typeof data !== "string") {
            throw new Error("Message data must be given as a string");
          }
          const ephemeralKeyPair = nacl.box.keyPair();
          let pubKeyUInt8Array;
          try {
            pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
          } catch (err) {
            throw new Error("Bad public key");
          }
          const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
          const nonce = nacl.randomBytes(nacl.box.nonceLength);
          const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
          const output = {
            version: "x25519-xsalsa20-poly1305",
            nonce: naclUtil.encodeBase64(nonce),
            ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
            ciphertext: naclUtil.encodeBase64(encryptedMessage)
          };
          return output;
        }
        default:
          throw new Error("Encryption type/version not supported");
      }
    }
    exports.encrypt = encrypt;
    function encryptSafely({ publicKey, data, version }) {
      if (utils_1.isNullish(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if (utils_1.isNullish(data)) {
        throw new Error("Missing data parameter");
      } else if (utils_1.isNullish(version)) {
        throw new Error("Missing version parameter");
      }
      const DEFAULT_PADDING_LENGTH = 2 ** 11;
      const NACL_EXTRA_BYTES = 16;
      if (typeof data === "object" && "toJSON" in data) {
        throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
      }
      const dataWithPadding = {
        data,
        padding: ""
      };
      const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), "utf-8");
      const modVal = dataLength % DEFAULT_PADDING_LENGTH;
      let padLength = 0;
      if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES;
      }
      dataWithPadding.padding = "0".repeat(padLength);
      const paddedMessage = JSON.stringify(dataWithPadding);
      return encrypt({ publicKey, data: paddedMessage, version });
    }
    exports.encryptSafely = encryptSafely;
    function decrypt({ encryptedData, privateKey }) {
      if (utils_1.isNullish(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if (utils_1.isNullish(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      switch (encryptedData.version) {
        case "x25519-xsalsa20-poly1305": {
          const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);
          const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
          const nonce = naclUtil.decodeBase64(encryptedData.nonce);
          const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
          const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
          const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
          let output;
          try {
            output = naclUtil.encodeUTF8(decryptedMessage);
          } catch (err) {
            throw new Error("Decryption failed.");
          }
          if (output) {
            return output;
          }
          throw new Error("Decryption failed.");
        }
        default:
          throw new Error("Encryption type/version not supported.");
      }
    }
    exports.decrypt = decrypt;
    function decryptSafely({ encryptedData, privateKey }) {
      if (utils_1.isNullish(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if (utils_1.isNullish(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));
      return dataWithPadding.data;
    }
    exports.decryptSafely = decryptSafely;
    function getEncryptionPublicKey(privateKey) {
      const privateKeyUint8Array = nacl_decodeHex(privateKey);
      const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
      return naclUtil.encodeBase64(encryptionPublicKey);
    }
    exports.getEncryptionPublicKey = getEncryptionPublicKey;
    function nacl_decodeHex(msgHex) {
      const msgBase64 = Buffer.from(msgHex, "hex").toString("base64");
      return naclUtil.decodeBase64(msgBase64);
    }
  }
});

// node_modules/@metamask/eth-sig-util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.concatSig = void 0;
    __exportStar(require_personal_sign(), exports);
    __exportStar(require_sign_typed_data(), exports);
    __exportStar(require_encryption(), exports);
    var utils_1 = require_utils();
    Object.defineProperty(exports, "concatSig", { enumerable: true, get: function() {
      return utils_1.concatSig;
    } });
    Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
      return utils_1.normalize;
    } });
  }
});
export default require_dist5();
//# sourceMappingURL=@metamask_eth-sig-util.js.map

import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/openpgp/dist/lightweight/openpgp.min.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
var t = Symbol("doneWritingPromise");
var r = Symbol("doneWritingResolve");
var n = Symbol("doneWritingReject");
var i = Symbol("readingIndex");
var a = class extends Array {
  constructor() {
    super(), this[t] = new Promise((e2, t2) => {
      this[r] = e2, this[n] = t2;
    }), this[t].catch(() => {
    });
  }
};
function s(e2) {
  return e2 && e2.getReader && Array.isArray(e2);
}
function o(e2) {
  if (!s(e2)) {
    const t2 = e2.getWriter(), r2 = t2.releaseLock;
    return t2.releaseLock = () => {
      t2.closed.catch(function() {
      }), r2.call(t2);
    }, t2;
  }
  this.stream = e2;
}
a.prototype.getReader = function() {
  return void 0 === this[i] && (this[i] = 0), { read: async () => (await this[t], this[i] === this.length ? { value: void 0, done: true } : { value: this[this[i]++], done: false }) };
}, a.prototype.readToEnd = async function(e2) {
  await this[t];
  const r2 = e2(this.slice(this[i]));
  return this.length = 0, r2;
}, a.prototype.clone = function() {
  const e2 = new a();
  return e2[t] = this[t].then(() => {
    e2.push(...this);
  }), e2;
}, o.prototype.write = async function(e2) {
  this.stream.push(e2);
}, o.prototype.close = async function() {
  this.stream[r]();
}, o.prototype.abort = async function(e2) {
  return this.stream[n](e2), e2;
}, o.prototype.releaseLock = function() {
};
var c = "object" == typeof e.process && "object" == typeof e.process.versions;
var h = c && void 0;
function u(t2) {
  return s(t2) ? "array" : e.ReadableStream && e.ReadableStream.prototype.isPrototypeOf(t2) ? "web" : A && A.prototype.isPrototypeOf(t2) ? "ponyfill" : h && h.prototype.isPrototypeOf(t2) ? "node" : !(!t2 || !t2.getReader) && "web-like";
}
function l(e2) {
  return Uint8Array.prototype.isPrototypeOf(e2);
}
function y(e2) {
  if (1 === e2.length) return e2[0];
  let t2 = 0;
  for (let r3 = 0; r3 < e2.length; r3++) {
    if (!l(e2[r3])) throw Error("concatUint8Array: Data must be in the form of a Uint8Array");
    t2 += e2[r3].length;
  }
  const r2 = new Uint8Array(t2);
  let n2 = 0;
  return e2.forEach(function(e3) {
    r2.set(e3, n2), n2 += e3.length;
  }), r2;
}
var d = c && void 0;
var p = c && void 0;
var f;
var g;
if (p) {
  f = function(e3) {
    let t2 = false;
    return new A({ start(r2) {
      e3.pause(), e3.on("data", (n2) => {
        t2 || (d.isBuffer(n2) && (n2 = new Uint8Array(n2.buffer, n2.byteOffset, n2.byteLength)), r2.enqueue(n2), e3.pause());
      }), e3.on("end", () => {
        t2 || r2.close();
      }), e3.on("error", (e4) => r2.error(e4));
    }, pull() {
      e3.resume();
    }, cancel(r2) {
      t2 = true, e3.destroy(r2);
    } });
  };
  class e2 extends p {
    constructor(e3, t2) {
      super(t2), this._reader = D(e3);
    }
    async _read(e3) {
      try {
        for (; ; ) {
          const { done: e4, value: t2 } = await this._reader.read();
          if (e4) {
            this.push(null);
            break;
          }
          if (!this.push(t2)) break;
        }
      } catch (e4) {
        this.destroy(e4);
      }
    }
    async _destroy(e3, t2) {
      this._reader.cancel(e3).then(t2, t2);
    }
  }
  g = function(t2, r2) {
    return new e2(t2, r2);
  };
}
var m = /* @__PURE__ */ new WeakSet();
var w = Symbol("externalBuffer");
function b(e2) {
  if (this.stream = e2, e2[w] && (this[w] = e2[w].slice()), s(e2)) {
    const t3 = e2.getReader();
    return this._read = t3.read.bind(t3), this._releaseLock = () => {
    }, void (this._cancel = async () => {
    });
  }
  let t2 = u(e2);
  if ("node" === t2 && (e2 = f(e2)), t2) {
    const t3 = e2.getReader();
    return this._read = t3.read.bind(t3), this._releaseLock = () => {
      t3.closed.catch(function() {
      }), t3.releaseLock();
    }, void (this._cancel = t3.cancel.bind(t3));
  }
  let r2 = false;
  this._read = async () => r2 || m.has(e2) ? { value: void 0, done: true } : (r2 = true, { value: e2, done: false }), this._releaseLock = () => {
    if (r2) try {
      m.add(e2);
    } catch (e3) {
    }
  };
}
b.prototype.read = async function() {
  if (this[w] && this[w].length) {
    return { done: false, value: this[w].shift() };
  }
  return this._read();
}, b.prototype.releaseLock = function() {
  this[w] && (this.stream[w] = this[w]), this._releaseLock();
}, b.prototype.cancel = function(e2) {
  return this._cancel(e2);
}, b.prototype.readLine = async function() {
  let e2, t2 = [];
  for (; !e2; ) {
    let { done: r2, value: n2 } = await this.read();
    if (n2 += "", r2) return t2.length ? U(t2) : void 0;
    const i2 = n2.indexOf("\n") + 1;
    i2 && (e2 = U(t2.concat(n2.substr(0, i2))), t2 = []), i2 !== n2.length && t2.push(n2.substr(i2));
  }
  return this.unshift(...t2), e2;
}, b.prototype.readByte = async function() {
  const { done: e2, value: t2 } = await this.read();
  if (e2) return;
  const r2 = t2[0];
  return this.unshift(F(t2, 1)), r2;
}, b.prototype.readBytes = async function(e2) {
  const t2 = [];
  let r2 = 0;
  for (; ; ) {
    const { done: n2, value: i2 } = await this.read();
    if (n2) return t2.length ? U(t2) : void 0;
    if (t2.push(i2), r2 += i2.length, r2 >= e2) {
      const r3 = U(t2);
      return this.unshift(F(r3, e2)), F(r3, 0, e2);
    }
  }
}, b.prototype.peekBytes = async function(e2) {
  const t2 = await this.readBytes(e2);
  return this.unshift(t2), t2;
}, b.prototype.unshift = function(...e2) {
  this[w] || (this[w] = []), 1 === e2.length && l(e2[0]) && this[w].length && e2[0].length && this[w][0].byteOffset >= e2[0].length ? this[w][0] = new Uint8Array(this[w][0].buffer, this[w][0].byteOffset - e2[0].length, this[w][0].byteLength + e2[0].length) : this[w].unshift(...e2.filter((e3) => e3 && e3.length));
}, b.prototype.readToEnd = async function(e2 = U) {
  const t2 = [];
  for (; ; ) {
    const { done: e3, value: r2 } = await this.read();
    if (e3) break;
    t2.push(r2);
  }
  return e2(t2);
};
var k;
var v;
var { ReadableStream: A, WritableStream: _, TransformStream: E } = e;
async function S() {
  if (E) return;
  const [t2, r2] = await Promise.all([import("./ponyfill.es6.min-GONLAZFS.js"), import("./web-streams-adapter.min-BUQUVRX7.js")]);
  ({ ReadableStream: A, WritableStream: _, TransformStream: E } = t2);
  const { createReadableStreamWrapper: n2 } = r2;
  e.ReadableStream && A !== e.ReadableStream && (k = n2(A), v = n2(e.ReadableStream));
}
var K = c && void 0;
function x(e2) {
  let t2 = u(e2);
  return "node" === t2 ? f(e2) : "web" === t2 && k ? k(e2) : t2 ? e2 : new A({ start(t3) {
    t3.enqueue(e2), t3.close();
  } });
}
function P(e2) {
  if (u(e2)) return e2;
  const t2 = new a();
  return (async () => {
    const r2 = C(t2);
    await r2.write(e2), await r2.close();
  })(), t2;
}
function U(e2) {
  return e2.some((e3) => u(e3) && !s(e3)) ? function(e3) {
    e3 = e3.map(x);
    const t2 = B(async function(e4) {
      await Promise.all(n2.map((t3) => j(t3, e4)));
    });
    let r2 = Promise.resolve();
    const n2 = e3.map((n3, i2) => R(n3, (n4, a2) => (r2 = r2.then(() => I(n4, t2.writable, { preventClose: i2 !== e3.length - 1 })), r2)));
    return t2.readable;
  }(e2) : e2.some((e3) => s(e3)) ? function(e3) {
    const t2 = new a();
    let r2 = Promise.resolve();
    return e3.forEach((n2, i2) => (r2 = r2.then(() => I(n2, t2, { preventClose: i2 !== e3.length - 1 })), r2)), t2;
  }(e2) : "string" == typeof e2[0] ? e2.join("") : K && K.isBuffer(e2[0]) ? K.concat(e2) : y(e2);
}
function D(e2) {
  return new b(e2);
}
function C(e2) {
  return new o(e2);
}
async function I(e2, t2, { preventClose: r2 = false, preventAbort: n2 = false, preventCancel: i2 = false } = {}) {
  if (u(e2) && !s(e2)) {
    e2 = x(e2);
    try {
      if (e2[w]) {
        const r3 = C(t2);
        for (let t3 = 0; t3 < e2[w].length; t3++) await r3.ready, await r3.write(e2[w][t3]);
        r3.releaseLock();
      }
      await e2.pipeTo(t2, { preventClose: r2, preventAbort: n2, preventCancel: i2 });
    } catch (e3) {
    }
    return;
  }
  const a2 = D(e2 = P(e2)), o2 = C(t2);
  try {
    for (; ; ) {
      await o2.ready;
      const { done: e3, value: t3 } = await a2.read();
      if (e3) {
        r2 || await o2.close();
        break;
      }
      await o2.write(t3);
    }
  } catch (e3) {
    n2 || await o2.abort(e3);
  } finally {
    a2.releaseLock(), o2.releaseLock();
  }
}
function T(e2, t2) {
  const r2 = new E(t2);
  return I(e2, r2.writable), r2.readable;
}
function B(e2) {
  let t2, r2, n2, i2 = false, a2 = false;
  return { readable: new A({ start(e3) {
    n2 = e3;
  }, pull() {
    t2 ? t2() : i2 = true;
  }, async cancel(t3) {
    a2 = true, e2 && await e2(t3), r2 && r2(t3);
  } }, { highWaterMark: 0 }), writable: new _({ write: async function(e3) {
    if (a2) throw Error("Stream is cancelled");
    n2.enqueue(e3), i2 ? i2 = false : (await new Promise((e4, n3) => {
      t2 = e4, r2 = n3;
    }), t2 = null, r2 = null);
  }, close: n2.close.bind(n2), abort: n2.error.bind(n2) }) };
}
function z(e2, t2 = () => {
}, r2 = () => {
}) {
  if (s(e2)) {
    const n3 = new a();
    return (async () => {
      const i3 = C(n3);
      try {
        const n4 = await H(e2), a2 = t2(n4), s2 = r2();
        let o2;
        o2 = void 0 !== a2 && void 0 !== s2 ? U([a2, s2]) : void 0 !== a2 ? a2 : s2, await i3.write(o2), await i3.close();
      } catch (e3) {
        await i3.abort(e3);
      }
    })(), n3;
  }
  if (u(e2)) return T(e2, { async transform(e3, r3) {
    try {
      const n3 = await t2(e3);
      void 0 !== n3 && r3.enqueue(n3);
    } catch (e4) {
      r3.error(e4);
    }
  }, async flush(e3) {
    try {
      const t3 = await r2();
      void 0 !== t3 && e3.enqueue(t3);
    } catch (t3) {
      e3.error(t3);
    }
  } });
  const n2 = t2(e2), i2 = r2();
  return void 0 !== n2 && void 0 !== i2 ? U([n2, i2]) : void 0 !== n2 ? n2 : i2;
}
function R(e2, t2) {
  if (u(e2) && !s(e2)) {
    let r3;
    const n2 = new E({ start(e3) {
      r3 = e3;
    } }), i2 = I(e2, n2.writable), a2 = B(async function(e3) {
      r3.error(e3), await i2, await new Promise(setTimeout);
    });
    return t2(n2.readable, a2.writable), a2.readable;
  }
  e2 = P(e2);
  const r2 = new a();
  return t2(e2, r2), r2;
}
function M(e2, t2) {
  let r2;
  const n2 = R(e2, (e3, i2) => {
    const a2 = D(e3);
    a2.remainder = () => (a2.releaseLock(), I(e3, i2), n2), r2 = t2(a2);
  });
  return r2;
}
function L(e2) {
  if (s(e2)) return e2.clone();
  if (u(e2)) {
    const t2 = function(e3) {
      if (s(e3)) throw Error("ArrayStream cannot be tee()d, use clone() instead");
      if (u(e3)) {
        const t3 = x(e3).tee();
        return t3[0][w] = t3[1][w] = e3[w], t3;
      }
      return [F(e3), F(e3)];
    }(e2);
    return O(e2, t2[0]), t2[1];
  }
  return F(e2);
}
function N(e2) {
  return s(e2) ? L(e2) : u(e2) ? new A({ start(t2) {
    const r2 = R(e2, async (e3, r3) => {
      const n2 = D(e3), i2 = C(r3);
      try {
        for (; ; ) {
          await i2.ready;
          const { done: e4, value: r4 } = await n2.read();
          if (e4) {
            try {
              t2.close();
            } catch (e5) {
            }
            return void await i2.close();
          }
          try {
            t2.enqueue(r4);
          } catch (e5) {
          }
          await i2.write(r4);
        }
      } catch (e4) {
        t2.error(e4), await i2.abort(e4);
      }
    });
    O(e2, r2);
  } }) : F(e2);
}
function O(e2, t2) {
  Object.entries(Object.getOwnPropertyDescriptors(e2.constructor.prototype)).forEach(([r2, n2]) => {
    "constructor" !== r2 && (n2.value ? n2.value = n2.value.bind(t2) : n2.get = n2.get.bind(t2), Object.defineProperty(e2, r2, n2));
  });
}
function F(e2, t2 = 0, r2 = 1 / 0) {
  if (s(e2)) throw Error("Not implemented");
  if (u(e2)) {
    if (t2 >= 0 && r2 >= 0) {
      let n2 = 0;
      return T(e2, { transform(e3, i2) {
        n2 < r2 ? (n2 + e3.length >= t2 && i2.enqueue(F(e3, Math.max(t2 - n2, 0), r2 - n2)), n2 += e3.length) : i2.terminate();
      } });
    }
    if (t2 < 0 && (r2 < 0 || r2 === 1 / 0)) {
      let n2 = [];
      return z(e2, (e3) => {
        e3.length >= -t2 ? n2 = [e3] : n2.push(e3);
      }, () => F(U(n2), t2, r2));
    }
    if (0 === t2 && r2 < 0) {
      let n2;
      return z(e2, (e3) => {
        const i2 = n2 ? U([n2, e3]) : e3;
        if (i2.length >= -r2) return n2 = F(i2, r2), F(i2, t2, r2);
        n2 = i2;
      });
    }
    return console.warn(`stream.slice(input, ${t2}, ${r2}) not implemented efficiently.`), q(async () => F(await H(e2), t2, r2));
  }
  return e2[w] && (e2 = U(e2[w].concat([e2]))), !l(e2) || K && K.isBuffer(e2) ? e2.slice(t2, r2) : (r2 === 1 / 0 && (r2 = e2.length), e2.subarray(t2, r2));
}
async function H(e2, t2 = U) {
  return s(e2) ? e2.readToEnd(t2) : u(e2) ? D(e2).readToEnd(t2) : e2;
}
async function j(e2, t2) {
  if (u(e2)) {
    if (e2.cancel) return e2.cancel(t2);
    if (e2.destroy) return e2.destroy(t2), await new Promise(setTimeout), t2;
  }
}
function q(e2) {
  const t2 = new a();
  return (async () => {
    const r2 = C(t2);
    try {
      await r2.write(await e2()), await r2.close();
    } catch (e3) {
      await r2.abort(e3);
    }
  })(), t2;
}
var G = class _G {
  constructor(e2) {
    if (void 0 === e2) throw Error("Invalid BigInteger input");
    if (e2 instanceof Uint8Array) {
      const t2 = e2, r2 = Array(t2.length);
      for (let e3 = 0; e3 < t2.length; e3++) {
        const n2 = t2[e3].toString(16);
        r2[e3] = t2[e3] <= 15 ? "0" + n2 : n2;
      }
      this.value = BigInt("0x0" + r2.join(""));
    } else this.value = BigInt(e2);
  }
  clone() {
    return new _G(this.value);
  }
  iinc() {
    return this.value++, this;
  }
  inc() {
    return this.clone().iinc();
  }
  idec() {
    return this.value--, this;
  }
  dec() {
    return this.clone().idec();
  }
  iadd(e2) {
    return this.value += e2.value, this;
  }
  add(e2) {
    return this.clone().iadd(e2);
  }
  isub(e2) {
    return this.value -= e2.value, this;
  }
  sub(e2) {
    return this.clone().isub(e2);
  }
  imul(e2) {
    return this.value *= e2.value, this;
  }
  mul(e2) {
    return this.clone().imul(e2);
  }
  imod(e2) {
    return this.value %= e2.value, this.isNegative() && this.iadd(e2), this;
  }
  mod(e2) {
    return this.clone().imod(e2);
  }
  modExp(e2, t2) {
    if (t2.isZero()) throw Error("Modulo cannot be zero");
    if (t2.isOne()) return new _G(0);
    if (e2.isNegative()) throw Error("Unsopported negative exponent");
    let r2 = e2.value, n2 = this.value;
    n2 %= t2.value;
    let i2 = BigInt(1);
    for (; r2 > BigInt(0); ) {
      const e3 = r2 & BigInt(1);
      r2 >>= BigInt(1);
      const a2 = i2 * n2 % t2.value;
      i2 = e3 ? a2 : i2, n2 = n2 * n2 % t2.value;
    }
    return new _G(i2);
  }
  modInv(e2) {
    const { gcd: t2, x: r2 } = this._egcd(e2);
    if (!t2.isOne()) throw Error("Inverse does not exist");
    return r2.add(e2).mod(e2);
  }
  _egcd(e2) {
    let t2 = BigInt(0), r2 = BigInt(1), n2 = BigInt(1), i2 = BigInt(0), a2 = this.value;
    for (e2 = e2.value; e2 !== BigInt(0); ) {
      const s2 = a2 / e2;
      let o2 = t2;
      t2 = n2 - s2 * t2, n2 = o2, o2 = r2, r2 = i2 - s2 * r2, i2 = o2, o2 = e2, e2 = a2 % e2, a2 = o2;
    }
    return { x: new _G(n2), y: new _G(i2), gcd: new _G(a2) };
  }
  gcd(e2) {
    let t2 = this.value;
    for (e2 = e2.value; e2 !== BigInt(0); ) {
      const r2 = e2;
      e2 = t2 % e2, t2 = r2;
    }
    return new _G(t2);
  }
  ileftShift(e2) {
    return this.value <<= e2.value, this;
  }
  leftShift(e2) {
    return this.clone().ileftShift(e2);
  }
  irightShift(e2) {
    return this.value >>= e2.value, this;
  }
  rightShift(e2) {
    return this.clone().irightShift(e2);
  }
  equal(e2) {
    return this.value === e2.value;
  }
  lt(e2) {
    return this.value < e2.value;
  }
  lte(e2) {
    return this.value <= e2.value;
  }
  gt(e2) {
    return this.value > e2.value;
  }
  gte(e2) {
    return this.value >= e2.value;
  }
  isZero() {
    return this.value === BigInt(0);
  }
  isOne() {
    return this.value === BigInt(1);
  }
  isNegative() {
    return this.value < BigInt(0);
  }
  isEven() {
    return !(this.value & BigInt(1));
  }
  abs() {
    const e2 = this.clone();
    return this.isNegative() && (e2.value = -e2.value), e2;
  }
  toString() {
    return this.value.toString();
  }
  toNumber() {
    const e2 = Number(this.value);
    if (e2 > Number.MAX_SAFE_INTEGER) throw Error("Number can only safely store up to 53 bits");
    return e2;
  }
  getBit(e2) {
    return (this.value >> BigInt(e2) & BigInt(1)) === BigInt(0) ? 0 : 1;
  }
  bitLength() {
    const e2 = new _G(0), t2 = new _G(1), r2 = new _G(-1), n2 = this.isNegative() ? r2 : e2;
    let i2 = 1;
    const a2 = this.clone();
    for (; !a2.irightShift(t2).equal(n2); ) i2++;
    return i2;
  }
  byteLength() {
    const e2 = new _G(0), t2 = new _G(-1), r2 = this.isNegative() ? t2 : e2, n2 = new _G(8);
    let i2 = 1;
    const a2 = this.clone();
    for (; !a2.irightShift(n2).equal(r2); ) i2++;
    return i2;
  }
  toUint8Array(e2 = "be", t2) {
    let r2 = this.value.toString(16);
    r2.length % 2 == 1 && (r2 = "0" + r2);
    const n2 = r2.length / 2, i2 = new Uint8Array(t2 || n2), a2 = t2 ? t2 - n2 : 0;
    let s2 = 0;
    for (; s2 < n2; ) i2[s2 + a2] = parseInt(r2.slice(2 * s2, 2 * s2 + 2), 16), s2++;
    return "be" !== e2 && i2.reverse(), i2;
  }
};
var V = () => "undefined" != typeof BigInt;
var W = Symbol("byValue");
var $ = { curve: { p256: "p256", "P-256": "p256", secp256r1: "p256", prime256v1: "p256", "1.2.840.10045.3.1.7": "p256", "2a8648ce3d030107": "p256", "2A8648CE3D030107": "p256", p384: "p384", "P-384": "p384", secp384r1: "p384", "1.3.132.0.34": "p384", "2b81040022": "p384", "2B81040022": "p384", p521: "p521", "P-521": "p521", secp521r1: "p521", "1.3.132.0.35": "p521", "2b81040023": "p521", "2B81040023": "p521", secp256k1: "secp256k1", "1.3.132.0.10": "secp256k1", "2b8104000a": "secp256k1", "2B8104000A": "secp256k1", ed25519Legacy: "ed25519", ED25519: "ed25519", ed25519: "ed25519", Ed25519: "ed25519", "1.3.6.1.4.1.11591.15.1": "ed25519", "2b06010401da470f01": "ed25519", "2B06010401DA470F01": "ed25519", curve25519Legacy: "curve25519", X25519: "curve25519", cv25519: "curve25519", curve25519: "curve25519", Curve25519: "curve25519", "1.3.6.1.4.1.3029.1.5.1": "curve25519", "2b060104019755010501": "curve25519", "2B060104019755010501": "curve25519", brainpoolP256r1: "brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1", "2b2403030208010107": "brainpoolP256r1", "2B2403030208010107": "brainpoolP256r1", brainpoolP384r1: "brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1", "2b240303020801010b": "brainpoolP384r1", "2B240303020801010B": "brainpoolP384r1", brainpoolP512r1: "brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1", "2b240303020801010d": "brainpoolP512r1", "2B240303020801010D": "brainpoolP512r1" }, s2k: { simple: 0, salted: 1, iterated: 3, gnu: 101 }, publicKey: { rsaEncryptSign: 1, rsaEncrypt: 2, rsaSign: 3, elgamal: 16, dsa: 17, ecdh: 18, ecdsa: 19, eddsaLegacy: 22, ed25519Legacy: 22, eddsa: 22, aedh: 23, aedsa: 24, x25519: 25, x448: 26, ed25519: 27, ed448: 28 }, symmetric: { plaintext: 0, idea: 1, tripledes: 2, cast5: 3, blowfish: 4, aes128: 7, aes192: 8, aes256: 9, twofish: 10 }, compression: { uncompressed: 0, zip: 1, zlib: 2, bzip2: 3 }, hash: { md5: 1, sha1: 2, ripemd: 3, sha256: 8, sha384: 9, sha512: 10, sha224: 11 }, webHash: { "SHA-1": 2, "SHA-256": 8, "SHA-384": 9, "SHA-512": 10 }, aead: { eax: 1, ocb: 2, experimentalGCM: 100 }, packet: { publicKeyEncryptedSessionKey: 1, signature: 2, symEncryptedSessionKey: 3, onePassSignature: 4, secretKey: 5, publicKey: 6, secretSubkey: 7, compressedData: 8, symmetricallyEncryptedData: 9, marker: 10, literalData: 11, trust: 12, userID: 13, publicSubkey: 14, userAttribute: 17, symEncryptedIntegrityProtectedData: 18, modificationDetectionCode: 19, aeadEncryptedData: 20 }, literal: { binary: 98, text: 116, utf8: 117, mime: 109 }, signature: { binary: 0, text: 1, standalone: 2, certGeneric: 16, certPersona: 17, certCasual: 18, certPositive: 19, certRevocation: 48, subkeyBinding: 24, keyBinding: 25, key: 31, keyRevocation: 32, subkeyRevocation: 40, timestamp: 64, thirdParty: 80 }, signatureSubpacket: { signatureCreationTime: 2, signatureExpirationTime: 3, exportableCertification: 4, trustSignature: 5, regularExpression: 6, revocable: 7, keyExpirationTime: 9, placeholderBackwardsCompatibility: 10, preferredSymmetricAlgorithms: 11, revocationKey: 12, issuer: 16, notationData: 20, preferredHashAlgorithms: 21, preferredCompressionAlgorithms: 22, keyServerPreferences: 23, preferredKeyServer: 24, primaryUserID: 25, policyURI: 26, keyFlags: 27, signersUserID: 28, reasonForRevocation: 29, features: 30, signatureTarget: 31, embeddedSignature: 32, issuerFingerprint: 33, preferredAEADAlgorithms: 34 }, keyFlags: { certifyKeys: 1, signData: 2, encryptCommunication: 4, encryptStorage: 8, splitPrivateKey: 16, authentication: 32, sharedPrivateKey: 128 }, armor: { multipartSection: 0, multipartLast: 1, signed: 2, message: 3, publicKey: 4, privateKey: 5, signature: 6 }, reasonForRevocation: { noReason: 0, keySuperseded: 1, keyCompromised: 2, keyRetired: 3, userIDInvalid: 32 }, features: { modificationDetection: 1, aead: 2, v5Keys: 4 }, write: function(e2, t2) {
  if ("number" == typeof t2 && (t2 = this.read(e2, t2)), void 0 !== e2[t2]) return e2[t2];
  throw Error("Invalid enum value.");
}, read: function(e2, t2) {
  if (e2[W] || (e2[W] = [], Object.entries(e2).forEach(([t3, r2]) => {
    e2[W][r2] = t3;
  })), void 0 !== e2[W][t2]) return e2[W][t2];
  throw Error("Invalid enum value.");
} };
var Z = (() => {
  try {
    return "development" === process.env.NODE_ENV;
  } catch (e2) {
  }
  return false;
})();
var X = { isString: function(e2) {
  return "string" == typeof e2 || e2 instanceof String;
}, isArray: function(e2) {
  return e2 instanceof Array;
}, isUint8Array: l, isStream: u, readNumber: function(e2) {
  let t2 = 0;
  for (let r2 = 0; r2 < e2.length; r2++) t2 += 256 ** r2 * e2[e2.length - 1 - r2];
  return t2;
}, writeNumber: function(e2, t2) {
  const r2 = new Uint8Array(t2);
  for (let n2 = 0; n2 < t2; n2++) r2[n2] = e2 >> 8 * (t2 - n2 - 1) & 255;
  return r2;
}, readDate: function(e2) {
  const t2 = X.readNumber(e2);
  return new Date(1e3 * t2);
}, writeDate: function(e2) {
  const t2 = Math.floor(e2.getTime() / 1e3);
  return X.writeNumber(t2, 4);
}, normalizeDate: function(e2 = Date.now()) {
  return null === e2 || e2 === 1 / 0 ? e2 : new Date(1e3 * Math.floor(+e2 / 1e3));
}, readMPI: function(e2) {
  const t2 = (e2[0] << 8 | e2[1]) + 7 >>> 3;
  return e2.subarray(2, 2 + t2);
}, leftPad(e2, t2) {
  const r2 = new Uint8Array(t2), n2 = t2 - e2.length;
  return r2.set(e2, n2), r2;
}, uint8ArrayToMPI: function(e2) {
  const t2 = X.uint8ArrayBitLength(e2);
  if (0 === t2) throw Error("Zero MPI");
  const r2 = e2.subarray(e2.length - Math.ceil(t2 / 8)), n2 = new Uint8Array([(65280 & t2) >> 8, 255 & t2]);
  return X.concatUint8Array([n2, r2]);
}, uint8ArrayBitLength: function(e2) {
  let t2;
  for (t2 = 0; t2 < e2.length && 0 === e2[t2]; t2++) ;
  if (t2 === e2.length) return 0;
  const r2 = e2.subarray(t2);
  return 8 * (r2.length - 1) + X.nbits(r2[0]);
}, hexToUint8Array: function(e2) {
  const t2 = new Uint8Array(e2.length >> 1);
  for (let r2 = 0; r2 < e2.length >> 1; r2++) t2[r2] = parseInt(e2.substr(r2 << 1, 2), 16);
  return t2;
}, uint8ArrayToHex: function(e2) {
  const t2 = [], r2 = e2.length;
  let n2, i2 = 0;
  for (; i2 < r2; ) {
    for (n2 = e2[i2++].toString(16); n2.length < 2; ) n2 = "0" + n2;
    t2.push("" + n2);
  }
  return t2.join("");
}, stringToUint8Array: function(e2) {
  return z(e2, (e3) => {
    if (!X.isString(e3)) throw Error("stringToUint8Array: Data must be in the form of a string");
    const t2 = new Uint8Array(e3.length);
    for (let r2 = 0; r2 < e3.length; r2++) t2[r2] = e3.charCodeAt(r2);
    return t2;
  });
}, uint8ArrayToString: function(e2) {
  const t2 = [], r2 = 16384, n2 = (e2 = new Uint8Array(e2)).length;
  for (let i2 = 0; i2 < n2; i2 += r2) t2.push(String.fromCharCode.apply(String, e2.subarray(i2, i2 + r2 < n2 ? i2 + r2 : n2)));
  return t2.join("");
}, encodeUTF8: function(e2) {
  const t2 = new TextEncoder("utf-8");
  function r2(e3, r3 = false) {
    return t2.encode(e3, { stream: !r3 });
  }
  return z(e2, r2, () => r2("", true));
}, decodeUTF8: function(e2) {
  const t2 = new TextDecoder("utf-8");
  function r2(e3, r3 = false) {
    return t2.decode(e3, { stream: !r3 });
  }
  return z(e2, r2, () => r2(new Uint8Array(), true));
}, concat: U, concatUint8Array: y, equalsUint8Array: function(e2, t2) {
  if (!X.isUint8Array(e2) || !X.isUint8Array(t2)) throw Error("Data must be in the form of a Uint8Array");
  if (e2.length !== t2.length) return false;
  for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2] !== t2[r2]) return false;
  return true;
}, writeChecksum: function(e2) {
  let t2 = 0;
  for (let r2 = 0; r2 < e2.length; r2++) t2 = t2 + e2[r2] & 65535;
  return X.writeNumber(t2, 2);
}, printDebug: function(e2) {
  Z && console.log("[OpenPGP.js debug]", e2);
}, printDebugError: function(e2) {
  Z && console.error("[OpenPGP.js debug]", e2);
}, nbits: function(e2) {
  let t2 = 1, r2 = e2 >>> 16;
  return 0 !== r2 && (e2 = r2, t2 += 16), r2 = e2 >> 8, 0 !== r2 && (e2 = r2, t2 += 8), r2 = e2 >> 4, 0 !== r2 && (e2 = r2, t2 += 4), r2 = e2 >> 2, 0 !== r2 && (e2 = r2, t2 += 2), r2 = e2 >> 1, 0 !== r2 && (e2 = r2, t2 += 1), t2;
}, double: function(e2) {
  const t2 = new Uint8Array(e2.length), r2 = e2.length - 1;
  for (let n2 = 0; n2 < r2; n2++) t2[n2] = e2[n2] << 1 ^ e2[n2 + 1] >> 7;
  return t2[r2] = e2[r2] << 1 ^ 135 * (e2[0] >> 7), t2;
}, shiftRight: function(e2, t2) {
  if (t2) for (let r2 = e2.length - 1; r2 >= 0; r2--) e2[r2] >>= t2, r2 > 0 && (e2[r2] |= e2[r2 - 1] << 8 - t2);
  return e2;
}, getWebCrypto: function() {
  return void 0 !== e && e.crypto && e.crypto.subtle;
}, getBigInteger: async function() {
  if (V()) return G;
  {
    const { default: e2 } = await import("./bn.interface.min-GT6U4SP5.js");
    return e2;
  }
}, getNodeCrypto: function() {
}, getNodeZlib: function() {
}, getNodeBuffer: function() {
  return {}.Buffer;
}, getHardwareConcurrency: function() {
  if ("undefined" != typeof navigator) return navigator.hardwareConcurrency || 1;
  return (void 0).cpus().length;
}, isEmailAddress: function(e2) {
  if (!X.isString(e2)) return false;
  return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+([a-zA-Z]{2,}[0-9]*|xn--[a-zA-Z\-0-9]+)))$/.test(e2);
}, canonicalizeEOL: function(e2) {
  let t2 = false;
  return z(e2, (e3) => {
    let r2;
    t2 && (e3 = X.concatUint8Array([new Uint8Array([13]), e3])), 13 === e3[e3.length - 1] ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
    const n2 = [];
    for (let t3 = 0; r2 = e3.indexOf(10, t3) + 1, r2; t3 = r2) 13 !== e3[r2 - 2] && n2.push(r2);
    if (!n2.length) return e3;
    const i2 = new Uint8Array(e3.length + n2.length);
    let a2 = 0;
    for (let t3 = 0; t3 < n2.length; t3++) {
      const r3 = e3.subarray(n2[t3 - 1] || 0, n2[t3]);
      i2.set(r3, a2), a2 += r3.length, i2[a2 - 1] = 13, i2[a2] = 10, a2++;
    }
    return i2.set(e3.subarray(n2[n2.length - 1] || 0), a2), i2;
  }, () => t2 ? new Uint8Array([13]) : void 0);
}, nativeEOL: function(e2) {
  let t2 = false;
  return z(e2, (e3) => {
    let r2;
    13 === (e3 = t2 && 10 !== e3[0] ? X.concatUint8Array([new Uint8Array([13]), e3]) : new Uint8Array(e3))[e3.length - 1] ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
    let n2 = 0;
    for (let t3 = 0; t3 !== e3.length; t3 = r2) {
      r2 = e3.indexOf(13, t3) + 1, r2 || (r2 = e3.length);
      const i2 = r2 - (10 === e3[r2] ? 1 : 0);
      t3 && e3.copyWithin(n2, t3, i2), n2 += i2 - t3;
    }
    return e3.subarray(0, n2);
  }, () => t2 ? new Uint8Array([13]) : void 0);
}, removeTrailingSpaces: function(e2) {
  return e2.split("\n").map((e3) => {
    let t2 = e3.length - 1;
    for (; t2 >= 0 && (" " === e3[t2] || "	" === e3[t2] || "\r" === e3[t2]); t2--) ;
    return e3.substr(0, t2 + 1);
  }).join("\n");
}, wrapError: function(e2, t2) {
  if (!t2) return Error(e2);
  try {
    t2.message = e2 + ": " + t2.message;
  } catch (e3) {
  }
  return t2;
}, constructAllowedPackets: function(e2) {
  const t2 = {};
  return e2.forEach((e3) => {
    if (!e3.tag) throw Error("Invalid input: expected a packet class");
    t2[e3.tag] = e3;
  }), t2;
}, anyPromise: function(e2) {
  return new Promise(async (t2, r2) => {
    let n2;
    await Promise.all(e2.map(async (e3) => {
      try {
        t2(await e3);
      } catch (e4) {
        n2 = e4;
      }
    })), r2(n2);
  });
}, selectUint8Array: function(e2, t2, r2) {
  const n2 = Math.max(t2.length, r2.length), i2 = new Uint8Array(n2);
  let a2 = 0;
  for (let n3 = 0; n3 < i2.length; n3++) i2[n3] = t2[n3] & 256 - e2 | r2[n3] & 255 + e2, a2 += e2 & n3 < t2.length | 1 - e2 & n3 < r2.length;
  return i2.subarray(0, a2);
}, selectUint8: function(e2, t2, r2) {
  return t2 & 256 - e2 | r2 & 255 + e2;
}, isAES: function(e2) {
  return e2 === $.symmetric.aes128 || e2 === $.symmetric.aes192 || e2 === $.symmetric.aes256;
} };
var Q = X.getNodeBuffer();
var Y;
var J;
function ee(e2) {
  let t2 = new Uint8Array();
  return z(e2, (e3) => {
    t2 = X.concatUint8Array([t2, e3]);
    const r2 = [], n2 = Math.floor(t2.length / 45), i2 = 45 * n2, a2 = Y(t2.subarray(0, i2));
    for (let e4 = 0; e4 < n2; e4++) r2.push(a2.substr(60 * e4, 60)), r2.push("\n");
    return t2 = t2.subarray(i2), r2.join("");
  }, () => t2.length ? Y(t2) + "\n" : "");
}
function te(e2) {
  let t2 = "";
  return z(e2, (e3) => {
    t2 += e3;
    let r2 = 0;
    const n2 = [" ", "	", "\r", "\n"];
    for (let e4 = 0; e4 < n2.length; e4++) {
      const i3 = n2[e4];
      for (let e5 = t2.indexOf(i3); -1 !== e5; e5 = t2.indexOf(i3, e5 + 1)) r2++;
    }
    let i2 = t2.length;
    for (; i2 > 0 && (i2 - r2) % 4 != 0; i2--) n2.includes(t2[i2]) && r2--;
    const a2 = J(t2.substr(0, i2));
    return t2 = t2.substr(i2), a2;
  }, () => J(t2));
}
function re(e2) {
  return te(e2.replace(/-/g, "+").replace(/_/g, "/"));
}
function ne(e2, t2) {
  let r2 = ee(e2).replace(/[\r\n]/g, "");
  return t2 && (r2 = r2.replace(/[+]/g, "-").replace(/[/]/g, "_").replace(/[=]/g, "")), r2;
}
Q ? (Y = (e2) => Q.from(e2).toString("base64"), J = (e2) => {
  const t2 = Q.from(e2, "base64");
  return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
}) : (Y = (e2) => btoa(X.uint8ArrayToString(e2)), J = (e2) => X.stringToUint8Array(atob(e2)));
var ie = { preferredHashAlgorithm: $.hash.sha256, preferredSymmetricAlgorithm: $.symmetric.aes256, preferredCompressionAlgorithm: $.compression.uncompressed, deflateLevel: 6, aeadProtect: false, preferredAEADAlgorithm: $.aead.eax, aeadChunkSizeByte: 12, v5Keys: false, s2kIterationCountByte: 224, allowUnauthenticatedMessages: false, allowUnauthenticatedStream: false, checksumRequired: false, minRSABits: 2047, passwordCollisionCheck: false, revocationsExpire: false, allowInsecureDecryptionWithSigningKeys: false, allowInsecureVerificationWithReformattedKeys: false, constantTimePKCS1Decryption: false, constantTimePKCS1DecryptionSupportedSymmetricAlgorithms: /* @__PURE__ */ new Set([$.symmetric.aes128, $.symmetric.aes192, $.symmetric.aes256]), minBytesForWebCrypto: 1e3, ignoreUnsupportedPackets: true, ignoreMalformedPackets: false, additionalAllowedPackets: [], showVersion: false, showComment: false, versionString: "OpenPGP.js 5.11.2", commentString: "https://openpgpjs.org", maxUserIDLength: 5120, knownNotations: [], useIndutnyElliptic: true, rejectHashAlgorithms: /* @__PURE__ */ new Set([$.hash.md5, $.hash.ripemd]), rejectMessageHashAlgorithms: /* @__PURE__ */ new Set([$.hash.md5, $.hash.ripemd, $.hash.sha1]), rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set([$.publicKey.elgamal, $.publicKey.dsa]), rejectCurves: /* @__PURE__ */ new Set([$.curve.secp256k1]) };
function ae(e2) {
  const t2 = e2.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);
  if (!t2) throw Error("Unknown ASCII armor type");
  return /MESSAGE, PART \d+\/\d+/.test(t2[1]) ? $.armor.multipartSection : /MESSAGE, PART \d+/.test(t2[1]) ? $.armor.multipartLast : /SIGNED MESSAGE/.test(t2[1]) ? $.armor.signed : /MESSAGE/.test(t2[1]) ? $.armor.message : /PUBLIC KEY BLOCK/.test(t2[1]) ? $.armor.publicKey : /PRIVATE KEY BLOCK/.test(t2[1]) ? $.armor.privateKey : /SIGNATURE/.test(t2[1]) ? $.armor.signature : void 0;
}
function se(e2, t2) {
  let r2 = "";
  return t2.showVersion && (r2 += "Version: " + t2.versionString + "\n"), t2.showComment && (r2 += "Comment: " + t2.commentString + "\n"), e2 && (r2 += "Comment: " + e2 + "\n"), r2 += "\n", r2;
}
function oe(e2) {
  return ee(function(e3) {
    let t2 = 13501623;
    return z(e3, (e4) => {
      const r2 = he ? Math.floor(e4.length / 4) : 0, n2 = new Uint32Array(e4.buffer, e4.byteOffset, r2);
      for (let e5 = 0; e5 < r2; e5++) t2 ^= n2[e5], t2 = ce[0][t2 >> 24 & 255] ^ ce[1][t2 >> 16 & 255] ^ ce[2][t2 >> 8 & 255] ^ ce[3][t2 >> 0 & 255];
      for (let n3 = 4 * r2; n3 < e4.length; n3++) t2 = t2 >> 8 ^ ce[0][255 & t2 ^ e4[n3]];
    }, () => new Uint8Array([t2, t2 >> 8, t2 >> 16]));
  }(e2));
}
var ce = [Array(255), Array(255), Array(255), Array(255)];
for (let e2 = 0; e2 <= 255; e2++) {
  let t2 = e2 << 16;
  for (let e3 = 0; e3 < 8; e3++) t2 = t2 << 1 ^ (0 != (8388608 & t2) ? 8801531 : 0);
  ce[0][e2] = (16711680 & t2) >> 16 | 65280 & t2 | (255 & t2) << 16;
}
for (let e2 = 0; e2 <= 255; e2++) ce[1][e2] = ce[0][e2] >> 8 ^ ce[0][255 & ce[0][e2]];
for (let e2 = 0; e2 <= 255; e2++) ce[2][e2] = ce[1][e2] >> 8 ^ ce[0][255 & ce[1][e2]];
for (let e2 = 0; e2 <= 255; e2++) ce[3][e2] = ce[2][e2] >> 8 ^ ce[0][255 & ce[2][e2]];
var he = function() {
  const e2 = new ArrayBuffer(2);
  return new DataView(e2).setInt16(0, 255, true), 255 === new Int16Array(e2)[0];
}();
function ue(e2) {
  for (let t2 = 0; t2 < e2.length; t2++) /^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e2[t2]) || X.printDebugError(Error("Improperly formatted armor header: " + e2[t2])), /^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e2[t2]) || X.printDebugError(Error("Unknown header: " + e2[t2]));
}
function le(e2) {
  let t2 = e2, r2 = "";
  const n2 = e2.lastIndexOf("=");
  return n2 >= 0 && n2 !== e2.length - 1 && (t2 = e2.slice(0, n2), r2 = e2.slice(n2 + 1).substr(0, 4)), { body: t2, checksum: r2 };
}
function ye(e2, t2 = ie) {
  return new Promise(async (r2, n2) => {
    try {
      const i2 = /^-----[^-]+-----$/m, a2 = /^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;
      let s2;
      const o2 = [];
      let c2, h2, u2, l2 = o2, y2 = [], d2 = te(R(e2, async (e3, t3) => {
        const p2 = D(e3);
        try {
          for (; ; ) {
            let e4 = await p2.readLine();
            if (void 0 === e4) throw Error("Misformed armored text");
            if (e4 = X.removeTrailingSpaces(e4.replace(/[\r\n]/g, "")), s2) if (c2) h2 || 2 !== s2 || (i2.test(e4) ? (y2 = y2.join("\r\n"), h2 = true, ue(l2), l2 = [], c2 = false) : y2.push(e4.replace(/^- /, "")));
            else if (i2.test(e4) && n2(Error("Mandatory blank line missing between armor headers and armor data")), a2.test(e4)) {
              if (ue(l2), c2 = true, h2 || 2 !== s2) {
                r2({ text: y2, data: d2, headers: o2, type: s2 });
                break;
              }
            } else l2.push(e4);
            else i2.test(e4) && (s2 = ae(e4));
          }
        } catch (e4) {
          return void n2(e4);
        }
        const f2 = C(t3);
        try {
          for (; ; ) {
            await f2.ready;
            const { done: e4, value: t4 } = await p2.read();
            if (e4) throw Error("Misformed armored text");
            const r3 = t4 + "";
            if (-1 !== r3.indexOf("=") || -1 !== r3.indexOf("-")) {
              let e5 = await p2.readToEnd();
              e5.length || (e5 = ""), e5 = r3 + e5, e5 = X.removeTrailingSpaces(e5.replace(/\r/g, ""));
              const t5 = e5.split(i2);
              if (1 === t5.length) throw Error("Misformed armored text");
              const n3 = le(t5[0].slice(0, -1));
              u2 = n3.checksum, await f2.write(n3.body);
              break;
            }
            await f2.write(r3);
          }
          await f2.ready, await f2.close();
        } catch (e4) {
          await f2.abort(e4);
        }
      }));
      d2 = R(d2, async (e3, r3) => {
        const n3 = H(oe(N(e3)));
        n3.catch(() => {
        }), await I(e3, r3, { preventClose: true });
        const i3 = C(r3);
        try {
          const e4 = (await n3).replace("\n", "");
          if (u2 !== e4 && (u2 || t2.checksumRequired)) throw Error("Ascii armor integrity check failed");
          await i3.ready, await i3.close();
        } catch (e4) {
          await i3.abort(e4);
        }
      });
    } catch (e3) {
      n2(e3);
    }
  }).then(async (e3) => (s(e3.data) && (e3.data = await H(e3.data)), e3));
}
function de(e2, t2, r2, n2, i2, a2 = ie) {
  let s2, o2;
  e2 === $.armor.signed && (s2 = t2.text, o2 = t2.hash, t2 = t2.data);
  const c2 = N(t2), h2 = [];
  switch (e2) {
    case $.armor.multipartSection:
      h2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "/" + n2 + "-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP MESSAGE, PART " + r2 + "/" + n2 + "-----\n");
      break;
    case $.armor.multipartLast:
      h2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP MESSAGE, PART " + r2 + "-----\n");
      break;
    case $.armor.signed:
      h2.push("-----BEGIN PGP SIGNED MESSAGE-----\n"), h2.push("Hash: " + o2 + "\n\n"), h2.push(s2.replace(/^-/gm, "- -")), h2.push("\n-----BEGIN PGP SIGNATURE-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP SIGNATURE-----\n");
      break;
    case $.armor.message:
      h2.push("-----BEGIN PGP MESSAGE-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP MESSAGE-----\n");
      break;
    case $.armor.publicKey:
      h2.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP PUBLIC KEY BLOCK-----\n");
      break;
    case $.armor.privateKey:
      h2.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP PRIVATE KEY BLOCK-----\n");
      break;
    case $.armor.signature:
      h2.push("-----BEGIN PGP SIGNATURE-----\n"), h2.push(se(i2, a2)), h2.push(ee(t2)), h2.push("=", oe(c2)), h2.push("-----END PGP SIGNATURE-----\n");
  }
  return X.concat(h2);
}
var pe = class _pe {
  constructor() {
    this.bytes = "";
  }
  read(e2) {
    return this.bytes = X.uint8ArrayToString(e2.subarray(0, 8)), this.bytes.length;
  }
  write() {
    return X.stringToUint8Array(this.bytes);
  }
  toHex() {
    return X.uint8ArrayToHex(X.stringToUint8Array(this.bytes));
  }
  equals(e2, t2 = false) {
    return t2 && (e2.isWildcard() || this.isWildcard()) || this.bytes === e2.bytes;
  }
  isNull() {
    return "" === this.bytes;
  }
  isWildcard() {
    return /^0+$/.test(this.toHex());
  }
  static mapToHex(e2) {
    return e2.toHex();
  }
  static fromID(e2) {
    const t2 = new _pe();
    return t2.read(X.hexToUint8Array(e2)), t2;
  }
  static wildcard() {
    const e2 = new _pe();
    return e2.read(new Uint8Array(8)), e2;
  }
};
var fe = function() {
  var e2, t2, r2 = false;
  function n2(r3, n3) {
    var i3 = e2[(t2[r3] + t2[n3]) % 255];
    return 0 !== r3 && 0 !== n3 || (i3 = 0), i3;
  }
  var i2, a2, s2, o2, c2 = false;
  function h2() {
    function h3(r3) {
      var n3, i3, a3;
      for (i3 = a3 = function(r4) {
        var n4 = e2[255 - t2[r4]];
        return 0 === r4 && (n4 = 0), n4;
      }(r3), n3 = 0; n3 < 4; n3++) a3 ^= i3 = 255 & (i3 << 1 | i3 >>> 7);
      return a3 ^= 99;
    }
    r2 || function() {
      e2 = [], t2 = [];
      var n3, i3, a3 = 1;
      for (n3 = 0; n3 < 255; n3++) e2[n3] = a3, i3 = 128 & a3, a3 <<= 1, a3 &= 255, 128 === i3 && (a3 ^= 27), a3 ^= e2[n3], t2[e2[n3]] = n3;
      e2[255] = e2[0], t2[0] = 0, r2 = true;
    }(), i2 = [], a2 = [], s2 = [[], [], [], []], o2 = [[], [], [], []];
    for (var u3 = 0; u3 < 256; u3++) {
      var l2 = h3(u3);
      i2[u3] = l2, a2[l2] = u3, s2[0][u3] = n2(2, l2) << 24 | l2 << 16 | l2 << 8 | n2(3, l2), o2[0][l2] = n2(14, u3) << 24 | n2(9, u3) << 16 | n2(13, u3) << 8 | n2(11, u3);
      for (var y2 = 1; y2 < 4; y2++) s2[y2][u3] = s2[y2 - 1][u3] >>> 8 | s2[y2 - 1][u3] << 24, o2[y2][l2] = o2[y2 - 1][l2] >>> 8 | o2[y2 - 1][l2] << 24;
    }
    c2 = true;
  }
  var u2 = function(e3, t3) {
    c2 || h2();
    var r3 = new Uint32Array(t3);
    r3.set(i2, 512), r3.set(a2, 768);
    for (var n3 = 0; n3 < 4; n3++) r3.set(s2[n3], 4096 + 1024 * n3 >> 2), r3.set(o2[n3], 8192 + 1024 * n3 >> 2);
    var u3 = function(e4, t4, r4) {
      ;
      var n4 = 0, i3 = 0, a3 = 0, s3 = 0, o3 = 0, c3 = 0, h3 = 0, u4 = 0, l2 = 0, y2 = 0, d2 = 0, p2 = 0, f2 = 0, g2 = 0, m2 = 0, w2 = 0, b2 = 0, k2 = 0, v2 = 0, A2 = 0, _2 = 0;
      var E2 = new e4.Uint32Array(r4), S2 = new e4.Uint8Array(r4);
      function K2(e5, t5, r5, o4, c4, h4, u5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        o4 = o4 | 0;
        c4 = c4 | 0;
        h4 = h4 | 0;
        u5 = u5 | 0;
        l3 = l3 | 0;
        var y3 = 0, d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0;
        y3 = r5 | 1024, d3 = r5 | 2048, p3 = r5 | 3072;
        c4 = c4 ^ E2[(e5 | 0) >> 2], h4 = h4 ^ E2[(e5 | 4) >> 2], u5 = u5 ^ E2[(e5 | 8) >> 2], l3 = l3 ^ E2[(e5 | 12) >> 2];
        for (b3 = 16; (b3 | 0) <= o4 << 4; b3 = b3 + 16 | 0) {
          f3 = E2[(r5 | c4 >> 22 & 1020) >> 2] ^ E2[(y3 | h4 >> 14 & 1020) >> 2] ^ E2[(d3 | u5 >> 6 & 1020) >> 2] ^ E2[(p3 | l3 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 0) >> 2], g3 = E2[(r5 | h4 >> 22 & 1020) >> 2] ^ E2[(y3 | u5 >> 14 & 1020) >> 2] ^ E2[(d3 | l3 >> 6 & 1020) >> 2] ^ E2[(p3 | c4 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 4) >> 2], m3 = E2[(r5 | u5 >> 22 & 1020) >> 2] ^ E2[(y3 | l3 >> 14 & 1020) >> 2] ^ E2[(d3 | c4 >> 6 & 1020) >> 2] ^ E2[(p3 | h4 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 8) >> 2], w3 = E2[(r5 | l3 >> 22 & 1020) >> 2] ^ E2[(y3 | c4 >> 14 & 1020) >> 2] ^ E2[(d3 | h4 >> 6 & 1020) >> 2] ^ E2[(p3 | u5 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 12) >> 2];
          c4 = f3, h4 = g3, u5 = m3, l3 = w3;
        }
        n4 = E2[(t5 | c4 >> 22 & 1020) >> 2] << 24 ^ E2[(t5 | h4 >> 14 & 1020) >> 2] << 16 ^ E2[(t5 | u5 >> 6 & 1020) >> 2] << 8 ^ E2[(t5 | l3 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 0) >> 2], i3 = E2[(t5 | h4 >> 22 & 1020) >> 2] << 24 ^ E2[(t5 | u5 >> 14 & 1020) >> 2] << 16 ^ E2[(t5 | l3 >> 6 & 1020) >> 2] << 8 ^ E2[(t5 | c4 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 4) >> 2], a3 = E2[(t5 | u5 >> 22 & 1020) >> 2] << 24 ^ E2[(t5 | l3 >> 14 & 1020) >> 2] << 16 ^ E2[(t5 | c4 >> 6 & 1020) >> 2] << 8 ^ E2[(t5 | h4 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 8) >> 2], s3 = E2[(t5 | l3 >> 22 & 1020) >> 2] << 24 ^ E2[(t5 | c4 >> 14 & 1020) >> 2] << 16 ^ E2[(t5 | h4 >> 6 & 1020) >> 2] << 8 ^ E2[(t5 | u5 << 2 & 1020) >> 2] ^ E2[(e5 | b3 | 12) >> 2];
      }
      function x2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        K2(0, 2048, 4096, _2, e5, t5, r5, n5);
      }
      function P2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        var a4 = 0;
        K2(1024, 3072, 8192, _2, e5, n5, r5, t5);
        a4 = i3, i3 = s3, s3 = a4;
      }
      function U2(e5, t5, r5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        l3 = l3 | 0;
        K2(0, 2048, 4096, _2, o3 ^ e5, c3 ^ t5, h3 ^ r5, u4 ^ l3);
        o3 = n4, c3 = i3, h3 = a3, u4 = s3;
      }
      function D2(e5, t5, r5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        l3 = l3 | 0;
        var y3 = 0;
        K2(1024, 3072, 8192, _2, e5, l3, r5, t5);
        y3 = i3, i3 = s3, s3 = y3;
        n4 = n4 ^ o3, i3 = i3 ^ c3, a3 = a3 ^ h3, s3 = s3 ^ u4;
        o3 = e5, c3 = t5, h3 = r5, u4 = l3;
      }
      function C2(e5, t5, r5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        l3 = l3 | 0;
        K2(0, 2048, 4096, _2, o3, c3, h3, u4);
        o3 = n4 = n4 ^ e5, c3 = i3 = i3 ^ t5, h3 = a3 = a3 ^ r5, u4 = s3 = s3 ^ l3;
      }
      function I2(e5, t5, r5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        l3 = l3 | 0;
        K2(0, 2048, 4096, _2, o3, c3, h3, u4);
        n4 = n4 ^ e5, i3 = i3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ l3;
        o3 = e5, c3 = t5, h3 = r5, u4 = l3;
      }
      function T2(e5, t5, r5, l3) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        l3 = l3 | 0;
        K2(0, 2048, 4096, _2, o3, c3, h3, u4);
        o3 = n4, c3 = i3, h3 = a3, u4 = s3;
        n4 = n4 ^ e5, i3 = i3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ l3;
      }
      function B2(e5, t5, r5, o4) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        o4 = o4 | 0;
        K2(0, 2048, 4096, _2, l2, y2, d2, p2);
        p2 = ~w2 & p2 | w2 & p2 + 1;
        d2 = ~m2 & d2 | m2 & d2 + ((p2 | 0) == 0);
        y2 = ~g2 & y2 | g2 & y2 + ((d2 | 0) == 0);
        l2 = ~f2 & l2 | f2 & l2 + ((y2 | 0) == 0);
        n4 = n4 ^ e5;
        i3 = i3 ^ t5;
        a3 = a3 ^ r5;
        s3 = s3 ^ o4;
      }
      function z2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        var i4 = 0, a4 = 0, s4 = 0, l3 = 0, y3 = 0, d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0;
        e5 = e5 ^ o3, t5 = t5 ^ c3, r5 = r5 ^ h3, n5 = n5 ^ u4;
        i4 = b2 | 0, a4 = k2 | 0, s4 = v2 | 0, l3 = A2 | 0;
        for (; (g3 | 0) < 128; g3 = g3 + 1 | 0) {
          if (i4 >>> 31) {
            y3 = y3 ^ e5, d3 = d3 ^ t5, p3 = p3 ^ r5, f3 = f3 ^ n5;
          }
          i4 = i4 << 1 | a4 >>> 31, a4 = a4 << 1 | s4 >>> 31, s4 = s4 << 1 | l3 >>> 31, l3 = l3 << 1;
          m3 = n5 & 1;
          n5 = n5 >>> 1 | r5 << 31, r5 = r5 >>> 1 | t5 << 31, t5 = t5 >>> 1 | e5 << 31, e5 = e5 >>> 1;
          if (m3) e5 = e5 ^ 3774873600;
        }
        o3 = y3, c3 = d3, h3 = p3, u4 = f3;
      }
      function R2(e5) {
        e5 = e5 | 0;
        _2 = e5;
      }
      function M2(e5, t5, r5, o4) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        o4 = o4 | 0;
        n4 = e5, i3 = t5, a3 = r5, s3 = o4;
      }
      function L2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        o3 = e5, c3 = t5, h3 = r5, u4 = n5;
      }
      function N2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        l2 = e5, y2 = t5, d2 = r5, p2 = n5;
      }
      function O2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        f2 = e5, g2 = t5, m2 = r5, w2 = n5;
      }
      function F2(e5, t5, r5, n5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        n5 = n5 | 0;
        p2 = ~w2 & p2 | w2 & n5, d2 = ~m2 & d2 | m2 & r5, y2 = ~g2 & y2 | g2 & t5, l2 = ~f2 & l2 | f2 & e5;
      }
      function H2(e5) {
        e5 = e5 | 0;
        if (e5 & 15) return -1;
        S2[e5 | 0] = n4 >>> 24, S2[e5 | 1] = n4 >>> 16 & 255, S2[e5 | 2] = n4 >>> 8 & 255, S2[e5 | 3] = n4 & 255, S2[e5 | 4] = i3 >>> 24, S2[e5 | 5] = i3 >>> 16 & 255, S2[e5 | 6] = i3 >>> 8 & 255, S2[e5 | 7] = i3 & 255, S2[e5 | 8] = a3 >>> 24, S2[e5 | 9] = a3 >>> 16 & 255, S2[e5 | 10] = a3 >>> 8 & 255, S2[e5 | 11] = a3 & 255, S2[e5 | 12] = s3 >>> 24, S2[e5 | 13] = s3 >>> 16 & 255, S2[e5 | 14] = s3 >>> 8 & 255, S2[e5 | 15] = s3 & 255;
        return 16;
      }
      function j2(e5) {
        e5 = e5 | 0;
        if (e5 & 15) return -1;
        S2[e5 | 0] = o3 >>> 24, S2[e5 | 1] = o3 >>> 16 & 255, S2[e5 | 2] = o3 >>> 8 & 255, S2[e5 | 3] = o3 & 255, S2[e5 | 4] = c3 >>> 24, S2[e5 | 5] = c3 >>> 16 & 255, S2[e5 | 6] = c3 >>> 8 & 255, S2[e5 | 7] = c3 & 255, S2[e5 | 8] = h3 >>> 24, S2[e5 | 9] = h3 >>> 16 & 255, S2[e5 | 10] = h3 >>> 8 & 255, S2[e5 | 11] = h3 & 255, S2[e5 | 12] = u4 >>> 24, S2[e5 | 13] = u4 >>> 16 & 255, S2[e5 | 14] = u4 >>> 8 & 255, S2[e5 | 15] = u4 & 255;
        return 16;
      }
      function q2() {
        x2(0, 0, 0, 0);
        b2 = n4, k2 = i3, v2 = a3, A2 = s3;
      }
      function G2(e5, t5, r5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        var o4 = 0;
        if (t5 & 15) return -1;
        while ((r5 | 0) >= 16) {
          W2[e5 & 7](S2[t5 | 0] << 24 | S2[t5 | 1] << 16 | S2[t5 | 2] << 8 | S2[t5 | 3], S2[t5 | 4] << 24 | S2[t5 | 5] << 16 | S2[t5 | 6] << 8 | S2[t5 | 7], S2[t5 | 8] << 24 | S2[t5 | 9] << 16 | S2[t5 | 10] << 8 | S2[t5 | 11], S2[t5 | 12] << 24 | S2[t5 | 13] << 16 | S2[t5 | 14] << 8 | S2[t5 | 15]);
          S2[t5 | 0] = n4 >>> 24, S2[t5 | 1] = n4 >>> 16 & 255, S2[t5 | 2] = n4 >>> 8 & 255, S2[t5 | 3] = n4 & 255, S2[t5 | 4] = i3 >>> 24, S2[t5 | 5] = i3 >>> 16 & 255, S2[t5 | 6] = i3 >>> 8 & 255, S2[t5 | 7] = i3 & 255, S2[t5 | 8] = a3 >>> 24, S2[t5 | 9] = a3 >>> 16 & 255, S2[t5 | 10] = a3 >>> 8 & 255, S2[t5 | 11] = a3 & 255, S2[t5 | 12] = s3 >>> 24, S2[t5 | 13] = s3 >>> 16 & 255, S2[t5 | 14] = s3 >>> 8 & 255, S2[t5 | 15] = s3 & 255;
          o4 = o4 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
        }
        return o4 | 0;
      }
      function V2(e5, t5, r5) {
        e5 = e5 | 0;
        t5 = t5 | 0;
        r5 = r5 | 0;
        var n5 = 0;
        if (t5 & 15) return -1;
        while ((r5 | 0) >= 16) {
          $2[e5 & 1](S2[t5 | 0] << 24 | S2[t5 | 1] << 16 | S2[t5 | 2] << 8 | S2[t5 | 3], S2[t5 | 4] << 24 | S2[t5 | 5] << 16 | S2[t5 | 6] << 8 | S2[t5 | 7], S2[t5 | 8] << 24 | S2[t5 | 9] << 16 | S2[t5 | 10] << 8 | S2[t5 | 11], S2[t5 | 12] << 24 | S2[t5 | 13] << 16 | S2[t5 | 14] << 8 | S2[t5 | 15]);
          n5 = n5 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
        }
        return n5 | 0;
      }
      var W2 = [x2, P2, U2, D2, C2, I2, T2, B2];
      var $2 = [U2, z2];
      return { set_rounds: R2, set_state: M2, set_iv: L2, set_nonce: N2, set_mask: O2, set_counter: F2, get_state: H2, get_iv: j2, gcm_init: q2, cipher: G2, mac: V2 };
    }({ Uint8Array, Uint32Array }, e3, t3);
    return u3.set_key = function(e4, t4, n4, a3, s3, c3, h3, l2, y2) {
      var d2 = r3.subarray(0, 60), p2 = r3.subarray(256, 316);
      d2.set([t4, n4, a3, s3, c3, h3, l2, y2]);
      for (var f2 = e4, g2 = 1; f2 < 4 * e4 + 28; f2++) {
        var m2 = d2[f2 - 1];
        (f2 % e4 == 0 || 8 === e4 && f2 % e4 == 4) && (m2 = i2[m2 >>> 24] << 24 ^ i2[m2 >>> 16 & 255] << 16 ^ i2[m2 >>> 8 & 255] << 8 ^ i2[255 & m2]), f2 % e4 == 0 && (m2 = m2 << 8 ^ m2 >>> 24 ^ g2 << 24, g2 = g2 << 1 ^ (128 & g2 ? 27 : 0)), d2[f2] = d2[f2 - e4] ^ m2;
      }
      for (var w2 = 0; w2 < f2; w2 += 4) for (var b2 = 0; b2 < 4; b2++) {
        m2 = d2[f2 - (4 + w2) + (4 - b2) % 4];
        p2[w2 + b2] = w2 < 4 || w2 >= f2 - 4 ? m2 : o2[0][i2[m2 >>> 24]] ^ o2[1][i2[m2 >>> 16 & 255]] ^ o2[2][i2[m2 >>> 8 & 255]] ^ o2[3][i2[255 & m2]];
      }
      u3.set_rounds(e4 + 5);
    }, u3;
  };
  return u2.ENC = { ECB: 0, CBC: 2, CFB: 4, OFB: 6, CTR: 7 }, u2.DEC = { ECB: 1, CBC: 3, CFB: 5, OFB: 6, CTR: 7 }, u2.MAC = { CBC: 0, GCM: 1 }, u2.HEAP_DATA = 16384, u2;
}();
function ge(e2) {
  return e2 instanceof Uint8Array;
}
function me(e2, t2) {
  const r2 = e2 ? e2.byteLength : t2 || 65536;
  if (4095 & r2 || r2 <= 0) throw Error("heap size must be a positive integer and a multiple of 4096");
  return e2 = e2 || new Uint8Array(new ArrayBuffer(r2));
}
function we(e2, t2, r2, n2, i2) {
  const a2 = e2.length - t2, s2 = a2 < i2 ? a2 : i2;
  return e2.set(r2.subarray(n2, n2 + s2), t2), s2;
}
function be(...e2) {
  const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
  let n2 = 0;
  for (let t3 = 0; t3 < e2.length; t3++) r2.set(e2[t3], n2), n2 += e2[t3].length;
  return r2;
}
var ke = class extends Error {
  constructor(...e2) {
    super(...e2);
  }
};
var ve = class extends Error {
  constructor(...e2) {
    super(...e2);
  }
};
var Ae = class extends Error {
  constructor(...e2) {
    super(...e2);
  }
};
var _e = [];
var Ee = [];
var Se = class {
  constructor(e2, t2, r2 = true, n2, i2, a2) {
    this.pos = 0, this.len = 0, this.mode = n2, this.pos = 0, this.len = 0, this.key = e2, this.iv = t2, this.padding = r2, this.acquire_asm(i2, a2);
  }
  acquire_asm(e2, t2) {
    return void 0 !== this.heap && void 0 !== this.asm || (this.heap = e2 || _e.pop() || me().subarray(fe.HEAP_DATA), this.asm = t2 || Ee.pop() || new fe(null, this.heap.buffer), this.reset(this.key, this.iv)), { heap: this.heap, asm: this.asm };
  }
  release_asm() {
    void 0 !== this.heap && void 0 !== this.asm && (_e.push(this.heap), Ee.push(this.asm)), this.heap = void 0, this.asm = void 0;
  }
  reset(e2, t2) {
    const { asm: r2 } = this.acquire_asm(), n2 = e2.length;
    if (16 !== n2 && 24 !== n2 && 32 !== n2) throw new ve("illegal key size");
    const i2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
    if (r2.set_key(n2 >> 2, i2.getUint32(0), i2.getUint32(4), i2.getUint32(8), i2.getUint32(12), n2 > 16 ? i2.getUint32(16) : 0, n2 > 16 ? i2.getUint32(20) : 0, n2 > 24 ? i2.getUint32(24) : 0, n2 > 24 ? i2.getUint32(28) : 0), void 0 !== t2) {
      if (16 !== t2.length) throw new ve("illegal iv size");
      let e3 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
      r2.set_iv(e3.getUint32(0), e3.getUint32(4), e3.getUint32(8), e3.getUint32(12));
    } else r2.set_iv(0, 0, 0, 0);
  }
  AES_Encrypt_process(e2) {
    if (!ge(e2)) throw new TypeError("data isn't of expected type");
    let { heap: t2, asm: r2 } = this.acquire_asm(), n2 = fe.ENC[this.mode], i2 = fe.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, h2 = 0, u2 = 0, l2 = new Uint8Array(s2 + c2 & -16);
    for (; c2 > 0; ) u2 = we(t2, a2 + s2, e2, o2, c2), s2 += u2, o2 += u2, c2 -= u2, u2 = r2.cipher(n2, i2 + a2, s2), u2 && l2.set(t2.subarray(a2, a2 + u2), h2), h2 += u2, u2 < s2 ? (a2 += u2, s2 -= u2) : (a2 = 0, s2 = 0);
    return this.pos = a2, this.len = s2, l2;
  }
  AES_Encrypt_finish() {
    let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = fe.ENC[this.mode], n2 = fe.HEAP_DATA, i2 = this.pos, a2 = this.len, s2 = 16 - a2 % 16, o2 = a2;
    if (this.hasOwnProperty("padding")) {
      if (this.padding) {
        for (let t3 = 0; t3 < s2; ++t3) e2[i2 + a2 + t3] = s2;
        a2 += s2, o2 = a2;
      } else if (a2 % 16) throw new ve("data length must be a multiple of the block size");
    } else a2 += s2;
    const c2 = new Uint8Array(o2);
    return a2 && t2.cipher(r2, n2 + i2, a2), o2 && c2.set(e2.subarray(i2, i2 + o2)), this.pos = 0, this.len = 0, this.release_asm(), c2;
  }
  AES_Decrypt_process(e2) {
    if (!ge(e2)) throw new TypeError("data isn't of expected type");
    let { heap: t2, asm: r2 } = this.acquire_asm(), n2 = fe.DEC[this.mode], i2 = fe.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, h2 = 0, u2 = s2 + c2 & -16, l2 = 0, y2 = 0;
    this.padding && (l2 = s2 + c2 - u2 || 16, u2 -= l2);
    const d2 = new Uint8Array(u2);
    for (; c2 > 0; ) y2 = we(t2, a2 + s2, e2, o2, c2), s2 += y2, o2 += y2, c2 -= y2, y2 = r2.cipher(n2, i2 + a2, s2 - (c2 ? 0 : l2)), y2 && d2.set(t2.subarray(a2, a2 + y2), h2), h2 += y2, y2 < s2 ? (a2 += y2, s2 -= y2) : (a2 = 0, s2 = 0);
    return this.pos = a2, this.len = s2, d2;
  }
  AES_Decrypt_finish() {
    let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = fe.DEC[this.mode], n2 = fe.HEAP_DATA, i2 = this.pos, a2 = this.len, s2 = a2;
    if (a2 > 0) {
      if (a2 % 16) {
        if (this.hasOwnProperty("padding")) throw new ve("data length must be a multiple of the block size");
        a2 += 16 - a2 % 16;
      }
      if (t2.cipher(r2, n2 + i2, a2), this.hasOwnProperty("padding") && this.padding) {
        let t3 = e2[i2 + s2 - 1];
        if (t3 < 1 || t3 > 16 || t3 > s2) throw new Ae("bad padding");
        let r3 = 0;
        for (let n3 = t3; n3 > 1; n3--) r3 |= t3 ^ e2[i2 + s2 - n3];
        if (r3) throw new Ae("bad padding");
        s2 -= t3;
      }
    }
    const o2 = new Uint8Array(s2);
    return s2 > 0 && o2.set(e2.subarray(i2, i2 + s2)), this.pos = 0, this.len = 0, this.release_asm(), o2;
  }
};
var Ke = class _Ke {
  static encrypt(e2, t2, r2 = false) {
    return new _Ke(t2, r2).encrypt(e2);
  }
  static decrypt(e2, t2, r2 = false) {
    return new _Ke(t2, r2).decrypt(e2);
  }
  constructor(e2, t2 = false, r2) {
    this.aes = r2 || new Se(e2, void 0, t2, "ECB");
  }
  encrypt(e2) {
    return be(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
  }
  decrypt(e2) {
    return be(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
  }
};
function xe(e2) {
  const t2 = function(e3) {
    const t3 = new Ke(e3);
    this.encrypt = function(e4) {
      return t3.encrypt(e4);
    }, this.decrypt = function(e4) {
      return t3.decrypt(e4);
    };
  };
  return t2.blockSize = t2.prototype.blockSize = 16, t2.keySize = t2.prototype.keySize = e2 / 8, t2;
}
function Pe(e2, t2, r2, n2, i2, a2) {
  const s2 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], o2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], c2 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], h2 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], u2 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], l2 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], y2 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], d2 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  let p2, f2, g2, m2, w2, b2, k2, v2, A2, _2, E2, S2, K2, x2, P2 = 0, U2 = t2.length;
  const D2 = 32 === e2.length ? 3 : 9;
  v2 = 3 === D2 ? r2 ? [0, 32, 2] : [30, -2, -2] : r2 ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2], r2 && (t2 = function(e3, t3) {
    const r3 = 8 - e3.length % 8;
    let n3;
    if (2 === t3 && r3 < 8) n3 = 32;
    else if (1 === t3) n3 = r3;
    else {
      if (t3 || !(r3 < 8)) {
        if (8 === r3) return e3;
        throw Error("des: invalid padding");
      }
      n3 = 0;
    }
    const i3 = new Uint8Array(e3.length + r3);
    for (let t4 = 0; t4 < e3.length; t4++) i3[t4] = e3[t4];
    for (let t4 = 0; t4 < r3; t4++) i3[e3.length + t4] = n3;
    return i3;
  }(t2, a2), U2 = t2.length);
  let C2 = new Uint8Array(U2), I2 = 0;
  for (1 === n2 && (A2 = i2[P2++] << 24 | i2[P2++] << 16 | i2[P2++] << 8 | i2[P2++], E2 = i2[P2++] << 24 | i2[P2++] << 16 | i2[P2++] << 8 | i2[P2++], P2 = 0); P2 < U2; ) {
    for (b2 = t2[P2++] << 24 | t2[P2++] << 16 | t2[P2++] << 8 | t2[P2++], k2 = t2[P2++] << 24 | t2[P2++] << 16 | t2[P2++] << 8 | t2[P2++], 1 === n2 && (r2 ? (b2 ^= A2, k2 ^= E2) : (_2 = A2, S2 = E2, A2 = b2, E2 = k2)), g2 = 252645135 & (b2 >>> 4 ^ k2), k2 ^= g2, b2 ^= g2 << 4, g2 = 65535 & (b2 >>> 16 ^ k2), k2 ^= g2, b2 ^= g2 << 16, g2 = 858993459 & (k2 >>> 2 ^ b2), b2 ^= g2, k2 ^= g2 << 2, g2 = 16711935 & (k2 >>> 8 ^ b2), b2 ^= g2, k2 ^= g2 << 8, g2 = 1431655765 & (b2 >>> 1 ^ k2), k2 ^= g2, b2 ^= g2 << 1, b2 = b2 << 1 | b2 >>> 31, k2 = k2 << 1 | k2 >>> 31, f2 = 0; f2 < D2; f2 += 3) {
      for (K2 = v2[f2 + 1], x2 = v2[f2 + 2], p2 = v2[f2]; p2 !== K2; p2 += x2) m2 = k2 ^ e2[p2], w2 = (k2 >>> 4 | k2 << 28) ^ e2[p2 + 1], g2 = b2, b2 = k2, k2 = g2 ^ (o2[m2 >>> 24 & 63] | h2[m2 >>> 16 & 63] | l2[m2 >>> 8 & 63] | d2[63 & m2] | s2[w2 >>> 24 & 63] | c2[w2 >>> 16 & 63] | u2[w2 >>> 8 & 63] | y2[63 & w2]);
      g2 = b2, b2 = k2, k2 = g2;
    }
    b2 = b2 >>> 1 | b2 << 31, k2 = k2 >>> 1 | k2 << 31, g2 = 1431655765 & (b2 >>> 1 ^ k2), k2 ^= g2, b2 ^= g2 << 1, g2 = 16711935 & (k2 >>> 8 ^ b2), b2 ^= g2, k2 ^= g2 << 8, g2 = 858993459 & (k2 >>> 2 ^ b2), b2 ^= g2, k2 ^= g2 << 2, g2 = 65535 & (b2 >>> 16 ^ k2), k2 ^= g2, b2 ^= g2 << 16, g2 = 252645135 & (b2 >>> 4 ^ k2), k2 ^= g2, b2 ^= g2 << 4, 1 === n2 && (r2 ? (A2 = b2, E2 = k2) : (b2 ^= _2, k2 ^= S2)), C2[I2++] = b2 >>> 24, C2[I2++] = b2 >>> 16 & 255, C2[I2++] = b2 >>> 8 & 255, C2[I2++] = 255 & b2, C2[I2++] = k2 >>> 24, C2[I2++] = k2 >>> 16 & 255, C2[I2++] = k2 >>> 8 & 255, C2[I2++] = 255 & k2;
  }
  return r2 || (C2 = function(e3, t3) {
    let r3, n3 = null;
    if (2 === t3) r3 = 32;
    else if (1 === t3) n3 = e3[e3.length - 1];
    else {
      if (t3) throw Error("des: invalid padding");
      r3 = 0;
    }
    if (!n3) {
      for (n3 = 1; e3[e3.length - n3] === r3; ) n3++;
      n3--;
    }
    return e3.subarray(0, e3.length - n3);
  }(C2, a2)), C2;
}
function Ue(e2) {
  const t2 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], r2 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], n2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], i2 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], a2 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], s2 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], o2 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c2 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], h2 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], u2 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], l2 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], y2 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], d2 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], p2 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], f2 = e2.length > 8 ? 3 : 1, g2 = Array(32 * f2), m2 = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  let w2, b2, k2, v2 = 0, A2 = 0;
  for (let _2 = 0; _2 < f2; _2++) {
    let f3 = e2[v2++] << 24 | e2[v2++] << 16 | e2[v2++] << 8 | e2[v2++], _3 = e2[v2++] << 24 | e2[v2++] << 16 | e2[v2++] << 8 | e2[v2++];
    k2 = 252645135 & (f3 >>> 4 ^ _3), _3 ^= k2, f3 ^= k2 << 4, k2 = 65535 & (_3 >>> -16 ^ f3), f3 ^= k2, _3 ^= k2 << -16, k2 = 858993459 & (f3 >>> 2 ^ _3), _3 ^= k2, f3 ^= k2 << 2, k2 = 65535 & (_3 >>> -16 ^ f3), f3 ^= k2, _3 ^= k2 << -16, k2 = 1431655765 & (f3 >>> 1 ^ _3), _3 ^= k2, f3 ^= k2 << 1, k2 = 16711935 & (_3 >>> 8 ^ f3), f3 ^= k2, _3 ^= k2 << 8, k2 = 1431655765 & (f3 >>> 1 ^ _3), _3 ^= k2, f3 ^= k2 << 1, k2 = f3 << 8 | _3 >>> 20 & 240, f3 = _3 << 24 | _3 << 8 & 16711680 | _3 >>> 8 & 65280 | _3 >>> 24 & 240, _3 = k2;
    for (let e3 = 0; e3 < 16; e3++) m2[e3] ? (f3 = f3 << 2 | f3 >>> 26, _3 = _3 << 2 | _3 >>> 26) : (f3 = f3 << 1 | f3 >>> 27, _3 = _3 << 1 | _3 >>> 27), f3 &= -15, _3 &= -15, w2 = t2[f3 >>> 28] | r2[f3 >>> 24 & 15] | n2[f3 >>> 20 & 15] | i2[f3 >>> 16 & 15] | a2[f3 >>> 12 & 15] | s2[f3 >>> 8 & 15] | o2[f3 >>> 4 & 15], b2 = c2[_3 >>> 28] | h2[_3 >>> 24 & 15] | u2[_3 >>> 20 & 15] | l2[_3 >>> 16 & 15] | y2[_3 >>> 12 & 15] | d2[_3 >>> 8 & 15] | p2[_3 >>> 4 & 15], k2 = 65535 & (b2 >>> 16 ^ w2), g2[A2++] = w2 ^ k2, g2[A2++] = b2 ^ k2 << 16;
  }
  return g2;
}
function De(e2) {
  this.key = [];
  for (let t2 = 0; t2 < 3; t2++) this.key.push(new Uint8Array(e2.subarray(8 * t2, 8 * t2 + 8)));
  this.encrypt = function(e3) {
    return Pe(Ue(this.key[2]), Pe(Ue(this.key[1]), Pe(Ue(this.key[0]), e3, true, 0, null, null), false, 0, null, null), true, 0, null, null);
  };
}
function Ce() {
  this.BlockSize = 8, this.KeySize = 16, this.setKey = function(e3) {
    if (this.masking = Array(16), this.rotate = Array(16), this.reset(), e3.length !== this.KeySize) throw Error("CAST-128: keys must be 16 bytes");
    return this.keySchedule(e3), true;
  }, this.reset = function() {
    for (let e3 = 0; e3 < 16; e3++) this.masking[e3] = 0, this.rotate[e3] = 0;
  }, this.getBlockSize = function() {
    return this.BlockSize;
  }, this.encrypt = function(e3) {
    const t3 = Array(e3.length);
    for (let a3 = 0; a3 < e3.length; a3 += 8) {
      let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
      s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >>> 16 & 255, t3[a3 + 6] = o2 >>> 8 & 255, t3[a3 + 7] = 255 & o2;
    }
    return t3;
  }, this.decrypt = function(e3) {
    const t3 = Array(e3.length);
    for (let a3 = 0; a3 < e3.length; a3 += 8) {
      let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
      s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >> 16 & 255, t3[a3 + 6] = o2 >> 8 & 255, t3[a3 + 7] = 255 & o2;
    }
    return t3;
  };
  const e2 = [, , , ,];
  e2[0] = [, , , ,], e2[0][0] = [4, 0, 13, 15, 12, 14, 8], e2[0][1] = [5, 2, 16, 18, 17, 19, 10], e2[0][2] = [6, 3, 23, 22, 21, 20, 9], e2[0][3] = [7, 1, 26, 25, 27, 24, 11], e2[1] = [, , , ,], e2[1][0] = [0, 6, 21, 23, 20, 22, 16], e2[1][1] = [1, 4, 0, 2, 1, 3, 18], e2[1][2] = [2, 5, 7, 6, 5, 4, 17], e2[1][3] = [3, 7, 10, 9, 11, 8, 19], e2[2] = [, , , ,], e2[2][0] = [4, 0, 13, 15, 12, 14, 8], e2[2][1] = [5, 2, 16, 18, 17, 19, 10], e2[2][2] = [6, 3, 23, 22, 21, 20, 9], e2[2][3] = [7, 1, 26, 25, 27, 24, 11], e2[3] = [, , , ,], e2[3][0] = [0, 6, 21, 23, 20, 22, 16], e2[3][1] = [1, 4, 0, 2, 1, 3, 18], e2[3][2] = [2, 5, 7, 6, 5, 4, 17], e2[3][3] = [3, 7, 10, 9, 11, 8, 19];
  const t2 = [, , , ,];
  function r2(e3, t3, r3) {
    const n3 = t3 + e3, i3 = n3 << r3 | n3 >>> 32 - r3;
    return (a2[0][i3 >>> 24] ^ a2[1][i3 >>> 16 & 255]) - a2[2][i3 >>> 8 & 255] + a2[3][255 & i3];
  }
  function n2(e3, t3, r3) {
    const n3 = t3 ^ e3, i3 = n3 << r3 | n3 >>> 32 - r3;
    return a2[0][i3 >>> 24] - a2[1][i3 >>> 16 & 255] + a2[2][i3 >>> 8 & 255] ^ a2[3][255 & i3];
  }
  function i2(e3, t3, r3) {
    const n3 = t3 - e3, i3 = n3 << r3 | n3 >>> 32 - r3;
    return (a2[0][i3 >>> 24] + a2[1][i3 >>> 16 & 255] ^ a2[2][i3 >>> 8 & 255]) - a2[3][255 & i3];
  }
  t2[0] = [, , , ,], t2[0][0] = [24, 25, 23, 22, 18], t2[0][1] = [26, 27, 21, 20, 22], t2[0][2] = [28, 29, 19, 18, 25], t2[0][3] = [30, 31, 17, 16, 28], t2[1] = [, , , ,], t2[1][0] = [3, 2, 12, 13, 8], t2[1][1] = [1, 0, 14, 15, 13], t2[1][2] = [7, 6, 8, 9, 3], t2[1][3] = [5, 4, 10, 11, 7], t2[2] = [, , , ,], t2[2][0] = [19, 18, 28, 29, 25], t2[2][1] = [17, 16, 30, 31, 28], t2[2][2] = [23, 22, 24, 25, 18], t2[2][3] = [21, 20, 26, 27, 22], t2[3] = [, , , ,], t2[3][0] = [8, 9, 7, 6, 3], t2[3][1] = [10, 11, 5, 4, 7], t2[3][2] = [12, 13, 3, 2, 8], t2[3][3] = [14, 15, 1, 0, 13], this.keySchedule = function(r3) {
    const n3 = [, , , , , , , ,], i3 = Array(32);
    let s2;
    for (let e3 = 0; e3 < 4; e3++) s2 = 4 * e3, n3[e3] = r3[s2] << 24 | r3[s2 + 1] << 16 | r3[s2 + 2] << 8 | r3[s2 + 3];
    const o2 = [6, 7, 4, 5];
    let c2, h2 = 0;
    for (let r4 = 0; r4 < 2; r4++) for (let r5 = 0; r5 < 4; r5++) {
      for (s2 = 0; s2 < 4; s2++) {
        const t3 = e2[r5][s2];
        c2 = n3[t3[1]], c2 ^= a2[4][n3[t3[2] >>> 2] >>> 24 - 8 * (3 & t3[2]) & 255], c2 ^= a2[5][n3[t3[3] >>> 2] >>> 24 - 8 * (3 & t3[3]) & 255], c2 ^= a2[6][n3[t3[4] >>> 2] >>> 24 - 8 * (3 & t3[4]) & 255], c2 ^= a2[7][n3[t3[5] >>> 2] >>> 24 - 8 * (3 & t3[5]) & 255], c2 ^= a2[o2[s2]][n3[t3[6] >>> 2] >>> 24 - 8 * (3 & t3[6]) & 255], n3[t3[0]] = c2;
      }
      for (s2 = 0; s2 < 4; s2++) {
        const e3 = t2[r5][s2];
        c2 = a2[4][n3[e3[0] >>> 2] >>> 24 - 8 * (3 & e3[0]) & 255], c2 ^= a2[5][n3[e3[1] >>> 2] >>> 24 - 8 * (3 & e3[1]) & 255], c2 ^= a2[6][n3[e3[2] >>> 2] >>> 24 - 8 * (3 & e3[2]) & 255], c2 ^= a2[7][n3[e3[3] >>> 2] >>> 24 - 8 * (3 & e3[3]) & 255], c2 ^= a2[4 + s2][n3[e3[4] >>> 2] >>> 24 - 8 * (3 & e3[4]) & 255], i3[h2] = c2, h2++;
      }
    }
    for (let e3 = 0; e3 < 16; e3++) this.masking[e3] = i3[e3], this.rotate[e3] = 31 & i3[16 + e3];
  };
  const a2 = [, , , , , , , ,];
  a2[0] = [821772500, 2678128395, 1810681135, 1059425402, 505495343, 2617265619, 1610868032, 3483355465, 3218386727, 2294005173, 3791863952, 2563806837, 1852023008, 365126098, 3269944861, 584384398, 677919599, 3229601881, 4280515016, 2002735330, 1136869587, 3744433750, 2289869850, 2731719981, 2714362070, 879511577, 1639411079, 575934255, 717107937, 2857637483, 576097850, 2731753936, 1725645e3, 2810460463, 5111599, 767152862, 2543075244, 1251459544, 1383482551, 3052681127, 3089939183, 3612463449, 1878520045, 1510570527, 2189125840, 2431448366, 582008916, 3163445557, 1265446783, 1354458274, 3529918736, 3202711853, 3073581712, 3912963487, 3029263377, 1275016285, 4249207360, 2905708351, 3304509486, 1442611557, 3585198765, 2712415662, 2731849581, 3248163920, 2283946226, 208555832, 2766454743, 1331405426, 1447828783, 3315356441, 3108627284, 2957404670, 2981538698, 3339933917, 1669711173, 286233437, 1465092821, 1782121619, 3862771680, 710211251, 980974943, 1651941557, 430374111, 2051154026, 704238805, 4128970897, 3144820574, 2857402727, 948965521, 3333752299, 2227686284, 718756367, 2269778983, 2731643755, 718440111, 2857816721, 3616097120, 1113355533, 2478022182, 410092745, 1811985197, 1944238868, 2696854588, 1415722873, 1682284203, 1060277122, 1998114690, 1503841958, 82706478, 2315155686, 1068173648, 845149890, 2167947013, 1768146376, 1993038550, 3566826697, 3390574031, 940016341, 3355073782, 2328040721, 904371731, 1205506512, 4094660742, 2816623006, 825647681, 85914773, 2857843460, 1249926541, 1417871568, 3287612, 3211054559, 3126306446, 1975924523, 1353700161, 2814456437, 2438597621, 1800716203, 722146342, 2873936343, 1151126914, 4160483941, 2877670899, 458611604, 2866078500, 3483680063, 770352098, 2652916994, 3367839148, 3940505011, 3585973912, 3809620402, 718646636, 2504206814, 2914927912, 3631288169, 2857486607, 2860018678, 575749918, 2857478043, 718488780, 2069512688, 3548183469, 453416197, 1106044049, 3032691430, 52586708, 3378514636, 3459808877, 3211506028, 1785789304, 218356169, 3571399134, 3759170522, 1194783844, 1523787992, 3007827094, 1975193539, 2555452411, 1341901877, 3045838698, 3776907964, 3217423946, 2802510864, 2889438986, 1057244207, 1636348243, 3761863214, 1462225785, 2632663439, 481089165, 718503062, 24497053, 3332243209, 3344655856, 3655024856, 3960371065, 1195698900, 2971415156, 3710176158, 2115785917, 4027663609, 3525578417, 2524296189, 2745972565, 3564906415, 1372086093, 1452307862, 2780501478, 1476592880, 3389271281, 18495466, 2378148571, 901398090, 891748256, 3279637769, 3157290713, 2560960102, 1447622437, 4284372637, 216884176, 2086908623, 1879786977, 3588903153, 2242455666, 2938092967, 3559082096, 2810645491, 758861177, 1121993112, 215018983, 642190776, 4169236812, 1196255959, 2081185372, 3508738393, 941322904, 4124243163, 2877523539, 1848581667, 2205260958, 3180453958, 2589345134, 3694731276, 550028657, 2519456284, 3789985535, 2973870856, 2093648313, 443148163, 46942275, 2734146937, 1117713533, 1115362972, 1523183689, 3717140224, 1551984063], a2[1] = [522195092, 4010518363, 1776537470, 960447360, 4267822970, 4005896314, 1435016340, 1929119313, 2913464185, 1310552629, 3579470798, 3724818106, 2579771631, 1594623892, 417127293, 2715217907, 2696228731, 1508390405, 3994398868, 3925858569, 3695444102, 4019471449, 3129199795, 3770928635, 3520741761, 990456497, 4187484609, 2783367035, 21106139, 3840405339, 631373633, 3783325702, 532942976, 396095098, 3548038825, 4267192484, 2564721535, 2011709262, 2039648873, 620404603, 3776170075, 2898526339, 3612357925, 4159332703, 1645490516, 223693667, 1567101217, 3362177881, 1029951347, 3470931136, 3570957959, 1550265121, 119497089, 972513919, 907948164, 3840628539, 1613718692, 3594177948, 465323573, 2659255085, 654439692, 2575596212, 2699288441, 3127702412, 277098644, 624404830, 4100943870, 2717858591, 546110314, 2403699828, 3655377447, 1321679412, 4236791657, 1045293279, 4010672264, 895050893, 2319792268, 494945126, 1914543101, 2777056443, 3894764339, 2219737618, 311263384, 4275257268, 3458730721, 669096869, 3584475730, 3835122877, 3319158237, 3949359204, 2005142349, 2713102337, 2228954793, 3769984788, 569394103, 3855636576, 1425027204, 108000370, 2736431443, 3671869269, 3043122623, 1750473702, 2211081108, 762237499, 3972989403, 2798899386, 3061857628, 2943854345, 867476300, 964413654, 1591880597, 1594774276, 2179821409, 552026980, 3026064248, 3726140315, 2283577634, 3110545105, 2152310760, 582474363, 1582640421, 1383256631, 2043843868, 3322775884, 1217180674, 463797851, 2763038571, 480777679, 2718707717, 2289164131, 3118346187, 214354409, 200212307, 3810608407, 3025414197, 2674075964, 3997296425, 1847405948, 1342460550, 510035443, 4080271814, 815934613, 833030224, 1620250387, 1945732119, 2703661145, 3966000196, 1388869545, 3456054182, 2687178561, 2092620194, 562037615, 1356438536, 3409922145, 3261847397, 1688467115, 2150901366, 631725691, 3840332284, 549916902, 3455104640, 394546491, 837744717, 2114462948, 751520235, 2221554606, 2415360136, 3999097078, 2063029875, 803036379, 2702586305, 821456707, 3019566164, 360699898, 4018502092, 3511869016, 3677355358, 2402471449, 812317050, 49299192, 2570164949, 3259169295, 2816732080, 3331213574, 3101303564, 2156015656, 3705598920, 3546263921, 143268808, 3200304480, 1638124008, 3165189453, 3341807610, 578956953, 2193977524, 3638120073, 2333881532, 807278310, 658237817, 2969561766, 1641658566, 11683945, 3086995007, 148645947, 1138423386, 4158756760, 1981396783, 2401016740, 3699783584, 380097457, 2680394679, 2803068651, 3334260286, 441530178, 4016580796, 1375954390, 761952171, 891809099, 2183123478, 157052462, 3683840763, 1592404427, 341349109, 2438483839, 1417898363, 644327628, 2233032776, 2353769706, 2201510100, 220455161, 1815641738, 182899273, 2995019788, 3627381533, 3702638151, 2890684138, 1052606899, 588164016, 1681439879, 4038439418, 2405343923, 4229449282, 167996282, 1336969661, 1688053129, 2739224926, 1543734051, 1046297529, 1138201970, 2121126012, 115334942, 1819067631, 1902159161, 1941945968, 2206692869, 1159982321], a2[2] = [2381300288, 637164959, 3952098751, 3893414151, 1197506559, 916448331, 2350892612, 2932787856, 3199334847, 4009478890, 3905886544, 1373570990, 2450425862, 4037870920, 3778841987, 2456817877, 286293407, 124026297, 3001279700, 1028597854, 3115296800, 4208886496, 2691114635, 2188540206, 1430237888, 1218109995, 3572471700, 308166588, 570424558, 2187009021, 2455094765, 307733056, 1310360322, 3135275007, 1384269543, 2388071438, 863238079, 2359263624, 2801553128, 3380786597, 2831162807, 1470087780, 1728663345, 4072488799, 1090516929, 532123132, 2389430977, 1132193179, 2578464191, 3051079243, 1670234342, 1434557849, 2711078940, 1241591150, 3314043432, 3435360113, 3091448339, 1812415473, 2198440252, 267246943, 796911696, 3619716990, 38830015, 1526438404, 2806502096, 374413614, 2943401790, 1489179520, 1603809326, 1920779204, 168801282, 260042626, 2358705581, 1563175598, 2397674057, 1356499128, 2217211040, 514611088, 2037363785, 2186468373, 4022173083, 2792511869, 2913485016, 1173701892, 4200428547, 3896427269, 1334932762, 2455136706, 602925377, 2835607854, 1613172210, 41346230, 2499634548, 2457437618, 2188827595, 41386358, 4172255629, 1313404830, 2405527007, 3801973774, 2217704835, 873260488, 2528884354, 2478092616, 4012915883, 2555359016, 2006953883, 2463913485, 575479328, 2218240648, 2099895446, 660001756, 2341502190, 3038761536, 3888151779, 3848713377, 3286851934, 1022894237, 1620365795, 3449594689, 1551255054, 15374395, 3570825345, 4249311020, 4151111129, 3181912732, 310226346, 1133119310, 530038928, 136043402, 2476768958, 3107506709, 2544909567, 1036173560, 2367337196, 1681395281, 1758231547, 3641649032, 306774401, 1575354324, 3716085866, 1990386196, 3114533736, 2455606671, 1262092282, 3124342505, 2768229131, 4210529083, 1833535011, 423410938, 660763973, 2187129978, 1639812e3, 3508421329, 3467445492, 310289298, 272797111, 2188552562, 2456863912, 310240523, 677093832, 1013118031, 901835429, 3892695601, 1116285435, 3036471170, 1337354835, 243122523, 520626091, 277223598, 4244441197, 4194248841, 1766575121, 594173102, 316590669, 742362309, 3536858622, 4176435350, 3838792410, 2501204839, 1229605004, 3115755532, 1552908988, 2312334149, 979407927, 3959474601, 1148277331, 176638793, 3614686272, 2083809052, 40992502, 1340822838, 2731552767, 3535757508, 3560899520, 1354035053, 122129617, 7215240, 2732932949, 3118912700, 2718203926, 2539075635, 3609230695, 3725561661, 1928887091, 2882293555, 1988674909, 2063640240, 2491088897, 1459647954, 4189817080, 2302804382, 1113892351, 2237858528, 1927010603, 4002880361, 1856122846, 1594404395, 2944033133, 3855189863, 3474975698, 1643104450, 4054590833, 3431086530, 1730235576, 2984608721, 3084664418, 2131803598, 4178205752, 267404349, 1617849798, 1616132681, 1462223176, 736725533, 2327058232, 551665188, 2945899023, 1749386277, 2575514597, 1611482493, 674206544, 2201269090, 3642560800, 728599968, 1680547377, 2620414464, 1388111496, 453204106, 4156223445, 1094905244, 2754698257, 2201108165, 3757000246, 2704524545, 3922940700, 3996465027], a2[3] = [2645754912, 532081118, 2814278639, 3530793624, 1246723035, 1689095255, 2236679235, 4194438865, 2116582143, 3859789411, 157234593, 2045505824, 4245003587, 1687664561, 4083425123, 605965023, 672431967, 1336064205, 3376611392, 214114848, 4258466608, 3232053071, 489488601, 605322005, 3998028058, 264917351, 1912574028, 756637694, 436560991, 202637054, 135989450, 85393697, 2152923392, 3896401662, 2895836408, 2145855233, 3535335007, 115294817, 3147733898, 1922296357, 3464822751, 4117858305, 1037454084, 2725193275, 2127856640, 1417604070, 1148013728, 1827919605, 642362335, 2929772533, 909348033, 1346338451, 3547799649, 297154785, 1917849091, 4161712827, 2883604526, 3968694238, 1469521537, 3780077382, 3375584256, 1763717519, 136166297, 4290970789, 1295325189, 2134727907, 2798151366, 1566297257, 3672928234, 2677174161, 2672173615, 965822077, 2780786062, 289653839, 1133871874, 3491843819, 35685304, 1068898316, 418943774, 672553190, 642281022, 2346158704, 1954014401, 3037126780, 4079815205, 2030668546, 3840588673, 672283427, 1776201016, 359975446, 3750173538, 555499703, 2769985273, 1324923, 69110472, 152125443, 3176785106, 3822147285, 1340634837, 798073664, 1434183902, 15393959, 216384236, 1303690150, 3881221631, 3711134124, 3960975413, 106373927, 2578434224, 1455997841, 1801814300, 1578393881, 1854262133, 3188178946, 3258078583, 2302670060, 1539295533, 3505142565, 3078625975, 2372746020, 549938159, 3278284284, 2620926080, 181285381, 2865321098, 3970029511, 68876850, 488006234, 1728155692, 2608167508, 836007927, 2435231793, 919367643, 3339422534, 3655756360, 1457871481, 40520939, 1380155135, 797931188, 234455205, 2255801827, 3990488299, 397000196, 739833055, 3077865373, 2871719860, 4022553888, 772369276, 390177364, 3853951029, 557662966, 740064294, 1640166671, 1699928825, 3535942136, 622006121, 3625353122, 68743880, 1742502, 219489963, 1664179233, 1577743084, 1236991741, 410585305, 2366487942, 823226535, 1050371084, 3426619607, 3586839478, 212779912, 4147118561, 1819446015, 1911218849, 530248558, 3486241071, 3252585495, 2886188651, 3410272728, 2342195030, 20547779, 2982490058, 3032363469, 3631753222, 312714466, 1870521650, 1493008054, 3491686656, 615382978, 4103671749, 2534517445, 1932181, 2196105170, 278426614, 6369430, 3274544417, 2913018367, 697336853, 2143000447, 2946413531, 701099306, 1558357093, 2805003052, 3500818408, 2321334417, 3567135975, 216290473, 3591032198, 23009561, 1996984579, 3735042806, 2024298078, 3739440863, 569400510, 2339758983, 3016033873, 3097871343, 3639523026, 3844324983, 3256173865, 795471839, 2951117563, 4101031090, 4091603803, 3603732598, 971261452, 534414648, 428311343, 3389027175, 2844869880, 694888862, 1227866773, 2456207019, 3043454569, 2614353370, 3749578031, 3676663836, 459166190, 4132644070, 1794958188, 51825668, 2252611902, 3084671440, 2036672799, 3436641603, 1099053433, 2469121526, 3059204941, 1323291266, 2061838604, 1018778475, 2233344254, 2553501054, 334295216, 3556750194, 1065731521, 183467730], a2[4] = [2127105028, 745436345, 2601412319, 2788391185, 3093987327, 500390133, 1155374404, 389092991, 150729210, 3891597772, 3523549952, 1935325696, 716645080, 946045387, 2901812282, 1774124410, 3869435775, 4039581901, 3293136918, 3438657920, 948246080, 363898952, 3867875531, 1286266623, 1598556673, 68334250, 630723836, 1104211938, 1312863373, 613332731, 2377784574, 1101634306, 441780740, 3129959883, 1917973735, 2510624549, 3238456535, 2544211978, 3308894634, 1299840618, 4076074851, 1756332096, 3977027158, 297047435, 3790297736, 2265573040, 3621810518, 1311375015, 1667687725, 47300608, 3299642885, 2474112369, 201668394, 1468347890, 576830978, 3594690761, 3742605952, 1958042578, 1747032512, 3558991340, 1408974056, 3366841779, 682131401, 1033214337, 1545599232, 4265137049, 206503691, 103024618, 2855227313, 1337551222, 2428998917, 2963842932, 4015366655, 3852247746, 2796956967, 3865723491, 3747938335, 247794022, 3755824572, 702416469, 2434691994, 397379957, 851939612, 2314769512, 218229120, 1380406772, 62274761, 214451378, 3170103466, 2276210409, 3845813286, 28563499, 446592073, 1693330814, 3453727194, 29968656, 3093872512, 220656637, 2470637031, 77972100, 1667708854, 1358280214, 4064765667, 2395616961, 325977563, 4277240721, 4220025399, 3605526484, 3355147721, 811859167, 3069544926, 3962126810, 652502677, 3075892249, 4132761541, 3498924215, 1217549313, 3250244479, 3858715919, 3053989961, 1538642152, 2279026266, 2875879137, 574252750, 3324769229, 2651358713, 1758150215, 141295887, 2719868960, 3515574750, 4093007735, 4194485238, 1082055363, 3417560400, 395511885, 2966884026, 179534037, 3646028556, 3738688086, 1092926436, 2496269142, 257381841, 3772900718, 1636087230, 1477059743, 2499234752, 3811018894, 2675660129, 3285975680, 90732309, 1684827095, 1150307763, 1723134115, 3237045386, 1769919919, 1240018934, 815675215, 750138730, 2239792499, 1234303040, 1995484674, 138143821, 675421338, 1145607174, 1936608440, 3238603024, 2345230278, 2105974004, 323969391, 779555213, 3004902369, 2861610098, 1017501463, 2098600890, 2628620304, 2940611490, 2682542546, 1171473753, 3656571411, 3687208071, 4091869518, 393037935, 159126506, 1662887367, 1147106178, 391545844, 3452332695, 1891500680, 3016609650, 1851642611, 546529401, 1167818917, 3194020571, 2848076033, 3953471836, 575554290, 475796850, 4134673196, 450035699, 2351251534, 844027695, 1080539133, 86184846, 1554234488, 3692025454, 1972511363, 2018339607, 1491841390, 1141460869, 1061690759, 4244549243, 2008416118, 2351104703, 2868147542, 1598468138, 722020353, 1027143159, 212344630, 1387219594, 1725294528, 3745187956, 2500153616, 458938280, 4129215917, 1828119673, 544571780, 3503225445, 2297937496, 1241802790, 267843827, 2694610800, 1397140384, 1558801448, 3782667683, 1806446719, 929573330, 2234912681, 400817706, 616011623, 4121520928, 3603768725, 1761550015, 1968522284, 4053731006, 4192232858, 4005120285, 872482584, 3140537016, 3894607381, 2287405443, 1963876937, 3663887957, 1584857e3, 2975024454, 1833426440, 4025083860], a2[5] = [4143615901, 749497569, 1285769319, 3795025788, 2514159847, 23610292, 3974978748, 844452780, 3214870880, 3751928557, 2213566365, 1676510905, 448177848, 3730751033, 4086298418, 2307502392, 871450977, 3222878141, 4110862042, 3831651966, 2735270553, 1310974780, 2043402188, 1218528103, 2736035353, 4274605013, 2702448458, 3936360550, 2693061421, 162023535, 2827510090, 687910808, 23484817, 3784910947, 3371371616, 779677500, 3503626546, 3473927188, 4157212626, 3500679282, 4248902014, 2466621104, 3899384794, 1958663117, 925738300, 1283408968, 3669349440, 1840910019, 137959847, 2679828185, 1239142320, 1315376211, 1547541505, 1690155329, 739140458, 3128809933, 3933172616, 3876308834, 905091803, 1548541325, 4040461708, 3095483362, 144808038, 451078856, 676114313, 2861728291, 2469707347, 993665471, 373509091, 2599041286, 4025009006, 4170239449, 2149739950, 3275793571, 3749616649, 2794760199, 1534877388, 572371878, 2590613551, 1753320020, 3467782511, 1405125690, 4270405205, 633333386, 3026356924, 3475123903, 632057672, 2846462855, 1404951397, 3882875879, 3915906424, 195638627, 2385783745, 3902872553, 1233155085, 3355999740, 2380578713, 2702246304, 2144565621, 3663341248, 3894384975, 2502479241, 4248018925, 3094885567, 1594115437, 572884632, 3385116731, 767645374, 1331858858, 1475698373, 3793881790, 3532746431, 1321687957, 619889600, 1121017241, 3440213920, 2070816767, 2833025776, 1933951238, 4095615791, 890643334, 3874130214, 859025556, 360630002, 925594799, 1764062180, 3920222280, 4078305929, 979562269, 2810700344, 4087740022, 1949714515, 546639971, 1165388173, 3069891591, 1495988560, 922170659, 1291546247, 2107952832, 1813327274, 3406010024, 3306028637, 4241950635, 153207855, 2313154747, 1608695416, 1150242611, 1967526857, 721801357, 1220138373, 3691287617, 3356069787, 2112743302, 3281662835, 1111556101, 1778980689, 250857638, 2298507990, 673216130, 2846488510, 3207751581, 3562756981, 3008625920, 3417367384, 2198807050, 529510932, 3547516680, 3426503187, 2364944742, 102533054, 2294910856, 1617093527, 1204784762, 3066581635, 1019391227, 1069574518, 1317995090, 1691889997, 3661132003, 510022745, 3238594800, 1362108837, 1817929911, 2184153760, 805817662, 1953603311, 3699844737, 120799444, 2118332377, 207536705, 2282301548, 4120041617, 145305846, 2508124933, 3086745533, 3261524335, 1877257368, 2977164480, 3160454186, 2503252186, 4221677074, 759945014, 254147243, 2767453419, 3801518371, 629083197, 2471014217, 907280572, 3900796746, 940896768, 2751021123, 2625262786, 3161476951, 3661752313, 3260732218, 1425318020, 2977912069, 1496677566, 3988592072, 2140652971, 3126511541, 3069632175, 977771578, 1392695845, 1698528874, 1411812681, 1369733098, 1343739227, 3620887944, 1142123638, 67414216, 3102056737, 3088749194, 1626167401, 2546293654, 3941374235, 697522451, 33404913, 143560186, 2595682037, 994885535, 1247667115, 3859094837, 2699155541, 3547024625, 4114935275, 2968073508, 3199963069, 2732024527, 1237921620, 951448369, 1898488916, 1211705605, 2790989240, 2233243581, 3598044975], a2[6] = [2246066201, 858518887, 1714274303, 3485882003, 713916271, 2879113490, 3730835617, 539548191, 36158695, 1298409750, 419087104, 1358007170, 749914897, 2989680476, 1261868530, 2995193822, 2690628854, 3443622377, 3780124940, 3796824509, 2976433025, 4259637129, 1551479e3, 512490819, 1296650241, 951993153, 2436689437, 2460458047, 144139966, 3136204276, 310820559, 3068840729, 643875328, 1969602020, 1680088954, 2185813161, 3283332454, 672358534, 198762408, 896343282, 276269502, 3014846926, 84060815, 197145886, 376173866, 3943890818, 3813173521, 3545068822, 1316698879, 1598252827, 2633424951, 1233235075, 859989710, 2358460855, 3503838400, 3409603720, 1203513385, 1193654839, 2792018475, 2060853022, 207403770, 1144516871, 3068631394, 1121114134, 177607304, 3785736302, 326409831, 1929119770, 2983279095, 4183308101, 3474579288, 3200513878, 3228482096, 119610148, 1170376745, 3378393471, 3163473169, 951863017, 3337026068, 3135789130, 2907618374, 1183797387, 2015970143, 4045674555, 2182986399, 2952138740, 3928772205, 384012900, 2454997643, 10178499, 2879818989, 2596892536, 111523738, 2995089006, 451689641, 3196290696, 235406569, 1441906262, 3890558523, 3013735005, 4158569349, 1644036924, 376726067, 1006849064, 3664579700, 2041234796, 1021632941, 1374734338, 2566452058, 371631263, 4007144233, 490221539, 206551450, 3140638584, 1053219195, 1853335209, 3412429660, 3562156231, 735133835, 1623211703, 3104214392, 2738312436, 4096837757, 3366392578, 3110964274, 3956598718, 3196820781, 2038037254, 3877786376, 2339753847, 300912036, 3766732888, 2372630639, 1516443558, 4200396704, 1574567987, 4069441456, 4122592016, 2699739776, 146372218, 2748961456, 2043888151, 35287437, 2596680554, 655490400, 1132482787, 110692520, 1031794116, 2188192751, 1324057718, 1217253157, 919197030, 686247489, 3261139658, 1028237775, 3135486431, 3059715558, 2460921700, 986174950, 2661811465, 4062904701, 2752986992, 3709736643, 367056889, 1353824391, 731860949, 1650113154, 1778481506, 784341916, 357075625, 3608602432, 1074092588, 2480052770, 3811426202, 92751289, 877911070, 3600361838, 1231880047, 480201094, 3756190983, 3094495953, 434011822, 87971354, 363687820, 1717726236, 1901380172, 3926403882, 2481662265, 400339184, 1490350766, 2661455099, 1389319756, 2558787174, 784598401, 1983468483, 30828846, 3550527752, 2716276238, 3841122214, 1765724805, 1955612312, 1277890269, 1333098070, 1564029816, 2704417615, 1026694237, 3287671188, 1260819201, 3349086767, 1016692350, 1582273796, 1073413053, 1995943182, 694588404, 1025494639, 3323872702, 3551898420, 4146854327, 453260480, 1316140391, 1435673405, 3038941953, 3486689407, 1622062951, 403978347, 817677117, 950059133, 4246079218, 3278066075, 1486738320, 1417279718, 481875527, 2549965225, 3933690356, 760697757, 1452955855, 3897451437, 1177426808, 1702951038, 4085348628, 2447005172, 1084371187, 3516436277, 3068336338, 1073369276, 1027665953, 3284188590, 1230553676, 1368340146, 2226246512, 267243139, 2274220762, 4070734279, 2497715176, 2423353163, 2504755875], a2[7] = [3793104909, 3151888380, 2817252029, 895778965, 2005530807, 3871412763, 237245952, 86829237, 296341424, 3851759377, 3974600970, 2475086196, 709006108, 1994621201, 2972577594, 937287164, 3734691505, 168608556, 3189338153, 2225080640, 3139713551, 3033610191, 3025041904, 77524477, 185966941, 1208824168, 2344345178, 1721625922, 3354191921, 1066374631, 1927223579, 1971335949, 2483503697, 1551748602, 2881383779, 2856329572, 3003241482, 48746954, 1398218158, 2050065058, 313056748, 4255789917, 393167848, 1912293076, 940740642, 3465845460, 3091687853, 2522601570, 2197016661, 1727764327, 364383054, 492521376, 1291706479, 3264136376, 1474851438, 1685747964, 2575719748, 1619776915, 1814040067, 970743798, 1561002147, 2925768690, 2123093554, 1880132620, 3151188041, 697884420, 2550985770, 2607674513, 2659114323, 110200136, 1489731079, 997519150, 1378877361, 3527870668, 478029773, 2766872923, 1022481122, 431258168, 1112503832, 897933369, 2635587303, 669726182, 3383752315, 918222264, 163866573, 3246985393, 3776823163, 114105080, 1903216136, 761148244, 3571337562, 1690750982, 3166750252, 1037045171, 1888456500, 2010454850, 642736655, 616092351, 365016990, 1185228132, 4174898510, 1043824992, 2023083429, 2241598885, 3863320456, 3279669087, 3674716684, 108438443, 2132974366, 830746235, 606445527, 4173263986, 2204105912, 1844756978, 2532684181, 4245352700, 2969441100, 3796921661, 1335562986, 4061524517, 2720232303, 2679424040, 634407289, 885462008, 3294724487, 3933892248, 2094100220, 339117932, 4048830727, 3202280980, 1458155303, 2689246273, 1022871705, 2464987878, 3714515309, 353796843, 2822958815, 4256850100, 4052777845, 551748367, 618185374, 3778635579, 4020649912, 1904685140, 3069366075, 2670879810, 3407193292, 2954511620, 4058283405, 2219449317, 3135758300, 1120655984, 3447565834, 1474845562, 3577699062, 550456716, 3466908712, 2043752612, 881257467, 869518812, 2005220179, 938474677, 3305539448, 3850417126, 1315485940, 3318264702, 226533026, 965733244, 321539988, 1136104718, 804158748, 573969341, 3708209826, 937399083, 3290727049, 2901666755, 1461057207, 4013193437, 4066861423, 3242773476, 2421326174, 1581322155, 3028952165, 786071460, 3900391652, 3918438532, 1485433313, 4023619836, 3708277595, 3678951060, 953673138, 1467089153, 1930354364, 1533292819, 2492563023, 1346121658, 1685000834, 1965281866, 3765933717, 4190206607, 2052792609, 3515332758, 690371149, 3125873887, 2180283551, 2903598061, 3933952357, 436236910, 289419410, 14314871, 1242357089, 2904507907, 1616633776, 2666382180, 585885352, 3471299210, 2699507360, 1432659641, 277164553, 3354103607, 770115018, 2303809295, 3741942315, 3177781868, 2853364978, 2269453327, 3774259834, 987383833, 1290892879, 225909803, 1741533526, 890078084, 1496906255, 1111072499, 916028167, 243534141, 1252605537, 2204162171, 531204876, 290011180, 3916834213, 102027703, 237315147, 209093447, 1486785922, 220223953, 2758195998, 4175039106, 82940208, 3127791296, 2569425252, 518464269, 1353887104, 3941492737, 2377294467, 3935040926];
}
function Ie(e2) {
  this.cast5 = new Ce(), this.cast5.setKey(e2), this.encrypt = function(e3) {
    return this.cast5.encrypt(e3);
  };
}
De.keySize = De.prototype.keySize = 24, De.blockSize = De.prototype.blockSize = 8, Ie.blockSize = Ie.prototype.blockSize = 8, Ie.keySize = Ie.prototype.keySize = 16;
var Te = 4294967295;
function Be(e2, t2) {
  return (e2 << t2 | e2 >>> 32 - t2) & Te;
}
function ze(e2, t2) {
  return e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24;
}
function Re(e2, t2, r2) {
  e2.splice(t2, 4, 255 & r2, r2 >>> 8 & 255, r2 >>> 16 & 255, r2 >>> 24 & 255);
}
function Me(e2, t2) {
  return e2 >>> 8 * t2 & 255;
}
function Le(e2) {
  this.tf = /* @__PURE__ */ function() {
    let e3 = null, t2 = null, r2 = -1, n2 = [], i2 = [[], [], [], []];
    function a2(e4) {
      return i2[0][Me(e4, 0)] ^ i2[1][Me(e4, 1)] ^ i2[2][Me(e4, 2)] ^ i2[3][Me(e4, 3)];
    }
    function s2(e4) {
      return i2[0][Me(e4, 3)] ^ i2[1][Me(e4, 0)] ^ i2[2][Me(e4, 1)] ^ i2[3][Me(e4, 2)];
    }
    function o2(e4, t3) {
      let r3 = a2(t3[0]), i3 = s2(t3[1]);
      t3[2] = Be(t3[2] ^ r3 + i3 + n2[4 * e4 + 8] & Te, 31), t3[3] = Be(t3[3], 1) ^ r3 + 2 * i3 + n2[4 * e4 + 9] & Te, r3 = a2(t3[2]), i3 = s2(t3[3]), t3[0] = Be(t3[0] ^ r3 + i3 + n2[4 * e4 + 10] & Te, 31), t3[1] = Be(t3[1], 1) ^ r3 + 2 * i3 + n2[4 * e4 + 11] & Te;
    }
    function c2(e4, t3) {
      let r3 = a2(t3[0]), i3 = s2(t3[1]);
      t3[2] = Be(t3[2], 1) ^ r3 + i3 + n2[4 * e4 + 10] & Te, t3[3] = Be(t3[3] ^ r3 + 2 * i3 + n2[4 * e4 + 11] & Te, 31), r3 = a2(t3[2]), i3 = s2(t3[3]), t3[0] = Be(t3[0], 1) ^ r3 + i3 + n2[4 * e4 + 8] & Te, t3[1] = Be(t3[1] ^ r3 + 2 * i3 + n2[4 * e4 + 9] & Te, 31);
    }
    return { name: "twofish", blocksize: 16, open: function(t3) {
      let r3, a3, s3, o3, c3;
      e3 = t3;
      const h2 = [], u2 = [], l2 = [];
      let y2;
      const d2 = [];
      let p2, f2, g2;
      const m2 = [[8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4], [2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5]], w2 = [[14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13], [1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8]], b2 = [[11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1], [4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15]], k2 = [[13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10], [11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10]], v2 = [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15], A2 = [0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7], _2 = [[], []], E2 = [[], [], [], []];
      function S2(e4) {
        return e4 ^ e4 >> 2 ^ [0, 90, 180, 238][3 & e4];
      }
      function K2(e4) {
        return e4 ^ e4 >> 1 ^ e4 >> 2 ^ [0, 238, 180, 90][3 & e4];
      }
      function x2(e4, t4) {
        let r4, n3, i3;
        for (r4 = 0; r4 < 8; r4++) n3 = t4 >>> 24, t4 = t4 << 8 & Te | e4 >>> 24, e4 = e4 << 8 & Te, i3 = n3 << 1, 128 & n3 && (i3 ^= 333), t4 ^= n3 ^ i3 << 16, i3 ^= n3 >>> 1, 1 & n3 && (i3 ^= 166), t4 ^= i3 << 24 | i3 << 8;
        return t4;
      }
      function P2(e4, t4) {
        const r4 = t4 >> 4, n3 = 15 & t4, i3 = m2[e4][r4 ^ n3], a4 = w2[e4][v2[n3] ^ A2[r4]];
        return k2[e4][v2[a4] ^ A2[i3]] << 4 | b2[e4][i3 ^ a4];
      }
      function U2(e4, t4) {
        let r4 = Me(e4, 0), n3 = Me(e4, 1), i3 = Me(e4, 2), a4 = Me(e4, 3);
        switch (y2) {
          case 4:
            r4 = _2[1][r4] ^ Me(t4[3], 0), n3 = _2[0][n3] ^ Me(t4[3], 1), i3 = _2[0][i3] ^ Me(t4[3], 2), a4 = _2[1][a4] ^ Me(t4[3], 3);
          case 3:
            r4 = _2[1][r4] ^ Me(t4[2], 0), n3 = _2[1][n3] ^ Me(t4[2], 1), i3 = _2[0][i3] ^ Me(t4[2], 2), a4 = _2[0][a4] ^ Me(t4[2], 3);
          case 2:
            r4 = _2[0][_2[0][r4] ^ Me(t4[1], 0)] ^ Me(t4[0], 0), n3 = _2[0][_2[1][n3] ^ Me(t4[1], 1)] ^ Me(t4[0], 1), i3 = _2[1][_2[0][i3] ^ Me(t4[1], 2)] ^ Me(t4[0], 2), a4 = _2[1][_2[1][a4] ^ Me(t4[1], 3)] ^ Me(t4[0], 3);
        }
        return E2[0][r4] ^ E2[1][n3] ^ E2[2][i3] ^ E2[3][a4];
      }
      for (e3 = e3.slice(0, 32), r3 = e3.length; 16 !== r3 && 24 !== r3 && 32 !== r3; ) e3[r3++] = 0;
      for (r3 = 0; r3 < e3.length; r3 += 4) l2[r3 >> 2] = ze(e3, r3);
      for (r3 = 0; r3 < 256; r3++) _2[0][r3] = P2(0, r3), _2[1][r3] = P2(1, r3);
      for (r3 = 0; r3 < 256; r3++) p2 = _2[1][r3], f2 = S2(p2), g2 = K2(p2), E2[0][r3] = p2 + (f2 << 8) + (g2 << 16) + (g2 << 24), E2[2][r3] = f2 + (g2 << 8) + (p2 << 16) + (g2 << 24), p2 = _2[0][r3], f2 = S2(p2), g2 = K2(p2), E2[1][r3] = g2 + (g2 << 8) + (f2 << 16) + (p2 << 24), E2[3][r3] = f2 + (p2 << 8) + (g2 << 16) + (f2 << 24);
      for (y2 = l2.length / 2, r3 = 0; r3 < y2; r3++) a3 = l2[r3 + r3], h2[r3] = a3, s3 = l2[r3 + r3 + 1], u2[r3] = s3, d2[y2 - r3 - 1] = x2(a3, s3);
      for (r3 = 0; r3 < 40; r3 += 2) a3 = 16843009 * r3, s3 = a3 + 16843009, a3 = U2(a3, h2), s3 = Be(U2(s3, u2), 8), n2[r3] = a3 + s3 & Te, n2[r3 + 1] = Be(a3 + 2 * s3, 9);
      for (r3 = 0; r3 < 256; r3++) switch (a3 = s3 = o3 = c3 = r3, y2) {
        case 4:
          a3 = _2[1][a3] ^ Me(d2[3], 0), s3 = _2[0][s3] ^ Me(d2[3], 1), o3 = _2[0][o3] ^ Me(d2[3], 2), c3 = _2[1][c3] ^ Me(d2[3], 3);
        case 3:
          a3 = _2[1][a3] ^ Me(d2[2], 0), s3 = _2[1][s3] ^ Me(d2[2], 1), o3 = _2[0][o3] ^ Me(d2[2], 2), c3 = _2[0][c3] ^ Me(d2[2], 3);
        case 2:
          i2[0][r3] = E2[0][_2[0][_2[0][a3] ^ Me(d2[1], 0)] ^ Me(d2[0], 0)], i2[1][r3] = E2[1][_2[0][_2[1][s3] ^ Me(d2[1], 1)] ^ Me(d2[0], 1)], i2[2][r3] = E2[2][_2[1][_2[0][o3] ^ Me(d2[1], 2)] ^ Me(d2[0], 2)], i2[3][r3] = E2[3][_2[1][_2[1][c3] ^ Me(d2[1], 3)] ^ Me(d2[0], 3)];
      }
    }, close: function() {
      n2 = [], i2 = [[], [], [], []];
    }, encrypt: function(e4, i3) {
      t2 = e4, r2 = i3;
      const a3 = [ze(t2, r2) ^ n2[0], ze(t2, r2 + 4) ^ n2[1], ze(t2, r2 + 8) ^ n2[2], ze(t2, r2 + 12) ^ n2[3]];
      for (let e5 = 0; e5 < 8; e5++) o2(e5, a3);
      return Re(t2, r2, a3[2] ^ n2[4]), Re(t2, r2 + 4, a3[3] ^ n2[5]), Re(t2, r2 + 8, a3[0] ^ n2[6]), Re(t2, r2 + 12, a3[1] ^ n2[7]), r2 += 16, t2;
    }, decrypt: function(e4, i3) {
      t2 = e4, r2 = i3;
      const a3 = [ze(t2, r2) ^ n2[4], ze(t2, r2 + 4) ^ n2[5], ze(t2, r2 + 8) ^ n2[6], ze(t2, r2 + 12) ^ n2[7]];
      for (let e5 = 7; e5 >= 0; e5--) c2(e5, a3);
      Re(t2, r2, a3[2] ^ n2[0]), Re(t2, r2 + 4, a3[3] ^ n2[1]), Re(t2, r2 + 8, a3[0] ^ n2[2]), Re(t2, r2 + 12, a3[1] ^ n2[3]), r2 += 16;
    }, finalize: function() {
      return t2;
    } };
  }(), this.tf.open(Array.from(e2), 0), this.encrypt = function(e3) {
    return this.tf.encrypt(Array.from(e3), 0);
  };
}
function Ne() {
}
function Oe(e2) {
  this.bf = new Ne(), this.bf.init(e2), this.encrypt = function(e3) {
    return this.bf.encryptBlock(e3);
  };
}
Le.keySize = Le.prototype.keySize = 32, Le.blockSize = Le.prototype.blockSize = 16, Ne.prototype.BLOCKSIZE = 8, Ne.prototype.SBOXES = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]], Ne.prototype.PARRAY = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], Ne.prototype.NN = 16, Ne.prototype._clean = function(e2) {
  if (e2 < 0) {
    e2 = (2147483647 & e2) + 2147483648;
  }
  return e2;
}, Ne.prototype._F = function(e2) {
  let t2;
  const r2 = 255 & e2, n2 = 255 & (e2 >>>= 8), i2 = 255 & (e2 >>>= 8), a2 = 255 & (e2 >>>= 8);
  return t2 = this.sboxes[0][a2] + this.sboxes[1][i2], t2 ^= this.sboxes[2][n2], t2 += this.sboxes[3][r2], t2;
}, Ne.prototype._encryptBlock = function(e2) {
  let t2, r2 = e2[0], n2 = e2[1];
  for (t2 = 0; t2 < this.NN; ++t2) {
    r2 ^= this.parray[t2], n2 = this._F(r2) ^ n2;
    const e3 = r2;
    r2 = n2, n2 = e3;
  }
  r2 ^= this.parray[this.NN + 0], n2 ^= this.parray[this.NN + 1], e2[0] = this._clean(n2), e2[1] = this._clean(r2);
}, Ne.prototype.encryptBlock = function(e2) {
  let t2;
  const r2 = [0, 0], n2 = this.BLOCKSIZE / 2;
  for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2) r2[0] = r2[0] << 8 | 255 & e2[t2 + 0], r2[1] = r2[1] << 8 | 255 & e2[t2 + n2];
  this._encryptBlock(r2);
  const i2 = [];
  for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2) i2[t2 + 0] = r2[0] >>> 24 - 8 * t2 & 255, i2[t2 + n2] = r2[1] >>> 24 - 8 * t2 & 255;
  return i2;
}, Ne.prototype._decryptBlock = function(e2) {
  let t2, r2 = e2[0], n2 = e2[1];
  for (t2 = this.NN + 1; t2 > 1; --t2) {
    r2 ^= this.parray[t2], n2 = this._F(r2) ^ n2;
    const e3 = r2;
    r2 = n2, n2 = e3;
  }
  r2 ^= this.parray[1], n2 ^= this.parray[0], e2[0] = this._clean(n2), e2[1] = this._clean(r2);
}, Ne.prototype.init = function(e2) {
  let t2, r2 = 0;
  for (this.parray = [], t2 = 0; t2 < this.NN + 2; ++t2) {
    let n3 = 0;
    for (let t3 = 0; t3 < 4; ++t3) n3 = n3 << 8 | 255 & e2[r2], ++r2 >= e2.length && (r2 = 0);
    this.parray[t2] = this.PARRAY[t2] ^ n3;
  }
  for (this.sboxes = [], t2 = 0; t2 < 4; ++t2) for (this.sboxes[t2] = [], r2 = 0; r2 < 256; ++r2) this.sboxes[t2][r2] = this.SBOXES[t2][r2];
  const n2 = [0, 0];
  for (t2 = 0; t2 < this.NN + 2; t2 += 2) this._encryptBlock(n2), this.parray[t2 + 0] = n2[0], this.parray[t2 + 1] = n2[1];
  for (t2 = 0; t2 < 4; ++t2) for (r2 = 0; r2 < 256; r2 += 2) this._encryptBlock(n2), this.sboxes[t2][r2 + 0] = n2[0], this.sboxes[t2][r2 + 1] = n2[1];
}, Oe.keySize = Oe.prototype.keySize = 16, Oe.blockSize = Oe.prototype.blockSize = 8;
var Fe = xe(128);
var He = xe(192);
var je = xe(256);
var qe = Object.freeze({ __proto__: null, aes128: Fe, aes192: He, aes256: je, des: function(e2) {
  this.key = e2, this.encrypt = function(e3, t2) {
    return Pe(Ue(this.key), e3, true, 0, null, t2);
  }, this.decrypt = function(e3, t2) {
    return Pe(Ue(this.key), e3, false, 0, null, t2);
  };
}, tripledes: De, cast5: Ie, twofish: Le, blowfish: Oe, idea: function() {
  throw Error("IDEA symmetric-key algorithm not implemented");
} });
var Ge = function(e2, t2, r2) {
  ;
  var n2 = 0, i2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, h2 = 0;
  var u2 = 0, l2 = 0, y2 = 0, d2 = 0, p2 = 0, f2 = 0, g2 = 0, m2 = 0, w2 = 0, b2 = 0;
  var k2 = new e2.Uint8Array(r2);
  function v2(e3, t3, r3, c3, h3, u3, l3, y3, d3, p3, f3, g3, m3, w3, b3, k3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    c3 = c3 | 0;
    h3 = h3 | 0;
    u3 = u3 | 0;
    l3 = l3 | 0;
    y3 = y3 | 0;
    d3 = d3 | 0;
    p3 = p3 | 0;
    f3 = f3 | 0;
    g3 = g3 | 0;
    m3 = m3 | 0;
    w3 = w3 | 0;
    b3 = b3 | 0;
    k3 = k3 | 0;
    var v3 = 0, A3 = 0, _3 = 0, E3 = 0, S3 = 0, K3 = 0, x3 = 0, P3 = 0, U3 = 0, D3 = 0, C3 = 0, I3 = 0, T2 = 0, B2 = 0, z2 = 0, R2 = 0, M2 = 0, L2 = 0, N2 = 0, O2 = 0, F2 = 0, H2 = 0, j2 = 0, q2 = 0, G2 = 0, V2 = 0, W2 = 0, $2 = 0, Z2 = 0, X2 = 0, Q2 = 0, Y2 = 0, J2 = 0, ee2 = 0, te2 = 0, re2 = 0, ne2 = 0, ie2 = 0, ae2 = 0, se2 = 0, oe2 = 0, ce2 = 0, he2 = 0, ue2 = 0, le2 = 0, ye2 = 0, de2 = 0, pe2 = 0, fe2 = 0, ge2 = 0, me2 = 0, we2 = 0, be2 = 0, ke2 = 0, ve2 = 0, Ae2 = 0, _e2 = 0, Ee2 = 0, Se2 = 0, Ke2 = 0, xe2 = 0, Pe2 = 0, Ue2 = 0, De2 = 0, Ce2 = 0, Ie2 = 0, Te2 = 0, Be2 = 0, ze2 = 0, Re2 = 0, Me2 = 0;
    v3 = n2;
    A3 = i2;
    _3 = a2;
    E3 = s2;
    S3 = o2;
    x3 = e3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = t3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = r3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = c3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = h3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = u3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = l3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = y3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = d3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = p3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = f3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = g3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = m3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = w3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = b3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    x3 = k3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = w3 ^ d3 ^ r3 ^ e3;
    P3 = K3 << 1 | K3 >>> 31;
    x3 = P3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = b3 ^ p3 ^ c3 ^ t3;
    U3 = K3 << 1 | K3 >>> 31;
    x3 = U3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = k3 ^ f3 ^ h3 ^ r3;
    D3 = K3 << 1 | K3 >>> 31;
    x3 = D3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = P3 ^ g3 ^ u3 ^ c3;
    C3 = K3 << 1 | K3 >>> 31;
    x3 = C3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | ~A3 & E3) + 1518500249 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = U3 ^ m3 ^ l3 ^ h3;
    I3 = K3 << 1 | K3 >>> 31;
    x3 = I3 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = D3 ^ w3 ^ y3 ^ u3;
    T2 = K3 << 1 | K3 >>> 31;
    x3 = T2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = C3 ^ b3 ^ d3 ^ l3;
    B2 = K3 << 1 | K3 >>> 31;
    x3 = B2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = I3 ^ k3 ^ p3 ^ y3;
    z2 = K3 << 1 | K3 >>> 31;
    x3 = z2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = T2 ^ P3 ^ f3 ^ d3;
    R2 = K3 << 1 | K3 >>> 31;
    x3 = R2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = B2 ^ U3 ^ g3 ^ p3;
    M2 = K3 << 1 | K3 >>> 31;
    x3 = M2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = z2 ^ D3 ^ m3 ^ f3;
    L2 = K3 << 1 | K3 >>> 31;
    x3 = L2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = R2 ^ C3 ^ w3 ^ g3;
    N2 = K3 << 1 | K3 >>> 31;
    x3 = N2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = M2 ^ I3 ^ b3 ^ m3;
    O2 = K3 << 1 | K3 >>> 31;
    x3 = O2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = L2 ^ T2 ^ k3 ^ w3;
    F2 = K3 << 1 | K3 >>> 31;
    x3 = F2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = N2 ^ B2 ^ P3 ^ b3;
    H2 = K3 << 1 | K3 >>> 31;
    x3 = H2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = O2 ^ z2 ^ U3 ^ k3;
    j2 = K3 << 1 | K3 >>> 31;
    x3 = j2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = F2 ^ R2 ^ D3 ^ P3;
    q2 = K3 << 1 | K3 >>> 31;
    x3 = q2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = H2 ^ M2 ^ C3 ^ U3;
    G2 = K3 << 1 | K3 >>> 31;
    x3 = G2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = j2 ^ L2 ^ I3 ^ D3;
    V2 = K3 << 1 | K3 >>> 31;
    x3 = V2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = q2 ^ N2 ^ T2 ^ C3;
    W2 = K3 << 1 | K3 >>> 31;
    x3 = W2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = G2 ^ O2 ^ B2 ^ I3;
    $2 = K3 << 1 | K3 >>> 31;
    x3 = $2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = V2 ^ F2 ^ z2 ^ T2;
    Z2 = K3 << 1 | K3 >>> 31;
    x3 = Z2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = W2 ^ H2 ^ R2 ^ B2;
    X2 = K3 << 1 | K3 >>> 31;
    x3 = X2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = $2 ^ j2 ^ M2 ^ z2;
    Q2 = K3 << 1 | K3 >>> 31;
    x3 = Q2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) + 1859775393 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Z2 ^ q2 ^ L2 ^ R2;
    Y2 = K3 << 1 | K3 >>> 31;
    x3 = Y2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = X2 ^ G2 ^ N2 ^ M2;
    J2 = K3 << 1 | K3 >>> 31;
    x3 = J2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Q2 ^ V2 ^ O2 ^ L2;
    ee2 = K3 << 1 | K3 >>> 31;
    x3 = ee2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Y2 ^ W2 ^ F2 ^ N2;
    te2 = K3 << 1 | K3 >>> 31;
    x3 = te2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = J2 ^ $2 ^ H2 ^ O2;
    re2 = K3 << 1 | K3 >>> 31;
    x3 = re2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ee2 ^ Z2 ^ j2 ^ F2;
    ne2 = K3 << 1 | K3 >>> 31;
    x3 = ne2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = te2 ^ X2 ^ q2 ^ H2;
    ie2 = K3 << 1 | K3 >>> 31;
    x3 = ie2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = re2 ^ Q2 ^ G2 ^ j2;
    ae2 = K3 << 1 | K3 >>> 31;
    x3 = ae2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ne2 ^ Y2 ^ V2 ^ q2;
    se2 = K3 << 1 | K3 >>> 31;
    x3 = se2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ie2 ^ J2 ^ W2 ^ G2;
    oe2 = K3 << 1 | K3 >>> 31;
    x3 = oe2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ae2 ^ ee2 ^ $2 ^ V2;
    ce2 = K3 << 1 | K3 >>> 31;
    x3 = ce2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = se2 ^ te2 ^ Z2 ^ W2;
    he2 = K3 << 1 | K3 >>> 31;
    x3 = he2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = oe2 ^ re2 ^ X2 ^ $2;
    ue2 = K3 << 1 | K3 >>> 31;
    x3 = ue2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ce2 ^ ne2 ^ Q2 ^ Z2;
    le2 = K3 << 1 | K3 >>> 31;
    x3 = le2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = he2 ^ ie2 ^ Y2 ^ X2;
    ye2 = K3 << 1 | K3 >>> 31;
    x3 = ye2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ue2 ^ ae2 ^ J2 ^ Q2;
    de2 = K3 << 1 | K3 >>> 31;
    x3 = de2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = le2 ^ se2 ^ ee2 ^ Y2;
    pe2 = K3 << 1 | K3 >>> 31;
    x3 = pe2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ye2 ^ oe2 ^ te2 ^ J2;
    fe2 = K3 << 1 | K3 >>> 31;
    x3 = fe2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = de2 ^ ce2 ^ re2 ^ ee2;
    ge2 = K3 << 1 | K3 >>> 31;
    x3 = ge2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = pe2 ^ he2 ^ ne2 ^ te2;
    me2 = K3 << 1 | K3 >>> 31;
    x3 = me2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 & _3 | A3 & E3 | _3 & E3) - 1894007588 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = fe2 ^ ue2 ^ ie2 ^ re2;
    we2 = K3 << 1 | K3 >>> 31;
    x3 = we2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ge2 ^ le2 ^ ae2 ^ ne2;
    be2 = K3 << 1 | K3 >>> 31;
    x3 = be2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = me2 ^ ye2 ^ se2 ^ ie2;
    ke2 = K3 << 1 | K3 >>> 31;
    x3 = ke2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = we2 ^ de2 ^ oe2 ^ ae2;
    ve2 = K3 << 1 | K3 >>> 31;
    x3 = ve2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = be2 ^ pe2 ^ ce2 ^ se2;
    Ae2 = K3 << 1 | K3 >>> 31;
    x3 = Ae2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ke2 ^ fe2 ^ he2 ^ oe2;
    _e2 = K3 << 1 | K3 >>> 31;
    x3 = _e2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = ve2 ^ ge2 ^ ue2 ^ ce2;
    Ee2 = K3 << 1 | K3 >>> 31;
    x3 = Ee2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ae2 ^ me2 ^ le2 ^ he2;
    Se2 = K3 << 1 | K3 >>> 31;
    x3 = Se2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = _e2 ^ we2 ^ ye2 ^ ue2;
    Ke2 = K3 << 1 | K3 >>> 31;
    x3 = Ke2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ee2 ^ be2 ^ de2 ^ le2;
    xe2 = K3 << 1 | K3 >>> 31;
    x3 = xe2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Se2 ^ ke2 ^ pe2 ^ ye2;
    Pe2 = K3 << 1 | K3 >>> 31;
    x3 = Pe2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ke2 ^ ve2 ^ fe2 ^ de2;
    Ue2 = K3 << 1 | K3 >>> 31;
    x3 = Ue2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = xe2 ^ Ae2 ^ ge2 ^ pe2;
    De2 = K3 << 1 | K3 >>> 31;
    x3 = De2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Pe2 ^ _e2 ^ me2 ^ fe2;
    Ce2 = K3 << 1 | K3 >>> 31;
    x3 = Ce2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ue2 ^ Ee2 ^ we2 ^ ge2;
    Ie2 = K3 << 1 | K3 >>> 31;
    x3 = Ie2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = De2 ^ Se2 ^ be2 ^ me2;
    Te2 = K3 << 1 | K3 >>> 31;
    x3 = Te2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ce2 ^ Ke2 ^ ke2 ^ we2;
    Be2 = K3 << 1 | K3 >>> 31;
    x3 = Be2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Ie2 ^ xe2 ^ ve2 ^ be2;
    ze2 = K3 << 1 | K3 >>> 31;
    x3 = ze2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Te2 ^ Pe2 ^ Ae2 ^ ke2;
    Re2 = K3 << 1 | K3 >>> 31;
    x3 = Re2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    K3 = Be2 ^ Ue2 ^ _e2 ^ ve2;
    Me2 = K3 << 1 | K3 >>> 31;
    x3 = Me2 + (v3 << 5 | v3 >>> 27) + S3 + (A3 ^ _3 ^ E3) - 899497514 | 0;
    S3 = E3;
    E3 = _3;
    _3 = A3 << 30 | A3 >>> 2;
    A3 = v3;
    v3 = x3;
    n2 = n2 + v3 | 0;
    i2 = i2 + A3 | 0;
    a2 = a2 + _3 | 0;
    s2 = s2 + E3 | 0;
    o2 = o2 + S3 | 0;
  }
  function A2(e3) {
    e3 = e3 | 0;
    v2(k2[e3 | 0] << 24 | k2[e3 | 1] << 16 | k2[e3 | 2] << 8 | k2[e3 | 3], k2[e3 | 4] << 24 | k2[e3 | 5] << 16 | k2[e3 | 6] << 8 | k2[e3 | 7], k2[e3 | 8] << 24 | k2[e3 | 9] << 16 | k2[e3 | 10] << 8 | k2[e3 | 11], k2[e3 | 12] << 24 | k2[e3 | 13] << 16 | k2[e3 | 14] << 8 | k2[e3 | 15], k2[e3 | 16] << 24 | k2[e3 | 17] << 16 | k2[e3 | 18] << 8 | k2[e3 | 19], k2[e3 | 20] << 24 | k2[e3 | 21] << 16 | k2[e3 | 22] << 8 | k2[e3 | 23], k2[e3 | 24] << 24 | k2[e3 | 25] << 16 | k2[e3 | 26] << 8 | k2[e3 | 27], k2[e3 | 28] << 24 | k2[e3 | 29] << 16 | k2[e3 | 30] << 8 | k2[e3 | 31], k2[e3 | 32] << 24 | k2[e3 | 33] << 16 | k2[e3 | 34] << 8 | k2[e3 | 35], k2[e3 | 36] << 24 | k2[e3 | 37] << 16 | k2[e3 | 38] << 8 | k2[e3 | 39], k2[e3 | 40] << 24 | k2[e3 | 41] << 16 | k2[e3 | 42] << 8 | k2[e3 | 43], k2[e3 | 44] << 24 | k2[e3 | 45] << 16 | k2[e3 | 46] << 8 | k2[e3 | 47], k2[e3 | 48] << 24 | k2[e3 | 49] << 16 | k2[e3 | 50] << 8 | k2[e3 | 51], k2[e3 | 52] << 24 | k2[e3 | 53] << 16 | k2[e3 | 54] << 8 | k2[e3 | 55], k2[e3 | 56] << 24 | k2[e3 | 57] << 16 | k2[e3 | 58] << 8 | k2[e3 | 59], k2[e3 | 60] << 24 | k2[e3 | 61] << 16 | k2[e3 | 62] << 8 | k2[e3 | 63]);
  }
  function _2(e3) {
    e3 = e3 | 0;
    k2[e3 | 0] = n2 >>> 24;
    k2[e3 | 1] = n2 >>> 16 & 255;
    k2[e3 | 2] = n2 >>> 8 & 255;
    k2[e3 | 3] = n2 & 255;
    k2[e3 | 4] = i2 >>> 24;
    k2[e3 | 5] = i2 >>> 16 & 255;
    k2[e3 | 6] = i2 >>> 8 & 255;
    k2[e3 | 7] = i2 & 255;
    k2[e3 | 8] = a2 >>> 24;
    k2[e3 | 9] = a2 >>> 16 & 255;
    k2[e3 | 10] = a2 >>> 8 & 255;
    k2[e3 | 11] = a2 & 255;
    k2[e3 | 12] = s2 >>> 24;
    k2[e3 | 13] = s2 >>> 16 & 255;
    k2[e3 | 14] = s2 >>> 8 & 255;
    k2[e3 | 15] = s2 & 255;
    k2[e3 | 16] = o2 >>> 24;
    k2[e3 | 17] = o2 >>> 16 & 255;
    k2[e3 | 18] = o2 >>> 8 & 255;
    k2[e3 | 19] = o2 & 255;
  }
  function E2() {
    n2 = 1732584193;
    i2 = 4023233417;
    a2 = 2562383102;
    s2 = 271733878;
    o2 = 3285377520;
    c2 = h2 = 0;
  }
  function S2(e3, t3, r3, u3, l3, y3, d3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    u3 = u3 | 0;
    l3 = l3 | 0;
    y3 = y3 | 0;
    d3 = d3 | 0;
    n2 = e3;
    i2 = t3;
    a2 = r3;
    s2 = u3;
    o2 = l3;
    c2 = y3;
    h2 = d3;
  }
  function K2(e3, t3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    var r3 = 0;
    if (e3 & 63) return -1;
    while ((t3 | 0) >= 64) {
      A2(e3);
      e3 = e3 + 64 | 0;
      t3 = t3 - 64 | 0;
      r3 = r3 + 64 | 0;
    }
    c2 = c2 + r3 | 0;
    if (c2 >>> 0 < r3 >>> 0) h2 = h2 + 1 | 0;
    return r3 | 0;
  }
  function x2(e3, t3, r3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    var n3 = 0, i3 = 0;
    if (e3 & 63) return -1;
    if (~r3) {
      if (r3 & 31) return -1;
    }
    if ((t3 | 0) >= 64) {
      n3 = K2(e3, t3) | 0;
      if ((n3 | 0) == -1) return -1;
      e3 = e3 + n3 | 0;
      t3 = t3 - n3 | 0;
    }
    n3 = n3 + t3 | 0;
    c2 = c2 + t3 | 0;
    if (c2 >>> 0 < t3 >>> 0) h2 = h2 + 1 | 0;
    k2[e3 | t3] = 128;
    if ((t3 | 0) >= 56) {
      for (i3 = t3 + 1 | 0; (i3 | 0) < 64; i3 = i3 + 1 | 0) k2[e3 | i3] = 0;
      A2(e3);
      t3 = 0;
      k2[e3 | 0] = 0;
    }
    for (i3 = t3 + 1 | 0; (i3 | 0) < 59; i3 = i3 + 1 | 0) k2[e3 | i3] = 0;
    k2[e3 | 56] = h2 >>> 21 & 255;
    k2[e3 | 57] = h2 >>> 13 & 255;
    k2[e3 | 58] = h2 >>> 5 & 255;
    k2[e3 | 59] = h2 << 3 & 255 | c2 >>> 29;
    k2[e3 | 60] = c2 >>> 21 & 255;
    k2[e3 | 61] = c2 >>> 13 & 255;
    k2[e3 | 62] = c2 >>> 5 & 255;
    k2[e3 | 63] = c2 << 3 & 255;
    A2(e3);
    if (~r3) _2(r3);
    return n3 | 0;
  }
  function P2() {
    n2 = u2;
    i2 = l2;
    a2 = y2;
    s2 = d2;
    o2 = p2;
    c2 = 64;
    h2 = 0;
  }
  function U2() {
    n2 = f2;
    i2 = g2;
    a2 = m2;
    s2 = w2;
    o2 = b2;
    c2 = 64;
    h2 = 0;
  }
  function D2(e3, t3, r3, k3, A3, _3, S3, K3, x3, P3, U3, D3, C3, I3, T2, B2) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    k3 = k3 | 0;
    A3 = A3 | 0;
    _3 = _3 | 0;
    S3 = S3 | 0;
    K3 = K3 | 0;
    x3 = x3 | 0;
    P3 = P3 | 0;
    U3 = U3 | 0;
    D3 = D3 | 0;
    C3 = C3 | 0;
    I3 = I3 | 0;
    T2 = T2 | 0;
    B2 = B2 | 0;
    E2();
    v2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, k3 ^ 1549556828, A3 ^ 1549556828, _3 ^ 1549556828, S3 ^ 1549556828, K3 ^ 1549556828, x3 ^ 1549556828, P3 ^ 1549556828, U3 ^ 1549556828, D3 ^ 1549556828, C3 ^ 1549556828, I3 ^ 1549556828, T2 ^ 1549556828, B2 ^ 1549556828);
    f2 = n2;
    g2 = i2;
    m2 = a2;
    w2 = s2;
    b2 = o2;
    E2();
    v2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, k3 ^ 909522486, A3 ^ 909522486, _3 ^ 909522486, S3 ^ 909522486, K3 ^ 909522486, x3 ^ 909522486, P3 ^ 909522486, U3 ^ 909522486, D3 ^ 909522486, C3 ^ 909522486, I3 ^ 909522486, T2 ^ 909522486, B2 ^ 909522486);
    u2 = n2;
    l2 = i2;
    y2 = a2;
    d2 = s2;
    p2 = o2;
    c2 = 64;
    h2 = 0;
  }
  function C2(e3, t3, r3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    var c3 = 0, h3 = 0, u3 = 0, l3 = 0, y3 = 0, d3 = 0;
    if (e3 & 63) return -1;
    if (~r3) {
      if (r3 & 31) return -1;
    }
    d3 = x2(e3, t3, -1) | 0;
    c3 = n2, h3 = i2, u3 = a2, l3 = s2, y3 = o2;
    U2();
    v2(c3, h3, u3, l3, y3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
    if (~r3) _2(r3);
    return d3 | 0;
  }
  function I2(e3, t3, r3, c3, h3) {
    e3 = e3 | 0;
    t3 = t3 | 0;
    r3 = r3 | 0;
    c3 = c3 | 0;
    h3 = h3 | 0;
    var u3 = 0, l3 = 0, y3 = 0, d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0;
    if (e3 & 63) return -1;
    if (~h3) {
      if (h3 & 31) return -1;
    }
    k2[e3 + t3 | 0] = r3 >>> 24;
    k2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
    k2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
    k2[e3 + t3 + 3 | 0] = r3 & 255;
    C2(e3, t3 + 4 | 0, -1) | 0;
    u3 = f3 = n2, l3 = g3 = i2, y3 = m3 = a2, d3 = w3 = s2, p3 = b3 = o2;
    c3 = c3 - 1 | 0;
    while ((c3 | 0) > 0) {
      P2();
      v2(f3, g3, m3, w3, b3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
      f3 = n2, g3 = i2, m3 = a2, w3 = s2, b3 = o2;
      U2();
      v2(f3, g3, m3, w3, b3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
      f3 = n2, g3 = i2, m3 = a2, w3 = s2, b3 = o2;
      u3 = u3 ^ n2;
      l3 = l3 ^ i2;
      y3 = y3 ^ a2;
      d3 = d3 ^ s2;
      p3 = p3 ^ o2;
      c3 = c3 - 1 | 0;
    }
    n2 = u3;
    i2 = l3;
    a2 = y3;
    s2 = d3;
    o2 = p3;
    if (~h3) _2(h3);
    return 0;
  }
  return { reset: E2, init: S2, process: K2, finish: x2, hmac_reset: P2, hmac_init: D2, hmac_finish: C2, pbkdf2_generate_block: I2 };
};
var Ve = class {
  constructor() {
    this.pos = 0, this.len = 0;
  }
  reset() {
    const { asm: e2 } = this.acquire_asm();
    return this.result = null, this.pos = 0, this.len = 0, e2.reset(), this;
  }
  process(e2) {
    if (null !== this.result) throw new ke("state must be reset before processing new data");
    const { asm: t2, heap: r2 } = this.acquire_asm();
    let n2 = this.pos, i2 = this.len, a2 = 0, s2 = e2.length, o2 = 0;
    for (; s2 > 0; ) o2 = we(r2, n2 + i2, e2, a2, s2), i2 += o2, a2 += o2, s2 -= o2, o2 = t2.process(n2, i2), n2 += o2, i2 -= o2, i2 || (n2 = 0);
    return this.pos = n2, this.len = i2, this;
  }
  finish() {
    if (null !== this.result) throw new ke("state must be reset before processing new data");
    const { asm: e2, heap: t2 } = this.acquire_asm();
    return e2.finish(this.pos, this.len, 0), this.result = new Uint8Array(this.HASH_SIZE), this.result.set(t2.subarray(0, this.HASH_SIZE)), this.pos = 0, this.len = 0, this.release_asm(), this;
  }
};
var We = [];
var $e = [];
var Ze = class _Ze extends Ve {
  constructor() {
    super(), this.NAME = "sha1", this.BLOCK_SIZE = 64, this.HASH_SIZE = 20, this.acquire_asm();
  }
  acquire_asm() {
    return void 0 !== this.heap && void 0 !== this.asm || (this.heap = We.pop() || me(), this.asm = $e.pop() || Ge({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
  }
  release_asm() {
    void 0 !== this.heap && void 0 !== this.asm && (We.push(this.heap), $e.push(this.asm)), this.heap = void 0, this.asm = void 0;
  }
  static bytes(e2) {
    return new _Ze().process(e2).finish().result;
  }
};
Ze.NAME = "sha1", Ze.heap_pool = [], Ze.asm_pool = [], Ze.asm_function = Ge;
var Xe = [];
var Qe = [];
var Ye = class _Ye extends Ve {
  constructor() {
    super(), this.NAME = "sha256", this.BLOCK_SIZE = 64, this.HASH_SIZE = 32, this.acquire_asm();
  }
  acquire_asm() {
    return void 0 !== this.heap && void 0 !== this.asm || (this.heap = Xe.pop() || me(), this.asm = Qe.pop() || function(e2, t2, r2) {
      ;
      var n2 = 0, i2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, h2 = 0, u2 = 0, l2 = 0, y2 = 0, d2 = 0, p2 = 0, f2 = 0, g2 = 0, m2 = 0, w2 = 0, b2 = 0, k2 = 0, v2 = 0, A2 = 0, _2 = 0, E2 = 0, S2 = 0, K2 = 0, x2 = 0, P2 = 0, U2 = new e2.Uint8Array(r2);
      function D2(e3, t3, r3, l3, y3, d3, p3, f3, g3, m3, w3, b3, k3, v3, A3, _3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        l3 = l3 | 0;
        y3 = y3 | 0;
        d3 = d3 | 0;
        p3 = p3 | 0;
        f3 = f3 | 0;
        g3 = g3 | 0;
        m3 = m3 | 0;
        w3 = w3 | 0;
        b3 = b3 | 0;
        k3 = k3 | 0;
        v3 = v3 | 0;
        A3 = A3 | 0;
        _3 = _3 | 0;
        var E3 = 0, S3 = 0, K3 = 0, x3 = 0, P3 = 0, U3 = 0, D3 = 0, C3 = 0;
        E3 = n2;
        S3 = i2;
        K3 = a2;
        x3 = s2;
        P3 = o2;
        U3 = c2;
        D3 = h2;
        C3 = u2;
        C3 = e3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 1116352408 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        D3 = t3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 1899447441 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        U3 = r3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 3049323471 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        P3 = l3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 3921009573 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        x3 = y3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 961987163 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        K3 = d3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 1508970993 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        S3 = p3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 2453635748 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        E3 = f3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 2870763221 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 3624381080 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        D3 = m3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 310598401 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        U3 = w3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 607225278 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        P3 = b3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 1426881987 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        x3 = k3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 1925078388 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        K3 = v3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 2162078206 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        S3 = A3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 2614888103 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        E3 = _3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 3248222580 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + e3 + m3 | 0;
        C3 = e3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 3835390401 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + t3 + w3 | 0;
        D3 = t3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 4022224774 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        r3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + b3 | 0;
        U3 = r3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 264347078 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        l3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + l3 + k3 | 0;
        P3 = l3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 604807628 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        y3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + y3 + v3 | 0;
        x3 = y3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 770255983 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        d3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + d3 + A3 | 0;
        K3 = d3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 1249150122 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        p3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + p3 + _3 | 0;
        S3 = p3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 1555081692 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        f3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + f3 + e3 | 0;
        E3 = f3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 1996064986 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + g3 + t3 | 0;
        C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 2554220882 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + m3 + r3 | 0;
        D3 = m3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 2821834349 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        w3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + l3 | 0;
        U3 = w3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 2952996808 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        b3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + b3 + y3 | 0;
        P3 = b3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 3210313671 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        k3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + k3 + d3 | 0;
        x3 = k3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 3336571891 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        v3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + v3 + p3 | 0;
        K3 = v3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 3584528711 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        A3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + A3 + f3 | 0;
        S3 = A3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 113926993 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        _3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + _3 + g3 | 0;
        E3 = _3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 338241895 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + e3 + m3 | 0;
        C3 = e3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 666307205 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + t3 + w3 | 0;
        D3 = t3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 773529912 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        r3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + b3 | 0;
        U3 = r3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 1294757372 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        l3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + l3 + k3 | 0;
        P3 = l3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 1396182291 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        y3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + y3 + v3 | 0;
        x3 = y3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 1695183700 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        d3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + d3 + A3 | 0;
        K3 = d3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 1986661051 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        p3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + p3 + _3 | 0;
        S3 = p3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 2177026350 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        f3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + f3 + e3 | 0;
        E3 = f3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 2456956037 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + g3 + t3 | 0;
        C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 2730485921 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + m3 + r3 | 0;
        D3 = m3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 2820302411 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        w3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + l3 | 0;
        U3 = w3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 3259730800 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        b3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + b3 + y3 | 0;
        P3 = b3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 3345764771 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        k3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + k3 + d3 | 0;
        x3 = k3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 3516065817 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        v3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + v3 + p3 | 0;
        K3 = v3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 3600352804 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        A3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + A3 + f3 | 0;
        S3 = A3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 4094571909 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        _3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + _3 + g3 | 0;
        E3 = _3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 275423344 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + e3 + m3 | 0;
        C3 = e3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 430227734 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + t3 + w3 | 0;
        D3 = t3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 506948616 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        r3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + b3 | 0;
        U3 = r3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 659060556 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        l3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + l3 + k3 | 0;
        P3 = l3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 883997877 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        y3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + y3 + v3 | 0;
        x3 = y3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 958139571 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        d3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + d3 + A3 | 0;
        K3 = d3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 1322822218 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        p3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + p3 + _3 | 0;
        S3 = p3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 1537002063 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        f3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + f3 + e3 | 0;
        E3 = f3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 1747873779 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + g3 + t3 | 0;
        C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (D3 ^ P3 & (U3 ^ D3)) + 1955562222 | 0;
        x3 = x3 + C3 | 0;
        C3 = C3 + (E3 & S3 ^ K3 & (E3 ^ S3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
        m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + m3 + r3 | 0;
        D3 = m3 + D3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (U3 ^ x3 & (P3 ^ U3)) + 2024104815 | 0;
        K3 = K3 + D3 | 0;
        D3 = D3 + (C3 & E3 ^ S3 & (C3 ^ E3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
        w3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + l3 | 0;
        U3 = w3 + U3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (P3 ^ K3 & (x3 ^ P3)) + 2227730452 | 0;
        S3 = S3 + U3 | 0;
        U3 = U3 + (D3 & C3 ^ E3 & (D3 ^ C3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
        b3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + b3 + y3 | 0;
        P3 = b3 + P3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (x3 ^ S3 & (K3 ^ x3)) + 2361852424 | 0;
        E3 = E3 + P3 | 0;
        P3 = P3 + (U3 & D3 ^ C3 & (U3 ^ D3)) + (U3 >>> 2 ^ U3 >>> 13 ^ U3 >>> 22 ^ U3 << 30 ^ U3 << 19 ^ U3 << 10) | 0;
        k3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + k3 + d3 | 0;
        x3 = k3 + x3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (K3 ^ E3 & (S3 ^ K3)) + 2428436474 | 0;
        C3 = C3 + x3 | 0;
        x3 = x3 + (P3 & U3 ^ D3 & (P3 ^ U3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
        v3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + v3 + p3 | 0;
        K3 = v3 + K3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (E3 ^ S3)) + 2756734187 | 0;
        D3 = D3 + K3 | 0;
        K3 = K3 + (x3 & P3 ^ U3 & (x3 ^ P3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
        A3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + A3 + f3 | 0;
        S3 = A3 + S3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (C3 ^ E3)) + 3204031479 | 0;
        U3 = U3 + S3 | 0;
        S3 = S3 + (K3 & x3 ^ P3 & (K3 ^ x3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
        _3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + _3 + g3 | 0;
        E3 = _3 + E3 + (U3 >>> 6 ^ U3 >>> 11 ^ U3 >>> 25 ^ U3 << 26 ^ U3 << 21 ^ U3 << 7) + (C3 ^ U3 & (D3 ^ C3)) + 3329325298 | 0;
        P3 = P3 + E3 | 0;
        E3 = E3 + (S3 & K3 ^ x3 & (S3 ^ K3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
        n2 = n2 + E3 | 0;
        i2 = i2 + S3 | 0;
        a2 = a2 + K3 | 0;
        s2 = s2 + x3 | 0;
        o2 = o2 + P3 | 0;
        c2 = c2 + U3 | 0;
        h2 = h2 + D3 | 0;
        u2 = u2 + C3 | 0;
      }
      function C2(e3) {
        e3 = e3 | 0;
        D2(U2[e3 | 0] << 24 | U2[e3 | 1] << 16 | U2[e3 | 2] << 8 | U2[e3 | 3], U2[e3 | 4] << 24 | U2[e3 | 5] << 16 | U2[e3 | 6] << 8 | U2[e3 | 7], U2[e3 | 8] << 24 | U2[e3 | 9] << 16 | U2[e3 | 10] << 8 | U2[e3 | 11], U2[e3 | 12] << 24 | U2[e3 | 13] << 16 | U2[e3 | 14] << 8 | U2[e3 | 15], U2[e3 | 16] << 24 | U2[e3 | 17] << 16 | U2[e3 | 18] << 8 | U2[e3 | 19], U2[e3 | 20] << 24 | U2[e3 | 21] << 16 | U2[e3 | 22] << 8 | U2[e3 | 23], U2[e3 | 24] << 24 | U2[e3 | 25] << 16 | U2[e3 | 26] << 8 | U2[e3 | 27], U2[e3 | 28] << 24 | U2[e3 | 29] << 16 | U2[e3 | 30] << 8 | U2[e3 | 31], U2[e3 | 32] << 24 | U2[e3 | 33] << 16 | U2[e3 | 34] << 8 | U2[e3 | 35], U2[e3 | 36] << 24 | U2[e3 | 37] << 16 | U2[e3 | 38] << 8 | U2[e3 | 39], U2[e3 | 40] << 24 | U2[e3 | 41] << 16 | U2[e3 | 42] << 8 | U2[e3 | 43], U2[e3 | 44] << 24 | U2[e3 | 45] << 16 | U2[e3 | 46] << 8 | U2[e3 | 47], U2[e3 | 48] << 24 | U2[e3 | 49] << 16 | U2[e3 | 50] << 8 | U2[e3 | 51], U2[e3 | 52] << 24 | U2[e3 | 53] << 16 | U2[e3 | 54] << 8 | U2[e3 | 55], U2[e3 | 56] << 24 | U2[e3 | 57] << 16 | U2[e3 | 58] << 8 | U2[e3 | 59], U2[e3 | 60] << 24 | U2[e3 | 61] << 16 | U2[e3 | 62] << 8 | U2[e3 | 63]);
      }
      function I2(e3) {
        e3 = e3 | 0;
        U2[e3 | 0] = n2 >>> 24;
        U2[e3 | 1] = n2 >>> 16 & 255;
        U2[e3 | 2] = n2 >>> 8 & 255;
        U2[e3 | 3] = n2 & 255;
        U2[e3 | 4] = i2 >>> 24;
        U2[e3 | 5] = i2 >>> 16 & 255;
        U2[e3 | 6] = i2 >>> 8 & 255;
        U2[e3 | 7] = i2 & 255;
        U2[e3 | 8] = a2 >>> 24;
        U2[e3 | 9] = a2 >>> 16 & 255;
        U2[e3 | 10] = a2 >>> 8 & 255;
        U2[e3 | 11] = a2 & 255;
        U2[e3 | 12] = s2 >>> 24;
        U2[e3 | 13] = s2 >>> 16 & 255;
        U2[e3 | 14] = s2 >>> 8 & 255;
        U2[e3 | 15] = s2 & 255;
        U2[e3 | 16] = o2 >>> 24;
        U2[e3 | 17] = o2 >>> 16 & 255;
        U2[e3 | 18] = o2 >>> 8 & 255;
        U2[e3 | 19] = o2 & 255;
        U2[e3 | 20] = c2 >>> 24;
        U2[e3 | 21] = c2 >>> 16 & 255;
        U2[e3 | 22] = c2 >>> 8 & 255;
        U2[e3 | 23] = c2 & 255;
        U2[e3 | 24] = h2 >>> 24;
        U2[e3 | 25] = h2 >>> 16 & 255;
        U2[e3 | 26] = h2 >>> 8 & 255;
        U2[e3 | 27] = h2 & 255;
        U2[e3 | 28] = u2 >>> 24;
        U2[e3 | 29] = u2 >>> 16 & 255;
        U2[e3 | 30] = u2 >>> 8 & 255;
        U2[e3 | 31] = u2 & 255;
      }
      function T2() {
        n2 = 1779033703;
        i2 = 3144134277;
        a2 = 1013904242;
        s2 = 2773480762;
        o2 = 1359893119;
        c2 = 2600822924;
        h2 = 528734635;
        u2 = 1541459225;
        l2 = y2 = 0;
      }
      function B2(e3, t3, r3, d3, p3, f3, g3, m3, w3, b3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        d3 = d3 | 0;
        p3 = p3 | 0;
        f3 = f3 | 0;
        g3 = g3 | 0;
        m3 = m3 | 0;
        w3 = w3 | 0;
        b3 = b3 | 0;
        n2 = e3;
        i2 = t3;
        a2 = r3;
        s2 = d3;
        o2 = p3;
        c2 = f3;
        h2 = g3;
        u2 = m3;
        l2 = w3;
        y2 = b3;
      }
      function z2(e3, t3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        var r3 = 0;
        if (e3 & 63) return -1;
        while ((t3 | 0) >= 64) {
          C2(e3);
          e3 = e3 + 64 | 0;
          t3 = t3 - 64 | 0;
          r3 = r3 + 64 | 0;
        }
        l2 = l2 + r3 | 0;
        if (l2 >>> 0 < r3 >>> 0) y2 = y2 + 1 | 0;
        return r3 | 0;
      }
      function R2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var n3 = 0, i3 = 0;
        if (e3 & 63) return -1;
        if (~r3) {
          if (r3 & 31) return -1;
        }
        if ((t3 | 0) >= 64) {
          n3 = z2(e3, t3) | 0;
          if ((n3 | 0) == -1) return -1;
          e3 = e3 + n3 | 0;
          t3 = t3 - n3 | 0;
        }
        n3 = n3 + t3 | 0;
        l2 = l2 + t3 | 0;
        if (l2 >>> 0 < t3 >>> 0) y2 = y2 + 1 | 0;
        U2[e3 | t3] = 128;
        if ((t3 | 0) >= 56) {
          for (i3 = t3 + 1 | 0; (i3 | 0) < 64; i3 = i3 + 1 | 0) U2[e3 | i3] = 0;
          C2(e3);
          t3 = 0;
          U2[e3 | 0] = 0;
        }
        for (i3 = t3 + 1 | 0; (i3 | 0) < 59; i3 = i3 + 1 | 0) U2[e3 | i3] = 0;
        U2[e3 | 56] = y2 >>> 21 & 255;
        U2[e3 | 57] = y2 >>> 13 & 255;
        U2[e3 | 58] = y2 >>> 5 & 255;
        U2[e3 | 59] = y2 << 3 & 255 | l2 >>> 29;
        U2[e3 | 60] = l2 >>> 21 & 255;
        U2[e3 | 61] = l2 >>> 13 & 255;
        U2[e3 | 62] = l2 >>> 5 & 255;
        U2[e3 | 63] = l2 << 3 & 255;
        C2(e3);
        if (~r3) I2(r3);
        return n3 | 0;
      }
      function M2() {
        n2 = d2;
        i2 = p2;
        a2 = f2;
        s2 = g2;
        o2 = m2;
        c2 = w2;
        h2 = b2;
        u2 = k2;
        l2 = 64;
        y2 = 0;
      }
      function L2() {
        n2 = v2;
        i2 = A2;
        a2 = _2;
        s2 = E2;
        o2 = S2;
        c2 = K2;
        h2 = x2;
        u2 = P2;
        l2 = 64;
        y2 = 0;
      }
      function N2(e3, t3, r3, U3, C3, I3, B3, z3, R3, M3, L3, N3, O3, F3, H2, j2) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        U3 = U3 | 0;
        C3 = C3 | 0;
        I3 = I3 | 0;
        B3 = B3 | 0;
        z3 = z3 | 0;
        R3 = R3 | 0;
        M3 = M3 | 0;
        L3 = L3 | 0;
        N3 = N3 | 0;
        O3 = O3 | 0;
        F3 = F3 | 0;
        H2 = H2 | 0;
        j2 = j2 | 0;
        T2();
        D2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, U3 ^ 1549556828, C3 ^ 1549556828, I3 ^ 1549556828, B3 ^ 1549556828, z3 ^ 1549556828, R3 ^ 1549556828, M3 ^ 1549556828, L3 ^ 1549556828, N3 ^ 1549556828, O3 ^ 1549556828, F3 ^ 1549556828, H2 ^ 1549556828, j2 ^ 1549556828);
        v2 = n2;
        A2 = i2;
        _2 = a2;
        E2 = s2;
        S2 = o2;
        K2 = c2;
        x2 = h2;
        P2 = u2;
        T2();
        D2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, U3 ^ 909522486, C3 ^ 909522486, I3 ^ 909522486, B3 ^ 909522486, z3 ^ 909522486, R3 ^ 909522486, M3 ^ 909522486, L3 ^ 909522486, N3 ^ 909522486, O3 ^ 909522486, F3 ^ 909522486, H2 ^ 909522486, j2 ^ 909522486);
        d2 = n2;
        p2 = i2;
        f2 = a2;
        g2 = s2;
        m2 = o2;
        w2 = c2;
        b2 = h2;
        k2 = u2;
        l2 = 64;
        y2 = 0;
      }
      function O2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var l3 = 0, y3 = 0, d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0;
        if (e3 & 63) return -1;
        if (~r3) {
          if (r3 & 31) return -1;
        }
        b3 = R2(e3, t3, -1) | 0;
        l3 = n2, y3 = i2, d3 = a2, p3 = s2, f3 = o2, g3 = c2, m3 = h2, w3 = u2;
        L2();
        D2(l3, y3, d3, p3, f3, g3, m3, w3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
        if (~r3) I2(r3);
        return b3 | 0;
      }
      function F2(e3, t3, r3, l3, y3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        l3 = l3 | 0;
        y3 = y3 | 0;
        var d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0, k3 = 0, v3 = 0, A3 = 0, _3 = 0, E3 = 0, S3 = 0, K3 = 0, x3 = 0, P3 = 0;
        if (e3 & 63) return -1;
        if (~y3) {
          if (y3 & 31) return -1;
        }
        U2[e3 + t3 | 0] = r3 >>> 24;
        U2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
        U2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
        U2[e3 + t3 + 3 | 0] = r3 & 255;
        O2(e3, t3 + 4 | 0, -1) | 0;
        d3 = v3 = n2, p3 = A3 = i2, f3 = _3 = a2, g3 = E3 = s2, m3 = S3 = o2, w3 = K3 = c2, b3 = x3 = h2, k3 = P3 = u2;
        l3 = l3 - 1 | 0;
        while ((l3 | 0) > 0) {
          M2();
          D2(v3, A3, _3, E3, S3, K3, x3, P3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
          v3 = n2, A3 = i2, _3 = a2, E3 = s2, S3 = o2, K3 = c2, x3 = h2, P3 = u2;
          L2();
          D2(v3, A3, _3, E3, S3, K3, x3, P3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
          v3 = n2, A3 = i2, _3 = a2, E3 = s2, S3 = o2, K3 = c2, x3 = h2, P3 = u2;
          d3 = d3 ^ n2;
          p3 = p3 ^ i2;
          f3 = f3 ^ a2;
          g3 = g3 ^ s2;
          m3 = m3 ^ o2;
          w3 = w3 ^ c2;
          b3 = b3 ^ h2;
          k3 = k3 ^ u2;
          l3 = l3 - 1 | 0;
        }
        n2 = d3;
        i2 = p3;
        a2 = f3;
        s2 = g3;
        o2 = m3;
        c2 = w3;
        h2 = b3;
        u2 = k3;
        if (~y3) I2(y3);
        return 0;
      }
      return { reset: T2, init: B2, process: z2, finish: R2, hmac_reset: M2, hmac_init: N2, hmac_finish: O2, pbkdf2_generate_block: F2 };
    }({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
  }
  release_asm() {
    void 0 !== this.heap && void 0 !== this.asm && (Xe.push(this.heap), Qe.push(this.asm)), this.heap = void 0, this.asm = void 0;
  }
  static bytes(e2) {
    return new _Ye().process(e2).finish().result;
  }
};
Ye.NAME = "sha256";
var Je = et;
function et(e2, t2) {
  if (!e2) throw Error(t2 || "Assertion failed");
}
et.equal = function(e2, t2, r2) {
  if (e2 != t2) throw Error(r2 || "Assertion failed: " + e2 + " != " + t2);
};
var tt = void 0 !== e ? e : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function rt(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
function nt() {
  throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var it = rt(function(e2) {
  e2.exports = "function" == typeof Object.create ? function(e3, t2) {
    e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
  } : function(e3, t2) {
    e3.super_ = t2;
    var r2 = function() {
    };
    r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
  };
});
var at = function(e2, t2) {
  if (Array.isArray(e2)) return e2.slice();
  if (!e2) return [];
  var r2 = [];
  if ("string" == typeof e2) if (t2) {
    if ("hex" === t2) for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), n2 = 0; n2 < e2.length; n2 += 2) r2.push(parseInt(e2[n2] + e2[n2 + 1], 16));
  } else for (var n2 = 0; n2 < e2.length; n2++) {
    var i2 = e2.charCodeAt(n2), a2 = i2 >> 8, s2 = 255 & i2;
    a2 ? r2.push(a2, s2) : r2.push(s2);
  }
  else for (n2 = 0; n2 < e2.length; n2++) r2[n2] = 0 | e2[n2];
  return r2;
};
var st = function(e2) {
  for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += ht(e2[r2].toString(16));
  return t2;
};
function ot(e2) {
  return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
}
var ct = function(e2, t2) {
  for (var r2 = "", n2 = 0; n2 < e2.length; n2++) {
    var i2 = e2[n2];
    "little" === t2 && (i2 = ot(i2)), r2 += ut(i2.toString(16));
  }
  return r2;
};
function ht(e2) {
  return 1 === e2.length ? "0" + e2 : e2;
}
function ut(e2) {
  return 7 === e2.length ? "0" + e2 : 6 === e2.length ? "00" + e2 : 5 === e2.length ? "000" + e2 : 4 === e2.length ? "0000" + e2 : 3 === e2.length ? "00000" + e2 : 2 === e2.length ? "000000" + e2 : 1 === e2.length ? "0000000" + e2 : e2;
}
var lt = function(e2, t2, r2, n2) {
  var i2 = r2 - t2;
  Je(i2 % 4 == 0);
  for (var a2 = Array(i2 / 4), s2 = 0, o2 = t2; s2 < a2.length; s2++, o2 += 4) {
    var c2;
    c2 = "big" === n2 ? e2[o2] << 24 | e2[o2 + 1] << 16 | e2[o2 + 2] << 8 | e2[o2 + 3] : e2[o2 + 3] << 24 | e2[o2 + 2] << 16 | e2[o2 + 1] << 8 | e2[o2], a2[s2] = c2 >>> 0;
  }
  return a2;
};
var yt = function(e2, t2) {
  for (var r2 = Array(4 * e2.length), n2 = 0, i2 = 0; n2 < e2.length; n2++, i2 += 4) {
    var a2 = e2[n2];
    "big" === t2 ? (r2[i2] = a2 >>> 24, r2[i2 + 1] = a2 >>> 16 & 255, r2[i2 + 2] = a2 >>> 8 & 255, r2[i2 + 3] = 255 & a2) : (r2[i2 + 3] = a2 >>> 24, r2[i2 + 2] = a2 >>> 16 & 255, r2[i2 + 1] = a2 >>> 8 & 255, r2[i2] = 255 & a2);
  }
  return r2;
};
var dt = { inherits: it, toArray: at, toHex: st, htonl: ot, toHex32: ct, zero2: ht, zero8: ut, join32: lt, split32: yt, rotr32: function(e2, t2) {
  return e2 >>> t2 | e2 << 32 - t2;
}, rotl32: function(e2, t2) {
  return e2 << t2 | e2 >>> 32 - t2;
}, sum32: function(e2, t2) {
  return e2 + t2 >>> 0;
}, sum32_3: function(e2, t2, r2) {
  return e2 + t2 + r2 >>> 0;
}, sum32_4: function(e2, t2, r2, n2) {
  return e2 + t2 + r2 + n2 >>> 0;
}, sum32_5: function(e2, t2, r2, n2, i2) {
  return e2 + t2 + r2 + n2 + i2 >>> 0;
}, sum64: function(e2, t2, r2, n2) {
  var i2 = e2[t2], a2 = n2 + e2[t2 + 1] >>> 0, s2 = (a2 < n2 ? 1 : 0) + r2 + i2;
  e2[t2] = s2 >>> 0, e2[t2 + 1] = a2;
}, sum64_hi: function(e2, t2, r2, n2) {
  return (t2 + n2 >>> 0 < t2 ? 1 : 0) + e2 + r2 >>> 0;
}, sum64_lo: function(e2, t2, r2, n2) {
  return t2 + n2 >>> 0;
}, sum64_4_hi: function(e2, t2, r2, n2, i2, a2, s2, o2) {
  var c2 = 0, h2 = t2;
  return c2 += (h2 = h2 + n2 >>> 0) < t2 ? 1 : 0, c2 += (h2 = h2 + a2 >>> 0) < a2 ? 1 : 0, e2 + r2 + i2 + s2 + (c2 += (h2 = h2 + o2 >>> 0) < o2 ? 1 : 0) >>> 0;
}, sum64_4_lo: function(e2, t2, r2, n2, i2, a2, s2, o2) {
  return t2 + n2 + a2 + o2 >>> 0;
}, sum64_5_hi: function(e2, t2, r2, n2, i2, a2, s2, o2, c2, h2) {
  var u2 = 0, l2 = t2;
  return u2 += (l2 = l2 + n2 >>> 0) < t2 ? 1 : 0, u2 += (l2 = l2 + a2 >>> 0) < a2 ? 1 : 0, u2 += (l2 = l2 + o2 >>> 0) < o2 ? 1 : 0, e2 + r2 + i2 + s2 + c2 + (u2 += (l2 = l2 + h2 >>> 0) < h2 ? 1 : 0) >>> 0;
}, sum64_5_lo: function(e2, t2, r2, n2, i2, a2, s2, o2, c2, h2) {
  return t2 + n2 + a2 + o2 + h2 >>> 0;
}, rotr64_hi: function(e2, t2, r2) {
  return (t2 << 32 - r2 | e2 >>> r2) >>> 0;
}, rotr64_lo: function(e2, t2, r2) {
  return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
}, shr64_hi: function(e2, t2, r2) {
  return e2 >>> r2;
}, shr64_lo: function(e2, t2, r2) {
  return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
} };
function pt() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
var ft = pt;
pt.prototype.update = function(e2, t2) {
  if (e2 = dt.toArray(e2, t2), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
    var r2 = (e2 = this.pending).length % this._delta8;
    this.pending = e2.slice(e2.length - r2, e2.length), 0 === this.pending.length && (this.pending = null), e2 = dt.join32(e2, 0, e2.length - r2, this.endian);
    for (var n2 = 0; n2 < e2.length; n2 += this._delta32) this._update(e2, n2, n2 + this._delta32);
  }
  return this;
}, pt.prototype.digest = function(e2) {
  return this.update(this._pad()), Je(null === this.pending), this._digest(e2);
}, pt.prototype._pad = function() {
  var e2 = this.pendingTotal, t2 = this._delta8, r2 = t2 - (e2 + this.padLength) % t2, n2 = Array(r2 + this.padLength);
  n2[0] = 128;
  for (var i2 = 1; i2 < r2; i2++) n2[i2] = 0;
  if (e2 <<= 3, "big" === this.endian) {
    for (var a2 = 8; a2 < this.padLength; a2++) n2[i2++] = 0;
    n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = e2 >>> 24 & 255, n2[i2++] = e2 >>> 16 & 255, n2[i2++] = e2 >>> 8 & 255, n2[i2++] = 255 & e2;
  } else for (n2[i2++] = 255 & e2, n2[i2++] = e2 >>> 8 & 255, n2[i2++] = e2 >>> 16 & 255, n2[i2++] = e2 >>> 24 & 255, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, n2[i2++] = 0, a2 = 8; a2 < this.padLength; a2++) n2[i2++] = 0;
  return n2;
};
var gt = { BlockHash: ft };
var mt = dt.rotr32;
var wt = function(e2, t2, r2, n2) {
  return 0 === e2 ? bt(t2, r2, n2) : 1 === e2 || 3 === e2 ? vt(t2, r2, n2) : 2 === e2 ? kt(t2, r2, n2) : void 0;
};
function bt(e2, t2, r2) {
  return e2 & t2 ^ ~e2 & r2;
}
function kt(e2, t2, r2) {
  return e2 & t2 ^ e2 & r2 ^ t2 & r2;
}
function vt(e2, t2, r2) {
  return e2 ^ t2 ^ r2;
}
var At = { ft_1: wt, ch32: bt, maj32: kt, p32: vt, s0_256: function(e2) {
  return mt(e2, 2) ^ mt(e2, 13) ^ mt(e2, 22);
}, s1_256: function(e2) {
  return mt(e2, 6) ^ mt(e2, 11) ^ mt(e2, 25);
}, g0_256: function(e2) {
  return mt(e2, 7) ^ mt(e2, 18) ^ e2 >>> 3;
}, g1_256: function(e2) {
  return mt(e2, 17) ^ mt(e2, 19) ^ e2 >>> 10;
} };
var _t = dt.sum32;
var Et = dt.sum32_4;
var St = dt.sum32_5;
var Kt = At.ch32;
var xt = At.maj32;
var Pt = At.s0_256;
var Ut = At.s1_256;
var Dt = At.g0_256;
var Ct = At.g1_256;
var It = gt.BlockHash;
var Tt = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function Bt() {
  if (!(this instanceof Bt)) return new Bt();
  It.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Tt, this.W = Array(64);
}
dt.inherits(Bt, It);
var zt = Bt;
function Rt() {
  if (!(this instanceof Rt)) return new Rt();
  zt.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
Bt.blockSize = 512, Bt.outSize = 256, Bt.hmacStrength = 192, Bt.padLength = 64, Bt.prototype._update = function(e2, t2) {
  for (var r2 = this.W, n2 = 0; n2 < 16; n2++) r2[n2] = e2[t2 + n2];
  for (; n2 < r2.length; n2++) r2[n2] = Et(Ct(r2[n2 - 2]), r2[n2 - 7], Dt(r2[n2 - 15]), r2[n2 - 16]);
  var i2 = this.h[0], a2 = this.h[1], s2 = this.h[2], o2 = this.h[3], c2 = this.h[4], h2 = this.h[5], u2 = this.h[6], l2 = this.h[7];
  for (Je(this.k.length === r2.length), n2 = 0; n2 < r2.length; n2++) {
    var y2 = St(l2, Ut(c2), Kt(c2, h2, u2), this.k[n2], r2[n2]), d2 = _t(Pt(i2), xt(i2, a2, s2));
    l2 = u2, u2 = h2, h2 = c2, c2 = _t(o2, y2), o2 = s2, s2 = a2, a2 = i2, i2 = _t(y2, d2);
  }
  this.h[0] = _t(this.h[0], i2), this.h[1] = _t(this.h[1], a2), this.h[2] = _t(this.h[2], s2), this.h[3] = _t(this.h[3], o2), this.h[4] = _t(this.h[4], c2), this.h[5] = _t(this.h[5], h2), this.h[6] = _t(this.h[6], u2), this.h[7] = _t(this.h[7], l2);
}, Bt.prototype._digest = function(e2) {
  return "hex" === e2 ? dt.toHex32(this.h, "big") : dt.split32(this.h, "big");
}, dt.inherits(Rt, zt);
var Mt = Rt;
Rt.blockSize = 512, Rt.outSize = 224, Rt.hmacStrength = 192, Rt.padLength = 64, Rt.prototype._digest = function(e2) {
  return "hex" === e2 ? dt.toHex32(this.h.slice(0, 7), "big") : dt.split32(this.h.slice(0, 7), "big");
};
var Lt = dt.rotr64_hi;
var Nt = dt.rotr64_lo;
var Ot = dt.shr64_hi;
var Ft = dt.shr64_lo;
var Ht = dt.sum64;
var jt = dt.sum64_hi;
var qt = dt.sum64_lo;
var Gt = dt.sum64_4_hi;
var Vt = dt.sum64_4_lo;
var Wt = dt.sum64_5_hi;
var $t = dt.sum64_5_lo;
var Zt = gt.BlockHash;
var Xt = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function Qt() {
  if (!(this instanceof Qt)) return new Qt();
  Zt.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = Xt, this.W = Array(160);
}
dt.inherits(Qt, Zt);
var Yt = Qt;
function Jt(e2, t2, r2, n2, i2) {
  var a2 = e2 & r2 ^ ~e2 & i2;
  return a2 < 0 && (a2 += 4294967296), a2;
}
function er(e2, t2, r2, n2, i2, a2) {
  var s2 = t2 & n2 ^ ~t2 & a2;
  return s2 < 0 && (s2 += 4294967296), s2;
}
function tr(e2, t2, r2, n2, i2) {
  var a2 = e2 & r2 ^ e2 & i2 ^ r2 & i2;
  return a2 < 0 && (a2 += 4294967296), a2;
}
function rr(e2, t2, r2, n2, i2, a2) {
  var s2 = t2 & n2 ^ t2 & a2 ^ n2 & a2;
  return s2 < 0 && (s2 += 4294967296), s2;
}
function nr(e2, t2) {
  var r2 = Lt(e2, t2, 28) ^ Lt(t2, e2, 2) ^ Lt(t2, e2, 7);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function ir(e2, t2) {
  var r2 = Nt(e2, t2, 28) ^ Nt(t2, e2, 2) ^ Nt(t2, e2, 7);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function ar(e2, t2) {
  var r2 = Lt(e2, t2, 14) ^ Lt(e2, t2, 18) ^ Lt(t2, e2, 9);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function sr(e2, t2) {
  var r2 = Nt(e2, t2, 14) ^ Nt(e2, t2, 18) ^ Nt(t2, e2, 9);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function or(e2, t2) {
  var r2 = Lt(e2, t2, 1) ^ Lt(e2, t2, 8) ^ Ot(e2, t2, 7);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function cr(e2, t2) {
  var r2 = Nt(e2, t2, 1) ^ Nt(e2, t2, 8) ^ Ft(e2, t2, 7);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function hr(e2, t2) {
  var r2 = Lt(e2, t2, 19) ^ Lt(t2, e2, 29) ^ Ot(e2, t2, 6);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function ur(e2, t2) {
  var r2 = Nt(e2, t2, 19) ^ Nt(t2, e2, 29) ^ Ft(e2, t2, 6);
  return r2 < 0 && (r2 += 4294967296), r2;
}
function lr() {
  if (!(this instanceof lr)) return new lr();
  Yt.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
Qt.blockSize = 1024, Qt.outSize = 512, Qt.hmacStrength = 192, Qt.padLength = 128, Qt.prototype._prepareBlock = function(e2, t2) {
  for (var r2 = this.W, n2 = 0; n2 < 32; n2++) r2[n2] = e2[t2 + n2];
  for (; n2 < r2.length; n2 += 2) {
    var i2 = hr(r2[n2 - 4], r2[n2 - 3]), a2 = ur(r2[n2 - 4], r2[n2 - 3]), s2 = r2[n2 - 14], o2 = r2[n2 - 13], c2 = or(r2[n2 - 30], r2[n2 - 29]), h2 = cr(r2[n2 - 30], r2[n2 - 29]), u2 = r2[n2 - 32], l2 = r2[n2 - 31];
    r2[n2] = Gt(i2, a2, s2, o2, c2, h2, u2, l2), r2[n2 + 1] = Vt(i2, a2, s2, o2, c2, h2, u2, l2);
  }
}, Qt.prototype._update = function(e2, t2) {
  this._prepareBlock(e2, t2);
  var r2 = this.W, n2 = this.h[0], i2 = this.h[1], a2 = this.h[2], s2 = this.h[3], o2 = this.h[4], c2 = this.h[5], h2 = this.h[6], u2 = this.h[7], l2 = this.h[8], y2 = this.h[9], d2 = this.h[10], p2 = this.h[11], f2 = this.h[12], g2 = this.h[13], m2 = this.h[14], w2 = this.h[15];
  Je(this.k.length === r2.length);
  for (var b2 = 0; b2 < r2.length; b2 += 2) {
    var k2 = m2, v2 = w2, A2 = ar(l2, y2), _2 = sr(l2, y2), E2 = Jt(l2, y2, d2, p2, f2), S2 = er(l2, y2, d2, p2, f2, g2), K2 = this.k[b2], x2 = this.k[b2 + 1], P2 = r2[b2], U2 = r2[b2 + 1], D2 = Wt(k2, v2, A2, _2, E2, S2, K2, x2, P2, U2), C2 = $t(k2, v2, A2, _2, E2, S2, K2, x2, P2, U2);
    k2 = nr(n2, i2), v2 = ir(n2, i2), A2 = tr(n2, i2, a2, s2, o2), _2 = rr(n2, i2, a2, s2, o2, c2);
    var I2 = jt(k2, v2, A2, _2), T2 = qt(k2, v2, A2, _2);
    m2 = f2, w2 = g2, f2 = d2, g2 = p2, d2 = l2, p2 = y2, l2 = jt(h2, u2, D2, C2), y2 = qt(u2, u2, D2, C2), h2 = o2, u2 = c2, o2 = a2, c2 = s2, a2 = n2, s2 = i2, n2 = jt(D2, C2, I2, T2), i2 = qt(D2, C2, I2, T2);
  }
  Ht(this.h, 0, n2, i2), Ht(this.h, 2, a2, s2), Ht(this.h, 4, o2, c2), Ht(this.h, 6, h2, u2), Ht(this.h, 8, l2, y2), Ht(this.h, 10, d2, p2), Ht(this.h, 12, f2, g2), Ht(this.h, 14, m2, w2);
}, Qt.prototype._digest = function(e2) {
  return "hex" === e2 ? dt.toHex32(this.h, "big") : dt.split32(this.h, "big");
}, dt.inherits(lr, Yt);
var yr = lr;
lr.blockSize = 1024, lr.outSize = 384, lr.hmacStrength = 192, lr.padLength = 128, lr.prototype._digest = function(e2) {
  return "hex" === e2 ? dt.toHex32(this.h.slice(0, 12), "big") : dt.split32(this.h.slice(0, 12), "big");
};
var dr = dt.rotl32;
var pr = dt.sum32;
var fr = dt.sum32_3;
var gr = dt.sum32_4;
var mr = gt.BlockHash;
function wr() {
  if (!(this instanceof wr)) return new wr();
  mr.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
dt.inherits(wr, mr);
var br = wr;
function kr(e2, t2, r2, n2) {
  return e2 <= 15 ? t2 ^ r2 ^ n2 : e2 <= 31 ? t2 & r2 | ~t2 & n2 : e2 <= 47 ? (t2 | ~r2) ^ n2 : e2 <= 63 ? t2 & n2 | r2 & ~n2 : t2 ^ (r2 | ~n2);
}
function vr(e2) {
  return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
}
function Ar(e2) {
  return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
}
wr.blockSize = 512, wr.outSize = 160, wr.hmacStrength = 192, wr.padLength = 64, wr.prototype._update = function(e2, t2) {
  for (var r2 = this.h[0], n2 = this.h[1], i2 = this.h[2], a2 = this.h[3], s2 = this.h[4], o2 = r2, c2 = n2, h2 = i2, u2 = a2, l2 = s2, y2 = 0; y2 < 80; y2++) {
    var d2 = pr(dr(gr(r2, kr(y2, n2, i2, a2), e2[_r[y2] + t2], vr(y2)), Sr[y2]), s2);
    r2 = s2, s2 = a2, a2 = dr(i2, 10), i2 = n2, n2 = d2, d2 = pr(dr(gr(o2, kr(79 - y2, c2, h2, u2), e2[Er[y2] + t2], Ar(y2)), Kr[y2]), l2), o2 = l2, l2 = u2, u2 = dr(h2, 10), h2 = c2, c2 = d2;
  }
  d2 = fr(this.h[1], i2, u2), this.h[1] = fr(this.h[2], a2, l2), this.h[2] = fr(this.h[3], s2, o2), this.h[3] = fr(this.h[4], r2, c2), this.h[4] = fr(this.h[0], n2, h2), this.h[0] = d2;
}, wr.prototype._digest = function(e2) {
  return "hex" === e2 ? dt.toHex32(this.h, "little") : dt.split32(this.h, "little");
};
var _r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var Er = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var Sr = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var Kr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var xr = { ripemd160: br };
function Pr(e2, t2) {
  let r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3];
  r2 = Dr(r2, n2, i2, a2, t2[0], 7, -680876936), a2 = Dr(a2, r2, n2, i2, t2[1], 12, -389564586), i2 = Dr(i2, a2, r2, n2, t2[2], 17, 606105819), n2 = Dr(n2, i2, a2, r2, t2[3], 22, -1044525330), r2 = Dr(r2, n2, i2, a2, t2[4], 7, -176418897), a2 = Dr(a2, r2, n2, i2, t2[5], 12, 1200080426), i2 = Dr(i2, a2, r2, n2, t2[6], 17, -1473231341), n2 = Dr(n2, i2, a2, r2, t2[7], 22, -45705983), r2 = Dr(r2, n2, i2, a2, t2[8], 7, 1770035416), a2 = Dr(a2, r2, n2, i2, t2[9], 12, -1958414417), i2 = Dr(i2, a2, r2, n2, t2[10], 17, -42063), n2 = Dr(n2, i2, a2, r2, t2[11], 22, -1990404162), r2 = Dr(r2, n2, i2, a2, t2[12], 7, 1804603682), a2 = Dr(a2, r2, n2, i2, t2[13], 12, -40341101), i2 = Dr(i2, a2, r2, n2, t2[14], 17, -1502002290), n2 = Dr(n2, i2, a2, r2, t2[15], 22, 1236535329), r2 = Cr(r2, n2, i2, a2, t2[1], 5, -165796510), a2 = Cr(a2, r2, n2, i2, t2[6], 9, -1069501632), i2 = Cr(i2, a2, r2, n2, t2[11], 14, 643717713), n2 = Cr(n2, i2, a2, r2, t2[0], 20, -373897302), r2 = Cr(r2, n2, i2, a2, t2[5], 5, -701558691), a2 = Cr(a2, r2, n2, i2, t2[10], 9, 38016083), i2 = Cr(i2, a2, r2, n2, t2[15], 14, -660478335), n2 = Cr(n2, i2, a2, r2, t2[4], 20, -405537848), r2 = Cr(r2, n2, i2, a2, t2[9], 5, 568446438), a2 = Cr(a2, r2, n2, i2, t2[14], 9, -1019803690), i2 = Cr(i2, a2, r2, n2, t2[3], 14, -187363961), n2 = Cr(n2, i2, a2, r2, t2[8], 20, 1163531501), r2 = Cr(r2, n2, i2, a2, t2[13], 5, -1444681467), a2 = Cr(a2, r2, n2, i2, t2[2], 9, -51403784), i2 = Cr(i2, a2, r2, n2, t2[7], 14, 1735328473), n2 = Cr(n2, i2, a2, r2, t2[12], 20, -1926607734), r2 = Ir(r2, n2, i2, a2, t2[5], 4, -378558), a2 = Ir(a2, r2, n2, i2, t2[8], 11, -2022574463), i2 = Ir(i2, a2, r2, n2, t2[11], 16, 1839030562), n2 = Ir(n2, i2, a2, r2, t2[14], 23, -35309556), r2 = Ir(r2, n2, i2, a2, t2[1], 4, -1530992060), a2 = Ir(a2, r2, n2, i2, t2[4], 11, 1272893353), i2 = Ir(i2, a2, r2, n2, t2[7], 16, -155497632), n2 = Ir(n2, i2, a2, r2, t2[10], 23, -1094730640), r2 = Ir(r2, n2, i2, a2, t2[13], 4, 681279174), a2 = Ir(a2, r2, n2, i2, t2[0], 11, -358537222), i2 = Ir(i2, a2, r2, n2, t2[3], 16, -722521979), n2 = Ir(n2, i2, a2, r2, t2[6], 23, 76029189), r2 = Ir(r2, n2, i2, a2, t2[9], 4, -640364487), a2 = Ir(a2, r2, n2, i2, t2[12], 11, -421815835), i2 = Ir(i2, a2, r2, n2, t2[15], 16, 530742520), n2 = Ir(n2, i2, a2, r2, t2[2], 23, -995338651), r2 = Tr(r2, n2, i2, a2, t2[0], 6, -198630844), a2 = Tr(a2, r2, n2, i2, t2[7], 10, 1126891415), i2 = Tr(i2, a2, r2, n2, t2[14], 15, -1416354905), n2 = Tr(n2, i2, a2, r2, t2[5], 21, -57434055), r2 = Tr(r2, n2, i2, a2, t2[12], 6, 1700485571), a2 = Tr(a2, r2, n2, i2, t2[3], 10, -1894986606), i2 = Tr(i2, a2, r2, n2, t2[10], 15, -1051523), n2 = Tr(n2, i2, a2, r2, t2[1], 21, -2054922799), r2 = Tr(r2, n2, i2, a2, t2[8], 6, 1873313359), a2 = Tr(a2, r2, n2, i2, t2[15], 10, -30611744), i2 = Tr(i2, a2, r2, n2, t2[6], 15, -1560198380), n2 = Tr(n2, i2, a2, r2, t2[13], 21, 1309151649), r2 = Tr(r2, n2, i2, a2, t2[4], 6, -145523070), a2 = Tr(a2, r2, n2, i2, t2[11], 10, -1120210379), i2 = Tr(i2, a2, r2, n2, t2[2], 15, 718787259), n2 = Tr(n2, i2, a2, r2, t2[9], 21, -343485551), e2[0] = Mr(r2, e2[0]), e2[1] = Mr(n2, e2[1]), e2[2] = Mr(i2, e2[2]), e2[3] = Mr(a2, e2[3]);
}
function Ur(e2, t2, r2, n2, i2, a2) {
  return t2 = Mr(Mr(t2, e2), Mr(n2, a2)), Mr(t2 << i2 | t2 >>> 32 - i2, r2);
}
function Dr(e2, t2, r2, n2, i2, a2, s2) {
  return Ur(t2 & r2 | ~t2 & n2, e2, t2, i2, a2, s2);
}
function Cr(e2, t2, r2, n2, i2, a2, s2) {
  return Ur(t2 & n2 | r2 & ~n2, e2, t2, i2, a2, s2);
}
function Ir(e2, t2, r2, n2, i2, a2, s2) {
  return Ur(t2 ^ r2 ^ n2, e2, t2, i2, a2, s2);
}
function Tr(e2, t2, r2, n2, i2, a2, s2) {
  return Ur(r2 ^ (t2 | ~n2), e2, t2, i2, a2, s2);
}
function Br(e2) {
  const t2 = [];
  let r2;
  for (r2 = 0; r2 < 64; r2 += 4) t2[r2 >> 2] = e2.charCodeAt(r2) + (e2.charCodeAt(r2 + 1) << 8) + (e2.charCodeAt(r2 + 2) << 16) + (e2.charCodeAt(r2 + 3) << 24);
  return t2;
}
var zr = "0123456789abcdef".split("");
function Rr(e2) {
  let t2 = "", r2 = 0;
  for (; r2 < 4; r2++) t2 += zr[e2 >> 8 * r2 + 4 & 15] + zr[e2 >> 8 * r2 & 15];
  return t2;
}
function Mr(e2, t2) {
  return e2 + t2 & 4294967295;
}
var Lr = X.getWebCrypto();
var Nr = X.getNodeCrypto();
var Or = Nr && Nr.getHashes();
function Fr(e2) {
  if (Nr && Or.includes(e2)) return async function(t2) {
    const r2 = Nr.createHash(e2);
    return z(t2, (e3) => {
      r2.update(e3);
    }, () => new Uint8Array(r2.digest()));
  };
}
function Hr(e2, t2) {
  return async function(r2, n2 = ie) {
    if (s(r2) && (r2 = await H(r2)), !X.isStream(r2) && Lr && t2 && r2.length >= n2.minBytesForWebCrypto) return new Uint8Array(await Lr.digest(t2, r2));
    const i2 = e2();
    return z(r2, (e3) => {
      i2.update(e3);
    }, () => new Uint8Array(i2.digest()));
  };
}
function jr(e2, t2) {
  return async function(r2, n2 = ie) {
    if (s(r2) && (r2 = await H(r2)), X.isStream(r2)) {
      const t3 = new e2();
      return z(r2, (e3) => {
        t3.process(e3);
      }, () => t3.finish().result);
    }
    return Lr && t2 && r2.length >= n2.minBytesForWebCrypto ? new Uint8Array(await Lr.digest(t2, r2)) : e2.bytes(r2);
  };
}
var qr = { md5: Fr("md5") || async function(e2) {
  const t2 = function(e3) {
    const t3 = e3.length, r2 = [1732584193, -271733879, -1732584194, 271733878];
    let n2;
    for (n2 = 64; n2 <= e3.length; n2 += 64) Pr(r2, Br(e3.substring(n2 - 64, n2)));
    e3 = e3.substring(n2 - 64);
    const i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (n2 = 0; n2 < e3.length; n2++) i2[n2 >> 2] |= e3.charCodeAt(n2) << (n2 % 4 << 3);
    if (i2[n2 >> 2] |= 128 << (n2 % 4 << 3), n2 > 55) for (Pr(r2, i2), n2 = 0; n2 < 16; n2++) i2[n2] = 0;
    return i2[14] = 8 * t3, Pr(r2, i2), r2;
  }(X.uint8ArrayToString(e2));
  return X.hexToUint8Array(function(e3) {
    for (let t3 = 0; t3 < e3.length; t3++) e3[t3] = Rr(e3[t3]);
    return e3.join("");
  }(t2));
}, sha1: Fr("sha1") || jr(Ze, "SHA-1"), sha224: Fr("sha224") || Hr(Mt), sha256: Fr("sha256") || jr(Ye, "SHA-256"), sha384: Fr("sha384") || Hr(yr, "SHA-384"), sha512: Fr("sha512") || Hr(Yt, "SHA-512"), ripemd: Fr("ripemd160") || Hr(br) };
var Gr = { md5: qr.md5, sha1: qr.sha1, sha224: qr.sha224, sha256: qr.sha256, sha384: qr.sha384, sha512: qr.sha512, ripemd: qr.ripemd, digest: function(e2, t2) {
  switch (e2) {
    case $.hash.md5:
      return this.md5(t2);
    case $.hash.sha1:
      return this.sha1(t2);
    case $.hash.ripemd:
      return this.ripemd(t2);
    case $.hash.sha256:
      return this.sha256(t2);
    case $.hash.sha384:
      return this.sha384(t2);
    case $.hash.sha512:
      return this.sha512(t2);
    case $.hash.sha224:
      return this.sha224(t2);
    default:
      throw Error("Invalid hash function.");
  }
}, getHashByteLength: function(e2) {
  switch (e2) {
    case $.hash.md5:
      return 16;
    case $.hash.sha1:
    case $.hash.ripemd:
      return 20;
    case $.hash.sha256:
      return 32;
    case $.hash.sha384:
      return 48;
    case $.hash.sha512:
      return 64;
    case $.hash.sha224:
      return 28;
    default:
      throw Error("Invalid hash algorithm.");
  }
} };
var Vr = class _Vr {
  static encrypt(e2, t2, r2) {
    return new _Vr(t2, r2).encrypt(e2);
  }
  static decrypt(e2, t2, r2) {
    return new _Vr(t2, r2).decrypt(e2);
  }
  constructor(e2, t2, r2) {
    this.aes = r2 || new Se(e2, t2, true, "CFB"), delete this.aes.padding;
  }
  encrypt(e2) {
    return be(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
  }
  decrypt(e2) {
    return be(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
  }
};
function Wr(e2) {
  const t2 = $.read($.symmetric, e2);
  return qe[t2];
}
var $r = X.getWebCrypto();
var Zr = X.getNodeCrypto();
var Xr = Zr ? Zr.getCiphers() : [];
var Qr = { idea: Xr.includes("idea-cfb") ? "idea-cfb" : void 0, tripledes: Xr.includes("des-ede3-cfb") ? "des-ede3-cfb" : void 0, cast5: Xr.includes("cast5-cfb") ? "cast5-cfb" : void 0, blowfish: Xr.includes("bf-cfb") ? "bf-cfb" : void 0, aes128: Xr.includes("aes-128-cfb") ? "aes-128-cfb" : void 0, aes192: Xr.includes("aes-192-cfb") ? "aes-192-cfb" : void 0, aes256: Xr.includes("aes-256-cfb") ? "aes-256-cfb" : void 0 };
var Yr = Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, n2, i2) {
  const a2 = $.read($.symmetric, e2);
  if (X.getNodeCrypto() && Qr[a2]) return function(e3, t3, r3, n3) {
    const i3 = $.read($.symmetric, e3), a3 = new Zr.createCipheriv(Qr[i3], t3, n3);
    return z(r3, (e4) => new Uint8Array(a3.update(e4)));
  }(e2, t2, r2, n2);
  if (X.isAES(e2)) return function(e3, t3, r3, n3, i3) {
    if (X.getWebCrypto() && 24 !== t3.length && !X.isStream(r3) && r3.length >= 3e3 * i3.minBytesForWebCrypto) return async function(e4, t4, r4, n4) {
      const i4 = "AES-CBC", a4 = await $r.importKey("raw", t4, { name: i4 }, false, ["encrypt"]), { blockSize: s3 } = Wr(e4), o3 = X.concatUint8Array([new Uint8Array(s3), r4]), c3 = new Uint8Array(await $r.encrypt({ name: i4, iv: n4 }, a4, o3)).subarray(0, r4.length);
      return function(e5, t5) {
        for (let r5 = 0; r5 < e5.length; r5++) e5[r5] = e5[r5] ^ t5[r5];
      }(c3, r4), c3;
    }(e3, t3, r3, n3);
    const a3 = new Vr(t3, n3);
    return z(r3, (e4) => a3.aes.AES_Encrypt_process(e4), () => a3.aes.AES_Encrypt_finish());
  }(e2, t2, r2, n2, i2);
  const s2 = new (Wr(e2))(t2), o2 = s2.blockSize, c2 = n2.slice();
  let h2 = new Uint8Array();
  const u2 = (e3) => {
    e3 && (h2 = X.concatUint8Array([h2, e3]));
    const t3 = new Uint8Array(h2.length);
    let r3, n3 = 0;
    for (; e3 ? h2.length >= o2 : h2.length; ) {
      const e4 = s2.encrypt(c2);
      for (r3 = 0; r3 < o2; r3++) c2[r3] = h2[r3] ^ e4[r3], t3[n3++] = c2[r3];
      h2 = h2.subarray(o2);
    }
    return t3.subarray(0, n3);
  };
  return z(r2, u2, u2);
}, decrypt: async function(e2, t2, r2, n2) {
  const i2 = $.read($.symmetric, e2);
  if (X.getNodeCrypto() && Qr[i2]) return function(e3, t3, r3, n3) {
    const i3 = $.read($.symmetric, e3), a3 = new Zr.createDecipheriv(Qr[i3], t3, n3);
    return z(r3, (e4) => new Uint8Array(a3.update(e4)));
  }(e2, t2, r2, n2);
  if (X.isAES(e2)) return function(e3, t3, r3, n3) {
    if (X.isStream(r3)) {
      const e4 = new Vr(t3, n3);
      return z(r3, (t4) => e4.aes.AES_Decrypt_process(t4), () => e4.aes.AES_Decrypt_finish());
    }
    return Vr.decrypt(r3, t3, n3);
  }(0, t2, r2, n2);
  const a2 = new (Wr(e2))(t2), s2 = a2.blockSize;
  let o2 = n2, c2 = new Uint8Array();
  const h2 = (e3) => {
    e3 && (c2 = X.concatUint8Array([c2, e3]));
    const t3 = new Uint8Array(c2.length);
    let r3, n3 = 0;
    for (; e3 ? c2.length >= s2 : c2.length; ) {
      const e4 = a2.encrypt(o2);
      for (o2 = c2.subarray(0, s2), r3 = 0; r3 < s2; r3++) t3[n3++] = o2[r3] ^ e4[r3];
      c2 = c2.subarray(s2);
    }
    return t3.subarray(0, n3);
  };
  return z(r2, h2, h2);
} });
var Jr = class _Jr {
  static encrypt(e2, t2, r2) {
    return new _Jr(t2, r2).encrypt(e2);
  }
  static decrypt(e2, t2, r2) {
    return new _Jr(t2, r2).encrypt(e2);
  }
  constructor(e2, t2, r2) {
    this.aes = r2 || new Se(e2, void 0, false, "CTR"), delete this.aes.padding, this.AES_CTR_set_options(t2);
  }
  encrypt(e2) {
    return be(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
  }
  decrypt(e2) {
    return be(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
  }
  AES_CTR_set_options(e2, t2, r2) {
    let { asm: n2 } = this.aes.acquire_asm();
    if (void 0 !== r2) {
      if (r2 < 8 || r2 > 48) throw new ve("illegal counter size");
      let e3 = Math.pow(2, r2) - 1;
      n2.set_mask(0, 0, e3 / 4294967296 | 0, 0 | e3);
    } else r2 = 48, n2.set_mask(0, 0, 65535, 4294967295);
    if (void 0 === e2) throw Error("nonce is required");
    {
      let t3 = e2.length;
      if (!t3 || t3 > 16) throw new ve("illegal nonce size");
      let r3 = new DataView(new ArrayBuffer(16));
      new Uint8Array(r3.buffer).set(e2), n2.set_nonce(r3.getUint32(0), r3.getUint32(4), r3.getUint32(8), r3.getUint32(12));
    }
    if (void 0 !== t2) {
      if (t2 < 0 || t2 >= Math.pow(2, r2)) throw new ve("illegal counter value");
      n2.set_counter(0, 0, t2 / 4294967296 | 0, 0 | t2);
    }
  }
};
var en = class _en {
  static encrypt(e2, t2, r2 = true, n2) {
    return new _en(t2, n2, r2).encrypt(e2);
  }
  static decrypt(e2, t2, r2 = true, n2) {
    return new _en(t2, n2, r2).decrypt(e2);
  }
  constructor(e2, t2, r2 = true, n2) {
    this.aes = n2 || new Se(e2, t2, r2, "CBC");
  }
  encrypt(e2) {
    return be(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
  }
  decrypt(e2) {
    return be(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
  }
};
var tn = X.getWebCrypto();
var rn = X.getNodeCrypto();
var nn = 16;
function an(e2, t2) {
  const r2 = e2.length - nn;
  for (let n2 = 0; n2 < nn; n2++) e2[n2 + r2] ^= t2[n2];
  return e2;
}
var sn = new Uint8Array(nn);
async function on(e2) {
  const t2 = await async function(e3) {
    if (X.getWebCrypto() && 24 !== e3.length) return e3 = await tn.importKey("raw", e3, { name: "AES-CBC", length: 8 * e3.length }, false, ["encrypt"]), async function(t3) {
      const r3 = await tn.encrypt({ name: "AES-CBC", iv: sn, length: 8 * nn }, e3, t3);
      return new Uint8Array(r3).subarray(0, r3.byteLength - nn);
    };
    if (X.getNodeCrypto()) return async function(t3) {
      const r3 = new rn.createCipheriv("aes-" + 8 * e3.length + "-cbc", e3, sn).update(t3);
      return new Uint8Array(r3);
    };
    return async function(t3) {
      return en.encrypt(t3, e3, false, sn);
    };
  }(e2), r2 = X.double(await t2(sn)), n2 = X.double(r2);
  return async function(e3) {
    return (await t2(function(e4, t3, r3) {
      if (e4.length && e4.length % nn == 0) return an(e4, t3);
      const n3 = new Uint8Array(e4.length + (nn - e4.length % nn));
      return n3.set(e4), n3[e4.length] = 128, an(n3, r3);
    }(e3, r2, n2))).subarray(-nn);
  };
}
var cn = X.getWebCrypto();
var hn = X.getNodeCrypto();
var un = X.getNodeBuffer();
var ln = 16;
var yn = ln;
var dn = ln;
var pn = new Uint8Array(ln);
var fn = new Uint8Array(ln);
fn[ln - 1] = 1;
var gn = new Uint8Array(ln);
async function mn(e2) {
  const t2 = await on(e2);
  return function(e3, r2) {
    return t2(X.concatUint8Array([e3, r2]));
  };
}
async function wn(e2) {
  return X.getWebCrypto() && 24 !== e2.length ? (e2 = await cn.importKey("raw", e2, { name: "AES-CTR", length: 8 * e2.length }, false, ["encrypt"]), async function(t2, r2) {
    const n2 = await cn.encrypt({ name: "AES-CTR", counter: r2, length: 8 * ln }, e2, t2);
    return new Uint8Array(n2);
  }) : X.getNodeCrypto() ? async function(t2, r2) {
    const n2 = new hn.createCipheriv("aes-" + 8 * e2.length + "-ctr", e2, r2), i2 = un.concat([n2.update(t2), n2.final()]);
    return new Uint8Array(i2);
  } : async function(t2, r2) {
    return Jr.encrypt(t2, e2, r2);
  };
}
async function bn(e2, t2) {
  if (e2 !== $.symmetric.aes128 && e2 !== $.symmetric.aes192 && e2 !== $.symmetric.aes256) throw Error("EAX mode supports only AES cipher");
  const [r2, n2] = await Promise.all([mn(t2), wn(t2)]);
  return { encrypt: async function(e3, t3, i2) {
    const [a2, s2] = await Promise.all([r2(pn, t3), r2(fn, i2)]), o2 = await n2(e3, a2), c2 = await r2(gn, o2);
    for (let e4 = 0; e4 < dn; e4++) c2[e4] ^= s2[e4] ^ a2[e4];
    return X.concatUint8Array([o2, c2]);
  }, decrypt: async function(e3, t3, i2) {
    if (e3.length < dn) throw Error("Invalid EAX ciphertext");
    const a2 = e3.subarray(0, -dn), s2 = e3.subarray(-dn), [o2, c2, h2] = await Promise.all([r2(pn, t3), r2(fn, i2), r2(gn, a2)]), u2 = h2;
    for (let e4 = 0; e4 < dn; e4++) u2[e4] ^= c2[e4] ^ o2[e4];
    if (!X.equalsUint8Array(s2, u2)) throw Error("Authentication tag mismatch");
    return await n2(a2, o2);
  } };
}
gn[ln - 1] = 2, bn.getNonce = function(e2, t2) {
  const r2 = e2.slice();
  for (let e3 = 0; e3 < t2.length; e3++) r2[8 + e3] ^= t2[e3];
  return r2;
}, bn.blockLength = ln, bn.ivLength = yn, bn.tagLength = dn;
var kn = 16;
var vn = 15;
var An = 16;
function _n(e2) {
  let t2 = 0;
  for (let r2 = 1; 0 == (e2 & r2); r2 <<= 1) t2++;
  return t2;
}
function En(e2, t2) {
  for (let r2 = 0; r2 < e2.length; r2++) e2[r2] ^= t2[r2];
  return e2;
}
function Sn(e2, t2) {
  return En(e2.slice(), t2);
}
var Kn = new Uint8Array(kn);
var xn = new Uint8Array([1]);
async function Pn(e2, t2) {
  let r2, n2, i2, a2 = 0;
  function s2(e3, t3, n3, s3) {
    const o2 = t3.length / kn | 0;
    !function(e4, t4) {
      const r3 = X.nbits(Math.max(e4.length, t4.length) / kn | 0) - 1;
      for (let e5 = a2 + 1; e5 <= r3; e5++) i2[e5] = X.double(i2[e5 - 1]);
      a2 = r3;
    }(t3, s3);
    const c2 = X.concatUint8Array([Kn.subarray(0, vn - n3.length), xn, n3]), h2 = 63 & c2[kn - 1];
    c2[kn - 1] &= 192;
    const u2 = r2(c2), l2 = X.concatUint8Array([u2, Sn(u2.subarray(0, 8), u2.subarray(1, 9))]), y2 = X.shiftRight(l2.subarray(0 + (h2 >> 3), 17 + (h2 >> 3)), 8 - (7 & h2)).subarray(1), d2 = new Uint8Array(kn), p2 = new Uint8Array(t3.length + An);
    let f2, g2 = 0;
    for (f2 = 0; f2 < o2; f2++) En(y2, i2[_n(f2 + 1)]), p2.set(En(e3(Sn(y2, t3)), y2), g2), En(d2, e3 === r2 ? t3 : p2.subarray(g2)), t3 = t3.subarray(kn), g2 += kn;
    if (t3.length) {
      En(y2, i2.x);
      const n4 = r2(y2);
      p2.set(Sn(t3, n4), g2);
      const a3 = new Uint8Array(kn);
      a3.set(e3 === r2 ? t3 : p2.subarray(g2, -An), 0), a3[t3.length] = 128, En(d2, a3), g2 += t3.length;
    }
    const m2 = En(r2(En(En(d2, y2), i2.$)), function(e4) {
      if (!e4.length) return Kn;
      const t4 = e4.length / kn | 0, n4 = new Uint8Array(kn), a3 = new Uint8Array(kn);
      for (let s4 = 0; s4 < t4; s4++) En(n4, i2[_n(s4 + 1)]), En(a3, r2(Sn(n4, e4))), e4 = e4.subarray(kn);
      if (e4.length) {
        En(n4, i2.x);
        const t5 = new Uint8Array(kn);
        t5.set(e4, 0), t5[e4.length] = 128, En(t5, n4), En(a3, r2(t5));
      }
      return a3;
    }(s3));
    return p2.set(m2, g2), p2;
  }
  return function(e3, t3) {
    const a3 = $.read($.symmetric, e3), s3 = new qe[a3](t3);
    r2 = s3.encrypt.bind(s3), n2 = s3.decrypt.bind(s3);
    const o2 = r2(Kn), c2 = X.double(o2);
    i2 = [], i2[0] = X.double(c2), i2.x = o2, i2.$ = c2;
  }(e2, t2), { encrypt: async function(e3, t3, n3) {
    return s2(r2, e3, t3, n3);
  }, decrypt: async function(e3, t3, r3) {
    if (e3.length < An) throw Error("Invalid OCB ciphertext");
    const i3 = e3.subarray(-An);
    e3 = e3.subarray(0, -An);
    const a3 = s2(n2, e3, t3, r3);
    if (X.equalsUint8Array(i3, a3.subarray(-An))) return a3.subarray(0, -An);
    throw Error("Authentication tag mismatch");
  } };
}
Pn.getNonce = function(e2, t2) {
  const r2 = e2.slice();
  for (let e3 = 0; e3 < t2.length; e3++) r2[7 + e3] ^= t2[e3];
  return r2;
}, Pn.blockLength = kn, Pn.ivLength = vn, Pn.tagLength = An;
var Un = 68719476704;
var Dn = class _Dn {
  constructor(e2, t2, r2, n2 = 16, i2) {
    this.tagSize = n2, this.gamma0 = 0, this.counter = 1, this.aes = i2 || new Se(e2, void 0, false, "CTR");
    let { asm: a2, heap: s2 } = this.aes.acquire_asm();
    if (a2.gcm_init(), this.tagSize < 4 || this.tagSize > 16) throw new ve("illegal tagSize value");
    const o2 = t2.length || 0, c2 = new Uint8Array(16);
    12 !== o2 ? (this._gcm_mac_process(t2), s2[0] = 0, s2[1] = 0, s2[2] = 0, s2[3] = 0, s2[4] = 0, s2[5] = 0, s2[6] = 0, s2[7] = 0, s2[8] = 0, s2[9] = 0, s2[10] = 0, s2[11] = o2 >>> 29, s2[12] = o2 >>> 21 & 255, s2[13] = o2 >>> 13 & 255, s2[14] = o2 >>> 5 & 255, s2[15] = o2 << 3 & 255, a2.mac(fe.MAC.GCM, fe.HEAP_DATA, 16), a2.get_iv(fe.HEAP_DATA), a2.set_iv(0, 0, 0, 0), c2.set(s2.subarray(0, 16))) : (c2.set(t2), c2[15] = 1);
    const h2 = new DataView(c2.buffer);
    if (this.gamma0 = h2.getUint32(12), a2.set_nonce(h2.getUint32(0), h2.getUint32(4), h2.getUint32(8), 0), a2.set_mask(0, 0, 0, 4294967295), void 0 !== r2) {
      if (r2.length > Un) throw new ve("illegal adata length");
      r2.length ? (this.adata = r2, this._gcm_mac_process(r2)) : this.adata = void 0;
    } else this.adata = void 0;
    if (this.counter < 1 || this.counter > 4294967295) throw new RangeError("counter must be a positive 32-bit integer");
    a2.set_counter(0, 0, 0, this.gamma0 + this.counter | 0);
  }
  static encrypt(e2, t2, r2, n2, i2) {
    return new _Dn(t2, r2, n2, i2).encrypt(e2);
  }
  static decrypt(e2, t2, r2, n2, i2) {
    return new _Dn(t2, r2, n2, i2).decrypt(e2);
  }
  encrypt(e2) {
    return this.AES_GCM_encrypt(e2);
  }
  decrypt(e2) {
    return this.AES_GCM_decrypt(e2);
  }
  AES_GCM_Encrypt_process(e2) {
    let t2 = 0, r2 = e2.length || 0, { asm: n2, heap: i2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.aes.pos, o2 = this.aes.len, c2 = 0, h2 = o2 + r2 & -16, u2 = 0;
    if ((a2 - 1 << 4) + o2 + r2 > Un) throw new RangeError("counter overflow");
    const l2 = new Uint8Array(h2);
    for (; r2 > 0; ) u2 = we(i2, s2 + o2, e2, t2, r2), o2 += u2, t2 += u2, r2 -= u2, u2 = n2.cipher(fe.ENC.CTR, fe.HEAP_DATA + s2, o2), u2 = n2.mac(fe.MAC.GCM, fe.HEAP_DATA + s2, u2), u2 && l2.set(i2.subarray(s2, s2 + u2), c2), a2 += u2 >>> 4, c2 += u2, u2 < o2 ? (s2 += u2, o2 -= u2) : (s2 = 0, o2 = 0);
    return this.counter = a2, this.aes.pos = s2, this.aes.len = o2, l2;
  }
  AES_GCM_Encrypt_finish() {
    let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.counter, n2 = this.tagSize, i2 = this.adata, a2 = this.aes.pos, s2 = this.aes.len;
    const o2 = new Uint8Array(s2 + n2);
    e2.cipher(fe.ENC.CTR, fe.HEAP_DATA + a2, s2 + 15 & -16), s2 && o2.set(t2.subarray(a2, a2 + s2));
    let c2 = s2;
    for (; 15 & c2; c2++) t2[a2 + c2] = 0;
    e2.mac(fe.MAC.GCM, fe.HEAP_DATA + a2, c2);
    const h2 = void 0 !== i2 ? i2.length : 0, u2 = (r2 - 1 << 4) + s2;
    return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = h2 >>> 29, t2[4] = h2 >>> 21, t2[5] = h2 >>> 13 & 255, t2[6] = h2 >>> 5 & 255, t2[7] = h2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = u2 >>> 29, t2[12] = u2 >>> 21 & 255, t2[13] = u2 >>> 13 & 255, t2[14] = u2 >>> 5 & 255, t2[15] = u2 << 3 & 255, e2.mac(fe.MAC.GCM, fe.HEAP_DATA, 16), e2.get_iv(fe.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(fe.ENC.CTR, fe.HEAP_DATA, 16), o2.set(t2.subarray(0, n2), s2), this.counter = 1, this.aes.pos = 0, this.aes.len = 0, o2;
  }
  AES_GCM_Decrypt_process(e2) {
    let t2 = 0, r2 = e2.length || 0, { asm: n2, heap: i2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.tagSize, o2 = this.aes.pos, c2 = this.aes.len, h2 = 0, u2 = c2 + r2 > s2 ? c2 + r2 - s2 & -16 : 0, l2 = c2 + r2 - u2, y2 = 0;
    if ((a2 - 1 << 4) + c2 + r2 > Un) throw new RangeError("counter overflow");
    const d2 = new Uint8Array(u2);
    for (; r2 > l2; ) y2 = we(i2, o2 + c2, e2, t2, r2 - l2), c2 += y2, t2 += y2, r2 -= y2, y2 = n2.mac(fe.MAC.GCM, fe.HEAP_DATA + o2, y2), y2 = n2.cipher(fe.DEC.CTR, fe.HEAP_DATA + o2, y2), y2 && d2.set(i2.subarray(o2, o2 + y2), h2), a2 += y2 >>> 4, h2 += y2, o2 = 0, c2 = 0;
    return r2 > 0 && (c2 += we(i2, 0, e2, t2, r2)), this.counter = a2, this.aes.pos = o2, this.aes.len = c2, d2;
  }
  AES_GCM_Decrypt_finish() {
    let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.tagSize, n2 = this.adata, i2 = this.counter, a2 = this.aes.pos, s2 = this.aes.len, o2 = s2 - r2;
    if (s2 < r2) throw new ke("authentication tag not found");
    const c2 = new Uint8Array(o2), h2 = new Uint8Array(t2.subarray(a2 + o2, a2 + s2));
    let u2 = o2;
    for (; 15 & u2; u2++) t2[a2 + u2] = 0;
    e2.mac(fe.MAC.GCM, fe.HEAP_DATA + a2, u2), e2.cipher(fe.DEC.CTR, fe.HEAP_DATA + a2, u2), o2 && c2.set(t2.subarray(a2, a2 + o2));
    const l2 = void 0 !== n2 ? n2.length : 0, y2 = (i2 - 1 << 4) + s2 - r2;
    t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = l2 >>> 29, t2[4] = l2 >>> 21, t2[5] = l2 >>> 13 & 255, t2[6] = l2 >>> 5 & 255, t2[7] = l2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = y2 >>> 29, t2[12] = y2 >>> 21 & 255, t2[13] = y2 >>> 13 & 255, t2[14] = y2 >>> 5 & 255, t2[15] = y2 << 3 & 255, e2.mac(fe.MAC.GCM, fe.HEAP_DATA, 16), e2.get_iv(fe.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(fe.ENC.CTR, fe.HEAP_DATA, 16);
    let d2 = 0;
    for (let e3 = 0; e3 < r2; ++e3) d2 |= h2[e3] ^ t2[e3];
    if (d2) throw new Ae("data integrity check failed");
    return this.counter = 1, this.aes.pos = 0, this.aes.len = 0, c2;
  }
  AES_GCM_decrypt(e2) {
    const t2 = this.AES_GCM_Decrypt_process(e2), r2 = this.AES_GCM_Decrypt_finish(), n2 = new Uint8Array(t2.length + r2.length);
    return t2.length && n2.set(t2), r2.length && n2.set(r2, t2.length), n2;
  }
  AES_GCM_encrypt(e2) {
    const t2 = this.AES_GCM_Encrypt_process(e2), r2 = this.AES_GCM_Encrypt_finish(), n2 = new Uint8Array(t2.length + r2.length);
    return t2.length && n2.set(t2), r2.length && n2.set(r2, t2.length), n2;
  }
  _gcm_mac_process(e2) {
    let { asm: t2, heap: r2 } = this.aes.acquire_asm(), n2 = 0, i2 = e2.length || 0, a2 = 0;
    for (; i2 > 0; ) {
      for (a2 = we(r2, 0, e2, n2, i2), n2 += a2, i2 -= a2; 15 & a2; ) r2[a2++] = 0;
      t2.mac(fe.MAC.GCM, fe.HEAP_DATA, a2);
    }
  }
};
var Cn = X.getWebCrypto();
var In = X.getNodeCrypto();
var Tn = X.getNodeBuffer();
var Bn = 16;
var zn = "AES-GCM";
async function Rn(e2, t2) {
  if (e2 !== $.symmetric.aes128 && e2 !== $.symmetric.aes192 && e2 !== $.symmetric.aes256) throw Error("GCM mode supports only AES cipher");
  if (X.getNodeCrypto()) return { encrypt: async function(e3, r2, n2 = new Uint8Array()) {
    const i2 = new In.createCipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
    i2.setAAD(n2);
    const a2 = Tn.concat([i2.update(e3), i2.final(), i2.getAuthTag()]);
    return new Uint8Array(a2);
  }, decrypt: async function(e3, r2, n2 = new Uint8Array()) {
    const i2 = new In.createDecipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
    i2.setAAD(n2), i2.setAuthTag(e3.slice(e3.length - Bn, e3.length));
    const a2 = Tn.concat([i2.update(e3.slice(0, e3.length - Bn)), i2.final()]);
    return new Uint8Array(a2);
  } };
  if (X.getWebCrypto() && 24 !== t2.length) {
    const e3 = await Cn.importKey("raw", t2, { name: zn }, false, ["encrypt", "decrypt"]);
    return { encrypt: async function(r2, n2, i2 = new Uint8Array()) {
      if (!r2.length) return Dn.encrypt(r2, t2, n2, i2);
      const a2 = await Cn.encrypt({ name: zn, iv: n2, additionalData: i2, tagLength: 8 * Bn }, e3, r2);
      return new Uint8Array(a2);
    }, decrypt: async function(r2, n2, i2 = new Uint8Array()) {
      if (r2.length === Bn) return Dn.decrypt(r2, t2, n2, i2);
      const a2 = await Cn.decrypt({ name: zn, iv: n2, additionalData: i2, tagLength: 8 * Bn }, e3, r2);
      return new Uint8Array(a2);
    } };
  }
  return { encrypt: async function(e3, r2, n2) {
    return Dn.encrypt(e3, t2, r2, n2);
  }, decrypt: async function(e3, r2, n2) {
    return Dn.decrypt(e3, t2, r2, n2);
  } };
}
Rn.getNonce = function(e2, t2) {
  const r2 = e2.slice();
  for (let e3 = 0; e3 < t2.length; e3++) r2[4 + e3] ^= t2[e3];
  return r2;
}, Rn.blockLength = 16, Rn.ivLength = 12, Rn.tagLength = Bn;
var Mn = { cfb: Yr, gcm: Rn, experimentalGCM: Rn, eax: bn, ocb: Pn };
var Ln = rt(function(e2) {
  !function(e3) {
    var t2 = function(e4) {
      var t3, r3 = new Float64Array(16);
      if (e4) for (t3 = 0; t3 < e4.length; t3++) r3[t3] = e4[t3];
      return r3;
    }, r2 = function() {
      throw Error("no PRNG");
    }, n2 = new Uint8Array(32);
    n2[0] = 9;
    var i2 = t2(), a2 = t2([1]), s2 = t2([56129, 1]), o2 = t2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), c2 = t2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), h2 = t2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), u2 = t2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), l2 = t2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function y2(e4, t3, r3, n3) {
      return function(e5, t4, r4, n4, i3) {
        var a3, s3 = 0;
        for (a3 = 0; a3 < i3; a3++) s3 |= e5[t4 + a3] ^ r4[n4 + a3];
        return (1 & s3 - 1 >>> 8) - 1;
      }(e4, t3, r3, n3, 32);
    }
    function d2(e4, t3) {
      var r3;
      for (r3 = 0; r3 < 16; r3++) e4[r3] = 0 | t3[r3];
    }
    function p2(e4) {
      var t3, r3, n3 = 1;
      for (t3 = 0; t3 < 16; t3++) r3 = e4[t3] + n3 + 65535, n3 = Math.floor(r3 / 65536), e4[t3] = r3 - 65536 * n3;
      e4[0] += n3 - 1 + 37 * (n3 - 1);
    }
    function f2(e4, t3, r3) {
      for (var n3, i3 = ~(r3 - 1), a3 = 0; a3 < 16; a3++) n3 = i3 & (e4[a3] ^ t3[a3]), e4[a3] ^= n3, t3[a3] ^= n3;
    }
    function g2(e4, r3) {
      var n3, i3, a3, s3 = t2(), o3 = t2();
      for (n3 = 0; n3 < 16; n3++) o3[n3] = r3[n3];
      for (p2(o3), p2(o3), p2(o3), i3 = 0; i3 < 2; i3++) {
        for (s3[0] = o3[0] - 65517, n3 = 1; n3 < 15; n3++) s3[n3] = o3[n3] - 65535 - (s3[n3 - 1] >> 16 & 1), s3[n3 - 1] &= 65535;
        s3[15] = o3[15] - 32767 - (s3[14] >> 16 & 1), a3 = s3[15] >> 16 & 1, s3[14] &= 65535, f2(o3, s3, 1 - a3);
      }
      for (n3 = 0; n3 < 16; n3++) e4[2 * n3] = 255 & o3[n3], e4[2 * n3 + 1] = o3[n3] >> 8;
    }
    function m2(e4, t3) {
      var r3 = new Uint8Array(32), n3 = new Uint8Array(32);
      return g2(r3, e4), g2(n3, t3), y2(r3, 0, n3, 0);
    }
    function w2(e4) {
      var t3 = new Uint8Array(32);
      return g2(t3, e4), 1 & t3[0];
    }
    function b2(e4, t3) {
      var r3;
      for (r3 = 0; r3 < 16; r3++) e4[r3] = t3[2 * r3] + (t3[2 * r3 + 1] << 8);
      e4[15] &= 32767;
    }
    function k2(e4, t3, r3) {
      for (var n3 = 0; n3 < 16; n3++) e4[n3] = t3[n3] + r3[n3];
    }
    function v2(e4, t3, r3) {
      for (var n3 = 0; n3 < 16; n3++) e4[n3] = t3[n3] - r3[n3];
    }
    function A2(e4, t3, r3) {
      var n3, i3, a3 = 0, s3 = 0, o3 = 0, c3 = 0, h3 = 0, u3 = 0, l3 = 0, y3 = 0, d3 = 0, p3 = 0, f3 = 0, g3 = 0, m3 = 0, w3 = 0, b3 = 0, k3 = 0, v3 = 0, A3 = 0, _3 = 0, E3 = 0, S3 = 0, K3 = 0, x3 = 0, P3 = 0, U3 = 0, D3 = 0, C3 = 0, I3 = 0, T3 = 0, B3 = 0, z3 = 0, R3 = r3[0], M3 = r3[1], L3 = r3[2], N3 = r3[3], O2 = r3[4], F2 = r3[5], H2 = r3[6], j2 = r3[7], q2 = r3[8], G2 = r3[9], V2 = r3[10], W2 = r3[11], $2 = r3[12], Z2 = r3[13], X2 = r3[14], Q2 = r3[15];
      a3 += (n3 = t3[0]) * R3, s3 += n3 * M3, o3 += n3 * L3, c3 += n3 * N3, h3 += n3 * O2, u3 += n3 * F2, l3 += n3 * H2, y3 += n3 * j2, d3 += n3 * q2, p3 += n3 * G2, f3 += n3 * V2, g3 += n3 * W2, m3 += n3 * $2, w3 += n3 * Z2, b3 += n3 * X2, k3 += n3 * Q2, s3 += (n3 = t3[1]) * R3, o3 += n3 * M3, c3 += n3 * L3, h3 += n3 * N3, u3 += n3 * O2, l3 += n3 * F2, y3 += n3 * H2, d3 += n3 * j2, p3 += n3 * q2, f3 += n3 * G2, g3 += n3 * V2, m3 += n3 * W2, w3 += n3 * $2, b3 += n3 * Z2, k3 += n3 * X2, v3 += n3 * Q2, o3 += (n3 = t3[2]) * R3, c3 += n3 * M3, h3 += n3 * L3, u3 += n3 * N3, l3 += n3 * O2, y3 += n3 * F2, d3 += n3 * H2, p3 += n3 * j2, f3 += n3 * q2, g3 += n3 * G2, m3 += n3 * V2, w3 += n3 * W2, b3 += n3 * $2, k3 += n3 * Z2, v3 += n3 * X2, A3 += n3 * Q2, c3 += (n3 = t3[3]) * R3, h3 += n3 * M3, u3 += n3 * L3, l3 += n3 * N3, y3 += n3 * O2, d3 += n3 * F2, p3 += n3 * H2, f3 += n3 * j2, g3 += n3 * q2, m3 += n3 * G2, w3 += n3 * V2, b3 += n3 * W2, k3 += n3 * $2, v3 += n3 * Z2, A3 += n3 * X2, _3 += n3 * Q2, h3 += (n3 = t3[4]) * R3, u3 += n3 * M3, l3 += n3 * L3, y3 += n3 * N3, d3 += n3 * O2, p3 += n3 * F2, f3 += n3 * H2, g3 += n3 * j2, m3 += n3 * q2, w3 += n3 * G2, b3 += n3 * V2, k3 += n3 * W2, v3 += n3 * $2, A3 += n3 * Z2, _3 += n3 * X2, E3 += n3 * Q2, u3 += (n3 = t3[5]) * R3, l3 += n3 * M3, y3 += n3 * L3, d3 += n3 * N3, p3 += n3 * O2, f3 += n3 * F2, g3 += n3 * H2, m3 += n3 * j2, w3 += n3 * q2, b3 += n3 * G2, k3 += n3 * V2, v3 += n3 * W2, A3 += n3 * $2, _3 += n3 * Z2, E3 += n3 * X2, S3 += n3 * Q2, l3 += (n3 = t3[6]) * R3, y3 += n3 * M3, d3 += n3 * L3, p3 += n3 * N3, f3 += n3 * O2, g3 += n3 * F2, m3 += n3 * H2, w3 += n3 * j2, b3 += n3 * q2, k3 += n3 * G2, v3 += n3 * V2, A3 += n3 * W2, _3 += n3 * $2, E3 += n3 * Z2, S3 += n3 * X2, K3 += n3 * Q2, y3 += (n3 = t3[7]) * R3, d3 += n3 * M3, p3 += n3 * L3, f3 += n3 * N3, g3 += n3 * O2, m3 += n3 * F2, w3 += n3 * H2, b3 += n3 * j2, k3 += n3 * q2, v3 += n3 * G2, A3 += n3 * V2, _3 += n3 * W2, E3 += n3 * $2, S3 += n3 * Z2, K3 += n3 * X2, x3 += n3 * Q2, d3 += (n3 = t3[8]) * R3, p3 += n3 * M3, f3 += n3 * L3, g3 += n3 * N3, m3 += n3 * O2, w3 += n3 * F2, b3 += n3 * H2, k3 += n3 * j2, v3 += n3 * q2, A3 += n3 * G2, _3 += n3 * V2, E3 += n3 * W2, S3 += n3 * $2, K3 += n3 * Z2, x3 += n3 * X2, P3 += n3 * Q2, p3 += (n3 = t3[9]) * R3, f3 += n3 * M3, g3 += n3 * L3, m3 += n3 * N3, w3 += n3 * O2, b3 += n3 * F2, k3 += n3 * H2, v3 += n3 * j2, A3 += n3 * q2, _3 += n3 * G2, E3 += n3 * V2, S3 += n3 * W2, K3 += n3 * $2, x3 += n3 * Z2, P3 += n3 * X2, U3 += n3 * Q2, f3 += (n3 = t3[10]) * R3, g3 += n3 * M3, m3 += n3 * L3, w3 += n3 * N3, b3 += n3 * O2, k3 += n3 * F2, v3 += n3 * H2, A3 += n3 * j2, _3 += n3 * q2, E3 += n3 * G2, S3 += n3 * V2, K3 += n3 * W2, x3 += n3 * $2, P3 += n3 * Z2, U3 += n3 * X2, D3 += n3 * Q2, g3 += (n3 = t3[11]) * R3, m3 += n3 * M3, w3 += n3 * L3, b3 += n3 * N3, k3 += n3 * O2, v3 += n3 * F2, A3 += n3 * H2, _3 += n3 * j2, E3 += n3 * q2, S3 += n3 * G2, K3 += n3 * V2, x3 += n3 * W2, P3 += n3 * $2, U3 += n3 * Z2, D3 += n3 * X2, C3 += n3 * Q2, m3 += (n3 = t3[12]) * R3, w3 += n3 * M3, b3 += n3 * L3, k3 += n3 * N3, v3 += n3 * O2, A3 += n3 * F2, _3 += n3 * H2, E3 += n3 * j2, S3 += n3 * q2, K3 += n3 * G2, x3 += n3 * V2, P3 += n3 * W2, U3 += n3 * $2, D3 += n3 * Z2, C3 += n3 * X2, I3 += n3 * Q2, w3 += (n3 = t3[13]) * R3, b3 += n3 * M3, k3 += n3 * L3, v3 += n3 * N3, A3 += n3 * O2, _3 += n3 * F2, E3 += n3 * H2, S3 += n3 * j2, K3 += n3 * q2, x3 += n3 * G2, P3 += n3 * V2, U3 += n3 * W2, D3 += n3 * $2, C3 += n3 * Z2, I3 += n3 * X2, T3 += n3 * Q2, b3 += (n3 = t3[14]) * R3, k3 += n3 * M3, v3 += n3 * L3, A3 += n3 * N3, _3 += n3 * O2, E3 += n3 * F2, S3 += n3 * H2, K3 += n3 * j2, x3 += n3 * q2, P3 += n3 * G2, U3 += n3 * V2, D3 += n3 * W2, C3 += n3 * $2, I3 += n3 * Z2, T3 += n3 * X2, B3 += n3 * Q2, k3 += (n3 = t3[15]) * R3, s3 += 38 * (A3 += n3 * L3), o3 += 38 * (_3 += n3 * N3), c3 += 38 * (E3 += n3 * O2), h3 += 38 * (S3 += n3 * F2), u3 += 38 * (K3 += n3 * H2), l3 += 38 * (x3 += n3 * j2), y3 += 38 * (P3 += n3 * q2), d3 += 38 * (U3 += n3 * G2), p3 += 38 * (D3 += n3 * V2), f3 += 38 * (C3 += n3 * W2), g3 += 38 * (I3 += n3 * $2), m3 += 38 * (T3 += n3 * Z2), w3 += 38 * (B3 += n3 * X2), b3 += 38 * (z3 += n3 * Q2), a3 = (n3 = (a3 += 38 * (v3 += n3 * M3)) + (i3 = 1) + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), s3 = (n3 = s3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), o3 = (n3 = o3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), c3 = (n3 = c3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), h3 = (n3 = h3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), u3 = (n3 = u3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), l3 = (n3 = l3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), y3 = (n3 = y3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), d3 = (n3 = d3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), p3 = (n3 = p3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), f3 = (n3 = f3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), g3 = (n3 = g3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), m3 = (n3 = m3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), w3 = (n3 = w3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), k3 = (n3 = k3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), a3 = (n3 = (a3 += i3 - 1 + 37 * (i3 - 1)) + (i3 = 1) + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), s3 = (n3 = s3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), o3 = (n3 = o3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), c3 = (n3 = c3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), h3 = (n3 = h3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), u3 = (n3 = u3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), l3 = (n3 = l3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), y3 = (n3 = y3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), d3 = (n3 = d3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), p3 = (n3 = p3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), f3 = (n3 = f3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), g3 = (n3 = g3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), m3 = (n3 = m3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), w3 = (n3 = w3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), b3 = (n3 = b3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), k3 = (n3 = k3 + i3 + 65535) - 65536 * (i3 = Math.floor(n3 / 65536)), a3 += i3 - 1 + 37 * (i3 - 1), e4[0] = a3, e4[1] = s3, e4[2] = o3, e4[3] = c3, e4[4] = h3, e4[5] = u3, e4[6] = l3, e4[7] = y3, e4[8] = d3, e4[9] = p3, e4[10] = f3, e4[11] = g3, e4[12] = m3, e4[13] = w3, e4[14] = b3, e4[15] = k3;
    }
    function _2(e4, t3) {
      A2(e4, t3, t3);
    }
    function E2(e4, r3) {
      var n3, i3 = t2();
      for (n3 = 0; n3 < 16; n3++) i3[n3] = r3[n3];
      for (n3 = 253; n3 >= 0; n3--) _2(i3, i3), 2 !== n3 && 4 !== n3 && A2(i3, i3, r3);
      for (n3 = 0; n3 < 16; n3++) e4[n3] = i3[n3];
    }
    function S2(e4, r3, n3) {
      var i3, a3, o3 = new Uint8Array(32), c3 = new Float64Array(80), h3 = t2(), u3 = t2(), l3 = t2(), y3 = t2(), d3 = t2(), p3 = t2();
      for (a3 = 0; a3 < 31; a3++) o3[a3] = r3[a3];
      for (o3[31] = 127 & r3[31] | 64, o3[0] &= 248, b2(c3, n3), a3 = 0; a3 < 16; a3++) u3[a3] = c3[a3], y3[a3] = h3[a3] = l3[a3] = 0;
      for (h3[0] = y3[0] = 1, a3 = 254; a3 >= 0; --a3) f2(h3, u3, i3 = o3[a3 >>> 3] >>> (7 & a3) & 1), f2(l3, y3, i3), k2(d3, h3, l3), v2(h3, h3, l3), k2(l3, u3, y3), v2(u3, u3, y3), _2(y3, d3), _2(p3, h3), A2(h3, l3, h3), A2(l3, u3, d3), k2(d3, h3, l3), v2(h3, h3, l3), _2(u3, h3), v2(l3, y3, p3), A2(h3, l3, s2), k2(h3, h3, y3), A2(l3, l3, h3), A2(h3, y3, p3), A2(y3, u3, c3), _2(u3, d3), f2(h3, u3, i3), f2(l3, y3, i3);
      for (a3 = 0; a3 < 16; a3++) c3[a3 + 16] = h3[a3], c3[a3 + 32] = l3[a3], c3[a3 + 48] = u3[a3], c3[a3 + 64] = y3[a3];
      var m3 = c3.subarray(32), w3 = c3.subarray(16);
      return E2(m3, m3), A2(w3, w3, m3), g2(e4, w3), 0;
    }
    function K2(e4, t3) {
      return S2(e4, t3, n2);
    }
    function x2(e4, r3) {
      var n3 = t2(), i3 = t2(), a3 = t2(), s3 = t2(), o3 = t2(), h3 = t2(), u3 = t2(), l3 = t2(), y3 = t2();
      v2(n3, e4[1], e4[0]), v2(y3, r3[1], r3[0]), A2(n3, n3, y3), k2(i3, e4[0], e4[1]), k2(y3, r3[0], r3[1]), A2(i3, i3, y3), A2(a3, e4[3], r3[3]), A2(a3, a3, c2), A2(s3, e4[2], r3[2]), k2(s3, s3, s3), v2(o3, i3, n3), v2(h3, s3, a3), k2(u3, s3, a3), k2(l3, i3, n3), A2(e4[0], o3, h3), A2(e4[1], l3, u3), A2(e4[2], u3, h3), A2(e4[3], o3, l3);
    }
    function P2(e4, t3, r3) {
      var n3;
      for (n3 = 0; n3 < 4; n3++) f2(e4[n3], t3[n3], r3);
    }
    function U2(e4, r3) {
      var n3 = t2(), i3 = t2(), a3 = t2();
      E2(a3, r3[2]), A2(n3, r3[0], a3), A2(i3, r3[1], a3), g2(e4, i3), e4[31] ^= w2(n3) << 7;
    }
    function D2(e4, t3, r3) {
      var n3, s3;
      for (d2(e4[0], i2), d2(e4[1], a2), d2(e4[2], a2), d2(e4[3], i2), s3 = 255; s3 >= 0; --s3) P2(e4, t3, n3 = r3[s3 / 8 | 0] >> (7 & s3) & 1), x2(t3, e4), x2(e4, e4), P2(e4, t3, n3);
    }
    function C2(e4, r3) {
      var n3 = [t2(), t2(), t2(), t2()];
      d2(n3[0], h2), d2(n3[1], u2), d2(n3[2], a2), A2(n3[3], h2, u2), D2(e4, n3, r3);
    }
    function I2(n3, i3, a3) {
      var s3, o3, c3 = [t2(), t2(), t2(), t2()];
      for (a3 || r2(i3, 32), (s3 = e3.hash(i3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64, C2(c3, s3), U2(n3, c3), o3 = 0; o3 < 32; o3++) i3[o3 + 32] = n3[o3];
      return 0;
    }
    var T2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function B2(e4, t3) {
      var r3, n3, i3, a3;
      for (n3 = 63; n3 >= 32; --n3) {
        for (r3 = 0, i3 = n3 - 32, a3 = n3 - 12; i3 < a3; ++i3) t3[i3] += r3 - 16 * t3[n3] * T2[i3 - (n3 - 32)], r3 = Math.floor((t3[i3] + 128) / 256), t3[i3] -= 256 * r3;
        t3[i3] += r3, t3[n3] = 0;
      }
      for (r3 = 0, i3 = 0; i3 < 32; i3++) t3[i3] += r3 - (t3[31] >> 4) * T2[i3], r3 = t3[i3] >> 8, t3[i3] &= 255;
      for (i3 = 0; i3 < 32; i3++) t3[i3] -= r3 * T2[i3];
      for (n3 = 0; n3 < 32; n3++) t3[n3 + 1] += t3[n3] >> 8, e4[n3] = 255 & t3[n3];
    }
    function z2(e4) {
      var t3, r3 = new Float64Array(64);
      for (t3 = 0; t3 < 64; t3++) r3[t3] = e4[t3];
      for (t3 = 0; t3 < 64; t3++) e4[t3] = 0;
      B2(e4, r3);
    }
    function R2(e4, r3) {
      var n3 = t2(), s3 = t2(), c3 = t2(), h3 = t2(), u3 = t2(), y3 = t2(), p3 = t2();
      return d2(e4[2], a2), b2(e4[1], r3), _2(c3, e4[1]), A2(h3, c3, o2), v2(c3, c3, e4[2]), k2(h3, e4[2], h3), _2(u3, h3), _2(y3, u3), A2(p3, y3, u3), A2(n3, p3, c3), A2(n3, n3, h3), function(e5, r4) {
        var n4, i3 = t2();
        for (n4 = 0; n4 < 16; n4++) i3[n4] = r4[n4];
        for (n4 = 250; n4 >= 0; n4--) _2(i3, i3), 1 !== n4 && A2(i3, i3, r4);
        for (n4 = 0; n4 < 16; n4++) e5[n4] = i3[n4];
      }(n3, n3), A2(n3, n3, c3), A2(n3, n3, h3), A2(n3, n3, h3), A2(e4[0], n3, h3), _2(s3, e4[0]), A2(s3, s3, h3), m2(s3, c3) && A2(e4[0], e4[0], l2), _2(s3, e4[0]), A2(s3, s3, h3), m2(s3, c3) ? -1 : (w2(e4[0]) === r3[31] >> 7 && v2(e4[0], i2, e4[0]), A2(e4[3], e4[0], e4[1]), 0);
    }
    var M2 = 64;
    function L2() {
      for (var e4 = 0; e4 < arguments.length; e4++) if (!(arguments[e4] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
    }
    function N2(e4) {
      for (var t3 = 0; t3 < e4.length; t3++) e4[t3] = 0;
    }
    e3.scalarMult = function(e4, t3) {
      if (L2(e4, t3), 32 !== e4.length) throw Error("bad n size");
      if (32 !== t3.length) throw Error("bad p size");
      var r3 = new Uint8Array(32);
      return S2(r3, e4, t3), r3;
    }, e3.box = {}, e3.box.keyPair = function() {
      var e4, t3, n3 = new Uint8Array(32), i3 = new Uint8Array(32);
      return e4 = n3, r2(t3 = i3, 32), K2(e4, t3), { publicKey: n3, secretKey: i3 };
    }, e3.box.keyPair.fromSecretKey = function(e4) {
      if (L2(e4), 32 !== e4.length) throw Error("bad secret key size");
      var t3 = new Uint8Array(32);
      return K2(t3, e4), { publicKey: t3, secretKey: new Uint8Array(e4) };
    }, e3.sign = function(r3, n3) {
      if (L2(r3, n3), 64 !== n3.length) throw Error("bad secret key size");
      var i3 = new Uint8Array(M2 + r3.length);
      return function(r4, n4, i4, a3) {
        var s3, o3, c3, h3, u3, l3 = new Float64Array(64), y3 = [t2(), t2(), t2(), t2()];
        (s3 = e3.hash(a3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64;
        var d3 = i4 + 64;
        for (h3 = 0; h3 < i4; h3++) r4[64 + h3] = n4[h3];
        for (h3 = 0; h3 < 32; h3++) r4[32 + h3] = s3[32 + h3];
        for (z2(c3 = e3.hash(r4.subarray(32, d3))), C2(y3, c3), U2(r4, y3), h3 = 32; h3 < 64; h3++) r4[h3] = a3[h3];
        for (z2(o3 = e3.hash(r4.subarray(0, d3))), h3 = 0; h3 < 64; h3++) l3[h3] = 0;
        for (h3 = 0; h3 < 32; h3++) l3[h3] = c3[h3];
        for (h3 = 0; h3 < 32; h3++) for (u3 = 0; u3 < 32; u3++) l3[h3 + u3] += o3[h3] * s3[u3];
        B2(r4.subarray(32), l3);
      }(i3, r3, r3.length, n3), i3;
    }, e3.sign.detached = function(t3, r3) {
      for (var n3 = e3.sign(t3, r3), i3 = new Uint8Array(M2), a3 = 0; a3 < i3.length; a3++) i3[a3] = n3[a3];
      return i3;
    }, e3.sign.detached.verify = function(r3, n3, i3) {
      if (L2(r3, n3, i3), n3.length !== M2) throw Error("bad signature size");
      if (32 !== i3.length) throw Error("bad public key size");
      var a3, s3 = new Uint8Array(M2 + r3.length), o3 = new Uint8Array(M2 + r3.length);
      for (a3 = 0; a3 < M2; a3++) s3[a3] = n3[a3];
      for (a3 = 0; a3 < r3.length; a3++) s3[a3 + M2] = r3[a3];
      return function(r4, n4, i4, a4) {
        var s4, o4, c3 = new Uint8Array(32), h3 = [t2(), t2(), t2(), t2()], u3 = [t2(), t2(), t2(), t2()];
        if (i4 < 64) return -1;
        if (R2(u3, a4)) return -1;
        for (s4 = 0; s4 < i4; s4++) r4[s4] = n4[s4];
        for (s4 = 0; s4 < 32; s4++) r4[s4 + 32] = a4[s4];
        if (z2(o4 = e3.hash(r4.subarray(0, i4))), D2(h3, u3, o4), C2(u3, n4.subarray(32)), x2(h3, u3), U2(c3, h3), i4 -= 64, y2(n4, 0, c3, 0)) {
          for (s4 = 0; s4 < i4; s4++) r4[s4] = 0;
          return -1;
        }
        for (s4 = 0; s4 < i4; s4++) r4[s4] = n4[s4 + 64];
        return i4;
      }(o3, s3, s3.length, i3) >= 0;
    }, e3.sign.keyPair = function() {
      var e4 = new Uint8Array(32), t3 = new Uint8Array(64);
      return I2(e4, t3), { publicKey: e4, secretKey: t3 };
    }, e3.sign.keyPair.fromSecretKey = function(e4) {
      if (L2(e4), 64 !== e4.length) throw Error("bad secret key size");
      for (var t3 = new Uint8Array(32), r3 = 0; r3 < t3.length; r3++) t3[r3] = e4[32 + r3];
      return { publicKey: t3, secretKey: new Uint8Array(e4) };
    }, e3.sign.keyPair.fromSeed = function(e4) {
      if (L2(e4), 32 !== e4.length) throw Error("bad seed size");
      for (var t3 = new Uint8Array(32), r3 = new Uint8Array(64), n3 = 0; n3 < 32; n3++) r3[n3] = e4[n3];
      return I2(t3, r3, true), { publicKey: t3, secretKey: r3 };
    }, e3.setPRNG = function(e4) {
      r2 = e4;
    }, function() {
      var t3 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
      if (t3 && t3.getRandomValues) {
        e3.setPRNG(function(e4, r3) {
          var n3, i3 = new Uint8Array(r3);
          for (n3 = 0; n3 < r3; n3 += 65536) t3.getRandomValues(i3.subarray(n3, n3 + Math.min(r3 - n3, 65536)));
          for (n3 = 0; n3 < r3; n3++) e4[n3] = i3[n3];
          N2(i3);
        });
      } else void 0 !== nt && (t3 = void 0) && t3.randomBytes && e3.setPRNG(function(e4, r3) {
        var n3, i3 = t3.randomBytes(r3);
        for (n3 = 0; n3 < r3; n3++) e4[n3] = i3[n3];
        N2(i3);
      });
    }();
  }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
});
var Nn = X.getNodeCrypto();
function On(e2) {
  const t2 = new Uint8Array(e2);
  if (Nn) {
    const e3 = Nn.randomBytes(t2.length);
    t2.set(e3);
  } else {
    if ("undefined" == typeof crypto || !crypto.getRandomValues) throw Error("No secure random number generator available.");
    crypto.getRandomValues(t2);
  }
  return t2;
}
async function Fn(e2, t2) {
  const r2 = await X.getBigInteger();
  if (t2.lt(e2)) throw Error("Illegal parameter value: max <= min");
  const n2 = t2.sub(e2), i2 = n2.byteLength();
  return new r2(await On(i2 + 8)).mod(n2).add(e2);
}
var Hn = Object.freeze({ __proto__: null, getRandomBytes: On, getRandomBigInteger: Fn });
async function jn(e2, t2, r2) {
  const n2 = await X.getBigInteger(), i2 = new n2(1), a2 = i2.leftShift(new n2(e2 - 1)), s2 = new n2(30), o2 = [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2], c2 = await Fn(a2, a2.leftShift(i2));
  let h2 = c2.mod(s2).toNumber();
  do {
    c2.iadd(new n2(o2[h2])), h2 = (h2 + o2[h2]) % o2.length, c2.bitLength() > e2 && (c2.imod(a2.leftShift(i2)).iadd(a2), h2 = c2.mod(s2).toNumber());
  } while (!await qn(c2, t2, r2));
  return c2;
}
async function qn(e2, t2, r2) {
  return !(t2 && !e2.dec().gcd(t2).isOne()) && (!!await async function(e3) {
    const t3 = await X.getBigInteger();
    return Gn.every((r3) => 0 !== e3.mod(new t3(r3)));
  }(e2) && (!!await async function(e3, t3) {
    const r3 = await X.getBigInteger();
    return t3 = t3 || new r3(2), t3.modExp(e3.dec(), e3).isOne();
  }(e2) && !!await async function(e3, t3, r3) {
    const n2 = await X.getBigInteger(), i2 = e3.bitLength();
    t3 || (t3 = Math.max(1, i2 / 48 | 0));
    const a2 = e3.dec();
    let s2 = 0;
    for (; !a2.getBit(s2); ) s2++;
    const o2 = e3.rightShift(new n2(s2));
    for (; t3 > 0; t3--) {
      let t4, i3 = (r3 ? r3() : await Fn(new n2(2), a2)).modExp(o2, e3);
      if (!i3.isOne() && !i3.equal(a2)) {
        for (t4 = 1; t4 < s2; t4++) {
          if (i3 = i3.mul(i3).mod(e3), i3.isOne()) return false;
          if (i3.equal(a2)) break;
        }
        if (t4 === s2) return false;
      }
    }
    return true;
  }(e2, r2)));
}
var Gn = [7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999];
var Vn = [];
function Wn(e2, t2) {
  const r2 = e2.length;
  if (r2 > t2 - 11) throw Error("Message too long");
  const n2 = function(e3) {
    const t3 = new Uint8Array(e3);
    let r3 = 0;
    for (; r3 < e3; ) {
      const n3 = On(e3 - r3);
      for (let e4 = 0; e4 < n3.length; e4++) 0 !== n3[e4] && (t3[r3++] = n3[e4]);
    }
    return t3;
  }(t2 - r2 - 3), i2 = new Uint8Array(t2);
  return i2[1] = 2, i2.set(n2, 2), i2.set(e2, t2 - r2), i2;
}
function $n(e2, t2) {
  let r2 = 2, n2 = 1;
  for (let t3 = r2; t3 < e2.length; t3++) n2 &= 0 !== e2[t3], r2 += n2;
  const i2 = r2 - 2, a2 = e2.subarray(r2 + 1), s2 = 0 === e2[0] & 2 === e2[1] & i2 >= 8 & !n2;
  if (t2) return X.selectUint8Array(s2, a2, t2);
  if (s2) return a2;
  throw Error("Decryption error");
}
async function Zn(e2, t2, r2) {
  let n2;
  if (t2.length !== Gr.getHashByteLength(e2)) throw Error("Invalid hash length");
  const i2 = new Uint8Array(Vn[e2].length);
  for (n2 = 0; n2 < Vn[e2].length; n2++) i2[n2] = Vn[e2][n2];
  const a2 = i2.length + t2.length;
  if (r2 < a2 + 11) throw Error("Intended encoded message length too short");
  const s2 = new Uint8Array(r2 - a2 - 3).fill(255), o2 = new Uint8Array(r2);
  return o2[1] = 1, o2.set(s2, 2), o2.set(i2, r2 - a2), o2.set(t2, r2 - t2.length), o2;
}
Vn[1] = [48, 32, 48, 12, 6, 8, 42, 134, 72, 134, 247, 13, 2, 5, 5, 0, 4, 16], Vn[2] = [48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20], Vn[3] = [48, 33, 48, 9, 6, 5, 43, 36, 3, 2, 1, 5, 0, 4, 20], Vn[8] = [48, 49, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 5, 0, 4, 32], Vn[9] = [48, 65, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 2, 5, 0, 4, 48], Vn[10] = [48, 81, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 3, 5, 0, 4, 64], Vn[11] = [48, 45, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 4, 5, 0, 4, 28];
var Xn = Object.freeze({ __proto__: null, emeEncode: Wn, emeDecode: $n, emsaEncode: Zn });
var Qn = X.getWebCrypto();
var Yn = X.getNodeCrypto();
var Jn = void 0;
var ei = Yn ? Jn.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
}) : void 0;
var ti = Yn ? Jn.define("RSAPubliceKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
}) : void 0;
var ri = Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, n2, i2, a2, s2, o2, c2) {
  if (t2 && !X.isStream(t2)) {
    if (X.getWebCrypto()) try {
      return await async function(e3, t3, r3, n3, i3, a3, s3, o3) {
        const c3 = await async function(e4, t4, r4, n4, i4, a4) {
          const s4 = await X.getBigInteger(), o4 = new s4(n4), c4 = new s4(i4), h3 = new s4(r4);
          let u3 = h3.mod(c4.dec()), l2 = h3.mod(o4.dec());
          return l2 = l2.toUint8Array(), u3 = u3.toUint8Array(), { kty: "RSA", n: ne(e4, true), e: ne(t4, true), d: ne(r4, true), p: ne(i4, true), q: ne(n4, true), dp: ne(u3, true), dq: ne(l2, true), qi: ne(a4, true), ext: true };
        }(r3, n3, i3, a3, s3, o3), h2 = { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, u2 = await Qn.importKey("jwk", c3, h2, false, ["sign"]);
        return new Uint8Array(await Qn.sign("RSASSA-PKCS1-v1_5", u2, t3));
      }($.read($.webHash, e2), t2, r2, n2, i2, a2, s2, o2);
    } catch (e3) {
      X.printDebugError(e3);
    }
    else if (X.getNodeCrypto()) return async function(e3, t3, r3, n3, i3, a3, s3, o3) {
      const { default: c3 } = await import("./bn.min-PK2PZJFG.js"), h2 = new c3(a3), u2 = new c3(s3), l2 = new c3(i3), y2 = l2.mod(u2.subn(1)), d2 = l2.mod(h2.subn(1)), p2 = Yn.createSign($.read($.hash, e3));
      p2.write(t3), p2.end();
      const f2 = { version: 0, modulus: new c3(r3), publicExponent: new c3(n3), privateExponent: new c3(i3), prime1: new c3(s3), prime2: new c3(a3), exponent1: y2, exponent2: d2, coefficient: new c3(o3) };
      if (void 0 !== Yn.createPrivateKey) {
        const e4 = ei.encode(f2, "der");
        return new Uint8Array(p2.sign({ key: e4, format: "der", type: "pkcs1" }));
      }
      const g2 = ei.encode(f2, "pem", { label: "RSA PRIVATE KEY" });
      return new Uint8Array(p2.sign(g2));
    }(e2, t2, r2, n2, i2, a2, s2, o2);
  }
  return async function(e3, t3, r3, n3) {
    const i3 = await X.getBigInteger();
    t3 = new i3(t3);
    const a3 = new i3(await Zn(e3, n3, t3.byteLength()));
    if (r3 = new i3(r3), a3.gte(t3)) throw Error("Message size cannot exceed modulus size");
    return a3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
  }(e2, r2, i2, c2);
}, verify: async function(e2, t2, r2, n2, i2, a2) {
  if (t2 && !X.isStream(t2)) {
    if (X.getWebCrypto()) try {
      return await async function(e3, t3, r3, n3, i3) {
        const a3 = function(e4, t4) {
          return { kty: "RSA", n: ne(e4, true), e: ne(t4, true), ext: true };
        }(n3, i3), s2 = await Qn.importKey("jwk", a3, { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, false, ["verify"]);
        return Qn.verify("RSASSA-PKCS1-v1_5", s2, r3, t3);
      }($.read($.webHash, e2), t2, r2, n2, i2);
    } catch (e3) {
      X.printDebugError(e3);
    }
    else if (X.getNodeCrypto()) return async function(e3, t3, r3, n3, i3) {
      const { default: a3 } = await import("./bn.min-PK2PZJFG.js"), s2 = Yn.createVerify($.read($.hash, e3));
      s2.write(t3), s2.end();
      const o2 = { modulus: new a3(n3), publicExponent: new a3(i3) };
      let c2;
      if (void 0 !== Yn.createPrivateKey) {
        c2 = { key: ti.encode(o2, "der"), format: "der", type: "pkcs1" };
      } else c2 = ti.encode(o2, "pem", { label: "RSA PUBLIC KEY" });
      try {
        return await s2.verify(c2, r3);
      } catch (e4) {
        return false;
      }
    }(e2, t2, r2, n2, i2);
  }
  return async function(e3, t3, r3, n3, i3) {
    const a3 = await X.getBigInteger();
    if (r3 = new a3(r3), t3 = new a3(t3), n3 = new a3(n3), t3.gte(r3)) throw Error("Signature size cannot exceed modulus size");
    const s2 = t3.modExp(n3, r3).toUint8Array("be", r3.byteLength()), o2 = await Zn(e3, i3, r3.byteLength());
    return X.equalsUint8Array(s2, o2);
  }(e2, r2, n2, i2, a2);
}, encrypt: async function(e2, t2, r2) {
  return X.getNodeCrypto() ? async function(e3, t3, r3) {
    const { default: n2 } = await import("./bn.min-PK2PZJFG.js"), i2 = { modulus: new n2(t3), publicExponent: new n2(r3) };
    let a2;
    if (void 0 !== Yn.createPrivateKey) {
      a2 = { key: ti.encode(i2, "der"), format: "der", type: "pkcs1", padding: Yn.constants.RSA_PKCS1_PADDING };
    } else {
      a2 = { key: ti.encode(i2, "pem", { label: "RSA PUBLIC KEY" }), padding: Yn.constants.RSA_PKCS1_PADDING };
    }
    return new Uint8Array(Yn.publicEncrypt(a2, e3));
  }(e2, t2, r2) : async function(e3, t3, r3) {
    const n2 = await X.getBigInteger();
    if (t3 = new n2(t3), e3 = new n2(Wn(e3, t3.byteLength())), r3 = new n2(r3), e3.gte(t3)) throw Error("Message size cannot exceed modulus size");
    return e3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
  }(e2, t2, r2);
}, decrypt: async function(e2, t2, r2, n2, i2, a2, s2, o2) {
  if (X.getNodeCrypto() && !o2) try {
    return await async function(e3, t3, r3, n3, i3, a3, s3) {
      const { default: o3 } = await import("./bn.min-PK2PZJFG.js"), c2 = new o3(i3), h2 = new o3(a3), u2 = new o3(n3), l2 = u2.mod(h2.subn(1)), y2 = u2.mod(c2.subn(1)), d2 = { version: 0, modulus: new o3(t3), publicExponent: new o3(r3), privateExponent: new o3(n3), prime1: new o3(a3), prime2: new o3(i3), exponent1: l2, exponent2: y2, coefficient: new o3(s3) };
      let p2;
      if (void 0 !== Yn.createPrivateKey) {
        p2 = { key: ei.encode(d2, "der"), format: "der", type: "pkcs1", padding: Yn.constants.RSA_PKCS1_PADDING };
      } else {
        p2 = { key: ei.encode(d2, "pem", { label: "RSA PRIVATE KEY" }), padding: Yn.constants.RSA_PKCS1_PADDING };
      }
      try {
        return new Uint8Array(Yn.privateDecrypt(p2, e3));
      } catch (e4) {
        throw Error("Decryption error");
      }
    }(e2, t2, r2, n2, i2, a2, s2);
  } catch (e3) {
    X.printDebugError(e3);
  }
  return async function(e3, t3, r3, n3, i3, a3, s3, o3) {
    const c2 = await X.getBigInteger();
    if (e3 = new c2(e3), t3 = new c2(t3), r3 = new c2(r3), n3 = new c2(n3), i3 = new c2(i3), a3 = new c2(a3), s3 = new c2(s3), e3.gte(t3)) throw Error("Data too large.");
    const h2 = n3.mod(a3.dec()), u2 = n3.mod(i3.dec()), l2 = (await Fn(new c2(2), t3)).mod(t3), y2 = l2.modInv(t3).modExp(r3, t3);
    e3 = e3.mul(y2).mod(t3);
    const d2 = e3.modExp(u2, i3), p2 = e3.modExp(h2, a3), f2 = s3.mul(p2.sub(d2)).mod(a3);
    let g2 = f2.mul(i3).add(d2);
    return g2 = g2.mul(l2).mod(t3), $n(g2.toUint8Array("be", t3.byteLength()), o3);
  }(e2, t2, r2, n2, i2, a2, s2, o2);
}, generate: async function(e2, t2) {
  if (t2 = new (await X.getBigInteger())(t2), X.getWebCrypto()) {
    const r3 = { name: "RSASSA-PKCS1-v1_5", modulusLength: e2, publicExponent: t2.toUint8Array(), hash: { name: "SHA-1" } }, n3 = await Qn.generateKey(r3, true, ["sign", "verify"]), i3 = await Qn.exportKey("jwk", n3.privateKey);
    return { n: re(i3.n), e: t2.toUint8Array(), d: re(i3.d), p: re(i3.q), q: re(i3.p), u: re(i3.qi) };
  }
  if (X.getNodeCrypto() && Yn.generateKeyPair && ei) {
    const r3 = { modulusLength: e2, publicExponent: t2.toNumber(), publicKeyEncoding: { type: "pkcs1", format: "der" }, privateKeyEncoding: { type: "pkcs1", format: "der" } }, n3 = await new Promise((e3, t3) => {
      Yn.generateKeyPair("rsa", r3, (r4, n4, i3) => {
        r4 ? t3(r4) : e3(ei.decode(i3, "der"));
      });
    });
    return { n: n3.modulus.toArrayLike(Uint8Array), e: n3.publicExponent.toArrayLike(Uint8Array), d: n3.privateExponent.toArrayLike(Uint8Array), p: n3.prime2.toArrayLike(Uint8Array), q: n3.prime1.toArrayLike(Uint8Array), u: n3.coefficient.toArrayLike(Uint8Array) };
  }
  let r2, n2, i2;
  do {
    n2 = await jn(e2 - (e2 >> 1), t2, 40), r2 = await jn(e2 >> 1, t2, 40), i2 = r2.mul(n2);
  } while (i2.bitLength() !== e2);
  const a2 = r2.dec().imul(n2.dec());
  return n2.lt(r2) && ([r2, n2] = [n2, r2]), { n: i2.toUint8Array(), e: t2.toUint8Array(), d: t2.modInv(a2).toUint8Array(), p: r2.toUint8Array(), q: n2.toUint8Array(), u: r2.modInv(n2).toUint8Array() };
}, validateParams: async function(e2, t2, r2, n2, i2, a2) {
  const s2 = await X.getBigInteger();
  if (e2 = new s2(e2), n2 = new s2(n2), i2 = new s2(i2), !n2.mul(i2).equal(e2)) return false;
  const o2 = new s2(2);
  if (a2 = new s2(a2), !n2.mul(a2).mod(i2).isOne()) return false;
  t2 = new s2(t2), r2 = new s2(r2);
  const c2 = new s2(Math.floor(e2.bitLength() / 3)), h2 = await Fn(o2, o2.leftShift(c2)), u2 = h2.mul(r2).mul(t2);
  return !(!u2.mod(n2.dec()).equal(h2) || !u2.mod(i2.dec()).equal(h2));
} });
var ni = Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, n2) {
  const i2 = await X.getBigInteger();
  t2 = new i2(t2), r2 = new i2(r2), n2 = new i2(n2);
  const a2 = new i2(Wn(e2, t2.byteLength())), s2 = await Fn(new i2(1), t2.dec());
  return { c1: r2.modExp(s2, t2).toUint8Array(), c2: n2.modExp(s2, t2).imul(a2).imod(t2).toUint8Array() };
}, decrypt: async function(e2, t2, r2, n2, i2) {
  const a2 = await X.getBigInteger();
  return e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), n2 = new a2(n2), $n(e2.modExp(n2, r2).modInv(r2).imul(t2).imod(r2).toUint8Array("be", r2.byteLength()), i2);
}, validateParams: async function(e2, t2, r2, n2) {
  const i2 = await X.getBigInteger();
  e2 = new i2(e2), t2 = new i2(t2), r2 = new i2(r2);
  const a2 = new i2(1);
  if (t2.lte(a2) || t2.gte(e2)) return false;
  const s2 = new i2(e2.bitLength()), o2 = new i2(1023);
  if (s2.lt(o2)) return false;
  if (!t2.modExp(e2.dec(), e2).isOne()) return false;
  let c2 = t2;
  const h2 = new i2(1), u2 = new i2(2).leftShift(new i2(17));
  for (; h2.lt(u2); ) {
    if (c2 = c2.mul(t2).imod(e2), c2.isOne()) return false;
    h2.iinc();
  }
  n2 = new i2(n2);
  const l2 = new i2(2), y2 = await Fn(l2.leftShift(s2.dec()), l2.leftShift(s2)), d2 = e2.dec().imul(y2).iadd(n2);
  return !!r2.equal(t2.modExp(d2, e2));
} });
var ii = class _ii {
  constructor(e2) {
    if (e2 instanceof _ii) this.oid = e2.oid;
    else if (X.isArray(e2) || X.isUint8Array(e2)) {
      if (6 === (e2 = new Uint8Array(e2))[0]) {
        if (e2[1] !== e2.length - 2) throw Error("Length mismatch in DER encoded oid");
        e2 = e2.subarray(2);
      }
      this.oid = e2;
    } else this.oid = "";
  }
  read(e2) {
    if (e2.length >= 1) {
      const t2 = e2[0];
      if (e2.length >= 1 + t2) return this.oid = e2.subarray(1, 1 + t2), 1 + this.oid.length;
    }
    throw Error("Invalid oid");
  }
  write() {
    return X.concatUint8Array([new Uint8Array([this.oid.length]), this.oid]);
  }
  toHex() {
    return X.uint8ArrayToHex(this.oid);
  }
  getName() {
    const e2 = this.toHex();
    if ($.curve[e2]) return $.write($.curve, e2);
    throw Error("Unknown curve object identifier.");
  }
};
function ai(e2, t2) {
  return e2.keyPair({ priv: t2 });
}
function si(e2, t2) {
  const r2 = e2.keyPair({ pub: t2 });
  if (true !== r2.validate().result) throw Error("Invalid elliptic public key");
  return r2;
}
async function oi(e2) {
  if (!ie.useIndutnyElliptic) throw Error("This curve is only supported in the full build of OpenPGP.js");
  const { default: t2 } = await import("./elliptic.min-7CQX7QXZ.js");
  return new t2.ec(e2);
}
function ci(e2) {
  let t2, r2 = 0;
  const n2 = e2[0];
  return n2 < 192 ? ([r2] = e2, t2 = 1) : n2 < 255 ? (r2 = (e2[0] - 192 << 8) + e2[1] + 192, t2 = 2) : 255 === n2 && (r2 = X.readNumber(e2.subarray(1, 5)), t2 = 5), { len: r2, offset: t2 };
}
function hi(e2) {
  return e2 < 192 ? new Uint8Array([e2]) : e2 > 191 && e2 < 8384 ? new Uint8Array([192 + (e2 - 192 >> 8), e2 - 192 & 255]) : X.concatUint8Array([new Uint8Array([255]), X.writeNumber(e2, 4)]);
}
function ui(e2) {
  if (e2 < 0 || e2 > 30) throw Error("Partial Length power must be between 1 and 30");
  return new Uint8Array([224 + e2]);
}
function li(e2) {
  return new Uint8Array([192 | e2]);
}
function yi(e2, t2) {
  return X.concatUint8Array([li(e2), hi(t2)]);
}
function di(e2) {
  return [$.packet.literalData, $.packet.compressedData, $.packet.symmetricallyEncryptedData, $.packet.symEncryptedIntegrityProtectedData, $.packet.aeadEncryptedData].includes(e2);
}
async function pi(e2, t2) {
  const r2 = D(e2);
  let n2, i2;
  try {
    const s2 = await r2.peekBytes(2);
    if (!s2 || s2.length < 2 || 0 == (128 & s2[0])) throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");
    const o2 = await r2.readByte();
    let c2, h2, u2 = -1, l2 = -1;
    l2 = 0, 0 != (64 & o2) && (l2 = 1), l2 ? u2 = 63 & o2 : (u2 = (63 & o2) >> 2, h2 = 3 & o2);
    const y2 = di(u2);
    let d2, p2 = null;
    if (y2) {
      if ("array" === X.isStream(e2)) {
        const e3 = new a();
        n2 = C(e3), p2 = e3;
      } else {
        const e3 = new E();
        n2 = C(e3.writable), p2 = e3.readable;
      }
      i2 = t2({ tag: u2, packet: p2 });
    } else p2 = [];
    do {
      if (l2) {
        const e3 = await r2.readByte();
        if (d2 = false, e3 < 192) c2 = e3;
        else if (e3 >= 192 && e3 < 224) c2 = (e3 - 192 << 8) + await r2.readByte() + 192;
        else if (e3 > 223 && e3 < 255) {
          if (c2 = 1 << (31 & e3), d2 = true, !y2) throw new TypeError("This packet type does not support partial lengths.");
        } else c2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
      } else switch (h2) {
        case 0:
          c2 = await r2.readByte();
          break;
        case 1:
          c2 = await r2.readByte() << 8 | await r2.readByte();
          break;
        case 2:
          c2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
          break;
        default:
          c2 = 1 / 0;
      }
      if (c2 > 0) {
        let e3 = 0;
        for (; ; ) {
          n2 && await n2.ready;
          const { done: t3, value: i3 } = await r2.read();
          if (t3) {
            if (c2 === 1 / 0) break;
            throw Error("Unexpected end of packet");
          }
          const a2 = c2 === 1 / 0 ? i3 : i3.subarray(0, c2 - e3);
          if (n2 ? await n2.write(a2) : p2.push(a2), e3 += i3.length, e3 >= c2) {
            r2.unshift(i3.subarray(c2 - e3 + i3.length));
            break;
          }
        }
      }
    } while (d2);
    const f2 = await r2.peekBytes(y2 ? 1 / 0 : 2);
    return n2 ? (await n2.ready, await n2.close()) : (p2 = X.concatUint8Array(p2), await t2({ tag: u2, packet: p2 })), !f2 || !f2.length;
  } catch (e3) {
    if (n2) return await n2.abort(e3), true;
    throw e3;
  } finally {
    n2 && await i2, r2.releaseLock();
  }
}
var fi = class _fi extends Error {
  constructor(...e2) {
    super(...e2), Error.captureStackTrace && Error.captureStackTrace(this, _fi), this.name = "UnsupportedError";
  }
};
var gi = class {
  constructor(e2, t2) {
    this.tag = e2, this.rawContent = t2;
  }
  write() {
    return this.rawContent;
  }
};
var mi = X.getWebCrypto();
var wi = X.getNodeCrypto();
var bi = { p256: "P-256", p384: "P-384", p521: "P-521" };
var ki = wi ? wi.getCurves() : [];
var vi = wi ? { secp256k1: ki.includes("secp256k1") ? "secp256k1" : void 0, p256: ki.includes("prime256v1") ? "prime256v1" : void 0, p384: ki.includes("secp384r1") ? "secp384r1" : void 0, p521: ki.includes("secp521r1") ? "secp521r1" : void 0, ed25519: ki.includes("ED25519") ? "ED25519" : void 0, curve25519: ki.includes("X25519") ? "X25519" : void 0, brainpoolP256r1: ki.includes("brainpoolP256r1") ? "brainpoolP256r1" : void 0, brainpoolP384r1: ki.includes("brainpoolP384r1") ? "brainpoolP384r1" : void 0, brainpoolP512r1: ki.includes("brainpoolP512r1") ? "brainpoolP512r1" : void 0 } : {};
var Ai = { p256: { oid: [6, 8, 42, 134, 72, 206, 61, 3, 1, 7], keyType: $.publicKey.ecdsa, hash: $.hash.sha256, cipher: $.symmetric.aes128, node: vi.p256, web: bi.p256, payloadSize: 32, sharedSize: 256 }, p384: { oid: [6, 5, 43, 129, 4, 0, 34], keyType: $.publicKey.ecdsa, hash: $.hash.sha384, cipher: $.symmetric.aes192, node: vi.p384, web: bi.p384, payloadSize: 48, sharedSize: 384 }, p521: { oid: [6, 5, 43, 129, 4, 0, 35], keyType: $.publicKey.ecdsa, hash: $.hash.sha512, cipher: $.symmetric.aes256, node: vi.p521, web: bi.p521, payloadSize: 66, sharedSize: 528 }, secp256k1: { oid: [6, 5, 43, 129, 4, 0, 10], keyType: $.publicKey.ecdsa, hash: $.hash.sha256, cipher: $.symmetric.aes128, node: vi.secp256k1, payloadSize: 32 }, ed25519: { oid: [6, 9, 43, 6, 1, 4, 1, 218, 71, 15, 1], keyType: $.publicKey.eddsaLegacy, hash: $.hash.sha512, node: false, payloadSize: 32 }, curve25519: { oid: [6, 10, 43, 6, 1, 4, 1, 151, 85, 1, 5, 1], keyType: $.publicKey.ecdh, hash: $.hash.sha256, cipher: $.symmetric.aes128, node: false, payloadSize: 32 }, brainpoolP256r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 7], keyType: $.publicKey.ecdsa, hash: $.hash.sha256, cipher: $.symmetric.aes128, node: vi.brainpoolP256r1, payloadSize: 32 }, brainpoolP384r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 11], keyType: $.publicKey.ecdsa, hash: $.hash.sha384, cipher: $.symmetric.aes192, node: vi.brainpoolP384r1, payloadSize: 48 }, brainpoolP512r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 13], keyType: $.publicKey.ecdsa, hash: $.hash.sha512, cipher: $.symmetric.aes256, node: vi.brainpoolP512r1, payloadSize: 64 } };
var _i = class {
  constructor(e2, t2) {
    try {
      (X.isArray(e2) || X.isUint8Array(e2)) && (e2 = new ii(e2)), e2 instanceof ii && (e2 = e2.getName()), this.name = $.write($.curve, e2);
    } catch (e3) {
      throw new fi("Unknown curve");
    }
    t2 = t2 || Ai[this.name], this.keyType = t2.keyType, this.oid = t2.oid, this.hash = t2.hash, this.cipher = t2.cipher, this.node = t2.node && Ai[this.name], this.web = t2.web && Ai[this.name], this.payloadSize = t2.payloadSize, this.web && X.getWebCrypto() ? this.type = "web" : this.node && X.getNodeCrypto() ? this.type = "node" : "curve25519" === this.name ? this.type = "curve25519" : "ed25519" === this.name && (this.type = "ed25519");
  }
  async genKeyPair() {
    let e2;
    switch (this.type) {
      case "web":
        try {
          return await async function(e3) {
            const t3 = await mi.generateKey({ name: "ECDSA", namedCurve: bi[e3] }, true, ["sign", "verify"]), r2 = await mi.exportKey("jwk", t3.privateKey), n2 = await mi.exportKey("jwk", t3.publicKey);
            return { publicKey: Si(n2), privateKey: re(r2.d) };
          }(this.name);
        } catch (e3) {
          X.printDebugError("Browser did not support generating ec key " + e3.message);
          break;
        }
      case "node":
        return async function(e3) {
          const t3 = wi.createECDH(vi[e3]);
          return await t3.generateKeys(), { publicKey: new Uint8Array(t3.getPublicKey()), privateKey: new Uint8Array(t3.getPrivateKey()) };
        }(this.name);
      case "curve25519": {
        const t3 = On(32);
        t3[0] = 127 & t3[0] | 64, t3[31] &= 248;
        const r2 = t3.slice().reverse();
        e2 = Ln.box.keyPair.fromSecretKey(r2);
        return { publicKey: X.concatUint8Array([new Uint8Array([64]), e2.publicKey]), privateKey: t3 };
      }
      case "ed25519": {
        const e3 = On(32), t3 = Ln.sign.keyPair.fromSeed(e3);
        return { publicKey: X.concatUint8Array([new Uint8Array([64]), t3.publicKey]), privateKey: e3 };
      }
    }
    const t2 = await oi(this.name);
    return e2 = await t2.genKeyPair({ entropy: X.uint8ArrayToString(On(32)) }), { publicKey: new Uint8Array(e2.getPublic("array", false)), privateKey: e2.getPrivate().toArrayLike(Uint8Array) };
  }
};
async function Ei(e2, t2, r2, n2) {
  const i2 = { p256: true, p384: true, p521: true, secp256k1: true, curve25519: e2 === $.publicKey.ecdh, brainpoolP256r1: true, brainpoolP384r1: true, brainpoolP512r1: true }, a2 = t2.getName();
  if (!i2[a2]) return false;
  if ("curve25519" === a2) {
    n2 = n2.slice().reverse();
    const { publicKey: e3 } = Ln.box.keyPair.fromSecretKey(n2);
    r2 = new Uint8Array(r2);
    const t3 = new Uint8Array([64, ...e3]);
    return !!X.equalsUint8Array(t3, r2);
  }
  const s2 = await oi(a2);
  try {
    r2 = si(s2, r2).getPublic();
  } catch (e3) {
    return false;
  }
  return !!ai(s2, n2).getPublic().eq(r2);
}
function Si(e2) {
  const t2 = re(e2.x), r2 = re(e2.y), n2 = new Uint8Array(t2.length + r2.length + 1);
  return n2[0] = 4, n2.set(t2, 1), n2.set(r2, t2.length + 1), n2;
}
function Ki(e2, t2, r2) {
  const n2 = e2, i2 = r2.slice(1, n2 + 1), a2 = r2.slice(n2 + 1, 2 * n2 + 1);
  return { kty: "EC", crv: t2, x: ne(i2, true), y: ne(a2, true), ext: true };
}
function xi(e2, t2, r2, n2) {
  const i2 = Ki(e2, t2, r2);
  return i2.d = ne(n2, true), i2;
}
var Pi = X.getWebCrypto();
var Ui = X.getNodeCrypto();
async function Di(e2, t2, r2, n2, i2, a2) {
  const s2 = new _i(e2);
  if (r2 && !X.isStream(r2)) {
    const e3 = { publicKey: n2, privateKey: i2 };
    switch (s2.type) {
      case "web":
        try {
          return await async function(e4, t3, r3, n3) {
            const i3 = e4.payloadSize, a3 = xi(e4.payloadSize, bi[e4.name], n3.publicKey, n3.privateKey), s3 = await Pi.importKey("jwk", a3, { name: "ECDSA", namedCurve: bi[e4.name], hash: { name: $.read($.webHash, e4.hash) } }, false, ["sign"]), o2 = new Uint8Array(await Pi.sign({ name: "ECDSA", namedCurve: bi[e4.name], hash: { name: $.read($.webHash, t3) } }, s3, r3));
            return { r: o2.slice(0, i3), s: o2.slice(i3, i3 << 1) };
          }(s2, t2, r2, e3);
        } catch (e4) {
          if ("p521" !== s2.name && ("DataError" === e4.name || "OperationError" === e4.name)) throw e4;
          X.printDebugError("Browser did not support signing: " + e4.message);
        }
        break;
      case "node": {
        const n3 = await async function(e4, t3, r3, n4) {
          const i3 = Ui.createSign($.read($.hash, t3));
          i3.write(r3), i3.end();
          const a3 = Bi.encode({ version: 1, parameters: e4.oid, privateKey: Array.from(n4.privateKey), publicKey: { unused: 0, data: Array.from(n4.publicKey) } }, "pem", { label: "EC PRIVATE KEY" });
          return Ti.decode(i3.sign(a3), "der");
        }(s2, t2, r2, e3);
        return { r: n3.r.toArrayLike(Uint8Array), s: n3.s.toArrayLike(Uint8Array) };
      }
    }
  }
  return async function(e3, t3, r3) {
    const n3 = await oi(e3.name), i3 = ai(n3, r3), a3 = i3.sign(t3);
    return { r: a3.r.toArrayLike(Uint8Array), s: a3.s.toArrayLike(Uint8Array) };
  }(s2, a2, i2);
}
async function Ci(e2, t2, r2, n2, i2, a2) {
  const s2 = new _i(e2);
  if (n2 && !X.isStream(n2)) switch (s2.type) {
    case "web":
      try {
        return await async function(e3, t3, { r: r3, s: n3 }, i3, a3) {
          const s3 = Ki(e3.payloadSize, bi[e3.name], a3), o2 = await Pi.importKey("jwk", s3, { name: "ECDSA", namedCurve: bi[e3.name], hash: { name: $.read($.webHash, e3.hash) } }, false, ["verify"]), c2 = X.concatUint8Array([r3, n3]).buffer;
          return Pi.verify({ name: "ECDSA", namedCurve: bi[e3.name], hash: { name: $.read($.webHash, t3) } }, o2, c2, i3);
        }(s2, t2, r2, n2, i2);
      } catch (e3) {
        if ("p521" !== s2.name && ("DataError" === e3.name || "OperationError" === e3.name)) throw e3;
        X.printDebugError("Browser did not support verifying: " + e3.message);
      }
      break;
    case "node":
      return async function(e3, t3, { r: r3, s: n3 }, i3, a3) {
        const { default: s3 } = await import("./bn.min-PK2PZJFG.js"), o2 = Ui.createVerify($.read($.hash, t3));
        o2.write(i3), o2.end();
        const c2 = Ri.encode({ algorithm: { algorithm: [1, 2, 840, 10045, 2, 1], parameters: e3.oid }, subjectPublicKey: { unused: 0, data: Array.from(a3) } }, "pem", { label: "PUBLIC KEY" }), h2 = Ti.encode({ r: new s3(r3), s: new s3(n3) }, "der");
        try {
          return o2.verify(c2, h2);
        } catch (e4) {
          return false;
        }
      }(s2, t2, r2, n2, i2);
  }
  return async function(e3, t3, r3, n3) {
    const i3 = await oi(e3.name), a3 = si(i3, n3);
    return a3.verify(r3, t3);
  }(s2, r2, void 0 === t2 ? n2 : a2, i2);
}
var Ii = void 0;
var Ti = Ui ? Ii.define("ECDSASignature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
}) : void 0;
var Bi = Ui ? Ii.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).optional().any(), this.key("publicKey").explicit(1).optional().bitstr());
}) : void 0;
var zi = Ui ? Ii.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
}) : void 0;
var Ri = Ui ? Ii.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(zi), this.key("subjectPublicKey").bitstr());
}) : void 0;
var Mi = Object.freeze({ __proto__: null, sign: Di, verify: Ci, validateParams: async function(e2, t2, r2) {
  const n2 = new _i(e2);
  if (n2.keyType !== $.publicKey.ecdsa) return false;
  switch (n2.type) {
    case "web":
    case "node": {
      const n3 = On(8), i2 = $.hash.sha256, a2 = await Gr.digest(i2, n3);
      try {
        const s2 = await Di(e2, i2, n3, t2, r2, a2);
        return await Ci(e2, i2, s2, n3, t2, a2);
      } catch (e3) {
        return false;
      }
    }
    default:
      return Ei($.publicKey.ecdsa, e2, t2, r2);
  }
} });
Ln.hash = (e2) => new Uint8Array(Yt().update(e2).digest());
var Li = Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, n2, i2, a2) {
  if (Gr.getHashByteLength(t2) < Gr.getHashByteLength($.hash.sha256)) throw Error("Hash algorithm too weak for EdDSA.");
  const s2 = X.concatUint8Array([i2, n2.subarray(1)]), o2 = Ln.sign.detached(a2, s2);
  return { r: o2.subarray(0, 32), s: o2.subarray(32) };
}, verify: async function(e2, t2, { r: r2, s: n2 }, i2, a2, s2) {
  if (Gr.getHashByteLength(t2) < Gr.getHashByteLength($.hash.sha256)) throw Error("Hash algorithm too weak for EdDSA.");
  const o2 = X.concatUint8Array([r2, n2]);
  return Ln.sign.detached.verify(s2, o2, a2.subarray(1));
}, validateParams: async function(e2, t2, r2) {
  if ("ed25519" !== e2.getName()) return false;
  const { publicKey: n2 } = Ln.sign.keyPair.fromSeed(r2), i2 = new Uint8Array([64, ...n2]);
  return X.equalsUint8Array(t2, i2);
} });
function Ni(e2) {
  if (e2 === $.publicKey.ed25519) return $.hash.sha256;
  throw Error("Unknown EdDSA algo");
}
Ln.hash = (e2) => new Uint8Array(Yt().update(e2).digest());
var Oi = Object.freeze({ __proto__: null, generate: async function(e2) {
  if (e2 === $.publicKey.ed25519) {
    const e3 = On(32), { publicKey: t2 } = Ln.sign.keyPair.fromSeed(e3);
    return { A: t2, seed: e3 };
  }
  throw Error("Unsupported EdDSA algorithm");
}, sign: async function(e2, t2, r2, n2, i2, a2) {
  if (Gr.getHashByteLength(t2) < Gr.getHashByteLength(Ni(e2))) throw Error("Hash algorithm too weak for EdDSA.");
  switch (e2) {
    case $.publicKey.ed25519: {
      const e3 = X.concatUint8Array([i2, n2]);
      return { RS: Ln.sign.detached(a2, e3) };
    }
    case $.publicKey.ed448:
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}, verify: async function(e2, t2, { RS: r2 }, n2, i2, a2) {
  if (Gr.getHashByteLength(t2) < Gr.getHashByteLength(Ni(e2))) throw Error("Hash algorithm too weak for EdDSA.");
  switch (e2) {
    case $.publicKey.ed25519:
      return Ln.sign.detached.verify(a2, r2, i2);
    case $.publicKey.ed448:
    default:
      throw Error("Unsupported EdDSA algorithm");
  }
}, validateParams: async function(e2, t2, r2) {
  switch (e2) {
    case $.publicKey.ed25519: {
      const { publicKey: e3 } = Ln.sign.keyPair.fromSeed(r2);
      return X.equalsUint8Array(t2, e3);
    }
    case $.publicKey.ed448:
    default:
      return false;
  }
}, getPreferredHashAlgo: Ni });
function Fi(e2, t2) {
  const r2 = new qe["aes" + 8 * e2.length](e2), n2 = new Uint32Array([2795939494, 2795939494]), i2 = ji(t2);
  let a2 = n2;
  const s2 = i2, o2 = i2.length / 2, c2 = new Uint32Array([0, 0]);
  let h2 = new Uint32Array(4);
  for (let e3 = 0; e3 <= 5; ++e3) for (let t3 = 0; t3 < o2; ++t3) c2[1] = o2 * e3 + (1 + t3), h2[0] = a2[0], h2[1] = a2[1], h2[2] = s2[2 * t3], h2[3] = s2[2 * t3 + 1], h2 = ji(r2.encrypt(qi(h2))), a2 = h2.subarray(0, 2), a2[0] ^= c2[0], a2[1] ^= c2[1], s2[2 * t3] = h2[2], s2[2 * t3 + 1] = h2[3];
  return qi(a2, s2);
}
function Hi(e2, t2) {
  const r2 = new qe["aes" + 8 * e2.length](e2), n2 = new Uint32Array([2795939494, 2795939494]), i2 = ji(t2);
  let a2 = i2.subarray(0, 2);
  const s2 = i2.subarray(2), o2 = i2.length / 2 - 1, c2 = new Uint32Array([0, 0]);
  let h2 = new Uint32Array(4);
  for (let e3 = 5; e3 >= 0; --e3) for (let t3 = o2 - 1; t3 >= 0; --t3) c2[1] = o2 * e3 + (t3 + 1), h2[0] = a2[0] ^ c2[0], h2[1] = a2[1] ^ c2[1], h2[2] = s2[2 * t3], h2[3] = s2[2 * t3 + 1], h2 = ji(r2.decrypt(qi(h2))), a2 = h2.subarray(0, 2), s2[2 * t3] = h2[2], s2[2 * t3 + 1] = h2[3];
  if (a2[0] === n2[0] && a2[1] === n2[1]) return qi(s2);
  throw Error("Key Data Integrity failed");
}
function ji(e2) {
  const { length: t2 } = e2, r2 = function(e3) {
    if (X.isString(e3)) {
      const { length: t3 } = e3, r3 = new ArrayBuffer(t3), n3 = new Uint8Array(r3);
      for (let r4 = 0; r4 < t3; ++r4) n3[r4] = e3.charCodeAt(r4);
      return r3;
    }
    return new Uint8Array(e3).buffer;
  }(e2), n2 = new DataView(r2), i2 = new Uint32Array(t2 / 4);
  for (let e3 = 0; e3 < t2 / 4; ++e3) i2[e3] = n2.getUint32(4 * e3);
  return i2;
}
function qi() {
  let e2 = 0;
  for (let t3 = 0; t3 < arguments.length; ++t3) e2 += 4 * arguments[t3].length;
  const t2 = new ArrayBuffer(e2), r2 = new DataView(t2);
  let n2 = 0;
  for (let e3 = 0; e3 < arguments.length; ++e3) {
    for (let t3 = 0; t3 < arguments[e3].length; ++t3) r2.setUint32(n2 + 4 * t3, arguments[e3][t3]);
    n2 += 4 * arguments[e3].length;
  }
  return new Uint8Array(t2);
}
var Gi = Object.freeze({ __proto__: null, wrap: Fi, unwrap: Hi });
function Vi(e2) {
  const t2 = 8 - e2.length % 8, r2 = new Uint8Array(e2.length + t2).fill(t2);
  return r2.set(e2), r2;
}
function Wi(e2) {
  const t2 = e2.length;
  if (t2 > 0) {
    const r2 = e2[t2 - 1];
    if (r2 >= 1) {
      const n2 = e2.subarray(t2 - r2), i2 = new Uint8Array(r2).fill(r2);
      if (X.equalsUint8Array(n2, i2)) return e2.subarray(0, t2 - r2);
    }
  }
  throw Error("Invalid padding");
}
var $i = Object.freeze({ __proto__: null, encode: Vi, decode: Wi });
var Zi = X.getWebCrypto();
var Xi = X.getNodeCrypto();
function Qi(e2, t2, r2, n2) {
  return X.concatUint8Array([t2.write(), new Uint8Array([e2]), r2.write(), X.stringToUint8Array("Anonymous Sender    "), n2.subarray(0, 20)]);
}
async function Yi(e2, t2, r2, n2, i2 = false, a2 = false) {
  let s2;
  if (i2) {
    for (s2 = 0; s2 < t2.length && 0 === t2[s2]; s2++) ;
    t2 = t2.subarray(s2);
  }
  if (a2) {
    for (s2 = t2.length - 1; s2 >= 0 && 0 === t2[s2]; s2--) ;
    t2 = t2.subarray(0, s2 + 1);
  }
  return (await Gr.digest(e2, X.concatUint8Array([new Uint8Array([0, 0, 0, 1]), t2, n2]))).subarray(0, r2);
}
async function Ji(e2, t2) {
  switch (e2.type) {
    case "curve25519": {
      const r2 = On(32), { secretKey: n2, sharedKey: i2 } = await ea(e2, t2, null, r2);
      let { publicKey: a2 } = Ln.box.keyPair.fromSecretKey(n2);
      return a2 = X.concatUint8Array([new Uint8Array([64]), a2]), { publicKey: a2, sharedKey: i2 };
    }
    case "web":
      if (e2.web && X.getWebCrypto()) try {
        return await async function(e3, t3) {
          const r2 = Ki(e3.payloadSize, e3.web.web, t3);
          let n2 = Zi.generateKey({ name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]), i2 = Zi.importKey("jwk", r2, { name: "ECDH", namedCurve: e3.web.web }, false, []);
          [n2, i2] = await Promise.all([n2, i2]);
          let a2 = Zi.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: i2 }, n2.privateKey, e3.web.sharedSize), s2 = Zi.exportKey("jwk", n2.publicKey);
          [a2, s2] = await Promise.all([a2, s2]);
          const o2 = new Uint8Array(a2), c2 = new Uint8Array(Si(s2));
          return { publicKey: c2, sharedKey: o2 };
        }(e2, t2);
      } catch (e3) {
        X.printDebugError(e3);
      }
      break;
    case "node":
      return async function(e3, t3) {
        const r2 = Xi.createECDH(e3.node.node);
        r2.generateKeys();
        const n2 = new Uint8Array(r2.computeSecret(t3)), i2 = new Uint8Array(r2.getPublicKey());
        return { publicKey: i2, sharedKey: n2 };
      }(e2, t2);
  }
  return async function(e3, t3) {
    const r2 = await oi(e3.name), n2 = await e3.genKeyPair();
    t3 = si(r2, t3);
    const i2 = ai(r2, n2.privateKey), a2 = n2.publicKey, s2 = i2.derive(t3.getPublic()), o2 = r2.curve.p.byteLength(), c2 = s2.toArrayLike(Uint8Array, "be", o2);
    return { publicKey: a2, sharedKey: c2 };
  }(e2, t2);
}
async function ea(e2, t2, r2, n2) {
  if (n2.length !== e2.payloadSize) {
    const t3 = new Uint8Array(e2.payloadSize);
    t3.set(n2, e2.payloadSize - n2.length), n2 = t3;
  }
  switch (e2.type) {
    case "curve25519": {
      const e3 = n2.slice().reverse();
      return { secretKey: e3, sharedKey: Ln.scalarMult(e3, t2.subarray(1)) };
    }
    case "web":
      if (e2.web && X.getWebCrypto()) try {
        return await async function(e3, t3, r3, n3) {
          const i2 = xi(e3.payloadSize, e3.web.web, r3, n3);
          let a2 = Zi.importKey("jwk", i2, { name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]);
          const s2 = Ki(e3.payloadSize, e3.web.web, t3);
          let o2 = Zi.importKey("jwk", s2, { name: "ECDH", namedCurve: e3.web.web }, true, []);
          [a2, o2] = await Promise.all([a2, o2]);
          let c2 = Zi.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: o2 }, a2, e3.web.sharedSize), h2 = Zi.exportKey("jwk", a2);
          [c2, h2] = await Promise.all([c2, h2]);
          const u2 = new Uint8Array(c2);
          return { secretKey: re(h2.d), sharedKey: u2 };
        }(e2, t2, r2, n2);
      } catch (e3) {
        X.printDebugError(e3);
      }
      break;
    case "node":
      return async function(e3, t3, r3) {
        const n3 = Xi.createECDH(e3.node.node);
        n3.setPrivateKey(r3);
        const i2 = new Uint8Array(n3.computeSecret(t3));
        return { secretKey: new Uint8Array(n3.getPrivateKey()), sharedKey: i2 };
      }(e2, t2, n2);
  }
  return async function(e3, t3, r3) {
    const n3 = await oi(e3.name);
    t3 = si(n3, t3), r3 = ai(n3, r3);
    const i2 = new Uint8Array(r3.getPrivate()), a2 = r3.derive(t3.getPublic()), s2 = n3.curve.p.byteLength(), o2 = a2.toArrayLike(Uint8Array, "be", s2);
    return { secretKey: i2, sharedKey: o2 };
  }(e2, t2, n2);
}
var ta = Object.freeze({ __proto__: null, validateParams: async function(e2, t2, r2) {
  return Ei($.publicKey.ecdh, e2, t2, r2);
}, encrypt: async function(e2, t2, r2, n2, i2) {
  const a2 = Vi(r2), s2 = new _i(e2), { publicKey: o2, sharedKey: c2 } = await Ji(s2, n2), h2 = Qi($.publicKey.ecdh, e2, t2, i2), { keySize: u2 } = Wr(t2.cipher);
  return { publicKey: o2, wrappedKey: Fi(await Yi(t2.hash, c2, u2, h2), a2) };
}, decrypt: async function(e2, t2, r2, n2, i2, a2, s2) {
  const o2 = new _i(e2), { sharedKey: c2 } = await ea(o2, r2, i2, a2), h2 = Qi($.publicKey.ecdh, e2, t2, s2), { keySize: u2 } = Wr(t2.cipher);
  let l2;
  for (let e3 = 0; e3 < 3; e3++) try {
    return Wi(Hi(await Yi(t2.hash, c2, u2, h2, 1 === e3, 2 === e3), n2));
  } catch (e4) {
    l2 = e4;
  }
  throw l2;
} });
var ra = X.getWebCrypto();
var na = X.getNodeCrypto();
var ia = na && na.webcrypto && na.webcrypto.subtle;
async function aa(e2, t2, r2, n2, i2) {
  const a2 = $.read($.webHash, e2);
  if (!a2) throw Error("Hash algo not supported with HKDF");
  if (ra || ia) {
    const e3 = ra || ia, s2 = await e3.importKey("raw", t2, "HKDF", false, ["deriveBits"]), o2 = await e3.deriveBits({ name: "HKDF", hash: a2, salt: r2, info: n2 }, s2, 8 * i2);
    return new Uint8Array(o2);
  }
  if (na) {
    const a3 = $.read($.hash, e2), s2 = (e3, t3) => na.createHmac(a3, e3).update(t3).digest(), o2 = s2(r2, t2), c2 = o2.length, h2 = Math.ceil(i2 / c2), u2 = new Uint8Array(h2 * c2), l2 = new Uint8Array(c2 + n2.length + 1);
    l2.set(n2, c2);
    for (let e3 = 0; e3 < h2; e3++) {
      l2[l2.length - 1] = e3 + 1;
      const t3 = s2(o2, e3 > 0 ? l2 : l2.subarray(c2));
      l2.set(t3, 0), u2.set(t3, e3 * c2);
    }
    return u2.subarray(0, i2);
  }
  throw Error("No HKDF implementation available");
}
var sa = { x25519: X.encodeUTF8("OpenPGP X25519") };
var oa = Object.freeze({ __proto__: null, generate: async function(e2) {
  if (e2 === $.publicKey.x25519) {
    const e3 = On(32), { publicKey: t2 } = Ln.box.keyPair.fromSecretKey(e3);
    return { A: t2, k: e3 };
  }
  throw Error("Unsupported ECDH algorithm");
}, validateParams: async function(e2, t2, r2) {
  if (e2 === $.publicKey.x25519) {
    const { publicKey: e3 } = Ln.box.keyPair.fromSecretKey(r2);
    return X.equalsUint8Array(t2, e3);
  }
  return false;
}, encrypt: async function(e2, t2, r2) {
  if (e2 === $.publicKey.x25519) {
    const e3 = On(32), n2 = Ln.scalarMult(e3, r2), { publicKey: i2 } = Ln.box.keyPair.fromSecretKey(e3), a2 = X.concatUint8Array([i2, r2, n2]), { keySize: s2 } = Wr($.symmetric.aes128);
    return { ephemeralPublicKey: i2, wrappedKey: Fi(await aa($.hash.sha256, a2, new Uint8Array(), sa.x25519, s2), t2) };
  }
  throw Error("Unsupported ECDH algorithm");
}, decrypt: async function(e2, t2, r2, n2, i2) {
  if (e2 === $.publicKey.x25519) {
    const e3 = Ln.scalarMult(i2, t2), a2 = X.concatUint8Array([t2, n2, e3]), { keySize: s2 } = Wr($.symmetric.aes128);
    return Hi(await aa($.hash.sha256, a2, new Uint8Array(), sa.x25519, s2), r2);
  }
  throw Error("Unsupported ECDH algorithm");
} });
var ca = Object.freeze({ __proto__: null, CurveWithOID: _i, ecdh: ta, ecdhX: oa, ecdsa: Mi, eddsaLegacy: Li, eddsa: Oi, generate: async function(e2) {
  const t2 = await X.getBigInteger();
  e2 = new _i(e2);
  const r2 = await e2.genKeyPair(), n2 = new t2(r2.publicKey).toUint8Array(), i2 = new t2(r2.privateKey).toUint8Array("be", e2.payloadSize);
  return { oid: e2.oid, Q: n2, secret: i2, hash: e2.hash, cipher: e2.cipher };
}, getPreferredHashAlgo: function(e2) {
  return Ai[$.write($.curve, e2.toHex())].hash;
} });
var ha = Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, n2, i2, a2) {
  const s2 = await X.getBigInteger(), o2 = new s2(1);
  let c2, h2, u2, l2;
  n2 = new s2(n2), i2 = new s2(i2), r2 = new s2(r2), a2 = new s2(a2), r2 = r2.mod(n2), a2 = a2.mod(i2);
  const y2 = new s2(t2.subarray(0, i2.byteLength())).mod(i2);
  for (; ; ) {
    if (c2 = await Fn(o2, i2), h2 = r2.modExp(c2, n2).imod(i2), h2.isZero()) continue;
    const e3 = a2.mul(h2).imod(i2);
    if (l2 = y2.add(e3).imod(i2), u2 = c2.modInv(i2).imul(l2).imod(i2), !u2.isZero()) break;
  }
  return { r: h2.toUint8Array("be", i2.byteLength()), s: u2.toUint8Array("be", i2.byteLength()) };
}, verify: async function(e2, t2, r2, n2, i2, a2, s2, o2) {
  const c2 = await X.getBigInteger(), h2 = new c2(0);
  if (t2 = new c2(t2), r2 = new c2(r2), a2 = new c2(a2), s2 = new c2(s2), i2 = new c2(i2), o2 = new c2(o2), t2.lte(h2) || t2.gte(s2) || r2.lte(h2) || r2.gte(s2)) return X.printDebug("invalid DSA Signature"), false;
  const u2 = new c2(n2.subarray(0, s2.byteLength())).imod(s2), l2 = r2.modInv(s2);
  if (l2.isZero()) return X.printDebug("invalid DSA Signature"), false;
  i2 = i2.mod(a2), o2 = o2.mod(a2);
  const y2 = u2.mul(l2).imod(s2), d2 = t2.mul(l2).imod(s2), p2 = i2.modExp(y2, a2), f2 = o2.modExp(d2, a2);
  return p2.mul(f2).imod(a2).imod(s2).equal(t2);
}, validateParams: async function(e2, t2, r2, n2, i2) {
  const a2 = await X.getBigInteger();
  e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), n2 = new a2(n2);
  const s2 = new a2(1);
  if (r2.lte(s2) || r2.gte(e2)) return false;
  if (!e2.dec().mod(t2).isZero()) return false;
  if (!r2.modExp(t2, e2).isOne()) return false;
  const o2 = new a2(t2.bitLength()), c2 = new a2(150);
  if (o2.lt(c2) || !await qn(t2, null, 32)) return false;
  i2 = new a2(i2);
  const h2 = new a2(2), u2 = await Fn(h2.leftShift(o2.dec()), h2.leftShift(o2)), l2 = t2.mul(u2).add(i2);
  return !!n2.equal(r2.modExp(l2, e2));
} });
var ua = { rsa: ri, elgamal: ni, elliptic: ca, dsa: ha, nacl: Ln };
var la = Object.freeze({ __proto__: null, parseSignatureParams: function(e2, t2) {
  let r2 = 0;
  switch (e2) {
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaSign:
      return { s: X.readMPI(t2.subarray(r2)) };
    case $.publicKey.dsa:
    case $.publicKey.ecdsa: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      return { r: e3, s: X.readMPI(t2.subarray(r2)) };
    }
    case $.publicKey.eddsaLegacy: {
      let e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2, e3 = X.leftPad(e3, 32);
      let n2 = X.readMPI(t2.subarray(r2));
      return n2 = X.leftPad(n2, 32), { r: e3, s: n2 };
    }
    case $.publicKey.ed25519: {
      const e3 = t2.subarray(r2, r2 + 64);
      return r2 += e3.length, { RS: e3 };
    }
    default:
      throw new fi("Unknown signature algorithm.");
  }
}, verify: async function(e2, t2, r2, n2, i2, a2) {
  switch (e2) {
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaSign: {
      const { n: e3, e: s2 } = n2, o2 = X.leftPad(r2.s, e3.length);
      return ua.rsa.verify(t2, i2, o2, e3, s2, a2);
    }
    case $.publicKey.dsa: {
      const { g: e3, p: i3, q: s2, y: o2 } = n2, { r: c2, s: h2 } = r2;
      return ua.dsa.verify(t2, c2, h2, a2, e3, i3, s2, o2);
    }
    case $.publicKey.ecdsa: {
      const { oid: e3, Q: s2 } = n2, o2 = new ua.elliptic.CurveWithOID(e3).payloadSize, c2 = X.leftPad(r2.r, o2), h2 = X.leftPad(r2.s, o2);
      return ua.elliptic.ecdsa.verify(e3, t2, { r: c2, s: h2 }, i2, s2, a2);
    }
    case $.publicKey.eddsaLegacy: {
      const { oid: e3, Q: s2 } = n2;
      return ua.elliptic.eddsaLegacy.verify(e3, t2, r2, i2, s2, a2);
    }
    case $.publicKey.ed25519: {
      const { A: s2 } = n2;
      return ua.elliptic.eddsa.verify(e2, t2, r2, i2, s2, a2);
    }
    default:
      throw Error("Unknown signature algorithm.");
  }
}, sign: async function(e2, t2, r2, n2, i2, a2) {
  if (!r2 || !n2) throw Error("Missing key parameters");
  switch (e2) {
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaSign: {
      const { n: e3, e: s2 } = r2, { d: o2, p: c2, q: h2, u: u2 } = n2;
      return { s: await ua.rsa.sign(t2, i2, e3, s2, o2, c2, h2, u2, a2) };
    }
    case $.publicKey.dsa: {
      const { g: e3, p: i3, q: s2 } = r2, { x: o2 } = n2;
      return ua.dsa.sign(t2, a2, e3, i3, s2, o2);
    }
    case $.publicKey.elgamal:
      throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");
    case $.publicKey.ecdsa: {
      const { oid: e3, Q: s2 } = r2, { d: o2 } = n2;
      return ua.elliptic.ecdsa.sign(e3, t2, i2, s2, o2, a2);
    }
    case $.publicKey.eddsaLegacy: {
      const { oid: e3, Q: s2 } = r2, { seed: o2 } = n2;
      return ua.elliptic.eddsaLegacy.sign(e3, t2, i2, s2, o2, a2);
    }
    case $.publicKey.ed25519: {
      const { A: s2 } = r2, { seed: o2 } = n2;
      return ua.elliptic.eddsa.sign(e2, t2, i2, s2, o2, a2);
    }
    default:
      throw Error("Unknown signature algorithm.");
  }
} });
var ya = class {
  constructor(e2) {
    e2 && (this.data = e2);
  }
  read(e2) {
    if (e2.length >= 1) {
      const t2 = e2[0];
      if (e2.length >= 1 + t2) return this.data = e2.subarray(1, 1 + t2), 1 + this.data.length;
    }
    throw Error("Invalid symmetric key");
  }
  write() {
    return X.concatUint8Array([new Uint8Array([this.data.length]), this.data]);
  }
};
var da = class {
  constructor(e2) {
    if (e2) {
      const { hash: t2, cipher: r2 } = e2;
      this.hash = t2, this.cipher = r2;
    } else this.hash = null, this.cipher = null;
  }
  read(e2) {
    if (e2.length < 4 || 3 !== e2[0] || 1 !== e2[1]) throw new fi("Cannot read KDFParams");
    return this.hash = e2[2], this.cipher = e2[3], 4;
  }
  write() {
    return new Uint8Array([3, 1, this.hash, this.cipher]);
  }
};
var pa = class _pa {
  static fromObject({ wrappedKey: e2, algorithm: t2 }) {
    const r2 = new _pa();
    return r2.wrappedKey = e2, r2.algorithm = t2, r2;
  }
  read(e2) {
    let t2 = 0, r2 = e2[t2++];
    this.algorithm = r2 % 2 ? e2[t2++] : null, r2 -= r2 % 2, this.wrappedKey = e2.subarray(t2, t2 + r2), t2 += r2;
  }
  write() {
    return X.concatUint8Array([this.algorithm ? new Uint8Array([this.wrappedKey.length + 1, this.algorithm]) : new Uint8Array([this.wrappedKey.length]), this.wrappedKey]);
  }
};
function fa(e2) {
  try {
    e2.getName();
  } catch (e3) {
    throw new fi("Unknown curve OID");
  }
}
var ga = Object.freeze({ __proto__: null, publicKeyEncrypt: async function(e2, t2, r2, n2, i2) {
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign: {
      const { n: e3, e: t3 } = r2;
      return { c: await ua.rsa.encrypt(n2, e3, t3) };
    }
    case $.publicKey.elgamal: {
      const { p: e3, g: t3, y: i3 } = r2;
      return ua.elgamal.encrypt(n2, e3, t3, i3);
    }
    case $.publicKey.ecdh: {
      const { oid: e3, Q: t3, kdfParams: a2 } = r2, { publicKey: s2, wrappedKey: o2 } = await ua.elliptic.ecdh.encrypt(e3, a2, n2, t3, i2);
      return { V: s2, C: new ya(o2) };
    }
    case $.publicKey.x25519: {
      if (!X.isAES(t2)) throw Error("X25519 keys can only encrypt AES session keys");
      const { A: i3 } = r2, { ephemeralPublicKey: a2, wrappedKey: s2 } = await ua.elliptic.ecdhX.encrypt(e2, n2, i3);
      return { ephemeralPublicKey: a2, C: pa.fromObject({ algorithm: t2, wrappedKey: s2 }) };
    }
    default:
      return [];
  }
}, publicKeyDecrypt: async function(e2, t2, r2, n2, i2, a2) {
  switch (e2) {
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaEncrypt: {
      const { c: e3 } = n2, { n: i3, e: s2 } = t2, { d: o2, p: c2, q: h2, u: u2 } = r2;
      return ua.rsa.decrypt(e3, i3, s2, o2, c2, h2, u2, a2);
    }
    case $.publicKey.elgamal: {
      const { c1: e3, c2: i3 } = n2, s2 = t2.p, o2 = r2.x;
      return ua.elgamal.decrypt(e3, i3, s2, o2, a2);
    }
    case $.publicKey.ecdh: {
      const { oid: e3, Q: a3, kdfParams: s2 } = t2, { d: o2 } = r2, { V: c2, C: h2 } = n2;
      return ua.elliptic.ecdh.decrypt(e3, s2, c2, h2.data, a3, o2, i2);
    }
    case $.publicKey.x25519: {
      const { A: i3 } = t2, { k: a3 } = r2, { ephemeralPublicKey: s2, C: o2 } = n2;
      if (!X.isAES(o2.algorithm)) throw Error("AES session key expected");
      return ua.elliptic.ecdhX.decrypt(e2, s2, o2.wrappedKey, i3, a3);
    }
    default:
      throw Error("Unknown public key encryption algorithm.");
  }
}, parsePublicKeyParams: function(e2, t2) {
  let r2 = 0;
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaSign: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      const n2 = X.readMPI(t2.subarray(r2));
      return r2 += n2.length + 2, { read: r2, publicParams: { n: e3, e: n2 } };
    }
    case $.publicKey.dsa: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      const n2 = X.readMPI(t2.subarray(r2));
      r2 += n2.length + 2;
      const i2 = X.readMPI(t2.subarray(r2));
      r2 += i2.length + 2;
      const a2 = X.readMPI(t2.subarray(r2));
      return r2 += a2.length + 2, { read: r2, publicParams: { p: e3, q: n2, g: i2, y: a2 } };
    }
    case $.publicKey.elgamal: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      const n2 = X.readMPI(t2.subarray(r2));
      r2 += n2.length + 2;
      const i2 = X.readMPI(t2.subarray(r2));
      return r2 += i2.length + 2, { read: r2, publicParams: { p: e3, g: n2, y: i2 } };
    }
    case $.publicKey.ecdsa: {
      const e3 = new ii();
      r2 += e3.read(t2), fa(e3);
      const n2 = X.readMPI(t2.subarray(r2));
      return r2 += n2.length + 2, { read: r2, publicParams: { oid: e3, Q: n2 } };
    }
    case $.publicKey.eddsaLegacy: {
      const e3 = new ii();
      r2 += e3.read(t2), fa(e3);
      let n2 = X.readMPI(t2.subarray(r2));
      return r2 += n2.length + 2, n2 = X.leftPad(n2, 33), { read: r2, publicParams: { oid: e3, Q: n2 } };
    }
    case $.publicKey.ecdh: {
      const e3 = new ii();
      r2 += e3.read(t2), fa(e3);
      const n2 = X.readMPI(t2.subarray(r2));
      r2 += n2.length + 2;
      const i2 = new da();
      return r2 += i2.read(t2.subarray(r2)), { read: r2, publicParams: { oid: e3, Q: n2, kdfParams: i2 } };
    }
    case $.publicKey.ed25519:
    case $.publicKey.x25519: {
      const e3 = t2.subarray(r2, r2 + 32);
      return r2 += e3.length, { read: r2, publicParams: { A: e3 } };
    }
    default:
      throw new fi("Unknown public key encryption algorithm.");
  }
}, parsePrivateKeyParams: function(e2, t2, r2) {
  let n2 = 0;
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaSign: {
      const e3 = X.readMPI(t2.subarray(n2));
      n2 += e3.length + 2;
      const r3 = X.readMPI(t2.subarray(n2));
      n2 += r3.length + 2;
      const i2 = X.readMPI(t2.subarray(n2));
      n2 += i2.length + 2;
      const a2 = X.readMPI(t2.subarray(n2));
      return n2 += a2.length + 2, { read: n2, privateParams: { d: e3, p: r3, q: i2, u: a2 } };
    }
    case $.publicKey.dsa:
    case $.publicKey.elgamal: {
      const e3 = X.readMPI(t2.subarray(n2));
      return n2 += e3.length + 2, { read: n2, privateParams: { x: e3 } };
    }
    case $.publicKey.ecdsa:
    case $.publicKey.ecdh: {
      const e3 = new _i(r2.oid);
      let i2 = X.readMPI(t2.subarray(n2));
      return n2 += i2.length + 2, i2 = X.leftPad(i2, e3.payloadSize), { read: n2, privateParams: { d: i2 } };
    }
    case $.publicKey.eddsaLegacy: {
      const e3 = new _i(r2.oid);
      let i2 = X.readMPI(t2.subarray(n2));
      return n2 += i2.length + 2, i2 = X.leftPad(i2, e3.payloadSize), { read: n2, privateParams: { seed: i2 } };
    }
    case $.publicKey.ed25519: {
      const e3 = t2.subarray(n2, n2 + 32);
      return n2 += e3.length, { read: n2, privateParams: { seed: e3 } };
    }
    case $.publicKey.x25519: {
      const e3 = t2.subarray(n2, n2 + 32);
      return n2 += e3.length, { read: n2, privateParams: { k: e3 } };
    }
    default:
      throw new fi("Unknown public key encryption algorithm.");
  }
}, parseEncSessionKeyParams: function(e2, t2) {
  let r2 = 0;
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
      return { c: X.readMPI(t2.subarray(r2)) };
    case $.publicKey.elgamal: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      return { c1: e3, c2: X.readMPI(t2.subarray(r2)) };
    }
    case $.publicKey.ecdh: {
      const e3 = X.readMPI(t2.subarray(r2));
      r2 += e3.length + 2;
      const n2 = new ya();
      return n2.read(t2.subarray(r2)), { V: e3, C: n2 };
    }
    case $.publicKey.x25519: {
      const e3 = t2.subarray(r2, r2 + 32);
      r2 += e3.length;
      const n2 = new pa();
      return n2.read(t2.subarray(r2)), { ephemeralPublicKey: e3, C: n2 };
    }
    default:
      throw new fi("Unknown public key encryption algorithm.");
  }
}, serializeParams: function(e2, t2) {
  const r2 = /* @__PURE__ */ new Set([$.publicKey.ed25519, $.publicKey.x25519]), n2 = Object.keys(t2).map((n3) => {
    const i2 = t2[n3];
    return X.isUint8Array(i2) ? r2.has(e2) ? i2 : X.uint8ArrayToMPI(i2) : i2.write();
  });
  return X.concatUint8Array(n2);
}, generateParams: function(e2, t2, r2) {
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaSign:
      return ua.rsa.generate(t2, 65537).then(({ n: e3, e: t3, d: r3, p: n2, q: i2, u: a2 }) => ({ privateParams: { d: r3, p: n2, q: i2, u: a2 }, publicParams: { n: e3, e: t3 } }));
    case $.publicKey.ecdsa:
      return ua.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new ii(e3), Q: t3 } }));
    case $.publicKey.eddsaLegacy:
      return ua.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { seed: r3 }, publicParams: { oid: new ii(e3), Q: t3 } }));
    case $.publicKey.ecdh:
      return ua.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3, hash: n2, cipher: i2 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new ii(e3), Q: t3, kdfParams: new da({ hash: n2, cipher: i2 }) } }));
    case $.publicKey.ed25519:
      return ua.elliptic.eddsa.generate(e2).then(({ A: e3, seed: t3 }) => ({ privateParams: { seed: t3 }, publicParams: { A: e3 } }));
    case $.publicKey.x25519:
      return ua.elliptic.ecdhX.generate(e2).then(({ A: e3, k: t3 }) => ({ privateParams: { k: t3 }, publicParams: { A: e3 } }));
    case $.publicKey.dsa:
    case $.publicKey.elgamal:
      throw Error("Unsupported algorithm for key generation.");
    default:
      throw Error("Unknown public key algorithm.");
  }
}, validateParams: async function(e2, t2, r2) {
  if (!t2 || !r2) throw Error("Missing key parameters");
  switch (e2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaSign: {
      const { n: e3, e: n2 } = t2, { d: i2, p: a2, q: s2, u: o2 } = r2;
      return ua.rsa.validateParams(e3, n2, i2, a2, s2, o2);
    }
    case $.publicKey.dsa: {
      const { p: e3, q: n2, g: i2, y: a2 } = t2, { x: s2 } = r2;
      return ua.dsa.validateParams(e3, n2, i2, a2, s2);
    }
    case $.publicKey.elgamal: {
      const { p: e3, g: n2, y: i2 } = t2, { x: a2 } = r2;
      return ua.elgamal.validateParams(e3, n2, i2, a2);
    }
    case $.publicKey.ecdsa:
    case $.publicKey.ecdh: {
      const n2 = ua.elliptic[$.read($.publicKey, e2)], { oid: i2, Q: a2 } = t2, { d: s2 } = r2;
      return n2.validateParams(i2, a2, s2);
    }
    case $.publicKey.eddsaLegacy: {
      const { Q: e3, oid: n2 } = t2, { seed: i2 } = r2;
      return ua.elliptic.eddsaLegacy.validateParams(n2, e3, i2);
    }
    case $.publicKey.ed25519: {
      const { A: n2 } = t2, { seed: i2 } = r2;
      return ua.elliptic.eddsa.validateParams(e2, n2, i2);
    }
    case $.publicKey.x25519: {
      const { A: n2 } = t2, { k: i2 } = r2;
      return ua.elliptic.ecdhX.validateParams(e2, n2, i2);
    }
    default:
      throw Error("Unknown public key algorithm.");
  }
}, getPrefixRandom: async function(e2) {
  const { blockSize: t2 } = Wr(e2), r2 = await On(t2), n2 = new Uint8Array([r2[r2.length - 2], r2[r2.length - 1]]);
  return X.concat([r2, n2]);
}, generateSessionKey: function(e2) {
  const { keySize: t2 } = Wr(e2);
  return On(t2);
}, getAEADMode: function(e2) {
  const t2 = $.read($.aead, e2);
  return Mn[t2];
}, getCipher: Wr, getPreferredCurveHashAlgo: function(e2, t2) {
  switch (e2) {
    case $.publicKey.ecdsa:
    case $.publicKey.eddsaLegacy:
      return ua.elliptic.getPreferredHashAlgo(t2);
    case $.publicKey.ed25519:
      return ua.elliptic.eddsa.getPreferredHashAlgo(e2);
    default:
      throw Error("Unknown elliptic signing algo");
  }
} });
var ma = { cipher: qe, hash: Gr, mode: Mn, publicKey: ua, signature: la, random: Hn, pkcs1: Xn, pkcs5: $i, aesKW: Gi };
Object.assign(ma, ga);
var wa = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
function ba(e2, t2) {
  return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
}
var ka = { arraySet: function(e2, t2, r2, n2, i2) {
  if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
  else for (let a2 = 0; a2 < n2; a2++) e2[i2 + a2] = t2[r2 + a2];
}, flattenChunks: function(e2) {
  let t2, r2, n2, i2, a2;
  for (n2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
  const s2 = new Uint8Array(n2);
  for (i2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++) a2 = e2[t2], s2.set(a2, i2), i2 += a2.length;
  return s2;
} };
var va = { arraySet: function(e2, t2, r2, n2, i2) {
  for (let a2 = 0; a2 < n2; a2++) e2[i2 + a2] = t2[r2 + a2];
}, flattenChunks: function(e2) {
  return [].concat.apply([], e2);
} };
var Aa = wa ? Uint8Array : Array;
var _a = wa ? Uint16Array : Array;
var Ea = wa ? Int32Array : Array;
var Sa = wa ? ka.flattenChunks : va.flattenChunks;
var Ka = wa ? ka.arraySet : va.arraySet;
var xa = 0;
var Pa = 1;
var Ua = 2;
var Da = 3;
var Ca = 4;
var Ia = 5;
var Ta = 6;
var Ba = 0;
var za = 1;
var Ra = 2;
var Ma = -2;
var La = -3;
var Na = -5;
var Oa = -1;
var Fa = 1;
var Ha = 2;
var ja = 3;
var qa = 4;
var Ga = 0;
var Va = 1;
var Wa = 2;
var $a = 8;
function Za(e2) {
  let t2 = e2.length;
  for (; --t2 >= 0; ) e2[t2] = 0;
}
var Xa = 0;
var Qa = 1;
var Ya = 2;
var Ja = 29;
var es = 256;
var ts = es + 1 + Ja;
var rs = 30;
var ns = 19;
var is = 2 * ts + 1;
var as = 15;
var ss = 16;
var os = 7;
var cs = 256;
var hs = 16;
var us = 17;
var ls = 18;
var ys = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var ds = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var ps = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var fs = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var gs = Array(2 * (ts + 2));
Za(gs);
var ms = Array(2 * rs);
Za(ms);
var ws = Array(512);
Za(ws);
var bs = Array(256);
Za(bs);
var ks = Array(Ja);
Za(ks);
var vs = Array(rs);
function As(e2, t2, r2, n2, i2) {
  this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
}
var _s;
var Es;
var Ss;
function Ks(e2, t2) {
  this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
}
function xs(e2) {
  return e2 < 256 ? ws[e2] : ws[256 + (e2 >>> 7)];
}
function Ps(e2, t2) {
  e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
}
function Us(e2, t2, r2) {
  e2.bi_valid > ss - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, Ps(e2, e2.bi_buf), e2.bi_buf = t2 >> ss - e2.bi_valid, e2.bi_valid += r2 - ss) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
}
function Ds(e2, t2, r2) {
  Us(e2, r2[2 * t2], r2[2 * t2 + 1]);
}
function Cs(e2, t2) {
  let r2 = 0;
  do {
    r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1;
  } while (--t2 > 0);
  return r2 >>> 1;
}
function Is(e2, t2, r2) {
  const n2 = Array(as + 1);
  let i2, a2, s2 = 0;
  for (i2 = 1; i2 <= as; i2++) n2[i2] = s2 = s2 + r2[i2 - 1] << 1;
  for (a2 = 0; a2 <= t2; a2++) {
    const t3 = e2[2 * a2 + 1];
    0 !== t3 && (e2[2 * a2] = Cs(n2[t3]++, t3));
  }
}
function Ts(e2) {
  let t2;
  for (t2 = 0; t2 < ts; t2++) e2.dyn_ltree[2 * t2] = 0;
  for (t2 = 0; t2 < rs; t2++) e2.dyn_dtree[2 * t2] = 0;
  for (t2 = 0; t2 < ns; t2++) e2.bl_tree[2 * t2] = 0;
  e2.dyn_ltree[2 * cs] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
}
function Bs(e2) {
  e2.bi_valid > 8 ? Ps(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
}
function zs(e2, t2, r2, n2) {
  const i2 = 2 * t2, a2 = 2 * r2;
  return e2[i2] < e2[a2] || e2[i2] === e2[a2] && n2[t2] <= n2[r2];
}
function Rs(e2, t2, r2) {
  const n2 = e2.heap[r2];
  let i2 = r2 << 1;
  for (; i2 <= e2.heap_len && (i2 < e2.heap_len && zs(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !zs(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
  e2.heap[r2] = n2;
}
function Ms(e2, t2, r2) {
  let n2, i2, a2, s2, o2 = 0;
  if (0 !== e2.last_lit) do {
    n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? Ds(e2, i2, t2) : (a2 = bs[i2], Ds(e2, a2 + es + 1, t2), s2 = ys[a2], 0 !== s2 && (i2 -= ks[a2], Us(e2, i2, s2)), n2--, a2 = xs(n2), Ds(e2, a2, r2), s2 = ds[a2], 0 !== s2 && (n2 -= vs[a2], Us(e2, n2, s2)));
  } while (o2 < e2.last_lit);
  Ds(e2, cs, t2);
}
function Ls(e2, t2) {
  const r2 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, i2 = t2.stat_desc.has_stree, a2 = t2.stat_desc.elems;
  let s2, o2, c2, h2 = -1;
  for (e2.heap_len = 0, e2.heap_max = is, s2 = 0; s2 < a2; s2++) 0 !== r2[2 * s2] ? (e2.heap[++e2.heap_len] = h2 = s2, e2.depth[s2] = 0) : r2[2 * s2 + 1] = 0;
  for (; e2.heap_len < 2; ) c2 = e2.heap[++e2.heap_len] = h2 < 2 ? ++h2 : 0, r2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, i2 && (e2.static_len -= n2[2 * c2 + 1]);
  for (t2.max_code = h2, s2 = e2.heap_len >> 1; s2 >= 1; s2--) Rs(e2, r2, s2);
  c2 = a2;
  do {
    s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], Rs(e2, r2, 1), o2 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = o2, r2[2 * c2] = r2[2 * s2] + r2[2 * o2], e2.depth[c2] = (e2.depth[s2] >= e2.depth[o2] ? e2.depth[s2] : e2.depth[o2]) + 1, r2[2 * s2 + 1] = r2[2 * o2 + 1] = c2, e2.heap[1] = c2++, Rs(e2, r2, 1);
  } while (e2.heap_len >= 2);
  e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
    const r3 = t3.dyn_tree, n3 = t3.max_code, i3 = t3.stat_desc.static_tree, a3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, o3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
    let h3, u2, l2, y2, d2, p2, f2 = 0;
    for (y2 = 0; y2 <= as; y2++) e3.bl_count[y2] = 0;
    for (r3[2 * e3.heap[e3.heap_max] + 1] = 0, h3 = e3.heap_max + 1; h3 < is; h3++) u2 = e3.heap[h3], y2 = r3[2 * r3[2 * u2 + 1] + 1] + 1, y2 > c3 && (y2 = c3, f2++), r3[2 * u2 + 1] = y2, u2 > n3 || (e3.bl_count[y2]++, d2 = 0, u2 >= o3 && (d2 = s3[u2 - o3]), p2 = r3[2 * u2], e3.opt_len += p2 * (y2 + d2), a3 && (e3.static_len += p2 * (i3[2 * u2 + 1] + d2)));
    if (0 !== f2) {
      do {
        for (y2 = c3 - 1; 0 === e3.bl_count[y2]; ) y2--;
        e3.bl_count[y2]--, e3.bl_count[y2 + 1] += 2, e3.bl_count[c3]--, f2 -= 2;
      } while (f2 > 0);
      for (y2 = c3; 0 !== y2; y2--) for (u2 = e3.bl_count[y2]; 0 !== u2; ) l2 = e3.heap[--h3], l2 > n3 || (r3[2 * l2 + 1] !== y2 && (e3.opt_len += (y2 - r3[2 * l2 + 1]) * r3[2 * l2], r3[2 * l2 + 1] = y2), u2--);
    }
  }(e2, t2), Is(r2, h2, e2.bl_count);
}
function Ns(e2, t2, r2) {
  let n2, i2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, h2 = 4;
  for (0 === s2 && (c2 = 138, h2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = s2, s2 = t2[2 * (n2 + 1) + 1], ++o2 < c2 && i2 === s2 || (o2 < h2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== a2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * hs]++) : o2 <= 10 ? e2.bl_tree[2 * us]++ : e2.bl_tree[2 * ls]++, o2 = 0, a2 = i2, 0 === s2 ? (c2 = 138, h2 = 3) : i2 === s2 ? (c2 = 6, h2 = 3) : (c2 = 7, h2 = 4));
}
function Os(e2, t2, r2) {
  let n2, i2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, h2 = 4;
  for (0 === s2 && (c2 = 138, h2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = s2, s2 = t2[2 * (n2 + 1) + 1], !(++o2 < c2 && i2 === s2)) {
    if (o2 < h2) do {
      Ds(e2, i2, e2.bl_tree);
    } while (0 != --o2);
    else 0 !== i2 ? (i2 !== a2 && (Ds(e2, i2, e2.bl_tree), o2--), Ds(e2, hs, e2.bl_tree), Us(e2, o2 - 3, 2)) : o2 <= 10 ? (Ds(e2, us, e2.bl_tree), Us(e2, o2 - 3, 3)) : (Ds(e2, ls, e2.bl_tree), Us(e2, o2 - 11, 7));
    o2 = 0, a2 = i2, 0 === s2 ? (c2 = 138, h2 = 3) : i2 === s2 ? (c2 = 6, h2 = 3) : (c2 = 7, h2 = 4);
  }
}
Za(vs);
var Fs = false;
function Hs(e2) {
  Fs || (!function() {
    let e3, t2, r2, n2, i2;
    const a2 = Array(as + 1);
    for (r2 = 0, n2 = 0; n2 < Ja - 1; n2++) for (ks[n2] = r2, e3 = 0; e3 < 1 << ys[n2]; e3++) bs[r2++] = n2;
    for (bs[r2 - 1] = n2, i2 = 0, n2 = 0; n2 < 16; n2++) for (vs[n2] = i2, e3 = 0; e3 < 1 << ds[n2]; e3++) ws[i2++] = n2;
    for (i2 >>= 7; n2 < rs; n2++) for (vs[n2] = i2 << 7, e3 = 0; e3 < 1 << ds[n2] - 7; e3++) ws[256 + i2++] = n2;
    for (t2 = 0; t2 <= as; t2++) a2[t2] = 0;
    for (e3 = 0; e3 <= 143; ) gs[2 * e3 + 1] = 8, e3++, a2[8]++;
    for (; e3 <= 255; ) gs[2 * e3 + 1] = 9, e3++, a2[9]++;
    for (; e3 <= 279; ) gs[2 * e3 + 1] = 7, e3++, a2[7]++;
    for (; e3 <= 287; ) gs[2 * e3 + 1] = 8, e3++, a2[8]++;
    for (Is(gs, ts + 1, a2), e3 = 0; e3 < rs; e3++) ms[2 * e3 + 1] = 5, ms[2 * e3] = Cs(e3, 5);
    _s = new As(gs, ys, es + 1, ts, as), Es = new As(ms, ds, 0, rs, as), Ss = new As([], ps, 0, ns, os);
  }(), Fs = true), e2.l_desc = new Ks(e2.dyn_ltree, _s), e2.d_desc = new Ks(e2.dyn_dtree, Es), e2.bl_desc = new Ks(e2.bl_tree, Ss), e2.bi_buf = 0, e2.bi_valid = 0, Ts(e2);
}
function js(e2, t2, r2, n2) {
  Us(e2, (Xa << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
    Bs(e3), n3 && (Ps(e3, r3), Ps(e3, ~r3)), Ka(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
  }(e2, t2, r2, true);
}
function qs(e2) {
  Us(e2, Qa << 1, 3), Ds(e2, cs, gs), function(e3) {
    16 === e3.bi_valid ? (Ps(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
  }(e2);
}
function Gs(e2, t2, r2, n2) {
  let i2, a2, s2 = 0;
  e2.level > 0 ? (e2.strm.data_type === Wa && (e2.strm.data_type = function(e3) {
    let t3, r3 = 4093624447;
    for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return Ga;
    if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return Va;
    for (t3 = 32; t3 < es; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return Va;
    return Ga;
  }(e2)), Ls(e2, e2.l_desc), Ls(e2, e2.d_desc), s2 = function(e3) {
    let t3;
    for (Ns(e3, e3.dyn_ltree, e3.l_desc.max_code), Ns(e3, e3.dyn_dtree, e3.d_desc.max_code), Ls(e3, e3.bl_desc), t3 = ns - 1; t3 >= 3 && 0 === e3.bl_tree[2 * fs[t3] + 1]; t3--) ;
    return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
  }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, a2 = e2.static_len + 3 + 7 >>> 3, a2 <= i2 && (i2 = a2)) : i2 = a2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? js(e2, t2, r2, n2) : e2.strategy === qa || a2 === i2 ? (Us(e2, (Qa << 1) + (n2 ? 1 : 0), 3), Ms(e2, gs, ms)) : (Us(e2, (Ya << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
    let i3;
    for (Us(e3, t3 - 257, 5), Us(e3, r3 - 1, 5), Us(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) Us(e3, e3.bl_tree[2 * fs[i3] + 1], 3);
    Os(e3, e3.dyn_ltree, t3 - 1), Os(e3, e3.dyn_dtree, r3 - 1);
  }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), Ms(e2, e2.dyn_ltree, e2.dyn_dtree)), Ts(e2), n2 && Bs(e2);
}
function Vs(e2, t2, r2) {
  return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (bs[r2] + es + 1)]++, e2.dyn_dtree[2 * xs(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
}
function Ws(e2, t2, r2, n2) {
  let i2 = 65535 & e2 | 0, a2 = e2 >>> 16 & 65535 | 0, s2 = 0;
  for (; 0 !== r2; ) {
    s2 = r2 > 2e3 ? 2e3 : r2, r2 -= s2;
    do {
      i2 = i2 + t2[n2++] | 0, a2 = a2 + i2 | 0;
    } while (--s2);
    i2 %= 65521, a2 %= 65521;
  }
  return i2 | a2 << 16 | 0;
}
var $s = function() {
  let e2;
  const t2 = [];
  for (let r2 = 0; r2 < 256; r2++) {
    e2 = r2;
    for (let t3 = 0; t3 < 8; t3++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
    t2[r2] = e2;
  }
  return t2;
}();
function Zs(e2, t2, r2, n2) {
  const i2 = $s, a2 = n2 + r2;
  e2 ^= -1;
  for (let r3 = n2; r3 < a2; r3++) e2 = e2 >>> 8 ^ i2[255 & (e2 ^ t2[r3])];
  return -1 ^ e2;
}
var Xs = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
var Qs = 9;
var Ys = 3;
var Js = 258;
var eo = Js + Ys + 1;
var to = 32;
var ro = 42;
var no = 69;
var io = 73;
var ao = 91;
var so = 103;
var oo = 113;
var co = 666;
var ho = 1;
var uo = 2;
var lo = 3;
var yo = 4;
var po = 3;
function fo(e2, t2) {
  return e2.msg = Xs[t2], t2;
}
function go(e2) {
  return (e2 << 1) - (e2 > 4 ? 9 : 0);
}
function mo(e2) {
  let t2 = e2.length;
  for (; --t2 >= 0; ) e2[t2] = 0;
}
function wo(e2) {
  const t2 = e2.state;
  let r2 = t2.pending;
  r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (Ka(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
}
function bo(e2, t2) {
  Gs(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, wo(e2.strm);
}
function ko(e2, t2) {
  e2.pending_buf[e2.pending++] = t2;
}
function vo(e2, t2) {
  e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
}
function Ao(e2, t2, r2, n2) {
  let i2 = e2.avail_in;
  return i2 > n2 && (i2 = n2), 0 === i2 ? 0 : (e2.avail_in -= i2, Ka(t2, e2.input, e2.next_in, i2, r2), 1 === e2.state.wrap ? e2.adler = Ws(e2.adler, t2, i2, r2) : 2 === e2.state.wrap && (e2.adler = Zs(e2.adler, t2, i2, r2)), e2.next_in += i2, e2.total_in += i2, i2);
}
function _o(e2, t2) {
  let r2, n2, i2 = e2.max_chain_length, a2 = e2.strstart, s2 = e2.prev_length, o2 = e2.nice_match;
  const c2 = e2.strstart > e2.w_size - eo ? e2.strstart - (e2.w_size - eo) : 0, h2 = e2.window, u2 = e2.w_mask, l2 = e2.prev, y2 = e2.strstart + Js;
  let d2 = h2[a2 + s2 - 1], p2 = h2[a2 + s2];
  e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
  do {
    if (r2 = t2, h2[r2 + s2] === p2 && h2[r2 + s2 - 1] === d2 && h2[r2] === h2[a2] && h2[++r2] === h2[a2 + 1]) {
      a2 += 2, r2++;
      do {
      } while (h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && h2[++a2] === h2[++r2] && a2 < y2);
      if (n2 = Js - (y2 - a2), a2 = y2 - Js, n2 > s2) {
        if (e2.match_start = t2, s2 = n2, n2 >= o2) break;
        d2 = h2[a2 + s2 - 1], p2 = h2[a2 + s2];
      }
    }
  } while ((t2 = l2[t2 & u2]) > c2 && 0 != --i2);
  return s2 <= e2.lookahead ? s2 : e2.lookahead;
}
function Eo(e2) {
  const t2 = e2.w_size;
  let r2, n2, i2, a2, s2;
  do {
    if (a2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - eo)) {
      Ka(e2.window, e2.window, t2, t2, 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, n2 = e2.hash_size, r2 = n2;
      do {
        i2 = e2.head[--r2], e2.head[r2] = i2 >= t2 ? i2 - t2 : 0;
      } while (--n2);
      n2 = t2, r2 = n2;
      do {
        i2 = e2.prev[--r2], e2.prev[r2] = i2 >= t2 ? i2 - t2 : 0;
      } while (--n2);
      a2 += t2;
    }
    if (0 === e2.strm.avail_in) break;
    if (n2 = Ao(e2.strm, e2.window, e2.strstart + e2.lookahead, a2), e2.lookahead += n2, e2.lookahead + e2.insert >= Ys) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + Ys - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < Ys)); ) ;
  } while (e2.lookahead < eo && 0 !== e2.strm.avail_in);
}
function So(e2, t2) {
  let r2, n2;
  for (; ; ) {
    if (e2.lookahead < eo) {
      if (Eo(e2), e2.lookahead < eo && t2 === xa) return ho;
      if (0 === e2.lookahead) break;
    }
    if (r2 = 0, e2.lookahead >= Ys && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + Ys - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - eo && (e2.match_length = _o(e2, r2)), e2.match_length >= Ys) if (n2 = Vs(e2, e2.strstart - e2.match_start, e2.match_length - Ys), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= Ys) {
      e2.match_length--;
      do {
        e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + Ys - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
      } while (0 != --e2.match_length);
      e2.strstart++;
    } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
    else n2 = Vs(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
    if (n2 && (bo(e2, false), 0 === e2.strm.avail_out)) return ho;
  }
  return e2.insert = e2.strstart < Ys - 1 ? e2.strstart : Ys - 1, t2 === Ca ? (bo(e2, true), 0 === e2.strm.avail_out ? lo : yo) : e2.last_lit && (bo(e2, false), 0 === e2.strm.avail_out) ? ho : uo;
}
function Ko(e2, t2) {
  let r2, n2, i2;
  for (; ; ) {
    if (e2.lookahead < eo) {
      if (Eo(e2), e2.lookahead < eo && t2 === xa) return ho;
      if (0 === e2.lookahead) break;
    }
    if (r2 = 0, e2.lookahead >= Ys && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + Ys - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = Ys - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - eo && (e2.match_length = _o(e2, r2), e2.match_length <= 5 && (e2.strategy === Fa || e2.match_length === Ys && e2.strstart - e2.match_start > 4096) && (e2.match_length = Ys - 1)), e2.prev_length >= Ys && e2.match_length <= e2.prev_length) {
      i2 = e2.strstart + e2.lookahead - Ys, n2 = Vs(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - Ys), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
      do {
        ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + Ys - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
      } while (0 != --e2.prev_length);
      if (e2.match_available = 0, e2.match_length = Ys - 1, e2.strstart++, n2 && (bo(e2, false), 0 === e2.strm.avail_out)) return ho;
    } else if (e2.match_available) {
      if (n2 = Vs(e2, 0, e2.window[e2.strstart - 1]), n2 && bo(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return ho;
    } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
  }
  return e2.match_available && (n2 = Vs(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < Ys - 1 ? e2.strstart : Ys - 1, t2 === Ca ? (bo(e2, true), 0 === e2.strm.avail_out ? lo : yo) : e2.last_lit && (bo(e2, false), 0 === e2.strm.avail_out) ? ho : uo;
}
var xo = class {
  constructor(e2, t2, r2, n2, i2) {
    this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
  }
};
var Po = [new xo(0, 0, 0, 0, function(e2, t2) {
  let r2 = 65535;
  for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
    if (e2.lookahead <= 1) {
      if (Eo(e2), 0 === e2.lookahead && t2 === xa) return ho;
      if (0 === e2.lookahead) break;
    }
    e2.strstart += e2.lookahead, e2.lookahead = 0;
    const n2 = e2.block_start + r2;
    if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, bo(e2, false), 0 === e2.strm.avail_out)) return ho;
    if (e2.strstart - e2.block_start >= e2.w_size - eo && (bo(e2, false), 0 === e2.strm.avail_out)) return ho;
  }
  return e2.insert = 0, t2 === Ca ? (bo(e2, true), 0 === e2.strm.avail_out ? lo : yo) : (e2.strstart > e2.block_start && (bo(e2, false), e2.strm.avail_out), ho);
}), new xo(4, 4, 8, 4, So), new xo(4, 5, 16, 8, So), new xo(4, 6, 32, 32, So), new xo(4, 4, 16, 16, Ko), new xo(8, 16, 32, 32, Ko), new xo(8, 16, 128, 128, Ko), new xo(8, 32, 128, 256, Ko), new xo(32, 128, 258, 1024, Ko), new xo(32, 258, 258, 4096, Ko)];
var Uo = class {
  constructor() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = $a, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new _a(1146), this.dyn_dtree = new _a(122), this.bl_tree = new _a(78), mo(this.dyn_ltree), mo(this.dyn_dtree), mo(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new _a(16), this.heap = new _a(573), mo(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new _a(573), mo(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
};
function Do(e2) {
  const t2 = function(e3) {
    let t3;
    return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = Wa, t3 = e3.state, t3.pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? ro : oo, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = xa, Hs(t3), Ba) : fo(e3, Ma);
  }(e2);
  return t2 === Ba && function(e3) {
    e3.window_size = 2 * e3.w_size, mo(e3.head), e3.max_lazy_match = Po[e3.level].max_lazy, e3.good_match = Po[e3.level].good_length, e3.nice_match = Po[e3.level].nice_length, e3.max_chain_length = Po[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = Ys - 1, e3.match_available = 0, e3.ins_h = 0;
  }(e2.state), t2;
}
function Co(e2, t2) {
  let r2, n2, i2, a2;
  if (!e2 || !e2.state || t2 > Ia || t2 < 0) return e2 ? fo(e2, Ma) : Ma;
  if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || n2.status === co && t2 !== Ca) return fo(e2, 0 === e2.avail_out ? Na : Ma);
  if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === ro) if (2 === n2.wrap) e2.adler = 0, ko(n2, 31), ko(n2, 139), ko(n2, 8), n2.gzhead ? (ko(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), ko(n2, 255 & n2.gzhead.time), ko(n2, n2.gzhead.time >> 8 & 255), ko(n2, n2.gzhead.time >> 16 & 255), ko(n2, n2.gzhead.time >> 24 & 255), ko(n2, 9 === n2.level ? 2 : n2.strategy >= Ha || n2.level < 2 ? 4 : 0), ko(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (ko(n2, 255 & n2.gzhead.extra.length), ko(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = no) : (ko(n2, 0), ko(n2, 0), ko(n2, 0), ko(n2, 0), ko(n2, 0), ko(n2, 9 === n2.level ? 2 : n2.strategy >= Ha || n2.level < 2 ? 4 : 0), ko(n2, po), n2.status = oo);
  else {
    let t3 = $a + (n2.w_bits - 8 << 4) << 8, r3 = -1;
    r3 = n2.strategy >= Ha || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3, t3 |= r3 << 6, 0 !== n2.strstart && (t3 |= to), t3 += 31 - t3 % 31, n2.status = oo, vo(n2, t3), 0 !== n2.strstart && (vo(n2, e2.adler >>> 16), vo(n2, 65535 & e2.adler)), e2.adler = 1;
  }
  if (n2.status === no) if (n2.gzhead.extra) {
    for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), wo(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) ko(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = io);
  } else n2.status = io;
  if (n2.status === io) if (n2.gzhead.name) {
    i2 = n2.pending;
    do {
      if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), wo(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
        a2 = 1;
        break;
      }
      a2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, ko(n2, a2);
    } while (0 !== a2);
    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === a2 && (n2.gzindex = 0, n2.status = ao);
  } else n2.status = ao;
  if (n2.status === ao) if (n2.gzhead.comment) {
    i2 = n2.pending;
    do {
      if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), wo(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
        a2 = 1;
        break;
      }
      a2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, ko(n2, a2);
    } while (0 !== a2);
    n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zs(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === a2 && (n2.status = so);
  } else n2.status = so;
  if (n2.status === so && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && wo(e2), n2.pending + 2 <= n2.pending_buf_size && (ko(n2, 255 & e2.adler), ko(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = oo)) : n2.status = oo), 0 !== n2.pending) {
    if (wo(e2), 0 === e2.avail_out) return n2.last_flush = -1, Ba;
  } else if (0 === e2.avail_in && go(t2) <= go(r2) && t2 !== Ca) return fo(e2, Na);
  if (n2.status === co && 0 !== e2.avail_in) return fo(e2, Na);
  if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== xa && n2.status !== co) {
    var s2 = n2.strategy === Ha ? function(e3, t3) {
      let r3;
      for (; ; ) {
        if (0 === e3.lookahead && (Eo(e3), 0 === e3.lookahead)) {
          if (t3 === xa) return ho;
          break;
        }
        if (e3.match_length = 0, r3 = Vs(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (bo(e3, false), 0 === e3.strm.avail_out)) return ho;
      }
      return e3.insert = 0, t3 === Ca ? (bo(e3, true), 0 === e3.strm.avail_out ? lo : yo) : e3.last_lit && (bo(e3, false), 0 === e3.strm.avail_out) ? ho : uo;
    }(n2, t2) : n2.strategy === ja ? function(e3, t3) {
      let r3, n3, i3, a3;
      const s3 = e3.window;
      for (; ; ) {
        if (e3.lookahead <= Js) {
          if (Eo(e3), e3.lookahead <= Js && t3 === xa) return ho;
          if (0 === e3.lookahead) break;
        }
        if (e3.match_length = 0, e3.lookahead >= Ys && e3.strstart > 0 && (i3 = e3.strstart - 1, n3 = s3[i3], n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3])) {
          a3 = e3.strstart + Js;
          do {
          } while (n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && n3 === s3[++i3] && i3 < a3);
          e3.match_length = Js - (a3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
        }
        if (e3.match_length >= Ys ? (r3 = Vs(e3, 1, e3.match_length - Ys), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = Vs(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (bo(e3, false), 0 === e3.strm.avail_out)) return ho;
      }
      return e3.insert = 0, t3 === Ca ? (bo(e3, true), 0 === e3.strm.avail_out ? lo : yo) : e3.last_lit && (bo(e3, false), 0 === e3.strm.avail_out) ? ho : uo;
    }(n2, t2) : Po[n2.level].func(n2, t2);
    if (s2 !== lo && s2 !== yo || (n2.status = co), s2 === ho || s2 === lo) return 0 === e2.avail_out && (n2.last_flush = -1), Ba;
    if (s2 === uo && (t2 === Pa ? qs(n2) : t2 !== Ia && (js(n2, 0, 0, false), t2 === Da && (mo(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), wo(e2), 0 === e2.avail_out)) return n2.last_flush = -1, Ba;
  }
  return t2 !== Ca ? Ba : n2.wrap <= 0 ? za : (2 === n2.wrap ? (ko(n2, 255 & e2.adler), ko(n2, e2.adler >> 8 & 255), ko(n2, e2.adler >> 16 & 255), ko(n2, e2.adler >> 24 & 255), ko(n2, 255 & e2.total_in), ko(n2, e2.total_in >> 8 & 255), ko(n2, e2.total_in >> 16 & 255), ko(n2, e2.total_in >> 24 & 255)) : (vo(n2, e2.adler >>> 16), vo(n2, 65535 & e2.adler)), wo(e2), n2.wrap > 0 && (n2.wrap = -n2.wrap), 0 !== n2.pending ? Ba : za);
}
try {
  String.fromCharCode.call(null, 0);
} catch (e2) {
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e2) {
}
var Io = new Aa(256);
for (let e2 = 0; e2 < 256; e2++) Io[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
function To(e2) {
  let t2, r2, n2, i2, a2 = 0;
  const s2 = e2.length;
  for (n2 = 0; n2 < s2; n2++) t2 = e2.charCodeAt(n2), 55296 == (64512 & t2) && n2 + 1 < s2 && (r2 = e2.charCodeAt(n2 + 1), 56320 == (64512 & r2) && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), n2++)), a2 += t2 < 128 ? 1 : t2 < 2048 ? 2 : t2 < 65536 ? 3 : 4;
  const o2 = new Aa(a2);
  for (i2 = 0, n2 = 0; i2 < a2; n2++) t2 = e2.charCodeAt(n2), 55296 == (64512 & t2) && n2 + 1 < s2 && (r2 = e2.charCodeAt(n2 + 1), 56320 == (64512 & r2) && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), n2++)), t2 < 128 ? o2[i2++] = t2 : t2 < 2048 ? (o2[i2++] = 192 | t2 >>> 6, o2[i2++] = 128 | 63 & t2) : t2 < 65536 ? (o2[i2++] = 224 | t2 >>> 12, o2[i2++] = 128 | t2 >>> 6 & 63, o2[i2++] = 128 | 63 & t2) : (o2[i2++] = 240 | t2 >>> 18, o2[i2++] = 128 | t2 >>> 12 & 63, o2[i2++] = 128 | t2 >>> 6 & 63, o2[i2++] = 128 | 63 & t2);
  return o2;
}
Io[254] = Io[254] = 1;
var Bo = class {
  constructor() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
};
var zo = class {
  constructor(e2) {
    this.options = { level: Oa, method: $a, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, ...e2 || {} };
    const t2 = this.options;
    t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Bo(), this.strm.avail_out = 0;
    var r2, n2, i2 = function(e3, t3, r3, n3, i3, a2) {
      if (!e3) return Ma;
      let s2 = 1;
      if (t3 === Oa && (t3 = 6), n3 < 0 ? (s2 = 0, n3 = -n3) : n3 > 15 && (s2 = 2, n3 -= 16), i3 < 1 || i3 > Qs || r3 !== $a || n3 < 8 || n3 > 15 || t3 < 0 || t3 > 9 || a2 < 0 || a2 > qa) return fo(e3, Ma);
      8 === n3 && (n3 = 9);
      const o2 = new Uo();
      return e3.state = o2, o2.strm = e3, o2.wrap = s2, o2.gzhead = null, o2.w_bits = n3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i3 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + Ys - 1) / Ys), o2.window = new Aa(2 * o2.w_size), o2.head = new _a(o2.hash_size), o2.prev = new _a(o2.w_size), o2.lit_bufsize = 1 << i3 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new Aa(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = a2, o2.method = r3, Do(e3);
    }(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
    if (i2 !== Ba) throw Error(Xs[i2]);
    if (t2.header && (r2 = this.strm, n2 = t2.header, r2 && r2.state && (2 !== r2.state.wrap || (r2.state.gzhead = n2))), t2.dictionary) {
      let e3;
      if (e3 = "string" == typeof t2.dictionary ? To(t2.dictionary) : t2.dictionary instanceof ArrayBuffer ? new Uint8Array(t2.dictionary) : t2.dictionary, i2 = function(e4, t3) {
        let r3, n3, i3, a2, s2, o2, c2, h2, u2 = t3.length;
        if (!e4 || !e4.state) return Ma;
        if (r3 = e4.state, a2 = r3.wrap, 2 === a2 || 1 === a2 && r3.status !== ro || r3.lookahead) return Ma;
        for (1 === a2 && (e4.adler = Ws(e4.adler, t3, u2, 0)), r3.wrap = 0, u2 >= r3.w_size && (0 === a2 && (mo(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), h2 = new Aa(r3.w_size), Ka(h2, t3, u2 - r3.w_size, r3.w_size, 0), t3 = h2, u2 = r3.w_size), s2 = e4.avail_in, o2 = e4.next_in, c2 = e4.input, e4.avail_in = u2, e4.next_in = 0, e4.input = t3, Eo(r3); r3.lookahead >= Ys; ) {
          n3 = r3.strstart, i3 = r3.lookahead - (Ys - 1);
          do {
            r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + Ys - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++;
          } while (--i3);
          r3.strstart = n3, r3.lookahead = Ys - 1, Eo(r3);
        }
        return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = Ys - 1, r3.match_available = 0, e4.next_in = o2, e4.input = c2, e4.avail_in = s2, r3.wrap = a2, Ba;
      }(this.strm, e3), i2 !== Ba) throw Error(Xs[i2]);
      this._dict_set = true;
    }
  }
  push(e2, t2) {
    const { strm: r2, options: { chunkSize: n2 } } = this;
    var i2, a2;
    if (this.ended) return false;
    a2 = t2 === ~~t2 ? t2 : true === t2 ? Ca : xa, "string" == typeof e2 ? r2.input = To(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
    do {
      if (0 === r2.avail_out && (r2.output = new Aa(n2), r2.next_out = 0, r2.avail_out = n2), (i2 = Co(r2, a2)) !== za && i2 !== Ba) return this.onEnd(i2), this.ended = true, false;
      0 !== r2.avail_out && (0 !== r2.avail_in || a2 !== Ca && a2 !== Ua) || this.onData(ba(r2.output, r2.next_out));
    } while ((r2.avail_in > 0 || 0 === r2.avail_out) && i2 !== za);
    return a2 === Ca ? (i2 = function(e3) {
      let t3;
      return e3 && e3.state ? (t3 = e3.state.status, t3 !== ro && t3 !== no && t3 !== io && t3 !== ao && t3 !== so && t3 !== oo && t3 !== co ? fo(e3, Ma) : (e3.state = null, t3 === oo ? fo(e3, La) : Ba)) : Ma;
    }(this.strm), this.onEnd(i2), this.ended = true, i2 === Ba) : a2 !== Ua || (this.onEnd(Ba), r2.avail_out = 0, true);
  }
  onData(e2) {
    this.chunks.push(e2);
  }
  onEnd(e2) {
    e2 === Ba && (this.result = Sa(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
  }
};
var Ro = 30;
var Mo = 12;
function Lo(e2, t2) {
  let r2, n2, i2, a2, s2, o2, c2, h2, u2, l2;
  const y2 = e2.state;
  r2 = e2.next_in;
  const d2 = e2.input, p2 = r2 + (e2.avail_in - 5);
  n2 = e2.next_out;
  const f2 = e2.output, g2 = n2 - (t2 - e2.avail_out), m2 = n2 + (e2.avail_out - 257), w2 = y2.dmax, b2 = y2.wsize, k2 = y2.whave, v2 = y2.wnext, A2 = y2.window;
  i2 = y2.hold, a2 = y2.bits;
  const _2 = y2.lencode, E2 = y2.distcode, S2 = (1 << y2.lenbits) - 1, K2 = (1 << y2.distbits) - 1;
  e: do {
    a2 < 15 && (i2 += d2[r2++] << a2, a2 += 8, i2 += d2[r2++] << a2, a2 += 8), s2 = _2[i2 & S2];
    t: for (; ; ) {
      if (o2 = s2 >>> 24, i2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, 0 === o2) f2[n2++] = 65535 & s2;
      else {
        if (!(16 & o2)) {
          if (0 == (64 & o2)) {
            s2 = _2[(65535 & s2) + (i2 & (1 << o2) - 1)];
            continue t;
          }
          if (32 & o2) {
            y2.mode = Mo;
            break e;
          }
          e2.msg = "invalid literal/length code", y2.mode = Ro;
          break e;
        }
        c2 = 65535 & s2, o2 &= 15, o2 && (a2 < o2 && (i2 += d2[r2++] << a2, a2 += 8), c2 += i2 & (1 << o2) - 1, i2 >>>= o2, a2 -= o2), a2 < 15 && (i2 += d2[r2++] << a2, a2 += 8, i2 += d2[r2++] << a2, a2 += 8), s2 = E2[i2 & K2];
        r: for (; ; ) {
          if (o2 = s2 >>> 24, i2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, !(16 & o2)) {
            if (0 == (64 & o2)) {
              s2 = E2[(65535 & s2) + (i2 & (1 << o2) - 1)];
              continue r;
            }
            e2.msg = "invalid distance code", y2.mode = Ro;
            break e;
          }
          if (h2 = 65535 & s2, o2 &= 15, a2 < o2 && (i2 += d2[r2++] << a2, a2 += 8, a2 < o2 && (i2 += d2[r2++] << a2, a2 += 8)), h2 += i2 & (1 << o2) - 1, h2 > w2) {
            e2.msg = "invalid distance too far back", y2.mode = Ro;
            break e;
          }
          if (i2 >>>= o2, a2 -= o2, o2 = n2 - g2, h2 > o2) {
            if (o2 = h2 - o2, o2 > k2 && y2.sane) {
              e2.msg = "invalid distance too far back", y2.mode = Ro;
              break e;
            }
            if (u2 = 0, l2 = A2, 0 === v2) {
              if (u2 += b2 - o2, o2 < c2) {
                c2 -= o2;
                do {
                  f2[n2++] = A2[u2++];
                } while (--o2);
                u2 = n2 - h2, l2 = f2;
              }
            } else if (v2 < o2) {
              if (u2 += b2 + v2 - o2, o2 -= v2, o2 < c2) {
                c2 -= o2;
                do {
                  f2[n2++] = A2[u2++];
                } while (--o2);
                if (u2 = 0, v2 < c2) {
                  o2 = v2, c2 -= o2;
                  do {
                    f2[n2++] = A2[u2++];
                  } while (--o2);
                  u2 = n2 - h2, l2 = f2;
                }
              }
            } else if (u2 += v2 - o2, o2 < c2) {
              c2 -= o2;
              do {
                f2[n2++] = A2[u2++];
              } while (--o2);
              u2 = n2 - h2, l2 = f2;
            }
            for (; c2 > 2; ) f2[n2++] = l2[u2++], f2[n2++] = l2[u2++], f2[n2++] = l2[u2++], c2 -= 3;
            c2 && (f2[n2++] = l2[u2++], c2 > 1 && (f2[n2++] = l2[u2++]));
          } else {
            u2 = n2 - h2;
            do {
              f2[n2++] = f2[u2++], f2[n2++] = f2[u2++], f2[n2++] = f2[u2++], c2 -= 3;
            } while (c2 > 2);
            c2 && (f2[n2++] = f2[u2++], c2 > 1 && (f2[n2++] = f2[u2++]));
          }
          break;
        }
      }
      break;
    }
  } while (r2 < p2 && n2 < m2);
  c2 = a2 >> 3, r2 -= c2, a2 -= c2 << 3, i2 &= (1 << a2) - 1, e2.next_in = r2, e2.next_out = n2, e2.avail_in = r2 < p2 ? p2 - r2 + 5 : 5 - (r2 - p2), e2.avail_out = n2 < m2 ? m2 - n2 + 257 : 257 - (n2 - m2), y2.hold = i2, y2.bits = a2;
}
var No = 15;
var Oo = 852;
var Fo = 592;
var Ho = 0;
var jo = 1;
var qo = 2;
var Go = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var Vo = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var Wo = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var $o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
function Zo(e2, t2, r2, n2, i2, a2, s2, o2) {
  const c2 = o2.bits;
  let h2, u2, l2, y2, d2, p2 = 0, f2 = 0, g2 = 0, m2 = 0, w2 = 0, b2 = 0, k2 = 0, v2 = 0, A2 = 0, _2 = 0, E2 = null, S2 = 0;
  const K2 = new _a(No + 1), x2 = new _a(No + 1);
  let P2, U2, D2, C2 = null, I2 = 0;
  for (p2 = 0; p2 <= No; p2++) K2[p2] = 0;
  for (f2 = 0; f2 < n2; f2++) K2[t2[r2 + f2]]++;
  for (w2 = c2, m2 = No; m2 >= 1 && 0 === K2[m2]; m2--) ;
  if (w2 > m2 && (w2 = m2), 0 === m2) return i2[a2++] = 20971520, i2[a2++] = 20971520, o2.bits = 1, 0;
  for (g2 = 1; g2 < m2 && 0 === K2[g2]; g2++) ;
  for (w2 < g2 && (w2 = g2), v2 = 1, p2 = 1; p2 <= No; p2++) if (v2 <<= 1, v2 -= K2[p2], v2 < 0) return -1;
  if (v2 > 0 && (e2 === Ho || 1 !== m2)) return -1;
  for (x2[1] = 0, p2 = 1; p2 < No; p2++) x2[p2 + 1] = x2[p2] + K2[p2];
  for (f2 = 0; f2 < n2; f2++) 0 !== t2[r2 + f2] && (s2[x2[t2[r2 + f2]]++] = f2);
  e2 === Ho ? (E2 = C2 = s2, d2 = 19) : e2 === jo ? (E2 = Go, S2 -= 257, C2 = Vo, I2 -= 257, d2 = 256) : (E2 = Wo, C2 = $o, d2 = -1), _2 = 0, f2 = 0, p2 = g2, y2 = a2, b2 = w2, k2 = 0, l2 = -1, A2 = 1 << w2;
  const T2 = A2 - 1;
  if (e2 === jo && A2 > Oo || e2 === qo && A2 > Fo) return 1;
  for (; ; ) {
    P2 = p2 - k2, s2[f2] < d2 ? (U2 = 0, D2 = s2[f2]) : s2[f2] > d2 ? (U2 = C2[I2 + s2[f2]], D2 = E2[S2 + s2[f2]]) : (U2 = 96, D2 = 0), h2 = 1 << p2 - k2, u2 = 1 << b2, g2 = u2;
    do {
      u2 -= h2, i2[y2 + (_2 >> k2) + u2] = P2 << 24 | U2 << 16 | D2 | 0;
    } while (0 !== u2);
    for (h2 = 1 << p2 - 1; _2 & h2; ) h2 >>= 1;
    if (0 !== h2 ? (_2 &= h2 - 1, _2 += h2) : _2 = 0, f2++, 0 == --K2[p2]) {
      if (p2 === m2) break;
      p2 = t2[r2 + s2[f2]];
    }
    if (p2 > w2 && (_2 & T2) !== l2) {
      for (0 === k2 && (k2 = w2), y2 += g2, b2 = p2 - k2, v2 = 1 << b2; b2 + k2 < m2 && (v2 -= K2[b2 + k2], !(v2 <= 0)); ) b2++, v2 <<= 1;
      if (A2 += 1 << b2, e2 === jo && A2 > Oo || e2 === qo && A2 > Fo) return 1;
      l2 = _2 & T2, i2[l2] = w2 << 24 | b2 << 16 | y2 - a2 | 0;
    }
  }
  return 0 !== _2 && (i2[y2 + _2] = p2 - k2 << 24 | 64 << 16 | 0), o2.bits = w2, 0;
}
var Xo = 0;
var Qo = 1;
var Yo = 2;
var Jo = 1;
var ec = 2;
var tc = 3;
var rc = 4;
var nc = 5;
var ic = 6;
var ac = 7;
var sc = 8;
var oc = 9;
var cc = 10;
var hc = 11;
var uc = 12;
var lc = 13;
var yc = 14;
var dc = 15;
var pc = 16;
var fc = 17;
var gc = 18;
var mc = 19;
var wc = 20;
var bc = 21;
var kc = 22;
var vc = 23;
var Ac = 24;
var _c = 25;
var Ec = 26;
var Sc = 27;
var Kc = 28;
var xc = 29;
var Pc = 30;
var Uc = 852;
var Dc = 592;
function Cc(e2) {
  return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
}
var Ic = class {
  constructor() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new _a(320), this.work = new _a(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
};
function Tc(e2) {
  let t2;
  return e2 && e2.state ? (t2 = e2.state, t2.wsize = 0, t2.whave = 0, t2.wnext = 0, function(e3) {
    let t3;
    return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = Jo, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new Ea(Uc), t3.distcode = t3.distdyn = new Ea(Dc), t3.sane = 1, t3.back = -1, Ba) : Ma;
  }(e2)) : Ma;
}
function Bc(e2, t2) {
  let r2, n2;
  return e2 ? (n2 = new Ic(), e2.state = n2, n2.window = null, r2 = function(e3, t3) {
    let r3, n3;
    return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? Ma : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, Tc(e3))) : Ma;
  }(e2, t2), r2 !== Ba && (e2.state = null), r2) : Ma;
}
var zc;
var Rc;
var Mc = true;
function Lc(e2) {
  if (Mc) {
    let t2;
    for (zc = new Ea(512), Rc = new Ea(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
    for (; t2 < 256; ) e2.lens[t2++] = 9;
    for (; t2 < 280; ) e2.lens[t2++] = 7;
    for (; t2 < 288; ) e2.lens[t2++] = 8;
    for (Zo(Qo, e2.lens, 0, 288, zc, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
    Zo(Yo, e2.lens, 0, 32, Rc, 0, e2.work, { bits: 5 }), Mc = false;
  }
  e2.lencode = zc, e2.lenbits = 9, e2.distcode = Rc, e2.distbits = 5;
}
function Nc(e2, t2, r2, n2) {
  let i2;
  const a2 = e2.state;
  return null === a2.window && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new Aa(a2.wsize)), n2 >= a2.wsize ? (Ka(a2.window, t2, r2 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : (i2 = a2.wsize - a2.wnext, i2 > n2 && (i2 = n2), Ka(a2.window, t2, r2 - n2, i2, a2.wnext), (n2 -= i2) ? (Ka(a2.window, t2, r2 - n2, n2, 0), a2.wnext = n2, a2.whave = a2.wsize) : (a2.wnext += i2, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += i2))), 0;
}
function Oc(e2, t2) {
  let r2, n2, i2, a2, s2, o2, c2, h2, u2, l2, y2, d2, p2, f2, g2, m2, w2, b2, k2, v2, A2, _2, E2, S2, K2 = 0, x2 = new Aa(4);
  const P2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return Ma;
  r2 = e2.state, r2.mode === uc && (r2.mode = lc), s2 = e2.next_out, i2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, h2 = r2.hold, u2 = r2.bits, l2 = o2, y2 = c2, _2 = Ba;
  e: for (; ; ) switch (r2.mode) {
    case Jo:
      if (0 === r2.wrap) {
        r2.mode = lc;
        break;
      }
      for (; u2 < 16; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if (2 & r2.wrap && 35615 === h2) {
        r2.check = 0, x2[0] = 255 & h2, x2[1] = h2 >>> 8 & 255, r2.check = Zs(r2.check, x2, 2, 0), h2 = 0, u2 = 0, r2.mode = ec;
        break;
      }
      if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & h2) << 8) + (h2 >> 8)) % 31) {
        e2.msg = "incorrect header check", r2.mode = Pc;
        break;
      }
      if ((15 & h2) !== $a) {
        e2.msg = "unknown compression method", r2.mode = Pc;
        break;
      }
      if (h2 >>>= 4, u2 -= 4, A2 = 8 + (15 & h2), 0 === r2.wbits) r2.wbits = A2;
      else if (A2 > r2.wbits) {
        e2.msg = "invalid window size", r2.mode = Pc;
        break;
      }
      r2.dmax = 1 << A2, e2.adler = r2.check = 1, r2.mode = 512 & h2 ? cc : uc, h2 = 0, u2 = 0;
      break;
    case ec:
      for (; u2 < 16; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if (r2.flags = h2, (255 & r2.flags) !== $a) {
        e2.msg = "unknown compression method", r2.mode = Pc;
        break;
      }
      if (57344 & r2.flags) {
        e2.msg = "unknown header flags set", r2.mode = Pc;
        break;
      }
      r2.head && (r2.head.text = h2 >> 8 & 1), 512 & r2.flags && (x2[0] = 255 & h2, x2[1] = h2 >>> 8 & 255, r2.check = Zs(r2.check, x2, 2, 0)), h2 = 0, u2 = 0, r2.mode = tc;
    case tc:
      for (; u2 < 32; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      r2.head && (r2.head.time = h2), 512 & r2.flags && (x2[0] = 255 & h2, x2[1] = h2 >>> 8 & 255, x2[2] = h2 >>> 16 & 255, x2[3] = h2 >>> 24 & 255, r2.check = Zs(r2.check, x2, 4, 0)), h2 = 0, u2 = 0, r2.mode = rc;
    case rc:
      for (; u2 < 16; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      r2.head && (r2.head.xflags = 255 & h2, r2.head.os = h2 >> 8), 512 & r2.flags && (x2[0] = 255 & h2, x2[1] = h2 >>> 8 & 255, r2.check = Zs(r2.check, x2, 2, 0)), h2 = 0, u2 = 0, r2.mode = nc;
    case nc:
      if (1024 & r2.flags) {
        for (; u2 < 16; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        r2.length = h2, r2.head && (r2.head.extra_len = h2), 512 & r2.flags && (x2[0] = 255 & h2, x2[1] = h2 >>> 8 & 255, r2.check = Zs(r2.check, x2, 2, 0)), h2 = 0, u2 = 0;
      } else r2.head && (r2.head.extra = null);
      r2.mode = ic;
    case ic:
      if (1024 & r2.flags && (d2 = r2.length, d2 > o2 && (d2 = o2), d2 && (r2.head && (A2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = Array(r2.head.extra_len)), Ka(r2.head.extra, n2, a2, d2, A2)), 512 & r2.flags && (r2.check = Zs(r2.check, n2, d2, a2)), o2 -= d2, a2 += d2, r2.length -= d2), r2.length)) break e;
      r2.length = 0, r2.mode = ac;
    case ac:
      if (2048 & r2.flags) {
        if (0 === o2) break e;
        d2 = 0;
        do {
          A2 = n2[a2 + d2++], r2.head && A2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(A2));
        } while (A2 && d2 < o2);
        if (512 & r2.flags && (r2.check = Zs(r2.check, n2, d2, a2)), o2 -= d2, a2 += d2, A2) break e;
      } else r2.head && (r2.head.name = null);
      r2.length = 0, r2.mode = sc;
    case sc:
      if (4096 & r2.flags) {
        if (0 === o2) break e;
        d2 = 0;
        do {
          A2 = n2[a2 + d2++], r2.head && A2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(A2));
        } while (A2 && d2 < o2);
        if (512 & r2.flags && (r2.check = Zs(r2.check, n2, d2, a2)), o2 -= d2, a2 += d2, A2) break e;
      } else r2.head && (r2.head.comment = null);
      r2.mode = oc;
    case oc:
      if (512 & r2.flags) {
        for (; u2 < 16; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        if (h2 !== (65535 & r2.check)) {
          e2.msg = "header crc mismatch", r2.mode = Pc;
          break;
        }
        h2 = 0, u2 = 0;
      }
      r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = uc;
      break;
    case cc:
      for (; u2 < 32; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      e2.adler = r2.check = Cc(h2), h2 = 0, u2 = 0, r2.mode = hc;
    case hc:
      if (0 === r2.havedict) return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = h2, r2.bits = u2, Ra;
      e2.adler = r2.check = 1, r2.mode = uc;
    case uc:
      if (t2 === Ia || t2 === Ta) break e;
    case lc:
      if (r2.last) {
        h2 >>>= 7 & u2, u2 -= 7 & u2, r2.mode = Sc;
        break;
      }
      for (; u2 < 3; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      switch (r2.last = 1 & h2, h2 >>>= 1, u2 -= 1, 3 & h2) {
        case 0:
          r2.mode = yc;
          break;
        case 1:
          if (Lc(r2), r2.mode = wc, t2 === Ta) {
            h2 >>>= 2, u2 -= 2;
            break e;
          }
          break;
        case 2:
          r2.mode = fc;
          break;
        case 3:
          e2.msg = "invalid block type", r2.mode = Pc;
      }
      h2 >>>= 2, u2 -= 2;
      break;
    case yc:
      for (h2 >>>= 7 & u2, u2 -= 7 & u2; u2 < 32; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if ((65535 & h2) != (h2 >>> 16 ^ 65535)) {
        e2.msg = "invalid stored block lengths", r2.mode = Pc;
        break;
      }
      if (r2.length = 65535 & h2, h2 = 0, u2 = 0, r2.mode = dc, t2 === Ta) break e;
    case dc:
      r2.mode = pc;
    case pc:
      if (d2 = r2.length, d2) {
        if (d2 > o2 && (d2 = o2), d2 > c2 && (d2 = c2), 0 === d2) break e;
        Ka(i2, n2, a2, d2, s2), o2 -= d2, a2 += d2, c2 -= d2, s2 += d2, r2.length -= d2;
        break;
      }
      r2.mode = uc;
      break;
    case fc:
      for (; u2 < 14; ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if (r2.nlen = 257 + (31 & h2), h2 >>>= 5, u2 -= 5, r2.ndist = 1 + (31 & h2), h2 >>>= 5, u2 -= 5, r2.ncode = 4 + (15 & h2), h2 >>>= 4, u2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
        e2.msg = "too many length or distance symbols", r2.mode = Pc;
        break;
      }
      r2.have = 0, r2.mode = gc;
    case gc:
      for (; r2.have < r2.ncode; ) {
        for (; u2 < 3; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        r2.lens[P2[r2.have++]] = 7 & h2, h2 >>>= 3, u2 -= 3;
      }
      for (; r2.have < 19; ) r2.lens[P2[r2.have++]] = 0;
      if (r2.lencode = r2.lendyn, r2.lenbits = 7, E2 = { bits: r2.lenbits }, _2 = Zo(Xo, r2.lens, 0, 19, r2.lencode, 0, r2.work, E2), r2.lenbits = E2.bits, _2) {
        e2.msg = "invalid code lengths set", r2.mode = Pc;
        break;
      }
      r2.have = 0, r2.mode = mc;
    case mc:
      for (; r2.have < r2.nlen + r2.ndist; ) {
        for (; K2 = r2.lencode[h2 & (1 << r2.lenbits) - 1], g2 = K2 >>> 24, m2 = K2 >>> 16 & 255, w2 = 65535 & K2, !(g2 <= u2); ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        if (w2 < 16) h2 >>>= g2, u2 -= g2, r2.lens[r2.have++] = w2;
        else {
          if (16 === w2) {
            for (S2 = g2 + 2; u2 < S2; ) {
              if (0 === o2) break e;
              o2--, h2 += n2[a2++] << u2, u2 += 8;
            }
            if (h2 >>>= g2, u2 -= g2, 0 === r2.have) {
              e2.msg = "invalid bit length repeat", r2.mode = Pc;
              break;
            }
            A2 = r2.lens[r2.have - 1], d2 = 3 + (3 & h2), h2 >>>= 2, u2 -= 2;
          } else if (17 === w2) {
            for (S2 = g2 + 3; u2 < S2; ) {
              if (0 === o2) break e;
              o2--, h2 += n2[a2++] << u2, u2 += 8;
            }
            h2 >>>= g2, u2 -= g2, A2 = 0, d2 = 3 + (7 & h2), h2 >>>= 3, u2 -= 3;
          } else {
            for (S2 = g2 + 7; u2 < S2; ) {
              if (0 === o2) break e;
              o2--, h2 += n2[a2++] << u2, u2 += 8;
            }
            h2 >>>= g2, u2 -= g2, A2 = 0, d2 = 11 + (127 & h2), h2 >>>= 7, u2 -= 7;
          }
          if (r2.have + d2 > r2.nlen + r2.ndist) {
            e2.msg = "invalid bit length repeat", r2.mode = Pc;
            break;
          }
          for (; d2--; ) r2.lens[r2.have++] = A2;
        }
      }
      if (r2.mode === Pc) break;
      if (0 === r2.lens[256]) {
        e2.msg = "invalid code -- missing end-of-block", r2.mode = Pc;
        break;
      }
      if (r2.lenbits = 9, E2 = { bits: r2.lenbits }, _2 = Zo(Qo, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, E2), r2.lenbits = E2.bits, _2) {
        e2.msg = "invalid literal/lengths set", r2.mode = Pc;
        break;
      }
      if (r2.distbits = 6, r2.distcode = r2.distdyn, E2 = { bits: r2.distbits }, _2 = Zo(Yo, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, E2), r2.distbits = E2.bits, _2) {
        e2.msg = "invalid distances set", r2.mode = Pc;
        break;
      }
      if (r2.mode = wc, t2 === Ta) break e;
    case wc:
      r2.mode = bc;
    case bc:
      if (o2 >= 6 && c2 >= 258) {
        e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = h2, r2.bits = u2, Lo(e2, y2), s2 = e2.next_out, i2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, h2 = r2.hold, u2 = r2.bits, r2.mode === uc && (r2.back = -1);
        break;
      }
      for (r2.back = 0; K2 = r2.lencode[h2 & (1 << r2.lenbits) - 1], g2 = K2 >>> 24, m2 = K2 >>> 16 & 255, w2 = 65535 & K2, !(g2 <= u2); ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if (m2 && 0 == (240 & m2)) {
        for (b2 = g2, k2 = m2, v2 = w2; K2 = r2.lencode[v2 + ((h2 & (1 << b2 + k2) - 1) >> b2)], g2 = K2 >>> 24, m2 = K2 >>> 16 & 255, w2 = 65535 & K2, !(b2 + g2 <= u2); ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        h2 >>>= b2, u2 -= b2, r2.back += b2;
      }
      if (h2 >>>= g2, u2 -= g2, r2.back += g2, r2.length = w2, 0 === m2) {
        r2.mode = Ec;
        break;
      }
      if (32 & m2) {
        r2.back = -1, r2.mode = uc;
        break;
      }
      if (64 & m2) {
        e2.msg = "invalid literal/length code", r2.mode = Pc;
        break;
      }
      r2.extra = 15 & m2, r2.mode = kc;
    case kc:
      if (r2.extra) {
        for (S2 = r2.extra; u2 < S2; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        r2.length += h2 & (1 << r2.extra) - 1, h2 >>>= r2.extra, u2 -= r2.extra, r2.back += r2.extra;
      }
      r2.was = r2.length, r2.mode = vc;
    case vc:
      for (; K2 = r2.distcode[h2 & (1 << r2.distbits) - 1], g2 = K2 >>> 24, m2 = K2 >>> 16 & 255, w2 = 65535 & K2, !(g2 <= u2); ) {
        if (0 === o2) break e;
        o2--, h2 += n2[a2++] << u2, u2 += 8;
      }
      if (0 == (240 & m2)) {
        for (b2 = g2, k2 = m2, v2 = w2; K2 = r2.distcode[v2 + ((h2 & (1 << b2 + k2) - 1) >> b2)], g2 = K2 >>> 24, m2 = K2 >>> 16 & 255, w2 = 65535 & K2, !(b2 + g2 <= u2); ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        h2 >>>= b2, u2 -= b2, r2.back += b2;
      }
      if (h2 >>>= g2, u2 -= g2, r2.back += g2, 64 & m2) {
        e2.msg = "invalid distance code", r2.mode = Pc;
        break;
      }
      r2.offset = w2, r2.extra = 15 & m2, r2.mode = Ac;
    case Ac:
      if (r2.extra) {
        for (S2 = r2.extra; u2 < S2; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        r2.offset += h2 & (1 << r2.extra) - 1, h2 >>>= r2.extra, u2 -= r2.extra, r2.back += r2.extra;
      }
      if (r2.offset > r2.dmax) {
        e2.msg = "invalid distance too far back", r2.mode = Pc;
        break;
      }
      r2.mode = _c;
    case _c:
      if (0 === c2) break e;
      if (d2 = y2 - c2, r2.offset > d2) {
        if (d2 = r2.offset - d2, d2 > r2.whave && r2.sane) {
          e2.msg = "invalid distance too far back", r2.mode = Pc;
          break;
        }
        d2 > r2.wnext ? (d2 -= r2.wnext, p2 = r2.wsize - d2) : p2 = r2.wnext - d2, d2 > r2.length && (d2 = r2.length), f2 = r2.window;
      } else f2 = i2, p2 = s2 - r2.offset, d2 = r2.length;
      d2 > c2 && (d2 = c2), c2 -= d2, r2.length -= d2;
      do {
        i2[s2++] = f2[p2++];
      } while (--d2);
      0 === r2.length && (r2.mode = bc);
      break;
    case Ec:
      if (0 === c2) break e;
      i2[s2++] = r2.length, c2--, r2.mode = bc;
      break;
    case Sc:
      if (r2.wrap) {
        for (; u2 < 32; ) {
          if (0 === o2) break e;
          o2--, h2 |= n2[a2++] << u2, u2 += 8;
        }
        if (y2 -= c2, e2.total_out += y2, r2.total += y2, y2 && (e2.adler = r2.check = r2.flags ? Zs(r2.check, i2, y2, s2 - y2) : Ws(r2.check, i2, y2, s2 - y2)), y2 = c2, (r2.flags ? h2 : Cc(h2)) !== r2.check) {
          e2.msg = "incorrect data check", r2.mode = Pc;
          break;
        }
        h2 = 0, u2 = 0;
      }
      r2.mode = Kc;
    case Kc:
      if (r2.wrap && r2.flags) {
        for (; u2 < 32; ) {
          if (0 === o2) break e;
          o2--, h2 += n2[a2++] << u2, u2 += 8;
        }
        if (h2 !== (4294967295 & r2.total)) {
          e2.msg = "incorrect length check", r2.mode = Pc;
          break;
        }
        h2 = 0, u2 = 0;
      }
      r2.mode = xc;
    case xc:
      _2 = za;
      break e;
    case Pc:
      _2 = La;
      break e;
    default:
      return Ma;
  }
  return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = h2, r2.bits = u2, (r2.wsize || y2 !== e2.avail_out && r2.mode < Pc && (r2.mode < Sc || t2 !== Ca)) && Nc(e2, e2.output, e2.next_out, y2 - e2.avail_out), l2 -= e2.avail_in, y2 -= e2.avail_out, e2.total_in += l2, e2.total_out += y2, r2.total += y2, r2.wrap && y2 && (e2.adler = r2.check = r2.flags ? Zs(r2.check, i2, y2, e2.next_out - y2) : Ws(r2.check, i2, y2, e2.next_out - y2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === uc ? 128 : 0) + (r2.mode === wc || r2.mode === dc ? 256 : 0), (0 === l2 && 0 === y2 || t2 === Ca) && _2 === Ba && (_2 = Na), _2;
}
function Fc(e2, t2) {
  const r2 = t2.length;
  let n2, i2;
  return e2 && e2.state ? (n2 = e2.state, 0 !== n2.wrap && n2.mode !== hc ? Ma : n2.mode === hc && (i2 = 1, i2 = Ws(i2, t2, r2, 0), i2 !== n2.check) ? La : (Nc(e2, t2, r2, r2), n2.havedict = 1, Ba)) : Ma;
}
var Hc = class {
  constructor() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  }
};
var jc = class {
  constructor(e2) {
    this.options = { chunkSize: 16384, windowBits: 0, ...e2 || {} };
    const t2 = this.options;
    t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Bo(), this.strm.avail_out = 0;
    let r2 = Bc(this.strm, t2.windowBits);
    if (r2 !== Ba) throw Error(Xs[r2]);
    if (this.header = new Hc(), function(e3, t3) {
      let r3;
      e3 && e3.state && (r3 = e3.state, 0 == (2 & r3.wrap) || (r3.head = t3, t3.done = false));
    }(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = To(t2.dictionary) : t2.dictionary instanceof ArrayBuffer && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (r2 = Fc(this.strm, t2.dictionary), r2 !== Ba))) throw Error(Xs[r2]);
  }
  push(e2, t2) {
    const { strm: r2, options: { chunkSize: n2, dictionary: i2 } } = this;
    let a2, s2, o2 = false;
    if (this.ended) return false;
    s2 = t2 === ~~t2 ? t2 : true === t2 ? Ca : xa, "string" == typeof e2 ? r2.input = function(e3) {
      const t3 = new Aa(e3.length);
      for (let r3 = 0, n3 = t3.length; r3 < n3; r3++) t3[r3] = e3.charCodeAt(r3);
      return t3;
    }(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
    do {
      if (0 === r2.avail_out && (r2.output = new Aa(n2), r2.next_out = 0, r2.avail_out = n2), a2 = Oc(r2, xa), a2 === Ra && i2 && (a2 = Fc(this.strm, i2)), a2 === Na && true === o2 && (a2 = Ba, o2 = false), a2 !== za && a2 !== Ba) return this.onEnd(a2), this.ended = true, false;
      r2.next_out && (0 !== r2.avail_out && a2 !== za && (0 !== r2.avail_in || s2 !== Ca && s2 !== Ua) || this.onData(ba(r2.output, r2.next_out))), 0 === r2.avail_in && 0 === r2.avail_out && (o2 = true);
    } while ((r2.avail_in > 0 || 0 === r2.avail_out) && a2 !== za);
    return a2 === za && (s2 = Ca), s2 === Ca ? (a2 = function(e3) {
      if (!e3 || !e3.state) return Ma;
      const t3 = e3.state;
      return t3.window && (t3.window = null), e3.state = null, Ba;
    }(this.strm), this.onEnd(a2), this.ended = true, a2 === Ba) : s2 !== Ua || (this.onEnd(Ba), r2.avail_out = 0, true);
  }
  onData(e2) {
    this.chunks.push(e2);
  }
  onEnd(e2) {
    e2 === Ba && (this.result = Sa(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
  }
};
var qc = [0, 1, 3, 7, 15, 31, 63, 127, 255];
var Gc = function(e2) {
  this.stream = e2, this.bitOffset = 0, this.curByte = 0, this.hasByte = false;
};
Gc.prototype._ensureByte = function() {
  this.hasByte || (this.curByte = this.stream.readByte(), this.hasByte = true);
}, Gc.prototype.read = function(e2) {
  for (var t2 = 0; e2 > 0; ) {
    this._ensureByte();
    var r2 = 8 - this.bitOffset;
    if (e2 >= r2) t2 <<= r2, t2 |= qc[r2] & this.curByte, this.hasByte = false, this.bitOffset = 0, e2 -= r2;
    else {
      t2 <<= e2;
      var n2 = r2 - e2;
      t2 |= (this.curByte & qc[e2] << n2) >> n2, this.bitOffset += e2, e2 = 0;
    }
  }
  return t2;
}, Gc.prototype.seek = function(e2) {
  var t2 = e2 % 8, r2 = (e2 - t2) / 8;
  this.bitOffset = t2, this.stream.seek(r2), this.hasByte = false;
}, Gc.prototype.pi = function() {
  var e2, t2 = new Uint8Array(6);
  for (e2 = 0; e2 < t2.length; e2++) t2[e2] = this.read(8);
  return function(e3) {
    return Array.prototype.map.call(e3, (e4) => ("00" + e4.toString(16)).slice(-2)).join("");
  }(t2);
};
var Vc = Gc;
var Wc = function() {
};
Wc.prototype.readByte = function() {
  throw Error("abstract method readByte() not implemented");
}, Wc.prototype.read = function(e2, t2, r2) {
  for (var n2 = 0; n2 < r2; ) {
    var i2 = this.readByte();
    if (i2 < 0) return 0 === n2 ? -1 : n2;
    e2[t2++] = i2, n2++;
  }
  return n2;
}, Wc.prototype.seek = function(e2) {
  throw Error("abstract method seek() not implemented");
}, Wc.prototype.writeByte = function(e2) {
  throw Error("abstract method readByte() not implemented");
}, Wc.prototype.write = function(e2, t2, r2) {
  var n2;
  for (n2 = 0; n2 < r2; n2++) this.writeByte(e2[t2++]);
  return r2;
}, Wc.prototype.flush = function() {
};
var $c;
var Zc = Wc;
var Xc = ($c = new Uint32Array([0, 79764919, 159529838, 222504665, 319059676, 398814059, 445009330, 507990021, 638119352, 583659535, 797628118, 726387553, 890018660, 835552979, 1015980042, 944750013, 1276238704, 1221641927, 1167319070, 1095957929, 1595256236, 1540665371, 1452775106, 1381403509, 1780037320, 1859660671, 1671105958, 1733955601, 2031960084, 2111593891, 1889500026, 1952343757, 2552477408, 2632100695, 2443283854, 2506133561, 2334638140, 2414271883, 2191915858, 2254759653, 3190512472, 3135915759, 3081330742, 3009969537, 2905550212, 2850959411, 2762807018, 2691435357, 3560074640, 3505614887, 3719321342, 3648080713, 3342211916, 3287746299, 3467911202, 3396681109, 4063920168, 4143685023, 4223187782, 4286162673, 3779000052, 3858754371, 3904687514, 3967668269, 881225847, 809987520, 1023691545, 969234094, 662832811, 591600412, 771767749, 717299826, 311336399, 374308984, 453813921, 533576470, 25881363, 88864420, 134795389, 214552010, 2023205639, 2086057648, 1897238633, 1976864222, 1804852699, 1867694188, 1645340341, 1724971778, 1587496639, 1516133128, 1461550545, 1406951526, 1302016099, 1230646740, 1142491917, 1087903418, 2896545431, 2825181984, 2770861561, 2716262478, 3215044683, 3143675388, 3055782693, 3001194130, 2326604591, 2389456536, 2200899649, 2280525302, 2578013683, 2640855108, 2418763421, 2498394922, 3769900519, 3832873040, 3912640137, 3992402750, 4088425275, 4151408268, 4197601365, 4277358050, 3334271071, 3263032808, 3476998961, 3422541446, 3585640067, 3514407732, 3694837229, 3640369242, 1762451694, 1842216281, 1619975040, 1682949687, 2047383090, 2127137669, 1938468188, 2001449195, 1325665622, 1271206113, 1183200824, 1111960463, 1543535498, 1489069629, 1434599652, 1363369299, 622672798, 568075817, 748617968, 677256519, 907627842, 853037301, 1067152940, 995781531, 51762726, 131386257, 177728840, 240578815, 269590778, 349224269, 429104020, 491947555, 4046411278, 4126034873, 4172115296, 4234965207, 3794477266, 3874110821, 3953728444, 4016571915, 3609705398, 3555108353, 3735388376, 3664026991, 3290680682, 3236090077, 3449943556, 3378572211, 3174993278, 3120533705, 3032266256, 2961025959, 2923101090, 2868635157, 2813903052, 2742672763, 2604032198, 2683796849, 2461293480, 2524268063, 2284983834, 2364738477, 2175806836, 2238787779, 1569362073, 1498123566, 1409854455, 1355396672, 1317987909, 1246755826, 1192025387, 1137557660, 2072149281, 2135122070, 1912620623, 1992383480, 1753615357, 1816598090, 1627664531, 1707420964, 295390185, 358241886, 404320391, 483945776, 43990325, 106832002, 186451547, 266083308, 932423249, 861060070, 1041341759, 986742920, 613929101, 542559546, 756411363, 701822548, 3316196985, 3244833742, 3425377559, 3370778784, 3601682597, 3530312978, 3744426955, 3689838204, 3819031489, 3881883254, 3928223919, 4007849240, 4037393693, 4100235434, 4180117107, 4259748804, 2310601993, 2373574846, 2151335527, 2231098320, 2596047829, 2659030626, 2470359227, 2550115596, 2947551409, 2876312838, 2788305887, 2733848168, 3165939309, 3094707162, 3040238851, 2985771188]), function() {
  var e2 = 4294967295;
  this.getCRC = function() {
    return ~e2 >>> 0;
  }, this.updateCRC = function(t2) {
    e2 = e2 << 8 ^ $c[255 & (e2 >>> 24 ^ t2)];
  }, this.updateCRCRun = function(t2, r2) {
    for (; r2-- > 0; ) e2 = e2 << 8 ^ $c[255 & (e2 >>> 24 ^ t2)];
  };
});
var Qc = function(e2, t2) {
  var r2, n2 = e2[t2];
  for (r2 = t2; r2 > 0; r2--) e2[r2] = e2[r2 - 1];
  return e2[0] = n2, n2;
};
var Yc = { OK: 0, LAST_BLOCK: -1, NOT_BZIP_DATA: -2, UNEXPECTED_INPUT_EOF: -3, UNEXPECTED_OUTPUT_EOF: -4, DATA_ERROR: -5, OUT_OF_MEMORY: -6, OBSOLETE_INPUT: -7, END_OF_BLOCK: -8 };
var Jc = {};
Jc[Yc.LAST_BLOCK] = "Bad file checksum", Jc[Yc.NOT_BZIP_DATA] = "Not bzip data", Jc[Yc.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF", Jc[Yc.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF", Jc[Yc.DATA_ERROR] = "Data error", Jc[Yc.OUT_OF_MEMORY] = "Out of memory", Jc[Yc.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
var eh = function(e2, t2) {
  var r2 = Jc[e2] || "unknown error";
  t2 && (r2 += ": " + t2);
  var n2 = new TypeError(r2);
  throw n2.errorCode = e2, n2;
};
var th = function(e2, t2) {
  this.writePos = this.writeCurrent = this.writeCount = 0, this._start_bunzip(e2, t2);
};
th.prototype._init_block = function() {
  return this._get_next_block() ? (this.blockCRC = new Xc(), true) : (this.writeCount = -1, false);
}, th.prototype._start_bunzip = function(e2, t2) {
  var r2 = new Uint8Array(4);
  4 === e2.read(r2, 0, 4) && "BZh" === String.fromCharCode(r2[0], r2[1], r2[2]) || eh(Yc.NOT_BZIP_DATA, "bad magic");
  var n2 = r2[3] - 48;
  (n2 < 1 || n2 > 9) && eh(Yc.NOT_BZIP_DATA, "level out of range"), this.reader = new Vc(e2), this.dbufSize = 1e5 * n2, this.nextoutput = 0, this.outputStream = t2, this.streamCRC = 0;
}, th.prototype._get_next_block = function() {
  var e2, t2, r2, n2 = this.reader, i2 = n2.pi();
  if ("177245385090" === i2) return false;
  "314159265359" !== i2 && eh(Yc.NOT_BZIP_DATA), this.targetBlockCRC = n2.read(32) >>> 0, this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0, n2.read(1) && eh(Yc.OBSOLETE_INPUT);
  var a2 = n2.read(24);
  a2 > this.dbufSize && eh(Yc.DATA_ERROR, "initial position out of bounds");
  var s2 = n2.read(16), o2 = new Uint8Array(256), c2 = 0;
  for (e2 = 0; e2 < 16; e2++) if (s2 & 1 << 15 - e2) {
    var h2 = 16 * e2;
    for (r2 = n2.read(16), t2 = 0; t2 < 16; t2++) r2 & 1 << 15 - t2 && (o2[c2++] = h2 + t2);
  }
  var u2 = n2.read(3);
  (u2 < 2 || u2 > 6) && eh(Yc.DATA_ERROR);
  var l2 = n2.read(15);
  0 === l2 && eh(Yc.DATA_ERROR);
  var y2 = new Uint8Array(256);
  for (e2 = 0; e2 < u2; e2++) y2[e2] = e2;
  var d2 = new Uint8Array(l2);
  for (e2 = 0; e2 < l2; e2++) {
    for (t2 = 0; n2.read(1); t2++) t2 >= u2 && eh(Yc.DATA_ERROR);
    d2[e2] = Qc(y2, t2);
  }
  var p2, f2 = c2 + 2, g2 = [];
  for (t2 = 0; t2 < u2; t2++) {
    var m2, w2, b2 = new Uint8Array(f2), k2 = new Uint16Array(21);
    for (s2 = n2.read(5), e2 = 0; e2 < f2; e2++) {
      for (; (s2 < 1 || s2 > 20) && eh(Yc.DATA_ERROR), n2.read(1); ) n2.read(1) ? s2-- : s2++;
      b2[e2] = s2;
    }
    for (m2 = w2 = b2[0], e2 = 1; e2 < f2; e2++) b2[e2] > w2 ? w2 = b2[e2] : b2[e2] < m2 && (m2 = b2[e2]);
    p2 = {}, g2.push(p2), p2.permute = new Uint16Array(258), p2.limit = new Uint32Array(22), p2.base = new Uint32Array(21), p2.minLen = m2, p2.maxLen = w2;
    var v2 = 0;
    for (e2 = m2; e2 <= w2; e2++) for (k2[e2] = p2.limit[e2] = 0, s2 = 0; s2 < f2; s2++) b2[s2] === e2 && (p2.permute[v2++] = s2);
    for (e2 = 0; e2 < f2; e2++) k2[b2[e2]]++;
    for (v2 = s2 = 0, e2 = m2; e2 < w2; e2++) v2 += k2[e2], p2.limit[e2] = v2 - 1, v2 <<= 1, s2 += k2[e2], p2.base[e2 + 1] = v2 - s2;
    p2.limit[w2 + 1] = Number.MAX_VALUE, p2.limit[w2] = v2 + k2[w2] - 1, p2.base[m2] = 0;
  }
  var A2 = new Uint32Array(256);
  for (e2 = 0; e2 < 256; e2++) y2[e2] = e2;
  var _2, E2 = 0, S2 = 0, K2 = 0, x2 = this.dbuf = new Uint32Array(this.dbufSize);
  for (f2 = 0; ; ) {
    for (f2-- || (f2 = 49, K2 >= l2 && eh(Yc.DATA_ERROR), p2 = g2[d2[K2++]]), e2 = p2.minLen, t2 = n2.read(e2); e2 > p2.maxLen && eh(Yc.DATA_ERROR), !(t2 <= p2.limit[e2]); e2++) t2 = t2 << 1 | n2.read(1);
    ((t2 -= p2.base[e2]) < 0 || t2 >= 258) && eh(Yc.DATA_ERROR);
    var P2 = p2.permute[t2];
    if (0 !== P2 && 1 !== P2) {
      if (E2) for (E2 = 0, S2 + s2 > this.dbufSize && eh(Yc.DATA_ERROR), A2[_2 = o2[y2[0]]] += s2; s2--; ) x2[S2++] = _2;
      if (P2 > c2) break;
      S2 >= this.dbufSize && eh(Yc.DATA_ERROR), A2[_2 = o2[_2 = Qc(y2, e2 = P2 - 1)]]++, x2[S2++] = _2;
    } else E2 || (E2 = 1, s2 = 0), s2 += 0 === P2 ? E2 : 2 * E2, E2 <<= 1;
  }
  for ((a2 < 0 || a2 >= S2) && eh(Yc.DATA_ERROR), t2 = 0, e2 = 0; e2 < 256; e2++) r2 = t2 + A2[e2], A2[e2] = t2, t2 = r2;
  for (e2 = 0; e2 < S2; e2++) x2[A2[_2 = 255 & x2[e2]]] |= e2 << 8, A2[_2]++;
  var U2 = 0, D2 = 0, C2 = 0;
  return S2 && (D2 = 255 & (U2 = x2[a2]), U2 >>= 8, C2 = -1), this.writePos = U2, this.writeCurrent = D2, this.writeCount = S2, this.writeRun = C2, true;
}, th.prototype._read_bunzip = function(e2, t2) {
  var r2, n2, i2;
  if (this.writeCount < 0) return 0;
  var a2 = this.dbuf, s2 = this.writePos, o2 = this.writeCurrent, c2 = this.writeCount;
  this.outputsize;
  for (var h2 = this.writeRun; c2; ) {
    for (c2--, n2 = o2, o2 = 255 & (s2 = a2[s2]), s2 >>= 8, 3 == h2++ ? (r2 = o2, i2 = n2, o2 = -1) : (r2 = 1, i2 = o2), this.blockCRC.updateCRCRun(i2, r2); r2--; ) this.outputStream.writeByte(i2), this.nextoutput++;
    o2 != n2 && (h2 = 0);
  }
  return this.writeCount = c2, this.blockCRC.getCRC() !== this.targetBlockCRC && eh(Yc.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")"), this.nextoutput;
};
var rh = function(e2) {
  if ("readByte" in e2) return e2;
  var t2 = new Zc();
  return t2.pos = 0, t2.readByte = function() {
    return e2[this.pos++];
  }, t2.seek = function(e3) {
    this.pos = e3;
  }, t2.eof = function() {
    return this.pos >= e2.length;
  }, t2;
};
var nh = function(e2) {
  var t2 = new Zc(), r2 = true;
  if (e2) if ("number" == typeof e2) t2.buffer = new Uint8Array(e2), r2 = false;
  else {
    if ("writeByte" in e2) return e2;
    t2.buffer = e2, r2 = false;
  }
  else t2.buffer = new Uint8Array(16384);
  return t2.pos = 0, t2.writeByte = function(e3) {
    if (r2 && this.pos >= this.buffer.length) {
      var t3 = new Uint8Array(2 * this.buffer.length);
      t3.set(this.buffer), this.buffer = t3;
    }
    this.buffer[this.pos++] = e3;
  }, t2.getBuffer = function() {
    if (this.pos !== this.buffer.length) {
      if (!r2) throw new TypeError("outputsize does not match decoded input");
      var e3 = new Uint8Array(this.pos);
      e3.set(this.buffer.subarray(0, this.pos)), this.buffer = e3;
    }
    return this.buffer;
  }, t2._coerced = true, t2;
};
var ih = function(e2, t2, r2) {
  for (var n2 = rh(e2), i2 = nh(t2), a2 = new th(n2, i2); !("eof" in n2) || !n2.eof(); ) if (a2._init_block()) a2._read_bunzip();
  else {
    var s2 = a2.reader.read(32) >>> 0;
    if (s2 !== a2.streamCRC && eh(Yc.DATA_ERROR, "Bad stream CRC (got " + a2.streamCRC.toString(16) + " expected " + s2.toString(16) + ")"), !r2 || !("eof" in n2) || n2.eof()) break;
    a2._start_bunzip(n2, i2);
  }
  if ("getBuffer" in i2) return i2.getBuffer();
};
var ah = class {
  static get tag() {
    return $.packet.literalData;
  }
  constructor(e2 = /* @__PURE__ */ new Date()) {
    this.format = $.literal.utf8, this.date = X.normalizeDate(e2), this.text = null, this.data = null, this.filename = "";
  }
  setText(e2, t2 = $.literal.utf8) {
    this.format = t2, this.text = e2, this.data = null;
  }
  getText(e2 = false) {
    return (null === this.text || X.isStream(this.text)) && (this.text = X.decodeUTF8(X.nativeEOL(this.getBytes(e2)))), this.text;
  }
  setBytes(e2, t2) {
    this.format = t2, this.data = e2, this.text = null;
  }
  getBytes(e2 = false) {
    return null === this.data && (this.data = X.canonicalizeEOL(X.encodeUTF8(this.text))), e2 ? N(this.data) : this.data;
  }
  setFilename(e2) {
    this.filename = e2;
  }
  getFilename() {
    return this.filename;
  }
  async read(e2) {
    await M(e2, async (e3) => {
      const t2 = await e3.readByte(), r2 = await e3.readByte();
      this.filename = X.decodeUTF8(await e3.readBytes(r2)), this.date = X.readDate(await e3.readBytes(4));
      let n2 = e3.remainder();
      s(n2) && (n2 = await H(n2)), this.setBytes(n2, t2);
    });
  }
  writeHeader() {
    const e2 = X.encodeUTF8(this.filename), t2 = new Uint8Array([e2.length]), r2 = new Uint8Array([this.format]), n2 = X.writeDate(this.date);
    return X.concatUint8Array([r2, t2, e2, n2]);
  }
  write() {
    const e2 = this.writeHeader(), t2 = this.getBytes();
    return X.concat([e2, t2]);
  }
};
var sh = Symbol("verified");
var oh = /* @__PURE__ */ new Set([$.signatureSubpacket.issuer, $.signatureSubpacket.issuerFingerprint, $.signatureSubpacket.embeddedSignature]);
var ch = class _ch {
  static get tag() {
    return $.packet.signature;
  }
  constructor() {
    this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.signatureData = null, this.unhashedSubpackets = [], this.signedHashValue = null, this.created = null, this.signatureExpirationTime = null, this.signatureNeverExpires = true, this.exportable = null, this.trustLevel = null, this.trustAmount = null, this.regularExpression = null, this.revocable = null, this.keyExpirationTime = null, this.keyNeverExpires = null, this.preferredSymmetricAlgorithms = null, this.revocationKeyClass = null, this.revocationKeyAlgorithm = null, this.revocationKeyFingerprint = null, this.issuerKeyID = new pe(), this.rawNotations = [], this.notations = {}, this.preferredHashAlgorithms = null, this.preferredCompressionAlgorithms = null, this.keyServerPreferences = null, this.preferredKeyServer = null, this.isPrimaryUserID = null, this.policyURI = null, this.keyFlags = null, this.signersUserID = null, this.reasonForRevocationFlag = null, this.reasonForRevocationString = null, this.features = null, this.signatureTargetPublicKeyAlgorithm = null, this.signatureTargetHashAlgorithm = null, this.signatureTargetHash = null, this.embeddedSignature = null, this.issuerKeyVersion = null, this.issuerFingerprint = null, this.preferredAEADAlgorithms = null, this.revoked = null, this[sh] = null;
  }
  read(e2) {
    let t2 = 0;
    if (this.version = e2[t2++], 4 !== this.version && 5 !== this.version) throw new fi(`Version ${this.version} of the signature packet is unsupported.`);
    if (this.signatureType = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.hashAlgorithm = e2[t2++], t2 += this.readSubPackets(e2.subarray(t2, e2.length), true), !this.created) throw Error("Missing signature creation time subpacket.");
    this.signatureData = e2.subarray(0, t2), t2 += this.readSubPackets(e2.subarray(t2, e2.length), false), this.signedHashValue = e2.subarray(t2, t2 + 2), t2 += 2, this.params = ma.signature.parseSignatureParams(this.publicKeyAlgorithm, e2.subarray(t2, e2.length));
  }
  writeParams() {
    return this.params instanceof Promise ? q(async () => ma.serializeParams(this.publicKeyAlgorithm, await this.params)) : ma.serializeParams(this.publicKeyAlgorithm, this.params);
  }
  write() {
    const e2 = [];
    return e2.push(this.signatureData), e2.push(this.writeUnhashedSubPackets()), e2.push(this.signedHashValue), e2.push(this.writeParams()), X.concat(e2);
  }
  async sign(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = false) {
    5 === e2.version ? this.version = 5 : this.version = 4;
    const i2 = [new Uint8Array([this.version, this.signatureType, this.publicKeyAlgorithm, this.hashAlgorithm])];
    this.created = X.normalizeDate(r2), this.issuerKeyVersion = e2.version, this.issuerFingerprint = e2.getFingerprintBytes(), this.issuerKeyID = e2.getKeyID(), i2.push(this.writeHashedSubPackets()), this.unhashedSubpackets = [], this.signatureData = X.concat(i2);
    const a2 = this.toHash(this.signatureType, t2, n2), s2 = await this.hash(this.signatureType, t2, a2, n2);
    this.signedHashValue = F(L(s2), 0, 2);
    const o2 = async () => ma.signature.sign(this.publicKeyAlgorithm, this.hashAlgorithm, e2.publicParams, e2.privateParams, a2, await H(s2));
    X.isStream(s2) ? this.params = o2() : (this.params = await o2(), this[sh] = true);
  }
  writeHashedSubPackets() {
    const e2 = $.signatureSubpacket, t2 = [];
    let r2;
    if (null === this.created) throw Error("Missing signature creation time");
    t2.push(hh(e2.signatureCreationTime, true, X.writeDate(this.created))), null !== this.signatureExpirationTime && t2.push(hh(e2.signatureExpirationTime, true, X.writeNumber(this.signatureExpirationTime, 4))), null !== this.exportable && t2.push(hh(e2.exportableCertification, true, new Uint8Array([this.exportable ? 1 : 0]))), null !== this.trustLevel && (r2 = new Uint8Array([this.trustLevel, this.trustAmount]), t2.push(hh(e2.trustSignature, true, r2))), null !== this.regularExpression && t2.push(hh(e2.regularExpression, true, this.regularExpression)), null !== this.revocable && t2.push(hh(e2.revocable, true, new Uint8Array([this.revocable ? 1 : 0]))), null !== this.keyExpirationTime && t2.push(hh(e2.keyExpirationTime, true, X.writeNumber(this.keyExpirationTime, 4))), null !== this.preferredSymmetricAlgorithms && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.preferredSymmetricAlgorithms)), t2.push(hh(e2.preferredSymmetricAlgorithms, false, r2))), null !== this.revocationKeyClass && (r2 = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]), r2 = X.concat([r2, this.revocationKeyFingerprint]), t2.push(hh(e2.revocationKey, false, r2))), this.issuerKeyID.isNull() || 5 === this.issuerKeyVersion || t2.push(hh(e2.issuer, true, this.issuerKeyID.write())), this.rawNotations.forEach(({ name: n3, value: i3, humanReadable: a2, critical: s2 }) => {
      r2 = [new Uint8Array([a2 ? 128 : 0, 0, 0, 0])];
      const o2 = X.encodeUTF8(n3);
      r2.push(X.writeNumber(o2.length, 2)), r2.push(X.writeNumber(i3.length, 2)), r2.push(o2), r2.push(i3), r2 = X.concat(r2), t2.push(hh(e2.notationData, s2, r2));
    }), null !== this.preferredHashAlgorithms && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.preferredHashAlgorithms)), t2.push(hh(e2.preferredHashAlgorithms, false, r2))), null !== this.preferredCompressionAlgorithms && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.preferredCompressionAlgorithms)), t2.push(hh(e2.preferredCompressionAlgorithms, false, r2))), null !== this.keyServerPreferences && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.keyServerPreferences)), t2.push(hh(e2.keyServerPreferences, false, r2))), null !== this.preferredKeyServer && t2.push(hh(e2.preferredKeyServer, false, X.encodeUTF8(this.preferredKeyServer))), null !== this.isPrimaryUserID && t2.push(hh(e2.primaryUserID, false, new Uint8Array([this.isPrimaryUserID ? 1 : 0]))), null !== this.policyURI && t2.push(hh(e2.policyURI, false, X.encodeUTF8(this.policyURI))), null !== this.keyFlags && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.keyFlags)), t2.push(hh(e2.keyFlags, true, r2))), null !== this.signersUserID && t2.push(hh(e2.signersUserID, false, X.encodeUTF8(this.signersUserID))), null !== this.reasonForRevocationFlag && (r2 = X.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString), t2.push(hh(e2.reasonForRevocation, true, r2))), null !== this.features && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.features)), t2.push(hh(e2.features, false, r2))), null !== this.signatureTargetPublicKeyAlgorithm && (r2 = [new Uint8Array([this.signatureTargetPublicKeyAlgorithm, this.signatureTargetHashAlgorithm])], r2.push(X.stringToUint8Array(this.signatureTargetHash)), r2 = X.concat(r2), t2.push(hh(e2.signatureTarget, true, r2))), null !== this.embeddedSignature && t2.push(hh(e2.embeddedSignature, true, this.embeddedSignature.write())), null !== this.issuerFingerprint && (r2 = [new Uint8Array([this.issuerKeyVersion]), this.issuerFingerprint], r2 = X.concat(r2), t2.push(hh(e2.issuerFingerprint, 5 === this.version, r2))), null !== this.preferredAEADAlgorithms && (r2 = X.stringToUint8Array(X.uint8ArrayToString(this.preferredAEADAlgorithms)), t2.push(hh(e2.preferredAEADAlgorithms, false, r2)));
    const n2 = X.concat(t2), i2 = X.writeNumber(n2.length, 2);
    return X.concat([i2, n2]);
  }
  writeUnhashedSubPackets() {
    const e2 = [];
    this.unhashedSubpackets.forEach((t3) => {
      e2.push(hi(t3.length)), e2.push(t3);
    });
    const t2 = X.concat(e2), r2 = X.writeNumber(t2.length, 2);
    return X.concat([r2, t2]);
  }
  readSubPacket(e2, t2 = true) {
    let r2 = 0;
    const n2 = !!(128 & e2[r2]), i2 = 127 & e2[r2];
    if (t2 || (this.unhashedSubpackets.push(e2.subarray(r2, e2.length)), oh.has(i2))) switch (r2++, i2) {
      case $.signatureSubpacket.signatureCreationTime:
        this.created = X.readDate(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.signatureExpirationTime: {
        const t3 = X.readNumber(e2.subarray(r2, e2.length));
        this.signatureNeverExpires = 0 === t3, this.signatureExpirationTime = t3;
        break;
      }
      case $.signatureSubpacket.exportableCertification:
        this.exportable = 1 === e2[r2++];
        break;
      case $.signatureSubpacket.trustSignature:
        this.trustLevel = e2[r2++], this.trustAmount = e2[r2++];
        break;
      case $.signatureSubpacket.regularExpression:
        this.regularExpression = e2[r2];
        break;
      case $.signatureSubpacket.revocable:
        this.revocable = 1 === e2[r2++];
        break;
      case $.signatureSubpacket.keyExpirationTime: {
        const t3 = X.readNumber(e2.subarray(r2, e2.length));
        this.keyExpirationTime = t3, this.keyNeverExpires = 0 === t3;
        break;
      }
      case $.signatureSubpacket.preferredSymmetricAlgorithms:
        this.preferredSymmetricAlgorithms = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.revocationKey:
        this.revocationKeyClass = e2[r2++], this.revocationKeyAlgorithm = e2[r2++], this.revocationKeyFingerprint = e2.subarray(r2, r2 + 20);
        break;
      case $.signatureSubpacket.issuer:
        this.issuerKeyID.read(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.notationData: {
        const t3 = !!(128 & e2[r2]);
        r2 += 4;
        const i3 = X.readNumber(e2.subarray(r2, r2 + 2));
        r2 += 2;
        const a2 = X.readNumber(e2.subarray(r2, r2 + 2));
        r2 += 2;
        const s2 = X.decodeUTF8(e2.subarray(r2, r2 + i3)), o2 = e2.subarray(r2 + i3, r2 + i3 + a2);
        this.rawNotations.push({ name: s2, humanReadable: t3, value: o2, critical: n2 }), t3 && (this.notations[s2] = X.decodeUTF8(o2));
        break;
      }
      case $.signatureSubpacket.preferredHashAlgorithms:
        this.preferredHashAlgorithms = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.preferredCompressionAlgorithms:
        this.preferredCompressionAlgorithms = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.keyServerPreferences:
        this.keyServerPreferences = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.preferredKeyServer:
        this.preferredKeyServer = X.decodeUTF8(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.primaryUserID:
        this.isPrimaryUserID = 0 !== e2[r2++];
        break;
      case $.signatureSubpacket.policyURI:
        this.policyURI = X.decodeUTF8(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.keyFlags:
        this.keyFlags = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.signersUserID:
        this.signersUserID = X.decodeUTF8(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.reasonForRevocation:
        this.reasonForRevocationFlag = e2[r2++], this.reasonForRevocationString = X.decodeUTF8(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.features:
        this.features = [...e2.subarray(r2, e2.length)];
        break;
      case $.signatureSubpacket.signatureTarget: {
        this.signatureTargetPublicKeyAlgorithm = e2[r2++], this.signatureTargetHashAlgorithm = e2[r2++];
        const t3 = ma.getHashByteLength(this.signatureTargetHashAlgorithm);
        this.signatureTargetHash = X.uint8ArrayToString(e2.subarray(r2, r2 + t3));
        break;
      }
      case $.signatureSubpacket.embeddedSignature:
        this.embeddedSignature = new _ch(), this.embeddedSignature.read(e2.subarray(r2, e2.length));
        break;
      case $.signatureSubpacket.issuerFingerprint:
        this.issuerKeyVersion = e2[r2++], this.issuerFingerprint = e2.subarray(r2, e2.length), 5 === this.issuerKeyVersion ? this.issuerKeyID.read(this.issuerFingerprint) : this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));
        break;
      case $.signatureSubpacket.preferredAEADAlgorithms:
        this.preferredAEADAlgorithms = [...e2.subarray(r2, e2.length)];
        break;
      default: {
        const e3 = Error("Unknown signature subpacket type " + i2);
        if (n2) throw e3;
        X.printDebug(e3);
      }
    }
  }
  readSubPackets(e2, t2 = true, r2) {
    const n2 = X.readNumber(e2.subarray(0, 2));
    let i2 = 2;
    for (; i2 < 2 + n2; ) {
      const n3 = ci(e2.subarray(i2, e2.length));
      i2 += n3.offset, this.readSubPacket(e2.subarray(i2, i2 + n3.len), t2, r2), i2 += n3.len;
    }
    return i2;
  }
  toSign(e2, t2) {
    const r2 = $.signature;
    switch (e2) {
      case r2.binary:
        return null !== t2.text ? X.encodeUTF8(t2.getText(true)) : t2.getBytes(true);
      case r2.text: {
        const e3 = t2.getBytes(true);
        return X.canonicalizeEOL(e3);
      }
      case r2.standalone:
        return new Uint8Array(0);
      case r2.certGeneric:
      case r2.certPersona:
      case r2.certCasual:
      case r2.certPositive:
      case r2.certRevocation: {
        let e3, n2;
        if (t2.userID) n2 = 180, e3 = t2.userID;
        else {
          if (!t2.userAttribute) throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");
          n2 = 209, e3 = t2.userAttribute;
        }
        const i2 = e3.write();
        return X.concat([this.toSign(r2.key, t2), new Uint8Array([n2]), X.writeNumber(i2.length, 4), i2]);
      }
      case r2.subkeyBinding:
      case r2.subkeyRevocation:
      case r2.keyBinding:
        return X.concat([this.toSign(r2.key, t2), this.toSign(r2.key, { key: t2.bind })]);
      case r2.key:
        if (void 0 === t2.key) throw Error("Key packet is required for this signature.");
        return t2.key.writeForHash(this.version);
      case r2.keyRevocation:
        return this.toSign(r2.key, t2);
      case r2.timestamp:
        return new Uint8Array(0);
      case r2.thirdParty:
        throw Error("Not implemented");
      default:
        throw Error("Unknown signature type.");
    }
  }
  calculateTrailer(e2, t2) {
    let r2 = 0;
    return z(L(this.signatureData), (e3) => {
      r2 += e3.length;
    }, () => {
      const n2 = [];
      return 5 !== this.version || this.signatureType !== $.signature.binary && this.signatureType !== $.signature.text || (t2 ? n2.push(new Uint8Array(6)) : n2.push(e2.writeHeader())), n2.push(new Uint8Array([this.version, 255])), 5 === this.version && n2.push(new Uint8Array(4)), n2.push(X.writeNumber(r2, 4)), X.concat(n2);
    });
  }
  toHash(e2, t2, r2 = false) {
    const n2 = this.toSign(e2, t2);
    return X.concat([n2, this.signatureData, this.calculateTrailer(t2, r2)]);
  }
  async hash(e2, t2, r2, n2 = false) {
    return r2 || (r2 = this.toHash(e2, t2, n2)), ma.hash.digest(this.hashAlgorithm, r2);
  }
  async verify(e2, t2, r2, n2 = /* @__PURE__ */ new Date(), i2 = false, a2 = ie) {
    if (!this.issuerKeyID.equals(e2.getKeyID())) throw Error("Signature was not issued by the given public key");
    if (this.publicKeyAlgorithm !== e2.algorithm) throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");
    const s2 = t2 === $.signature.binary || t2 === $.signature.text;
    if (!(this[sh] && !s2)) {
      let n3, a3;
      if (this.hashed ? a3 = await this.hashed : (n3 = this.toHash(t2, r2, i2), a3 = await this.hash(t2, r2, n3)), a3 = await H(a3), this.signedHashValue[0] !== a3[0] || this.signedHashValue[1] !== a3[1]) throw Error("Signed digest did not match");
      if (this.params = await this.params, this[sh] = await ma.signature.verify(this.publicKeyAlgorithm, this.hashAlgorithm, this.params, e2.publicParams, n3, a3), !this[sh]) throw Error("Signature verification failed");
    }
    const o2 = X.normalizeDate(n2);
    if (o2 && this.created > o2) throw Error("Signature creation time is in the future");
    if (o2 && o2 >= this.getExpirationTime()) throw Error("Signature is expired");
    if (a2.rejectHashAlgorithms.has(this.hashAlgorithm)) throw Error("Insecure hash algorithm: " + $.read($.hash, this.hashAlgorithm).toUpperCase());
    if (a2.rejectMessageHashAlgorithms.has(this.hashAlgorithm) && [$.signature.binary, $.signature.text].includes(this.signatureType)) throw Error("Insecure message hash algorithm: " + $.read($.hash, this.hashAlgorithm).toUpperCase());
    if (this.rawNotations.forEach(({ name: e3, critical: t3 }) => {
      if (t3 && a2.knownNotations.indexOf(e3) < 0) throw Error("Unknown critical notation: " + e3);
    }), null !== this.revocationKeyClass) throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.");
  }
  isExpired(e2 = /* @__PURE__ */ new Date()) {
    const t2 = X.normalizeDate(e2);
    return null !== t2 && !(this.created <= t2 && t2 < this.getExpirationTime());
  }
  getExpirationTime() {
    return this.signatureNeverExpires ? 1 / 0 : new Date(this.created.getTime() + 1e3 * this.signatureExpirationTime);
  }
};
function hh(e2, t2, r2) {
  const n2 = [];
  return n2.push(hi(r2.length + 1)), n2.push(new Uint8Array([(t2 ? 128 : 0) | e2])), n2.push(r2), X.concat(n2);
}
var uh = class {
  static get tag() {
    return $.packet.onePassSignature;
  }
  constructor() {
    this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.issuerKeyID = null, this.flags = null;
  }
  read(e2) {
    let t2 = 0;
    if (this.version = e2[t2++], 3 !== this.version) throw new fi(`Version ${this.version} of the one-pass signature packet is unsupported.`);
    return this.signatureType = e2[t2++], this.hashAlgorithm = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.issuerKeyID = new pe(), this.issuerKeyID.read(e2.subarray(t2, t2 + 8)), t2 += 8, this.flags = e2[t2++], this;
  }
  write() {
    const e2 = new Uint8Array([3, this.signatureType, this.hashAlgorithm, this.publicKeyAlgorithm]), t2 = new Uint8Array([this.flags]);
    return X.concatUint8Array([e2, this.issuerKeyID.write(), t2]);
  }
  calculateTrailer(...e2) {
    return q(async () => ch.prototype.calculateTrailer.apply(await this.correspondingSig, e2));
  }
  async verify() {
    const e2 = await this.correspondingSig;
    if (!e2 || e2.constructor.tag !== $.packet.signature) throw Error("Corresponding signature packet missing");
    if (e2.signatureType !== this.signatureType || e2.hashAlgorithm !== this.hashAlgorithm || e2.publicKeyAlgorithm !== this.publicKeyAlgorithm || !e2.issuerKeyID.equals(this.issuerKeyID)) throw Error("Corresponding signature packet does not match one-pass signature packet");
    return e2.hashed = this.hashed, e2.verify.apply(e2, arguments);
  }
};
function lh(e2, t2) {
  if (!t2[e2]) {
    let t3;
    try {
      t3 = $.read($.packet, e2);
    } catch (t4) {
      throw new fi("Unknown packet type with tag: " + e2);
    }
    throw Error("Packet not allowed in this context: " + t3);
  }
  return new t2[e2]();
}
uh.prototype.hash = ch.prototype.hash, uh.prototype.toHash = ch.prototype.toHash, uh.prototype.toSign = ch.prototype.toSign;
var yh = class _yh extends Array {
  static async fromBinary(e2, t2, r2 = ie) {
    const n2 = new _yh();
    return await n2.read(e2, t2, r2), n2;
  }
  async read(e2, t2, r2 = ie) {
    r2.additionalAllowedPackets.length && (t2 = { ...t2, ...X.constructAllowedPackets(r2.additionalAllowedPackets) }), this.stream = R(e2, async (e3, n3) => {
      const i2 = C(n3);
      try {
        for (; ; ) {
          await i2.ready;
          if (await pi(e3, async (e4) => {
            try {
              if (e4.tag === $.packet.marker || e4.tag === $.packet.trust) return;
              const n4 = lh(e4.tag, t2);
              n4.packets = new _yh(), n4.fromStream = X.isStream(e4.packet), await n4.read(e4.packet, r2), await i2.write(n4);
            } catch (t3) {
              const n4 = !r2.ignoreUnsupportedPackets && t3 instanceof fi, a2 = !(r2.ignoreMalformedPackets || t3 instanceof fi);
              if (n4 || a2 || di(e4.tag)) await i2.abort(t3);
              else {
                const t4 = new gi(e4.tag, e4.packet);
                await i2.write(t4);
              }
              X.printDebugError(t3);
            }
          })) return await i2.ready, void await i2.close();
        }
      } catch (e4) {
        await i2.abort(e4);
      }
    });
    const n2 = D(this.stream);
    for (; ; ) {
      const { done: e3, value: t3 } = await n2.read();
      if (e3 ? this.stream = null : this.push(t3), e3 || di(t3.constructor.tag)) break;
    }
    n2.releaseLock();
  }
  write() {
    const e2 = [];
    for (let t2 = 0; t2 < this.length; t2++) {
      const r2 = this[t2] instanceof gi ? this[t2].tag : this[t2].constructor.tag, n2 = this[t2].write();
      if (X.isStream(n2) && di(this[t2].constructor.tag)) {
        let t3 = [], i2 = 0;
        const a2 = 512;
        e2.push(li(r2)), e2.push(z(n2, (e3) => {
          if (t3.push(e3), i2 += e3.length, i2 >= a2) {
            const e4 = Math.min(Math.log(i2) / Math.LN2 | 0, 30), r3 = 2 ** e4, n3 = X.concat([ui(e4)].concat(t3));
            return t3 = [n3.subarray(1 + r3)], i2 = t3[0].length, n3.subarray(0, 1 + r3);
          }
        }, () => X.concat([hi(i2)].concat(t3))));
      } else {
        if (X.isStream(n2)) {
          let t3 = 0;
          e2.push(z(L(n2), (e3) => {
            t3 += e3.length;
          }, () => yi(r2, t3)));
        } else e2.push(yi(r2, n2.length));
        e2.push(n2);
      }
    }
    return X.concat(e2);
  }
  filterByTag(...e2) {
    const t2 = new _yh(), r2 = (e3) => (t3) => e3 === t3;
    for (let n2 = 0; n2 < this.length; n2++) e2.some(r2(this[n2].constructor.tag)) && t2.push(this[n2]);
    return t2;
  }
  findPacket(e2) {
    return this.find((t2) => t2.constructor.tag === e2);
  }
  indexOfTag(...e2) {
    const t2 = [], r2 = this, n2 = (e3) => (t3) => e3 === t3;
    for (let i2 = 0; i2 < this.length; i2++) e2.some(n2(r2[i2].constructor.tag)) && t2.push(i2);
    return t2;
  }
};
var dh = X.constructAllowedPackets([ah, uh, ch]);
var ph = class {
  static get tag() {
    return $.packet.compressedData;
  }
  constructor(e2 = ie) {
    this.packets = null, this.algorithm = e2.preferredCompressionAlgorithm, this.compressed = null, this.deflateLevel = e2.deflateLevel;
  }
  async read(e2, t2 = ie) {
    await M(e2, async (e3) => {
      this.algorithm = await e3.readByte(), this.compressed = e3.remainder(), await this.decompress(t2);
    });
  }
  write() {
    return null === this.compressed && this.compress(), X.concat([new Uint8Array([this.algorithm]), this.compressed]);
  }
  async decompress(e2 = ie) {
    const t2 = $.read($.compression, this.algorithm), r2 = vh[t2];
    if (!r2) throw Error(t2 + " decompression not supported");
    this.packets = await yh.fromBinary(r2(this.compressed), dh, e2);
  }
  compress() {
    const e2 = $.read($.compression, this.algorithm), t2 = kh[e2];
    if (!t2) throw Error(e2 + " compression not supported");
    this.compressed = t2(this.packets.write(), this.deflateLevel);
  }
};
var fh = X.getNodeZlib();
function gh(e2) {
  return e2;
}
function mh(e2, t2, r2 = {}) {
  return function(n2) {
    return !X.isStream(n2) || s(n2) ? q(() => H(n2).then((t3) => new Promise((n3, i2) => {
      e2(t3, r2, (e3, t4) => {
        if (e3) return i2(e3);
        n3(t4);
      });
    }))) : f(g(n2).pipe(t2(r2)));
  };
}
function wh(e2, t2 = {}) {
  return function(r2) {
    const n2 = new e2(t2);
    return z(r2, (e3) => {
      if (e3.length) return n2.push(e3, Ua), n2.result;
    }, () => {
      if (e2 === zo) return n2.push([], Ca), n2.result;
    });
  };
}
function bh(e2) {
  return function(t2) {
    return q(async () => e2(await H(t2)));
  };
}
var kh = fh ? { zip: (e2, t2) => mh(fh.deflateRaw, fh.createDeflateRaw, { level: t2 })(e2), zlib: (e2, t2) => mh(fh.deflate, fh.createDeflate, { level: t2 })(e2) } : { zip: (e2, t2) => wh(zo, { raw: true, level: t2 })(e2), zlib: (e2, t2) => wh(zo, { level: t2 })(e2) };
var vh = fh ? { uncompressed: gh, zip: mh(fh.inflateRaw, fh.createInflateRaw), zlib: mh(fh.inflate, fh.createInflate), bzip2: bh(ih) } : { uncompressed: gh, zip: wh(jc, { raw: true }), zlib: wh(jc), bzip2: bh(ih) };
var Ah = X.constructAllowedPackets([ah, ph, uh, ch]);
var _h = class {
  static get tag() {
    return $.packet.symEncryptedIntegrityProtectedData;
  }
  constructor() {
    this.version = 1, this.encrypted = null, this.packets = null;
  }
  async read(e2) {
    await M(e2, async (e3) => {
      const t2 = await e3.readByte();
      if (1 !== t2) throw new fi(`Version ${t2} of the SEIP packet is unsupported.`);
      this.encrypted = e3.remainder();
    });
  }
  write() {
    return X.concat([new Uint8Array([1]), this.encrypted]);
  }
  async encrypt(e2, t2, r2 = ie) {
    const { blockSize: n2 } = ma.getCipher(e2);
    let i2 = this.packets.write();
    s(i2) && (i2 = await H(i2));
    const a2 = await ma.getPrefixRandom(e2), o2 = new Uint8Array([211, 20]), c2 = X.concat([a2, i2, o2]), h2 = await ma.hash.sha1(N(c2)), u2 = X.concat([c2, h2]);
    return this.encrypted = await ma.mode.cfb.encrypt(e2, t2, u2, new Uint8Array(n2), r2), true;
  }
  async decrypt(e2, t2, r2 = ie) {
    const { blockSize: n2 } = ma.getCipher(e2);
    let i2 = L(this.encrypted);
    s(i2) && (i2 = await H(i2));
    const a2 = await ma.mode.cfb.decrypt(e2, t2, i2, new Uint8Array(n2)), o2 = F(N(a2), -20), c2 = F(a2, 0, -20), h2 = Promise.all([H(await ma.hash.sha1(N(c2))), H(o2)]).then(([e3, t3]) => {
      if (!X.equalsUint8Array(e3, t3)) throw Error("Modification detected.");
      return new Uint8Array();
    }), u2 = F(c2, n2 + 2);
    let l2 = F(u2, 0, -2);
    return l2 = U([l2, q(() => h2)]), X.isStream(i2) && r2.allowUnauthenticatedStream || (l2 = await H(l2)), this.packets = await yh.fromBinary(l2, Ah, r2), true;
  }
};
var Eh = X.constructAllowedPackets([ah, ph, uh, ch]);
var Sh = class _Sh {
  static get tag() {
    return $.packet.aeadEncryptedData;
  }
  constructor() {
    this.version = 1, this.cipherAlgorithm = null, this.aeadAlgorithm = $.aead.eax, this.chunkSizeByte = null, this.iv = null, this.encrypted = null, this.packets = null;
  }
  async read(e2) {
    await M(e2, async (e3) => {
      const t2 = await e3.readByte();
      if (1 !== t2) throw new fi(`Version ${t2} of the AEAD-encrypted data packet is not supported.`);
      this.cipherAlgorithm = await e3.readByte(), this.aeadAlgorithm = await e3.readByte(), this.chunkSizeByte = await e3.readByte();
      const r2 = ma.getAEADMode(this.aeadAlgorithm);
      this.iv = await e3.readBytes(r2.ivLength), this.encrypted = e3.remainder();
    });
  }
  write() {
    return X.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.iv, this.encrypted]);
  }
  async decrypt(e2, t2, r2 = ie) {
    this.packets = await yh.fromBinary(await this.crypt("decrypt", t2, L(this.encrypted)), Eh, r2);
  }
  async encrypt(e2, t2, r2 = ie) {
    this.cipherAlgorithm = e2;
    const { ivLength: n2 } = ma.getAEADMode(this.aeadAlgorithm);
    this.iv = ma.random.getRandomBytes(n2), this.chunkSizeByte = r2.aeadChunkSizeByte;
    const i2 = this.packets.write();
    this.encrypted = await this.crypt("encrypt", t2, i2);
  }
  async crypt(e2, t2, r2) {
    const n2 = ma.getAEADMode(this.aeadAlgorithm), i2 = await n2(this.cipherAlgorithm, t2), a2 = "decrypt" === e2 ? n2.tagLength : 0, s2 = "encrypt" === e2 ? n2.tagLength : 0, o2 = 2 ** (this.chunkSizeByte + 6) + a2, c2 = new ArrayBuffer(21), h2 = new Uint8Array(c2, 0, 13), u2 = new Uint8Array(c2), l2 = new DataView(c2), y2 = new Uint8Array(c2, 5, 8);
    h2.set([192 | _Sh.tag, this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte], 0);
    let d2 = 0, p2 = Promise.resolve(), f2 = 0, g2 = 0;
    const m2 = this.iv;
    return R(r2, async (t3, r3) => {
      if ("array" !== X.isStream(t3)) {
        const e3 = new E({}, { highWaterMark: X.getHardwareConcurrency() * 2 ** (this.chunkSizeByte + 6), size: (e4) => e4.length });
        I(e3.readable, r3), r3 = e3.writable;
      }
      const c3 = D(t3), w2 = C(r3);
      try {
        for (; ; ) {
          let t4 = await c3.readBytes(o2 + a2) || new Uint8Array();
          const r4 = t4.subarray(t4.length - a2);
          let b2, k2;
          if (t4 = t4.subarray(0, t4.length - a2), !d2 || t4.length ? (c3.unshift(r4), b2 = i2[e2](t4, n2.getNonce(m2, y2), h2), g2 += t4.length - a2 + s2) : (l2.setInt32(17, f2), b2 = i2[e2](r4, n2.getNonce(m2, y2), u2), g2 += s2, k2 = true), f2 += t4.length - a2, p2 = p2.then(() => b2).then(async (e3) => {
            await w2.ready, await w2.write(e3), g2 -= e3.length;
          }).catch((e3) => w2.abort(e3)), (k2 || g2 > w2.desiredSize) && await p2, k2) {
            await w2.close();
            break;
          }
          l2.setInt32(9, ++d2);
        }
      } catch (e3) {
        await w2.abort(e3);
      }
    });
  }
};
var Kh = class {
  static get tag() {
    return $.packet.publicKeyEncryptedSessionKey;
  }
  constructor() {
    this.version = 3, this.publicKeyID = new pe(), this.publicKeyAlgorithm = null, this.sessionKey = null, this.sessionKeyAlgorithm = null, this.encrypted = {};
  }
  read(e2) {
    let t2 = 0;
    if (this.version = e2[t2++], 3 !== this.version) throw new fi(`Version ${this.version} of the PKESK packet is unsupported.`);
    t2 += this.publicKeyID.read(e2.subarray(t2)), this.publicKeyAlgorithm = e2[t2++], this.encrypted = ma.parseEncSessionKeyParams(this.publicKeyAlgorithm, e2.subarray(t2), this.version), this.publicKeyAlgorithm === $.publicKey.x25519 && (this.sessionKeyAlgorithm = $.write($.symmetric, this.encrypted.C.algorithm));
  }
  write() {
    const e2 = [new Uint8Array([this.version]), this.publicKeyID.write(), new Uint8Array([this.publicKeyAlgorithm]), ma.serializeParams(this.publicKeyAlgorithm, this.encrypted)];
    return X.concatUint8Array(e2);
  }
  async encrypt(e2) {
    const t2 = $.write($.publicKey, this.publicKeyAlgorithm), r2 = xh(this.version, t2, this.sessionKeyAlgorithm, this.sessionKey);
    this.encrypted = await ma.publicKeyEncrypt(t2, this.sessionKeyAlgorithm, e2.publicParams, r2, e2.getFingerprintBytes());
  }
  async decrypt(e2, t2) {
    if (this.publicKeyAlgorithm !== e2.algorithm) throw Error("Decryption error");
    const r2 = t2 ? xh(this.version, this.publicKeyAlgorithm, t2.sessionKeyAlgorithm, t2.sessionKey) : null, n2 = await ma.publicKeyDecrypt(this.publicKeyAlgorithm, e2.publicParams, e2.privateParams, this.encrypted, e2.getFingerprintBytes(), r2), { sessionKey: i2, sessionKeyAlgorithm: a2 } = function(e3, t3, r3, n3) {
      switch (t3) {
        case $.publicKey.rsaEncrypt:
        case $.publicKey.rsaEncryptSign:
        case $.publicKey.elgamal:
        case $.publicKey.ecdh: {
          const e4 = r3.subarray(0, r3.length - 2), t4 = r3.subarray(r3.length - 2), i3 = X.writeChecksum(e4.subarray(e4.length % 8)), a3 = i3[0] === t4[0] & i3[1] === t4[1], s2 = { sessionKeyAlgorithm: e4[0], sessionKey: e4.subarray(1) };
          if (n3) {
            const e5 = a3 & s2.sessionKeyAlgorithm === n3.sessionKeyAlgorithm & s2.sessionKey.length === n3.sessionKey.length;
            return { sessionKey: X.selectUint8Array(e5, s2.sessionKey, n3.sessionKey), sessionKeyAlgorithm: X.selectUint8(e5, s2.sessionKeyAlgorithm, n3.sessionKeyAlgorithm) };
          }
          if (a3 && $.read($.symmetric, s2.sessionKeyAlgorithm)) return s2;
          throw Error("Decryption error");
        }
        case $.publicKey.x25519:
          return { sessionKey: r3 };
        default:
          throw Error("Unsupported public key algorithm");
      }
    }(this.version, this.publicKeyAlgorithm, n2, t2);
    this.publicKeyAlgorithm !== $.publicKey.x25519 && (this.sessionKeyAlgorithm = a2), this.sessionKey = i2;
  }
};
function xh(e2, t2, r2, n2) {
  switch (t2) {
    case $.publicKey.rsaEncrypt:
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.elgamal:
    case $.publicKey.ecdh:
      return X.concatUint8Array([new Uint8Array([r2]), n2, X.writeChecksum(n2.subarray(n2.length % 8))]);
    case $.publicKey.x25519:
      return n2;
    default:
      throw Error("Unsupported public key algorithm");
  }
}
var Ph = class {
  constructor(e2 = ie) {
    this.algorithm = $.hash.sha256, this.type = "iterated", this.c = e2.s2kIterationCountByte, this.salt = null;
  }
  getCount() {
    return 16 + (15 & this.c) << 6 + (this.c >> 4);
  }
  read(e2) {
    let t2 = 0;
    try {
      this.type = $.read($.s2k, e2[t2++]);
    } catch (e3) {
      throw new fi("Unknown S2K type.");
    }
    switch (this.algorithm = e2[t2++], this.type) {
      case "simple":
        break;
      case "salted":
        this.salt = e2.subarray(t2, t2 + 8), t2 += 8;
        break;
      case "iterated":
        this.salt = e2.subarray(t2, t2 + 8), t2 += 8, this.c = e2[t2++];
        break;
      case "gnu":
        if ("GNU" !== X.uint8ArrayToString(e2.subarray(t2, t2 + 3))) throw new fi("Unknown s2k type.");
        t2 += 3;
        if (1001 !== 1e3 + e2[t2++]) throw new fi("Unknown s2k gnu protection mode.");
        this.type = "gnu-dummy";
        break;
      default:
        throw new fi("Unknown s2k type.");
    }
    return t2;
  }
  write() {
    if ("gnu-dummy" === this.type) return new Uint8Array([101, 0, ...X.stringToUint8Array("GNU"), 1]);
    const e2 = [new Uint8Array([$.write($.s2k, this.type), this.algorithm])];
    switch (this.type) {
      case "simple":
        break;
      case "salted":
        e2.push(this.salt);
        break;
      case "iterated":
        e2.push(this.salt), e2.push(new Uint8Array([this.c]));
        break;
      case "gnu":
        throw Error("GNU s2k type not supported.");
      default:
        throw Error("Unknown s2k type.");
    }
    return X.concatUint8Array(e2);
  }
  async produceKey(e2, t2) {
    e2 = X.encodeUTF8(e2);
    const r2 = [];
    let n2 = 0, i2 = 0;
    for (; n2 < t2; ) {
      let t3;
      switch (this.type) {
        case "simple":
          t3 = X.concatUint8Array([new Uint8Array(i2), e2]);
          break;
        case "salted":
          t3 = X.concatUint8Array([new Uint8Array(i2), this.salt, e2]);
          break;
        case "iterated": {
          const r3 = X.concatUint8Array([this.salt, e2]);
          let n3 = r3.length;
          const a3 = Math.max(this.getCount(), n3);
          t3 = new Uint8Array(i2 + a3), t3.set(r3, i2);
          for (let e3 = i2 + n3; e3 < a3; e3 += n3, n3 *= 2) t3.copyWithin(e3, i2, e3);
          break;
        }
        case "gnu":
          throw Error("GNU s2k type not supported.");
        default:
          throw Error("Unknown s2k type.");
      }
      const a2 = await ma.hash.digest(this.algorithm, t3);
      r2.push(a2), n2 += a2.length, i2++;
    }
    return X.concatUint8Array(r2).subarray(0, t2);
  }
};
var Uh = class _Uh {
  static get tag() {
    return $.packet.symEncryptedSessionKey;
  }
  constructor(e2 = ie) {
    this.version = e2.aeadProtect ? 5 : 4, this.sessionKey = null, this.sessionKeyEncryptionAlgorithm = null, this.sessionKeyAlgorithm = $.symmetric.aes256, this.aeadAlgorithm = $.write($.aead, e2.preferredAEADAlgorithm), this.encrypted = null, this.s2k = null, this.iv = null;
  }
  read(e2) {
    let t2 = 0;
    if (this.version = e2[t2++], 4 !== this.version && 5 !== this.version) throw new fi(`Version ${this.version} of the SKESK packet is unsupported.`);
    const r2 = e2[t2++];
    if (5 === this.version && (this.aeadAlgorithm = e2[t2++]), this.s2k = new Ph(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), 5 === this.version) {
      const r3 = ma.getAEADMode(this.aeadAlgorithm);
      this.iv = e2.subarray(t2, t2 += r3.ivLength);
    }
    5 === this.version || t2 < e2.length ? (this.encrypted = e2.subarray(t2, e2.length), this.sessionKeyEncryptionAlgorithm = r2) : this.sessionKeyAlgorithm = r2;
  }
  write() {
    const e2 = null === this.encrypted ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;
    let t2;
    return 5 === this.version ? t2 = X.concatUint8Array([new Uint8Array([this.version, e2, this.aeadAlgorithm]), this.s2k.write(), this.iv, this.encrypted]) : (t2 = X.concatUint8Array([new Uint8Array([this.version, e2]), this.s2k.write()]), null !== this.encrypted && (t2 = X.concatUint8Array([t2, this.encrypted]))), t2;
  }
  async decrypt(e2) {
    const t2 = null !== this.sessionKeyEncryptionAlgorithm ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm, { blockSize: r2, keySize: n2 } = ma.getCipher(t2), i2 = await this.s2k.produceKey(e2, n2);
    if (5 === this.version) {
      const e3 = ma.getAEADMode(this.aeadAlgorithm), r3 = new Uint8Array([192 | _Uh.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), n3 = await e3(t2, i2);
      this.sessionKey = await n3.decrypt(this.encrypted, this.iv, r3);
    } else if (null !== this.encrypted) {
      const e3 = await ma.mode.cfb.decrypt(t2, i2, this.encrypted, new Uint8Array(r2));
      this.sessionKeyAlgorithm = $.write($.symmetric, e3[0]), this.sessionKey = e3.subarray(1, e3.length);
    } else this.sessionKey = i2;
  }
  async encrypt(e2, t2 = ie) {
    const r2 = null !== this.sessionKeyEncryptionAlgorithm ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;
    this.sessionKeyEncryptionAlgorithm = r2, this.s2k = new Ph(t2), this.s2k.salt = ma.random.getRandomBytes(8);
    const { blockSize: n2, keySize: i2 } = ma.getCipher(r2), a2 = await this.s2k.produceKey(e2, i2);
    if (null === this.sessionKey && (this.sessionKey = ma.generateSessionKey(this.sessionKeyAlgorithm)), 5 === this.version) {
      const e3 = ma.getAEADMode(this.aeadAlgorithm);
      this.iv = ma.random.getRandomBytes(e3.ivLength);
      const t3 = new Uint8Array([192 | _Uh.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), n3 = await e3(r2, a2);
      this.encrypted = await n3.encrypt(this.sessionKey, this.iv, t3);
    } else {
      const e3 = X.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]), this.sessionKey]);
      this.encrypted = await ma.mode.cfb.encrypt(r2, a2, e3, new Uint8Array(n2), t2);
    }
  }
};
var Dh = class _Dh {
  static get tag() {
    return $.packet.publicKey;
  }
  constructor(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    this.version = t2.v5Keys ? 5 : 4, this.created = X.normalizeDate(e2), this.algorithm = null, this.publicParams = null, this.expirationTimeV3 = 0, this.fingerprint = null, this.keyID = null;
  }
  static fromSecretKeyPacket(e2) {
    const t2 = new _Dh(), { version: r2, created: n2, algorithm: i2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
    return t2.version = r2, t2.created = n2, t2.algorithm = i2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
  }
  async read(e2) {
    let t2 = 0;
    if (this.version = e2[t2++], 4 === this.version || 5 === this.version) {
      this.created = X.readDate(e2.subarray(t2, t2 + 4)), t2 += 4, this.algorithm = e2[t2++], 5 === this.version && (t2 += 4);
      const { read: r2, publicParams: n2 } = ma.parsePublicKeyParams(this.algorithm, e2.subarray(t2));
      return this.publicParams = n2, t2 += r2, await this.computeFingerprintAndKeyID(), t2;
    }
    throw new fi(`Version ${this.version} of the key packet is unsupported.`);
  }
  write() {
    const e2 = [];
    e2.push(new Uint8Array([this.version])), e2.push(X.writeDate(this.created)), e2.push(new Uint8Array([this.algorithm]));
    const t2 = ma.serializeParams(this.algorithm, this.publicParams);
    return 5 === this.version && e2.push(X.writeNumber(t2.length, 4)), e2.push(t2), X.concatUint8Array(e2);
  }
  writeForHash(e2) {
    const t2 = this.writePublicKey();
    return 5 === e2 ? X.concatUint8Array([new Uint8Array([154]), X.writeNumber(t2.length, 4), t2]) : X.concatUint8Array([new Uint8Array([153]), X.writeNumber(t2.length, 2), t2]);
  }
  isDecrypted() {
    return null;
  }
  getCreationTime() {
    return this.created;
  }
  getKeyID() {
    return this.keyID;
  }
  async computeFingerprintAndKeyID() {
    if (await this.computeFingerprint(), this.keyID = new pe(), 5 === this.version) this.keyID.read(this.fingerprint.subarray(0, 8));
    else {
      if (4 !== this.version) throw Error("Unsupported key version");
      this.keyID.read(this.fingerprint.subarray(12, 20));
    }
  }
  async computeFingerprint() {
    const e2 = this.writeForHash(this.version);
    if (5 === this.version) this.fingerprint = await ma.hash.sha256(e2);
    else {
      if (4 !== this.version) throw Error("Unsupported key version");
      this.fingerprint = await ma.hash.sha1(e2);
    }
  }
  getFingerprintBytes() {
    return this.fingerprint;
  }
  getFingerprint() {
    return X.uint8ArrayToHex(this.getFingerprintBytes());
  }
  hasSameFingerprintAs(e2) {
    return this.version === e2.version && X.equalsUint8Array(this.writePublicKey(), e2.writePublicKey());
  }
  getAlgorithmInfo() {
    const e2 = {};
    e2.algorithm = $.read($.publicKey, this.algorithm);
    const t2 = this.publicParams.n || this.publicParams.p;
    return t2 ? e2.bits = X.uint8ArrayBitLength(t2) : this.publicParams.oid && (e2.curve = this.publicParams.oid.getName()), e2;
  }
};
Dh.prototype.readPublicKey = Dh.prototype.read, Dh.prototype.writePublicKey = Dh.prototype.write;
var Ch = X.constructAllowedPackets([ah, ph, uh, ch]);
var Ih = class {
  static get tag() {
    return $.packet.symmetricallyEncryptedData;
  }
  constructor() {
    this.encrypted = null, this.packets = null;
  }
  read(e2) {
    this.encrypted = e2;
  }
  write() {
    return this.encrypted;
  }
  async decrypt(e2, t2, r2 = ie) {
    if (!r2.allowUnauthenticatedMessages) throw Error("Message is not authenticated.");
    const { blockSize: n2 } = ma.getCipher(e2), i2 = await H(L(this.encrypted)), a2 = await ma.mode.cfb.decrypt(e2, t2, i2.subarray(n2 + 2), i2.subarray(2, n2 + 2));
    this.packets = await yh.fromBinary(a2, Ch, r2);
  }
  async encrypt(e2, t2, r2 = ie) {
    const n2 = this.packets.write(), { blockSize: i2 } = ma.getCipher(e2), a2 = await ma.getPrefixRandom(e2), s2 = await ma.mode.cfb.encrypt(e2, t2, a2, new Uint8Array(i2), r2), o2 = await ma.mode.cfb.encrypt(e2, t2, n2, s2.subarray(2), r2);
    this.encrypted = X.concat([s2, o2]);
  }
};
var Th = class {
  static get tag() {
    return $.packet.marker;
  }
  read(e2) {
    return 80 === e2[0] && 71 === e2[1] && 80 === e2[2];
  }
  write() {
    return new Uint8Array([80, 71, 80]);
  }
};
var Bh = class _Bh extends Dh {
  static get tag() {
    return $.packet.publicSubkey;
  }
  constructor(e2, t2) {
    super(e2, t2);
  }
  static fromSecretSubkeyPacket(e2) {
    const t2 = new _Bh(), { version: r2, created: n2, algorithm: i2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
    return t2.version = r2, t2.created = n2, t2.algorithm = i2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
  }
};
var zh = class _zh {
  static get tag() {
    return $.packet.userAttribute;
  }
  constructor() {
    this.attributes = [];
  }
  read(e2) {
    let t2 = 0;
    for (; t2 < e2.length; ) {
      const r2 = ci(e2.subarray(t2, e2.length));
      t2 += r2.offset, this.attributes.push(X.uint8ArrayToString(e2.subarray(t2, t2 + r2.len))), t2 += r2.len;
    }
  }
  write() {
    const e2 = [];
    for (let t2 = 0; t2 < this.attributes.length; t2++) e2.push(hi(this.attributes[t2].length)), e2.push(X.stringToUint8Array(this.attributes[t2]));
    return X.concatUint8Array(e2);
  }
  equals(e2) {
    return !!(e2 && e2 instanceof _zh) && this.attributes.every(function(t2, r2) {
      return t2 === e2.attributes[r2];
    });
  }
};
var Rh = class extends Dh {
  static get tag() {
    return $.packet.secretKey;
  }
  constructor(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    super(e2, t2), this.keyMaterial = null, this.isEncrypted = null, this.s2kUsage = 0, this.s2k = null, this.symmetric = null, this.aead = null, this.privateParams = null;
  }
  async read(e2) {
    let t2 = await this.readPublicKey(e2);
    const r2 = t2;
    this.s2kUsage = e2[t2++], 5 === this.version && t2++;
    try {
      if (255 === this.s2kUsage || 254 === this.s2kUsage || 253 === this.s2kUsage) {
        if (this.symmetric = e2[t2++], 253 === this.s2kUsage && (this.aead = e2[t2++]), this.s2k = new Ph(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), "gnu-dummy" === this.s2k.type) return;
      } else this.s2kUsage && (this.symmetric = this.s2kUsage);
      this.s2kUsage && (this.iv = e2.subarray(t2, t2 + ma.getCipher(this.symmetric).blockSize), t2 += this.iv.length);
    } catch (t3) {
      if (!this.s2kUsage) throw t3;
      this.unparseableKeyMaterial = e2.subarray(r2), this.isEncrypted = true;
    }
    if (5 === this.version && (t2 += 4), this.keyMaterial = e2.subarray(t2), this.isEncrypted = !!this.s2kUsage, !this.isEncrypted) {
      const e3 = this.keyMaterial.subarray(0, -2);
      if (!X.equalsUint8Array(X.writeChecksum(e3), this.keyMaterial.subarray(-2))) throw Error("Key checksum mismatch");
      try {
        const { privateParams: t3 } = ma.parsePrivateKeyParams(this.algorithm, e3, this.publicParams);
        this.privateParams = t3;
      } catch (e4) {
        if (e4 instanceof fi) throw e4;
        throw Error("Error reading MPIs");
      }
    }
  }
  write() {
    const e2 = this.writePublicKey();
    if (this.unparseableKeyMaterial) return X.concatUint8Array([e2, this.unparseableKeyMaterial]);
    const t2 = [e2];
    t2.push(new Uint8Array([this.s2kUsage]));
    const r2 = [];
    return 255 !== this.s2kUsage && 254 !== this.s2kUsage && 253 !== this.s2kUsage || (r2.push(this.symmetric), 253 === this.s2kUsage && r2.push(this.aead), r2.push(...this.s2k.write())), this.s2kUsage && "gnu-dummy" !== this.s2k.type && r2.push(...this.iv), 5 === this.version && t2.push(new Uint8Array([r2.length])), t2.push(new Uint8Array(r2)), this.isDummy() || (this.s2kUsage || (this.keyMaterial = ma.serializeParams(this.algorithm, this.privateParams)), 5 === this.version && t2.push(X.writeNumber(this.keyMaterial.length, 4)), t2.push(this.keyMaterial), this.s2kUsage || t2.push(X.writeChecksum(this.keyMaterial))), X.concatUint8Array(t2);
  }
  isDecrypted() {
    return false === this.isEncrypted;
  }
  isMissingSecretKeyMaterial() {
    return void 0 !== this.unparseableKeyMaterial || this.isDummy();
  }
  isDummy() {
    return !(!this.s2k || "gnu-dummy" !== this.s2k.type);
  }
  makeDummy(e2 = ie) {
    this.isDummy() || (this.isDecrypted() && this.clearPrivateParams(), delete this.unparseableKeyMaterial, this.isEncrypted = null, this.keyMaterial = null, this.s2k = new Ph(e2), this.s2k.algorithm = 0, this.s2k.c = 0, this.s2k.type = "gnu-dummy", this.s2kUsage = 254, this.symmetric = $.symmetric.aes256);
  }
  async encrypt(e2, t2 = ie) {
    if (this.isDummy()) return;
    if (!this.isDecrypted()) throw Error("Key packet is already encrypted");
    if (!e2) throw Error("A non-empty passphrase is required for key encryption.");
    this.s2k = new Ph(t2), this.s2k.salt = ma.random.getRandomBytes(8);
    const r2 = ma.serializeParams(this.algorithm, this.privateParams);
    this.symmetric = $.symmetric.aes256;
    const n2 = await Mh(this.s2k, e2, this.symmetric), { blockSize: i2 } = ma.getCipher(this.symmetric);
    if (this.iv = ma.random.getRandomBytes(i2), t2.aeadProtect) {
      this.s2kUsage = 253, this.aead = $.aead.eax;
      const e3 = ma.getAEADMode(this.aead), t3 = await e3(this.symmetric, n2);
      this.keyMaterial = await t3.encrypt(r2, this.iv.subarray(0, e3.ivLength), new Uint8Array());
    } else this.s2kUsage = 254, this.keyMaterial = await ma.mode.cfb.encrypt(this.symmetric, n2, X.concatUint8Array([r2, await ma.hash.sha1(r2, t2)]), this.iv, t2);
  }
  async decrypt(e2) {
    if (this.isDummy()) return false;
    if (this.unparseableKeyMaterial) throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");
    if (this.isDecrypted()) throw Error("Key packet is already decrypted.");
    let t2, r2;
    if (254 !== this.s2kUsage && 253 !== this.s2kUsage) throw 255 === this.s2kUsage ? Error("Encrypted private key is authenticated using an insecure two-byte hash") : Error("Private key is encrypted using an insecure S2K function: unsalted MD5");
    if (t2 = await Mh(this.s2k, e2, this.symmetric), 253 === this.s2kUsage) {
      const e3 = ma.getAEADMode(this.aead), n2 = await e3(this.symmetric, t2);
      try {
        r2 = await n2.decrypt(this.keyMaterial, this.iv.subarray(0, e3.ivLength), new Uint8Array());
      } catch (e4) {
        if ("Authentication tag mismatch" === e4.message) throw Error("Incorrect key passphrase: " + e4.message);
        throw e4;
      }
    } else {
      const e3 = await ma.mode.cfb.decrypt(this.symmetric, t2, this.keyMaterial, this.iv);
      r2 = e3.subarray(0, -20);
      const n2 = await ma.hash.sha1(r2);
      if (!X.equalsUint8Array(n2, e3.subarray(-20))) throw Error("Incorrect key passphrase");
    }
    try {
      const { privateParams: e3 } = ma.parsePrivateKeyParams(this.algorithm, r2, this.publicParams);
      this.privateParams = e3;
    } catch (e3) {
      throw Error("Error reading MPIs");
    }
    this.isEncrypted = false, this.keyMaterial = null, this.s2kUsage = 0;
  }
  async validate() {
    if (this.isDummy()) return;
    if (!this.isDecrypted()) throw Error("Key is not decrypted");
    let e2;
    try {
      e2 = await ma.validateParams(this.algorithm, this.publicParams, this.privateParams);
    } catch (t2) {
      e2 = false;
    }
    if (!e2) throw Error("Key is invalid");
  }
  async generate(e2, t2) {
    const { privateParams: r2, publicParams: n2 } = await ma.generateParams(this.algorithm, e2, t2);
    this.privateParams = r2, this.publicParams = n2, this.isEncrypted = false;
  }
  clearPrivateParams() {
    this.isMissingSecretKeyMaterial() || (Object.keys(this.privateParams).forEach((e2) => {
      this.privateParams[e2].fill(0), delete this.privateParams[e2];
    }), this.privateParams = null, this.isEncrypted = true);
  }
};
async function Mh(e2, t2, r2) {
  const { keySize: n2 } = ma.getCipher(r2);
  return e2.produceKey(t2, n2);
}
var Lh = rt(function(e2) {
  !function(t2) {
    function r2(e3) {
      function t3() {
        return _e2 < Ee2;
      }
      function r3() {
        return _e2;
      }
      function i2(e4) {
        _e2 = e4;
      }
      function a2() {
        _e2 = 0, Ee2 = Ae2.length;
      }
      function s2(e4, t4) {
        return { name: e4, tokens: t4 || "", semantic: t4 || "", children: [] };
      }
      function o2(e4, t4) {
        var r4;
        return null === t4 ? null : ((r4 = s2(e4)).tokens = t4.tokens, r4.semantic = t4.semantic, r4.children.push(t4), r4);
      }
      function c2(e4, t4) {
        return null !== t4 && (e4.tokens += t4.tokens, e4.semantic += t4.semantic), e4.children.push(t4), e4;
      }
      function h2(e4) {
        var r4;
        return t3() && e4(r4 = Ae2[_e2]) ? (_e2 += 1, s2("token", r4)) : null;
      }
      function u2(e4) {
        return function() {
          return o2("literal", h2(function(t4) {
            return t4 === e4;
          }));
        };
      }
      function l2() {
        var e4 = arguments;
        return function() {
          var t4, n3, a3, o3;
          for (o3 = r3(), n3 = s2("and"), t4 = 0; t4 < e4.length; t4 += 1) {
            if (null === (a3 = e4[t4]())) return i2(o3), null;
            c2(n3, a3);
          }
          return n3;
        };
      }
      function y2() {
        var e4 = arguments;
        return function() {
          var t4, n3, a3;
          for (a3 = r3(), t4 = 0; t4 < e4.length; t4 += 1) {
            if (null !== (n3 = e4[t4]())) return n3;
            i2(a3);
          }
          return null;
        };
      }
      function d2(e4) {
        return function() {
          var t4, n3;
          return n3 = r3(), null !== (t4 = e4()) ? t4 : (i2(n3), s2("opt"));
        };
      }
      function p2(e4) {
        return function() {
          var t4 = e4();
          return null !== t4 && (t4.semantic = ""), t4;
        };
      }
      function f2(e4) {
        return function() {
          var t4 = e4();
          return null !== t4 && t4.semantic.length > 0 && (t4.semantic = " "), t4;
        };
      }
      function g2(e4, t4) {
        return function() {
          var n3, a3, o3, h3, u3;
          for (h3 = r3(), n3 = s2("star"), o3 = 0, u3 = void 0 === t4 ? 0 : t4; null !== (a3 = e4()); ) o3 += 1, c2(n3, a3);
          return o3 >= u3 ? n3 : (i2(h3), null);
        };
      }
      function m2(e4) {
        return e4.charCodeAt(0) >= 128;
      }
      function w2() {
        return o2("cr", u2("\r")());
      }
      function b2() {
        return o2("crlf", l2(w2, A2)());
      }
      function k2() {
        return o2("dquote", u2('"')());
      }
      function v2() {
        return o2("htab", u2("	")());
      }
      function A2() {
        return o2("lf", u2("\n")());
      }
      function _2() {
        return o2("sp", u2(" ")());
      }
      function E2() {
        return o2("vchar", h2(function(t4) {
          var r4 = t4.charCodeAt(0), n3 = 33 <= r4 && r4 <= 126;
          return e3.rfc6532 && (n3 = n3 || m2(t4)), n3;
        }));
      }
      function S2() {
        return o2("wsp", y2(_2, v2)());
      }
      function K2() {
        var e4 = o2("quoted-pair", y2(l2(u2("\\"), y2(E2, S2)), ne2)());
        return null === e4 ? null : (e4.semantic = e4.semantic[1], e4);
      }
      function x2() {
        return o2("fws", y2(ae2, l2(d2(l2(g2(S2), p2(b2))), g2(S2, 1)))());
      }
      function P2() {
        return o2("ctext", y2(function() {
          return h2(function(t4) {
            var r4 = t4.charCodeAt(0), n3 = 33 <= r4 && r4 <= 39 || 42 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
            return e3.rfc6532 && (n3 = n3 || m2(t4)), n3;
          });
        }, te2)());
      }
      function U2() {
        return o2("ccontent", y2(P2, K2, D2)());
      }
      function D2() {
        return o2("comment", l2(u2("("), g2(l2(d2(x2), U2)), d2(x2), u2(")"))());
      }
      function C2() {
        return o2("cfws", y2(l2(g2(l2(d2(x2), D2), 1), d2(x2)), x2)());
      }
      function I2() {
        return o2("atext", h2(function(t4) {
          var r4 = "a" <= t4 && t4 <= "z" || "A" <= t4 && t4 <= "Z" || "0" <= t4 && t4 <= "9" || ["!", "#", "$", "%", "&", "'", "*", "+", "-", "/", "=", "?", "^", "_", "`", "{", "|", "}", "~"].indexOf(t4) >= 0;
          return e3.rfc6532 && (r4 = r4 || m2(t4)), r4;
        }));
      }
      function T2() {
        return o2("atom", l2(f2(d2(C2)), g2(I2, 1), f2(d2(C2)))());
      }
      function B2() {
        var e4, t4;
        return null === (e4 = o2("dot-atom-text", g2(I2, 1)())) || null !== (t4 = g2(l2(u2("."), g2(I2, 1)))()) && c2(e4, t4), e4;
      }
      function z2() {
        return o2("dot-atom", l2(p2(d2(C2)), B2, p2(d2(C2)))());
      }
      function R2() {
        return o2("qtext", y2(function() {
          return h2(function(t4) {
            var r4 = t4.charCodeAt(0), n3 = 33 === r4 || 35 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
            return e3.rfc6532 && (n3 = n3 || m2(t4)), n3;
          });
        }, re2)());
      }
      function M2() {
        return o2("qcontent", y2(R2, K2)());
      }
      function L2() {
        return o2("quoted-string", l2(p2(d2(C2)), p2(k2), g2(l2(d2(f2(x2)), M2)), d2(p2(x2)), p2(k2), p2(d2(C2)))());
      }
      function N2() {
        return o2("word", y2(T2, L2)());
      }
      function O2() {
        return o2("address", y2(F2, q2)());
      }
      function F2() {
        return o2("mailbox", y2(H2, J2)());
      }
      function H2() {
        return o2("name-addr", l2(d2(G2), j2)());
      }
      function j2() {
        return o2("angle-addr", y2(l2(p2(d2(C2)), u2("<"), J2, u2(">"), p2(d2(C2))), se2)());
      }
      function q2() {
        return o2("group", l2(G2, u2(":"), d2($2), u2(";"), p2(d2(C2)))());
      }
      function G2() {
        return o2("display-name", (null !== (e4 = o2("phrase", y2(ie2, g2(N2, 1))())) && (e4.semantic = function(e5) {
          return e5.replace(/([ \t]|\r\n)+/g, " ").replace(/^\s*/, "").replace(/\s*$/, "");
        }(e4.semantic)), e4));
        var e4;
      }
      function V2() {
        return o2("mailbox-list", y2(l2(F2, g2(l2(u2(","), F2))), he2)());
      }
      function W2() {
        return o2("address-list", y2(l2(O2, g2(l2(u2(","), O2))), ue2)());
      }
      function $2() {
        return o2("group-list", y2(V2, p2(C2), le2)());
      }
      function Z2() {
        return o2("local-part", y2(ye2, z2, L2)());
      }
      function X2() {
        return o2("dtext", y2(function() {
          return h2(function(t4) {
            var r4 = t4.charCodeAt(0), n3 = 33 <= r4 && r4 <= 90 || 94 <= r4 && r4 <= 126;
            return e3.rfc6532 && (n3 = n3 || m2(t4)), n3;
          });
        }, pe2)());
      }
      function Q2() {
        return o2("domain-literal", l2(p2(d2(C2)), u2("["), g2(l2(d2(x2), X2)), d2(x2), u2("]"), p2(d2(C2)))());
      }
      function Y2() {
        return o2("domain", (t4 = y2(de2, z2, Q2)(), e3.rejectTLD && t4 && t4.semantic && t4.semantic.indexOf(".") < 0 ? null : (t4 && (t4.semantic = t4.semantic.replace(/\s+/g, "")), t4)));
        var t4;
      }
      function J2() {
        return o2("addr-spec", l2(Z2, u2("@"), Y2)());
      }
      function ee2() {
        return e3.strict ? null : o2("obs-NO-WS-CTL", h2(function(e4) {
          var t4 = e4.charCodeAt(0);
          return 1 <= t4 && t4 <= 8 || 11 === t4 || 12 === t4 || 14 <= t4 && t4 <= 31 || 127 === t4;
        }));
      }
      function te2() {
        return e3.strict ? null : o2("obs-ctext", ee2());
      }
      function re2() {
        return e3.strict ? null : o2("obs-qtext", ee2());
      }
      function ne2() {
        return e3.strict ? null : o2("obs-qp", l2(u2("\\"), y2(u2("\0"), ee2, A2, w2))());
      }
      function ie2() {
        return e3.strict ? null : e3.atInDisplayName ? o2("obs-phrase", l2(N2, g2(y2(N2, u2("."), u2("@"), f2(C2))))()) : o2("obs-phrase", l2(N2, g2(y2(N2, u2("."), f2(C2))))());
      }
      function ae2() {
        return e3.strict ? null : o2("obs-FWS", g2(l2(p2(d2(b2)), S2), 1)());
      }
      function se2() {
        return e3.strict ? null : o2("obs-angle-addr", l2(p2(d2(C2)), u2("<"), oe2, J2, u2(">"), p2(d2(C2)))());
      }
      function oe2() {
        return e3.strict ? null : o2("obs-route", l2(ce2, u2(":"))());
      }
      function ce2() {
        return e3.strict ? null : o2("obs-domain-list", l2(g2(y2(p2(C2), u2(","))), u2("@"), Y2, g2(l2(u2(","), p2(d2(C2)), d2(l2(u2("@"), Y2)))))());
      }
      function he2() {
        return e3.strict ? null : o2("obs-mbox-list", l2(g2(l2(p2(d2(C2)), u2(","))), F2, g2(l2(u2(","), d2(l2(F2, p2(C2))))))());
      }
      function ue2() {
        return e3.strict ? null : o2("obs-addr-list", l2(g2(l2(p2(d2(C2)), u2(","))), O2, g2(l2(u2(","), d2(l2(O2, p2(C2))))))());
      }
      function le2() {
        return e3.strict ? null : o2("obs-group-list", l2(g2(l2(p2(d2(C2)), u2(",")), 1), p2(d2(C2)))());
      }
      function ye2() {
        return e3.strict ? null : o2("obs-local-part", l2(N2, g2(l2(u2("."), N2)))());
      }
      function de2() {
        return e3.strict ? null : o2("obs-domain", l2(T2, g2(l2(u2("."), T2)))());
      }
      function pe2() {
        return e3.strict ? null : o2("obs-dtext", y2(ee2, K2)());
      }
      function fe2(e4, t4) {
        var r4, n3, i3;
        if (null == t4) return null;
        for (n3 = [t4]; n3.length > 0; ) {
          if ((i3 = n3.pop()).name === e4) return i3;
          for (r4 = i3.children.length - 1; r4 >= 0; r4 -= 1) n3.push(i3.children[r4]);
        }
        return null;
      }
      function ge2(e4, t4) {
        var r4, n3, i3, a3, s3;
        if (null == t4) return null;
        for (n3 = [t4], a3 = [], s3 = {}, r4 = 0; r4 < e4.length; r4 += 1) s3[e4[r4]] = true;
        for (; n3.length > 0; ) if ((i3 = n3.pop()).name in s3) a3.push(i3);
        else for (r4 = i3.children.length - 1; r4 >= 0; r4 -= 1) n3.push(i3.children[r4]);
        return a3;
      }
      function me2(t4) {
        var r4, n3, i3, a3, s3;
        if (null === t4) return null;
        for (r4 = [], n3 = ge2(["group", "mailbox"], t4), i3 = 0; i3 < n3.length; i3 += 1) "group" === (a3 = n3[i3]).name ? r4.push(we2(a3)) : "mailbox" === a3.name && r4.push(be2(a3));
        return s3 = { ast: t4, addresses: r4 }, e3.simple && (s3 = function(e4) {
          var t5;
          if (e4 && e4.addresses) for (t5 = 0; t5 < e4.addresses.length; t5 += 1) delete e4.addresses[t5].node;
          return e4;
        }(s3)), e3.oneResult ? function(t5) {
          if (!t5) return null;
          if (!e3.partial && t5.addresses.length > 1) return null;
          return t5.addresses && t5.addresses[0];
        }(s3) : e3.simple ? s3 && s3.addresses : s3;
      }
      function we2(e4) {
        var t4, r4 = fe2("display-name", e4), n3 = [], i3 = ge2(["mailbox"], e4);
        for (t4 = 0; t4 < i3.length; t4 += 1) n3.push(be2(i3[t4]));
        return { node: e4, parts: { name: r4 }, type: e4.name, name: ke2(r4), addresses: n3 };
      }
      function be2(e4) {
        var t4 = fe2("display-name", e4), r4 = fe2("addr-spec", e4), n3 = function(e5, t5) {
          var r5, n4, i4, a4;
          if (null == t5) return null;
          for (n4 = [t5], a4 = []; n4.length > 0; ) for ((i4 = n4.pop()).name === e5 && a4.push(i4), r5 = i4.children.length - 1; r5 >= 0; r5 -= 1) n4.push(i4.children[r5]);
          return a4;
        }("cfws", e4), i3 = ge2(["comment"], e4), a3 = fe2("local-part", r4), s3 = fe2("domain", r4);
        return { node: e4, parts: { name: t4, address: r4, local: a3, domain: s3, comments: n3 }, type: e4.name, name: ke2(t4), address: ke2(r4), local: ke2(a3), domain: ke2(s3), comments: ve2(i3), groupName: ke2(e4.groupName) };
      }
      function ke2(e4) {
        return null != e4 ? e4.semantic : null;
      }
      function ve2(e4) {
        var t4 = "";
        if (e4) for (var r4 = 0; r4 < e4.length; r4 += 1) t4 += ke2(e4[r4]);
        return t4;
      }
      var Ae2, _e2, Ee2, Se2, Ke2;
      if (null === (e3 = n2(e3, {}))) return null;
      if (Ae2 = e3.input, Ke2 = { address: O2, "address-list": W2, "angle-addr": j2, from: function() {
        return o2("from", y2(V2, W2)());
      }, group: q2, mailbox: F2, "mailbox-list": V2, "reply-to": function() {
        return o2("reply-to", W2());
      }, sender: function() {
        return o2("sender", y2(F2, O2)());
      } }[e3.startAt] || W2, !e3.strict) {
        if (a2(), e3.strict = true, Se2 = Ke2(Ae2), e3.partial || !t3()) return me2(Se2);
        e3.strict = false;
      }
      return a2(), Se2 = Ke2(Ae2), !e3.partial && t3() ? null : me2(Se2);
    }
    function n2(e3, t3) {
      function r3(e4) {
        return "[object String]" === Object.prototype.toString.call(e4);
      }
      function n3(e4) {
        return null == e4;
      }
      var i2, a2;
      if (r3(e3)) e3 = { input: e3 };
      else if (!function(e4) {
        return e4 === Object(e4);
      }(e3)) return null;
      if (!r3(e3.input)) return null;
      if (!t3) return null;
      for (a2 in i2 = { oneResult: false, partial: false, rejectTLD: false, rfc6532: false, simple: false, startAt: "address-list", strict: false, atInDisplayName: false }) n3(e3[a2]) && (e3[a2] = n3(t3[a2]) ? i2[a2] : t3[a2]);
      return e3;
    }
    r2.parseOneAddress = function(e3) {
      return r2(n2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "address-list" }));
    }, r2.parseAddressList = function(e3) {
      return r2(n2(e3, { rfc6532: true, simple: true, startAt: "address-list" }));
    }, r2.parseFrom = function(e3) {
      return r2(n2(e3, { rfc6532: true, simple: true, startAt: "from" }));
    }, r2.parseSender = function(e3) {
      return r2(n2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "sender" }));
    }, r2.parseReplyTo = function(e3) {
      return r2(n2(e3, { rfc6532: true, simple: true, startAt: "reply-to" }));
    }, e2.exports = r2;
  }();
});
var Nh = class _Nh {
  static get tag() {
    return $.packet.userID;
  }
  constructor() {
    this.userID = "", this.name = "", this.email = "", this.comment = "";
  }
  static fromObject(e2) {
    if (X.isString(e2) || e2.name && !X.isString(e2.name) || e2.email && !X.isEmailAddress(e2.email) || e2.comment && !X.isString(e2.comment)) throw Error("Invalid user ID format");
    const t2 = new _Nh();
    Object.assign(t2, e2);
    const r2 = [];
    return t2.name && r2.push(t2.name), t2.comment && r2.push(`(${t2.comment})`), t2.email && r2.push(`<${t2.email}>`), t2.userID = r2.join(" "), t2;
  }
  read(e2, t2 = ie) {
    const r2 = X.decodeUTF8(e2);
    if (r2.length > t2.maxUserIDLength) throw Error("User ID string is too long");
    try {
      const { name: e3, address: t3, comments: n2 } = Lh.parseOneAddress({ input: r2, atInDisplayName: true });
      this.comment = n2.replace(/^\(|\)$/g, ""), this.name = e3, this.email = t3;
    } catch (e3) {
    }
    this.userID = r2;
  }
  write() {
    return X.encodeUTF8(this.userID);
  }
  equals(e2) {
    return e2 && e2.userID === this.userID;
  }
};
var Oh = class extends Rh {
  static get tag() {
    return $.packet.secretSubkey;
  }
  constructor(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    super(e2, t2);
  }
};
var Fh = class {
  static get tag() {
    return $.packet.trust;
  }
  read() {
    throw new fi("Trust packets are not supported");
  }
  write() {
    throw new fi("Trust packets are not supported");
  }
};
var Hh = X.constructAllowedPackets([ch]);
var jh = class {
  constructor(e2) {
    this.packets = e2 || new yh();
  }
  write() {
    return this.packets.write();
  }
  armor(e2 = ie) {
    return de($.armor.signature, this.write(), void 0, void 0, void 0, e2);
  }
  getSigningKeyIDs() {
    return this.packets.map((e2) => e2.issuerKeyID);
  }
};
async function qh({ armoredSignature: e2, binarySignature: t2, config: r2, ...n2 }) {
  r2 = { ...ie, ...r2 };
  let i2 = e2 || t2;
  if (!i2) throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");
  if (e2 && !X.isString(e2)) throw Error("readSignature: options.armoredSignature must be a string");
  if (t2 && !X.isUint8Array(t2)) throw Error("readSignature: options.binarySignature must be a Uint8Array");
  const a2 = Object.keys(n2);
  if (a2.length > 0) throw Error("Unknown option: " + a2.join(", "));
  if (e2) {
    const { type: e3, data: t3 } = await ye(i2, r2);
    if (e3 !== $.armor.signature) throw Error("Armored text not of type signature");
    i2 = t3;
  }
  const s2 = await yh.fromBinary(i2, Hh, r2);
  return new jh(s2);
}
async function Gh(e2, t2) {
  const r2 = new Oh(e2.date, t2);
  return r2.packets = null, r2.algorithm = $.write($.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve), await r2.computeFingerprintAndKeyID(), r2;
}
async function Vh(e2, t2) {
  const r2 = new Rh(e2.date, t2);
  return r2.packets = null, r2.algorithm = $.write($.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve, e2.config), await r2.computeFingerprintAndKeyID(), r2;
}
async function Wh(e2, t2, r2, n2, i2 = /* @__PURE__ */ new Date(), a2) {
  let s2, o2;
  for (let c2 = e2.length - 1; c2 >= 0; c2--) try {
    (!s2 || e2[c2].created >= s2.created) && (await e2[c2].verify(t2, r2, n2, i2, void 0, a2), s2 = e2[c2]);
  } catch (e3) {
    o2 = e3;
  }
  if (!s2) throw X.wrapError(`Could not find valid ${$.read($.signature, r2)} signature in key ${t2.getKeyID().toHex()}`.replace("certGeneric ", "self-").replace(/([a-z])([A-Z])/g, (e3, t3, r3) => t3 + " " + r3.toLowerCase()), o2);
  return s2;
}
function $h(e2, t2, r2 = /* @__PURE__ */ new Date()) {
  const n2 = X.normalizeDate(r2);
  if (null !== n2) {
    const r3 = tu(e2, t2);
    return !(e2.created <= n2 && n2 < r3);
  }
  return false;
}
async function Zh(e2, t2, r2, n2) {
  const i2 = {};
  i2.key = t2, i2.bind = e2;
  const a2 = { signatureType: $.signature.subkeyBinding };
  r2.sign ? (a2.keyFlags = [$.keyFlags.signData], a2.embeddedSignature = await Yh(i2, null, e2, { signatureType: $.signature.keyBinding }, r2.date, void 0, void 0, void 0, n2)) : a2.keyFlags = [$.keyFlags.encryptCommunication | $.keyFlags.encryptStorage], r2.keyExpirationTime > 0 && (a2.keyExpirationTime = r2.keyExpirationTime, a2.keyNeverExpires = false);
  return await Yh(i2, null, t2, a2, r2.date, void 0, void 0, void 0, n2);
}
async function Xh(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = {}, i2) {
  let a2 = i2.preferredHashAlgorithm, s2 = a2;
  if (e2) {
    const t3 = await e2.getPrimaryUser(r2, n2, i2);
    t3.selfCertification.preferredHashAlgorithms && ([s2] = t3.selfCertification.preferredHashAlgorithms, a2 = ma.hash.getHashByteLength(a2) <= ma.hash.getHashByteLength(s2) ? s2 : a2);
  }
  switch (t2.algorithm) {
    case $.publicKey.ecdsa:
    case $.publicKey.eddsaLegacy:
    case $.publicKey.ed25519:
      s2 = ma.getPreferredCurveHashAlgo(t2.algorithm, t2.publicParams.oid);
  }
  return ma.hash.getHashByteLength(a2) <= ma.hash.getHashByteLength(s2) ? s2 : a2;
}
async function Qh(e2, t2 = [], r2 = /* @__PURE__ */ new Date(), n2 = [], i2 = ie) {
  const a2 = { symmetric: $.symmetric.aes128, aead: $.aead.eax, compression: $.compression.uncompressed }[e2], s2 = { symmetric: i2.preferredSymmetricAlgorithm, aead: i2.preferredAEADAlgorithm, compression: i2.preferredCompressionAlgorithm }[e2], o2 = { symmetric: "preferredSymmetricAlgorithms", aead: "preferredAEADAlgorithms", compression: "preferredCompressionAlgorithms" }[e2];
  return (await Promise.all(t2.map(async function(e3, t3) {
    const a3 = (await e3.getPrimaryUser(r2, n2[t3], i2)).selfCertification[o2];
    return !!a3 && a3.indexOf(s2) >= 0;
  }))).every(Boolean) ? s2 : a2;
}
async function Yh(e2, t2, r2, n2, i2, a2, s2 = [], o2 = false, c2) {
  if (r2.isDummy()) throw Error("Cannot sign with a gnu-dummy key.");
  if (!r2.isDecrypted()) throw Error("Signing key is not decrypted.");
  const h2 = new ch();
  return Object.assign(h2, n2), h2.publicKeyAlgorithm = r2.algorithm, h2.hashAlgorithm = await Xh(t2, r2, i2, a2, c2), h2.rawNotations = s2, await h2.sign(r2, e2, i2, o2), h2;
}
async function Jh(e2, t2, r2, n2 = /* @__PURE__ */ new Date(), i2) {
  (e2 = e2[r2]) && (t2[r2].length ? await Promise.all(e2.map(async function(e3) {
    e3.isExpired(n2) || i2 && !await i2(e3) || t2[r2].some(function(t3) {
      return X.equalsUint8Array(t3.writeParams(), e3.writeParams());
    }) || t2[r2].push(e3);
  })) : t2[r2] = e2);
}
async function eu(e2, t2, r2, n2, i2, a2, s2 = /* @__PURE__ */ new Date(), o2) {
  a2 = a2 || e2;
  const c2 = [];
  return await Promise.all(n2.map(async function(e3) {
    try {
      i2 && !e3.issuerKeyID.equals(i2.issuerKeyID) || (await e3.verify(a2, t2, r2, o2.revocationsExpire ? s2 : null, false, o2), c2.push(e3.issuerKeyID));
    } catch (e4) {
    }
  })), i2 ? (i2.revoked = !!c2.some((e3) => e3.equals(i2.issuerKeyID)) || (i2.revoked || false), i2.revoked) : c2.length > 0;
}
function tu(e2, t2) {
  let r2;
  return false === t2.keyNeverExpires && (r2 = e2.created.getTime() + 1e3 * t2.keyExpirationTime), r2 ? new Date(r2) : 1 / 0;
}
function ru(e2, t2 = {}) {
  switch (e2.type = e2.type || t2.type, e2.curve = e2.curve || t2.curve, e2.rsaBits = e2.rsaBits || t2.rsaBits, e2.keyExpirationTime = void 0 !== e2.keyExpirationTime ? e2.keyExpirationTime : t2.keyExpirationTime, e2.passphrase = X.isString(e2.passphrase) ? e2.passphrase : t2.passphrase, e2.date = e2.date || t2.date, e2.sign = e2.sign || false, e2.type) {
    case "ecc":
      try {
        e2.curve = $.write($.curve, e2.curve);
      } catch (e3) {
        throw Error("Unknown curve");
      }
      e2.curve !== $.curve.ed25519Legacy && e2.curve !== $.curve.curve25519Legacy || (e2.curve = e2.sign ? $.curve.ed25519Legacy : $.curve.curve25519Legacy), e2.sign ? e2.algorithm = e2.curve === $.curve.ed25519Legacy ? $.publicKey.eddsaLegacy : $.publicKey.ecdsa : e2.algorithm = $.publicKey.ecdh;
      break;
    case "rsa":
      e2.algorithm = $.publicKey.rsaEncryptSign;
      break;
    default:
      throw Error("Unsupported key type " + e2.type);
  }
  return e2;
}
function nu(e2, t2) {
  const r2 = e2.algorithm;
  return r2 !== $.publicKey.rsaEncrypt && r2 !== $.publicKey.elgamal && r2 !== $.publicKey.ecdh && r2 !== $.publicKey.x25519 && (!t2.keyFlags || 0 != (t2.keyFlags[0] & $.keyFlags.signData));
}
function iu(e2, t2) {
  const r2 = e2.algorithm;
  return r2 !== $.publicKey.dsa && r2 !== $.publicKey.rsaSign && r2 !== $.publicKey.ecdsa && r2 !== $.publicKey.eddsaLegacy && r2 !== $.publicKey.ed25519 && (!t2.keyFlags || 0 != (t2.keyFlags[0] & $.keyFlags.encryptCommunication) || 0 != (t2.keyFlags[0] & $.keyFlags.encryptStorage));
}
function au(e2, t2) {
  return !!t2.allowInsecureDecryptionWithSigningKeys || (!e2.keyFlags || 0 != (e2.keyFlags[0] & $.keyFlags.encryptCommunication) || 0 != (e2.keyFlags[0] & $.keyFlags.encryptStorage));
}
function su(e2, t2) {
  const r2 = $.write($.publicKey, e2.algorithm), n2 = e2.getAlgorithmInfo();
  if (t2.rejectPublicKeyAlgorithms.has(r2)) throw Error(n2.algorithm + " keys are considered too weak.");
  switch (r2) {
    case $.publicKey.rsaEncryptSign:
    case $.publicKey.rsaSign:
    case $.publicKey.rsaEncrypt:
      if (n2.bits < t2.minRSABits) throw Error(`RSA keys shorter than ${t2.minRSABits} bits are considered too weak.`);
      break;
    case $.publicKey.ecdsa:
    case $.publicKey.eddsaLegacy:
    case $.publicKey.ecdh:
      if (t2.rejectCurves.has(n2.curve)) throw Error(`Support for ${n2.algorithm} keys using curve ${n2.curve} is disabled.`);
  }
}
var ou = class _ou {
  constructor(e2, t2) {
    this.userID = e2.constructor.tag === $.packet.userID ? e2 : null, this.userAttribute = e2.constructor.tag === $.packet.userAttribute ? e2 : null, this.selfCertifications = [], this.otherCertifications = [], this.revocationSignatures = [], this.mainKey = t2;
  }
  toPacketList() {
    const e2 = new yh();
    return e2.push(this.userID || this.userAttribute), e2.push(...this.revocationSignatures), e2.push(...this.selfCertifications), e2.push(...this.otherCertifications), e2;
  }
  clone() {
    const e2 = new _ou(this.userID || this.userAttribute, this.mainKey);
    return e2.selfCertifications = [...this.selfCertifications], e2.otherCertifications = [...this.otherCertifications], e2.revocationSignatures = [...this.revocationSignatures], e2;
  }
  async certify(e2, t2, r2) {
    const n2 = this.mainKey.keyPacket, i2 = { userID: this.userID, userAttribute: this.userAttribute, key: n2 }, a2 = new _ou(i2.userID || i2.userAttribute, this.mainKey);
    return a2.otherCertifications = await Promise.all(e2.map(async function(e3) {
      if (!e3.isPrivate()) throw Error("Need private key for signing");
      if (e3.hasSameFingerprintAs(n2)) throw Error("The user's own key can only be used for self-certifications");
      const a3 = await e3.getSigningKey(void 0, t2, void 0, r2);
      return Yh(i2, e3, a3.keyPacket, { signatureType: $.signature.certGeneric, keyFlags: [$.keyFlags.certifyKeys | $.keyFlags.signData] }, t2, void 0, void 0, void 0, r2);
    })), await a2.update(this, t2, r2), a2;
  }
  async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    const i2 = this.mainKey.keyPacket;
    return eu(i2, $.signature.certRevocation, { key: i2, userID: this.userID, userAttribute: this.userAttribute }, this.revocationSignatures, e2, t2, r2, n2);
  }
  async verifyCertificate(e2, t2, r2 = /* @__PURE__ */ new Date(), n2) {
    const i2 = this, a2 = this.mainKey.keyPacket, s2 = { userID: this.userID, userAttribute: this.userAttribute, key: a2 }, { issuerKeyID: o2 } = e2, c2 = t2.filter((e3) => e3.getKeys(o2).length > 0);
    return 0 === c2.length ? null : (await Promise.all(c2.map(async (t3) => {
      const a3 = await t3.getSigningKey(o2, e2.created, void 0, n2);
      if (e2.revoked || await i2.isRevoked(e2, a3.keyPacket, r2, n2)) throw Error("User certificate is revoked");
      try {
        await e2.verify(a3.keyPacket, $.signature.certGeneric, s2, r2, void 0, n2);
      } catch (e3) {
        throw X.wrapError("User certificate is invalid", e3);
      }
    })), true);
  }
  async verifyAllCertifications(e2, t2 = /* @__PURE__ */ new Date(), r2) {
    const n2 = this, i2 = this.selfCertifications.concat(this.otherCertifications);
    return Promise.all(i2.map(async (i3) => ({ keyID: i3.issuerKeyID, valid: await n2.verifyCertificate(i3, e2, t2, r2).catch(() => false) })));
  }
  async verify(e2 = /* @__PURE__ */ new Date(), t2) {
    if (!this.selfCertifications.length) throw Error("No self-certifications found");
    const r2 = this, n2 = this.mainKey.keyPacket, i2 = { userID: this.userID, userAttribute: this.userAttribute, key: n2 };
    let a2;
    for (let s2 = this.selfCertifications.length - 1; s2 >= 0; s2--) try {
      const a3 = this.selfCertifications[s2];
      if (a3.revoked || await r2.isRevoked(a3, void 0, e2, t2)) throw Error("Self-certification is revoked");
      try {
        await a3.verify(n2, $.signature.certGeneric, i2, e2, void 0, t2);
      } catch (e3) {
        throw X.wrapError("Self-certification is invalid", e3);
      }
      return true;
    } catch (e3) {
      a2 = e3;
    }
    throw a2;
  }
  async update(e2, t2, r2) {
    const n2 = this.mainKey.keyPacket, i2 = { userID: this.userID, userAttribute: this.userAttribute, key: n2 };
    await Jh(e2, this, "selfCertifications", t2, async function(e3) {
      try {
        return await e3.verify(n2, $.signature.certGeneric, i2, t2, false, r2), true;
      } catch (e4) {
        return false;
      }
    }), await Jh(e2, this, "otherCertifications", t2), await Jh(e2, this, "revocationSignatures", t2, function(e3) {
      return eu(n2, $.signature.certRevocation, i2, [e3], void 0, void 0, t2, r2);
    });
  }
  async revoke(e2, { flag: t2 = $.reasonForRevocation.noReason, string: r2 = "" } = {}, n2 = /* @__PURE__ */ new Date(), i2 = ie) {
    const a2 = { userID: this.userID, userAttribute: this.userAttribute, key: e2 }, s2 = new _ou(a2.userID || a2.userAttribute, this.mainKey);
    return s2.revocationSignatures.push(await Yh(a2, null, e2, { signatureType: $.signature.certRevocation, reasonForRevocationFlag: $.write($.reasonForRevocation, t2), reasonForRevocationString: r2 }, n2, void 0, void 0, false, i2)), await s2.update(this), s2;
  }
};
var cu = class _cu {
  constructor(e2, t2) {
    this.keyPacket = e2, this.bindingSignatures = [], this.revocationSignatures = [], this.mainKey = t2;
  }
  toPacketList() {
    const e2 = new yh();
    return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.bindingSignatures), e2;
  }
  clone() {
    const e2 = new _cu(this.keyPacket, this.mainKey);
    return e2.bindingSignatures = [...this.bindingSignatures], e2.revocationSignatures = [...this.revocationSignatures], e2;
  }
  async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    const i2 = this.mainKey.keyPacket;
    return eu(i2, $.signature.subkeyRevocation, { key: i2, bind: this.keyPacket }, this.revocationSignatures, e2, t2, r2, n2);
  }
  async verify(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    const r2 = this.mainKey.keyPacket, n2 = { key: r2, bind: this.keyPacket }, i2 = await Wh(this.bindingSignatures, r2, $.signature.subkeyBinding, n2, e2, t2);
    if (i2.revoked || await this.isRevoked(i2, null, e2, t2)) throw Error("Subkey is revoked");
    if ($h(this.keyPacket, i2, e2)) throw Error("Subkey is expired");
    return i2;
  }
  async getExpirationTime(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    const r2 = this.mainKey.keyPacket, n2 = { key: r2, bind: this.keyPacket };
    let i2;
    try {
      i2 = await Wh(this.bindingSignatures, r2, $.signature.subkeyBinding, n2, e2, t2);
    } catch (e3) {
      return null;
    }
    const a2 = tu(this.keyPacket, i2), s2 = i2.getExpirationTime();
    return a2 < s2 ? a2 : s2;
  }
  async update(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = this.mainKey.keyPacket;
    if (!this.hasSameFingerprintAs(e2)) throw Error("Subkey update method: fingerprints of subkeys not equal");
    this.keyPacket.constructor.tag === $.packet.publicSubkey && e2.keyPacket.constructor.tag === $.packet.secretSubkey && (this.keyPacket = e2.keyPacket);
    const i2 = this, a2 = { key: n2, bind: i2.keyPacket };
    await Jh(e2, this, "bindingSignatures", t2, async function(e3) {
      for (let t3 = 0; t3 < i2.bindingSignatures.length; t3++) if (i2.bindingSignatures[t3].issuerKeyID.equals(e3.issuerKeyID)) return e3.created > i2.bindingSignatures[t3].created && (i2.bindingSignatures[t3] = e3), false;
      try {
        return await e3.verify(n2, $.signature.subkeyBinding, a2, t2, void 0, r2), true;
      } catch (e4) {
        return false;
      }
    }), await Jh(e2, this, "revocationSignatures", t2, function(e3) {
      return eu(n2, $.signature.subkeyRevocation, a2, [e3], void 0, void 0, t2, r2);
    });
  }
  async revoke(e2, { flag: t2 = $.reasonForRevocation.noReason, string: r2 = "" } = {}, n2 = /* @__PURE__ */ new Date(), i2 = ie) {
    const a2 = { key: e2, bind: this.keyPacket }, s2 = new _cu(this.keyPacket, this.mainKey);
    return s2.revocationSignatures.push(await Yh(a2, null, e2, { signatureType: $.signature.subkeyRevocation, reasonForRevocationFlag: $.write($.reasonForRevocation, t2), reasonForRevocationString: r2 }, n2, void 0, void 0, false, i2)), await s2.update(this), s2;
  }
  hasSameFingerprintAs(e2) {
    return this.keyPacket.hasSameFingerprintAs(e2.keyPacket || e2);
  }
};
["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "isDecrypted"].forEach((e2) => {
  cu.prototype[e2] = function() {
    return this.keyPacket[e2]();
  };
});
var hu = X.constructAllowedPackets([ch]);
var uu = /* @__PURE__ */ new Set([$.packet.publicKey, $.packet.privateKey]);
var lu = /* @__PURE__ */ new Set([$.packet.publicKey, $.packet.privateKey, $.packet.publicSubkey, $.packet.privateSubkey]);
var yu = class {
  packetListToStructure(e2, t2 = /* @__PURE__ */ new Set()) {
    let r2, n2, i2, a2;
    for (const s2 of e2) {
      if (s2 instanceof gi) {
        lu.has(s2.tag) && !a2 && (a2 = uu.has(s2.tag) ? uu : lu);
        continue;
      }
      const e3 = s2.constructor.tag;
      if (a2) {
        if (!a2.has(e3)) continue;
        a2 = null;
      }
      if (t2.has(e3)) throw Error("Unexpected packet type: " + e3);
      switch (e3) {
        case $.packet.publicKey:
        case $.packet.secretKey:
          if (this.keyPacket) throw Error("Key block contains multiple keys");
          if (this.keyPacket = s2, n2 = this.getKeyID(), !n2) throw Error("Missing Key ID");
          break;
        case $.packet.userID:
        case $.packet.userAttribute:
          r2 = new ou(s2, this), this.users.push(r2);
          break;
        case $.packet.publicSubkey:
        case $.packet.secretSubkey:
          r2 = null, i2 = new cu(s2, this), this.subkeys.push(i2);
          break;
        case $.packet.signature:
          switch (s2.signatureType) {
            case $.signature.certGeneric:
            case $.signature.certPersona:
            case $.signature.certCasual:
            case $.signature.certPositive:
              if (!r2) {
                X.printDebug("Dropping certification signatures without preceding user packet");
                continue;
              }
              s2.issuerKeyID.equals(n2) ? r2.selfCertifications.push(s2) : r2.otherCertifications.push(s2);
              break;
            case $.signature.certRevocation:
              r2 ? r2.revocationSignatures.push(s2) : this.directSignatures.push(s2);
              break;
            case $.signature.key:
              this.directSignatures.push(s2);
              break;
            case $.signature.subkeyBinding:
              if (!i2) {
                X.printDebug("Dropping subkey binding signature without preceding subkey packet");
                continue;
              }
              i2.bindingSignatures.push(s2);
              break;
            case $.signature.keyRevocation:
              this.revocationSignatures.push(s2);
              break;
            case $.signature.subkeyRevocation:
              if (!i2) {
                X.printDebug("Dropping subkey revocation signature without preceding subkey packet");
                continue;
              }
              i2.revocationSignatures.push(s2);
          }
      }
    }
  }
  toPacketList() {
    const e2 = new yh();
    return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.directSignatures), this.users.map((t2) => e2.push(...t2.toPacketList())), this.subkeys.map((t2) => e2.push(...t2.toPacketList())), e2;
  }
  clone(e2 = false) {
    const t2 = new this.constructor(this.toPacketList());
    return e2 && t2.getKeys().forEach((e3) => {
      if (e3.keyPacket = Object.create(Object.getPrototypeOf(e3.keyPacket), Object.getOwnPropertyDescriptors(e3.keyPacket)), !e3.keyPacket.isDecrypted()) return;
      const t3 = {};
      Object.keys(e3.keyPacket.privateParams).forEach((r2) => {
        t3[r2] = new Uint8Array(e3.keyPacket.privateParams[r2]);
      }), e3.keyPacket.privateParams = t3;
    }), t2;
  }
  getSubkeys(e2 = null) {
    return this.subkeys.filter((t2) => !e2 || t2.getKeyID().equals(e2, true));
  }
  getKeys(e2 = null) {
    const t2 = [];
    return e2 && !this.getKeyID().equals(e2, true) || t2.push(this), t2.concat(this.getSubkeys(e2));
  }
  getKeyIDs() {
    return this.getKeys().map((e2) => e2.getKeyID());
  }
  getUserIDs() {
    return this.users.map((e2) => e2.userID ? e2.userID.userID : null).filter((e2) => null !== e2);
  }
  write() {
    return this.toPacketList().write();
  }
  async getSigningKey(e2 = null, t2 = /* @__PURE__ */ new Date(), r2 = {}, n2 = ie) {
    await this.verifyPrimaryKey(t2, r2, n2);
    const i2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
    let s2;
    for (const r3 of a2) if (!e2 || r3.getKeyID().equals(e2)) try {
      await r3.verify(t2, n2);
      const e3 = { key: i2, bind: r3.keyPacket }, a3 = await Wh(r3.bindingSignatures, i2, $.signature.subkeyBinding, e3, t2, n2);
      if (!nu(r3.keyPacket, a3)) continue;
      if (!a3.embeddedSignature) throw Error("Missing embedded signature");
      return await Wh([a3.embeddedSignature], r3.keyPacket, $.signature.keyBinding, e3, t2, n2), su(r3.keyPacket, n2), r3;
    } catch (e3) {
      s2 = e3;
    }
    try {
      const a3 = await this.getPrimaryUser(t2, r2, n2);
      if ((!e2 || i2.getKeyID().equals(e2)) && nu(i2, a3.selfCertification)) return su(i2, n2), this;
    } catch (e3) {
      s2 = e3;
    }
    throw X.wrapError("Could not find valid signing key packet in key " + this.getKeyID().toHex(), s2);
  }
  async getEncryptionKey(e2, t2 = /* @__PURE__ */ new Date(), r2 = {}, n2 = ie) {
    await this.verifyPrimaryKey(t2, r2, n2);
    const i2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
    let s2;
    for (const r3 of a2) if (!e2 || r3.getKeyID().equals(e2)) try {
      await r3.verify(t2, n2);
      const e3 = { key: i2, bind: r3.keyPacket }, a3 = await Wh(r3.bindingSignatures, i2, $.signature.subkeyBinding, e3, t2, n2);
      if (iu(r3.keyPacket, a3)) return su(r3.keyPacket, n2), r3;
    } catch (e3) {
      s2 = e3;
    }
    try {
      const a3 = await this.getPrimaryUser(t2, r2, n2);
      if ((!e2 || i2.getKeyID().equals(e2)) && iu(i2, a3.selfCertification)) return su(i2, n2), this;
    } catch (e3) {
      s2 = e3;
    }
    throw X.wrapError("Could not find valid encryption key packet in key " + this.getKeyID().toHex(), s2);
  }
  async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    return eu(this.keyPacket, $.signature.keyRevocation, { key: this.keyPacket }, this.revocationSignatures, e2, t2, r2, n2);
  }
  async verifyPrimaryKey(e2 = /* @__PURE__ */ new Date(), t2 = {}, r2 = ie) {
    const n2 = this.keyPacket;
    if (await this.isRevoked(null, null, e2, r2)) throw Error("Primary key is revoked");
    const { selfCertification: i2 } = await this.getPrimaryUser(e2, t2, r2);
    if ($h(n2, i2, e2)) throw Error("Primary key is expired");
    const a2 = await Wh(this.directSignatures, n2, $.signature.key, { key: n2 }, e2, r2).catch(() => {
    });
    if (a2 && $h(n2, a2, e2)) throw Error("Primary key is expired");
  }
  async getExpirationTime(e2, t2 = ie) {
    let r2;
    try {
      const { selfCertification: n2 } = await this.getPrimaryUser(null, e2, t2), i2 = tu(this.keyPacket, n2), a2 = n2.getExpirationTime(), s2 = await Wh(this.directSignatures, this.keyPacket, $.signature.key, { key: this.keyPacket }, null, t2).catch(() => {
      });
      if (s2) {
        const e3 = tu(this.keyPacket, s2);
        r2 = Math.min(i2, a2, e3);
      } else r2 = i2 < a2 ? i2 : a2;
    } catch (e3) {
      r2 = null;
    }
    return X.normalizeDate(r2);
  }
  async getPrimaryUser(e2 = /* @__PURE__ */ new Date(), t2 = {}, r2 = ie) {
    const n2 = this.keyPacket, i2 = [];
    let a2;
    for (let s3 = 0; s3 < this.users.length; s3++) try {
      const a3 = this.users[s3];
      if (!a3.userID) continue;
      if (void 0 !== t2.name && a3.userID.name !== t2.name || void 0 !== t2.email && a3.userID.email !== t2.email || void 0 !== t2.comment && a3.userID.comment !== t2.comment) throw Error("Could not find user that matches that user ID");
      const o3 = { userID: a3.userID, key: n2 }, c3 = await Wh(a3.selfCertifications, n2, $.signature.certGeneric, o3, e2, r2);
      i2.push({ index: s3, user: a3, selfCertification: c3 });
    } catch (e3) {
      a2 = e3;
    }
    if (!i2.length) throw a2 || Error("Could not find primary user");
    await Promise.all(i2.map(async function(t3) {
      return t3.selfCertification.revoked || t3.user.isRevoked(t3.selfCertification, null, e2, r2);
    }));
    const s2 = i2.sort(function(e3, t3) {
      const r3 = e3.selfCertification, n3 = t3.selfCertification;
      return n3.revoked - r3.revoked || r3.isPrimaryUserID - n3.isPrimaryUserID || r3.created - n3.created;
    }).pop(), { user: o2, selfCertification: c2 } = s2;
    if (c2.revoked || await o2.isRevoked(c2, null, e2, r2)) throw Error("Primary user is revoked");
    return s2;
  }
  async update(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    if (!this.hasSameFingerprintAs(e2)) throw Error("Primary key fingerprints must be equal to update the key");
    if (!this.isPrivate() && e2.isPrivate()) {
      if (!(this.subkeys.length === e2.subkeys.length && this.subkeys.every((t3) => e2.subkeys.some((e3) => t3.hasSameFingerprintAs(e3))))) throw Error("Cannot update public key with private key if subkeys mismatch");
      return e2.update(this, r2);
    }
    const n2 = this.clone();
    return await Jh(e2, n2, "revocationSignatures", t2, (i2) => eu(n2.keyPacket, $.signature.keyRevocation, n2, [i2], null, e2.keyPacket, t2, r2)), await Jh(e2, n2, "directSignatures", t2), await Promise.all(e2.users.map(async (e3) => {
      const i2 = n2.users.filter((t3) => e3.userID && e3.userID.equals(t3.userID) || e3.userAttribute && e3.userAttribute.equals(t3.userAttribute));
      if (i2.length > 0) await Promise.all(i2.map((n3) => n3.update(e3, t2, r2)));
      else {
        const t3 = e3.clone();
        t3.mainKey = n2, n2.users.push(t3);
      }
    })), await Promise.all(e2.subkeys.map(async (e3) => {
      const i2 = n2.subkeys.filter((t3) => t3.hasSameFingerprintAs(e3));
      if (i2.length > 0) await Promise.all(i2.map((n3) => n3.update(e3, t2, r2)));
      else {
        const t3 = e3.clone();
        t3.mainKey = n2, n2.subkeys.push(t3);
      }
    })), n2;
  }
  async getRevocationCertificate(e2 = /* @__PURE__ */ new Date(), t2 = ie) {
    const r2 = { key: this.keyPacket }, n2 = await Wh(this.revocationSignatures, this.keyPacket, $.signature.keyRevocation, r2, e2, t2), i2 = new yh();
    return i2.push(n2), de($.armor.publicKey, i2.write(), null, null, "This is a revocation certificate");
  }
  async applyRevocationCertificate(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = await ye(e2, r2), i2 = (await yh.fromBinary(n2.data, hu, r2)).findPacket($.packet.signature);
    if (!i2 || i2.signatureType !== $.signature.keyRevocation) throw Error("Could not find revocation signature packet");
    if (!i2.issuerKeyID.equals(this.getKeyID())) throw Error("Revocation signature does not match key");
    try {
      await i2.verify(this.keyPacket, $.signature.keyRevocation, { key: this.keyPacket }, t2, void 0, r2);
    } catch (e3) {
      throw X.wrapError("Could not verify revocation signature", e3);
    }
    const a2 = this.clone();
    return a2.revocationSignatures.push(i2), a2;
  }
  async signPrimaryUser(e2, t2, r2, n2 = ie) {
    const { index: i2, user: a2 } = await this.getPrimaryUser(t2, r2, n2), s2 = await a2.certify(e2, t2, n2), o2 = this.clone();
    return o2.users[i2] = s2, o2;
  }
  async signAllUsers(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = this.clone();
    return n2.users = await Promise.all(this.users.map(function(n3) {
      return n3.certify(e2, t2, r2);
    })), n2;
  }
  async verifyPrimaryUser(e2, t2 = /* @__PURE__ */ new Date(), r2, n2 = ie) {
    const i2 = this.keyPacket, { user: a2 } = await this.getPrimaryUser(t2, r2, n2);
    return e2 ? await a2.verifyAllCertifications(e2, t2, n2) : [{ keyID: i2.getKeyID(), valid: await a2.verify(t2, n2).catch(() => false) }];
  }
  async verifyAllUsers(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = this.keyPacket, i2 = [];
    return await Promise.all(this.users.map(async (a2) => {
      const s2 = e2 ? await a2.verifyAllCertifications(e2, t2, r2) : [{ keyID: n2.getKeyID(), valid: await a2.verify(t2, r2).catch(() => false) }];
      i2.push(...s2.map((e3) => ({ userID: a2.userID ? a2.userID.userID : null, userAttribute: a2.userAttribute, keyID: e3.keyID, valid: e3.valid })));
    })), i2;
  }
};
["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "hasSameFingerprintAs"].forEach((e2) => {
  yu.prototype[e2] = cu.prototype[e2];
});
var du = class extends yu {
  constructor(e2) {
    if (super(), this.keyPacket = null, this.revocationSignatures = [], this.directSignatures = [], this.users = [], this.subkeys = [], e2 && (this.packetListToStructure(e2, /* @__PURE__ */ new Set([$.packet.secretKey, $.packet.secretSubkey])), !this.keyPacket)) throw Error("Invalid key: missing public-key packet");
  }
  isPrivate() {
    return false;
  }
  toPublic() {
    return this;
  }
  armor(e2 = ie) {
    return de($.armor.publicKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
  }
};
var pu = class _pu extends du {
  constructor(e2) {
    if (super(), this.packetListToStructure(e2, /* @__PURE__ */ new Set([$.packet.publicKey, $.packet.publicSubkey])), !this.keyPacket) throw Error("Invalid key: missing private-key packet");
  }
  isPrivate() {
    return true;
  }
  toPublic() {
    const e2 = new yh(), t2 = this.toPacketList();
    for (const r2 of t2) switch (r2.constructor.tag) {
      case $.packet.secretKey: {
        const t3 = Dh.fromSecretKeyPacket(r2);
        e2.push(t3);
        break;
      }
      case $.packet.secretSubkey: {
        const t3 = Bh.fromSecretSubkeyPacket(r2);
        e2.push(t3);
        break;
      }
      default:
        e2.push(r2);
    }
    return new du(e2);
  }
  armor(e2 = ie) {
    return de($.armor.privateKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
  }
  async getDecryptionKeys(e2, t2 = /* @__PURE__ */ new Date(), r2 = {}, n2 = ie) {
    const i2 = this.keyPacket, a2 = [];
    for (let r3 = 0; r3 < this.subkeys.length; r3++) if (!e2 || this.subkeys[r3].getKeyID().equals(e2, true)) try {
      const e3 = { key: i2, bind: this.subkeys[r3].keyPacket };
      au(await Wh(this.subkeys[r3].bindingSignatures, i2, $.signature.subkeyBinding, e3, t2, n2), n2) && a2.push(this.subkeys[r3]);
    } catch (e3) {
    }
    const s2 = await this.getPrimaryUser(t2, r2, n2);
    return e2 && !i2.getKeyID().equals(e2, true) || !au(s2.selfCertification, n2) || a2.push(this), a2;
  }
  isDecrypted() {
    return this.getKeys().some(({ keyPacket: e2 }) => e2.isDecrypted());
  }
  async validate(e2 = ie) {
    if (!this.isPrivate()) throw Error("Cannot validate a public key");
    let t2;
    if (this.keyPacket.isDummy()) {
      const r2 = await this.getSigningKey(null, null, void 0, { ...e2, rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set(), minRSABits: 0 });
      r2 && !r2.keyPacket.isDummy() && (t2 = r2.keyPacket);
    } else t2 = this.keyPacket;
    if (t2) return t2.validate();
    {
      const e3 = this.getKeys();
      if (e3.map((e4) => e4.keyPacket.isDummy()).every(Boolean)) throw Error("Cannot validate an all-gnu-dummy key");
      return Promise.all(e3.map(async (e4) => e4.keyPacket.validate()));
    }
  }
  clearPrivateParams() {
    this.getKeys().forEach(({ keyPacket: e2 }) => {
      e2.isDecrypted() && e2.clearPrivateParams();
    });
  }
  async revoke({ flag: e2 = $.reasonForRevocation.noReason, string: t2 = "" } = {}, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    if (!this.isPrivate()) throw Error("Need private key for revoking");
    const i2 = { key: this.keyPacket }, a2 = this.clone();
    return a2.revocationSignatures.push(await Yh(i2, null, this.keyPacket, { signatureType: $.signature.keyRevocation, reasonForRevocationFlag: $.write($.reasonForRevocation, e2), reasonForRevocationString: t2 }, r2, void 0, void 0, void 0, n2)), a2;
  }
  async addSubkey(e2 = {}) {
    const t2 = { ...ie, ...e2.config };
    if (e2.passphrase) throw Error("Subkey could not be encrypted here, please encrypt whole key");
    if (e2.rsaBits < t2.minRSABits) throw Error(`rsaBits should be at least ${t2.minRSABits}, got: ${e2.rsaBits}`);
    const r2 = this.keyPacket;
    if (r2.isDummy()) throw Error("Cannot add subkey to gnu-dummy primary key");
    if (!r2.isDecrypted()) throw Error("Key is not decrypted");
    const n2 = r2.getAlgorithmInfo();
    n2.type = n2.curve ? "ecc" : "rsa", n2.rsaBits = n2.bits || 4096, n2.curve = n2.curve || "curve25519", e2 = ru(e2, n2);
    const i2 = await Gh(e2);
    su(i2, t2);
    const a2 = await Zh(i2, r2, e2, t2), s2 = this.toPacketList();
    return s2.push(i2, a2), new _pu(s2);
  }
};
var fu = X.constructAllowedPackets([Dh, Bh, Rh, Oh, Nh, zh, ch]);
function gu(e2) {
  for (const t2 of e2) switch (t2.constructor.tag) {
    case $.packet.secretKey:
      return new pu(e2);
    case $.packet.publicKey:
      return new du(e2);
  }
  throw Error("No key packet found");
}
async function mu(e2, t2, r2, n2) {
  r2.passphrase && await e2.encrypt(r2.passphrase, n2), await Promise.all(t2.map(async function(e3, t3) {
    const i3 = r2.subkeys[t3].passphrase;
    i3 && await e3.encrypt(i3, n2);
  }));
  const i2 = new yh();
  i2.push(e2), await Promise.all(r2.userIDs.map(async function(t3, i3) {
    function a3(e3, t4) {
      return [t4, ...e3.filter((e4) => e4 !== t4)];
    }
    const s2 = Nh.fromObject(t3), o2 = {};
    o2.userID = s2, o2.key = e2;
    const c2 = {};
    c2.signatureType = $.signature.certGeneric, c2.keyFlags = [$.keyFlags.certifyKeys | $.keyFlags.signData], c2.preferredSymmetricAlgorithms = a3([$.symmetric.aes256, $.symmetric.aes128, $.symmetric.aes192], n2.preferredSymmetricAlgorithm), n2.aeadProtect && (c2.preferredAEADAlgorithms = a3([$.aead.eax, $.aead.ocb], n2.preferredAEADAlgorithm)), c2.preferredHashAlgorithms = a3([$.hash.sha256, $.hash.sha512], n2.preferredHashAlgorithm), c2.preferredCompressionAlgorithms = a3([$.compression.zlib, $.compression.zip, $.compression.uncompressed], n2.preferredCompressionAlgorithm), 0 === i3 && (c2.isPrimaryUserID = true), c2.features = [0], c2.features[0] |= $.features.modificationDetection, n2.aeadProtect && (c2.features[0] |= $.features.aead), n2.v5Keys && (c2.features[0] |= $.features.v5Keys), r2.keyExpirationTime > 0 && (c2.keyExpirationTime = r2.keyExpirationTime, c2.keyNeverExpires = false);
    return { userIDPacket: s2, signaturePacket: await Yh(o2, null, e2, c2, r2.date, void 0, void 0, void 0, n2) };
  })).then((e3) => {
    e3.forEach(({ userIDPacket: e4, signaturePacket: t3 }) => {
      i2.push(e4), i2.push(t3);
    });
  }), await Promise.all(t2.map(async function(t3, i3) {
    const a3 = r2.subkeys[i3];
    return { secretSubkeyPacket: t3, subkeySignaturePacket: await Zh(t3, e2, a3, n2) };
  })).then((e3) => {
    e3.forEach(({ secretSubkeyPacket: e4, subkeySignaturePacket: t3 }) => {
      i2.push(e4), i2.push(t3);
    });
  });
  const a2 = { key: e2 };
  return i2.push(await Yh(a2, null, e2, { signatureType: $.signature.keyRevocation, reasonForRevocationFlag: $.reasonForRevocation.noReason, reasonForRevocationString: "" }, r2.date, void 0, void 0, void 0, n2)), r2.passphrase && e2.clearPrivateParams(), await Promise.all(t2.map(async function(e3, t3) {
    r2.subkeys[t3].passphrase && e3.clearPrivateParams();
  })), new pu(i2);
}
async function wu({ armoredKey: e2, binaryKey: t2, config: r2, ...n2 }) {
  if (r2 = { ...ie, ...r2 }, !e2 && !t2) throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");
  if (e2 && !X.isString(e2)) throw Error("readKey: options.armoredKey must be a string");
  if (t2 && !X.isUint8Array(t2)) throw Error("readKey: options.binaryKey must be a Uint8Array");
  const i2 = Object.keys(n2);
  if (i2.length > 0) throw Error("Unknown option: " + i2.join(", "));
  let a2;
  if (e2) {
    const { type: t3, data: n3 } = await ye(e2, r2);
    if (t3 !== $.armor.publicKey && t3 !== $.armor.privateKey) throw Error("Armored text not of type key");
    a2 = n3;
  } else a2 = t2;
  return gu(await yh.fromBinary(a2, fu, r2));
}
async function bu({ armoredKey: e2, binaryKey: t2, config: r2, ...n2 }) {
  if (r2 = { ...ie, ...r2 }, !e2 && !t2) throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");
  if (e2 && !X.isString(e2)) throw Error("readPrivateKey: options.armoredKey must be a string");
  if (t2 && !X.isUint8Array(t2)) throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");
  const i2 = Object.keys(n2);
  if (i2.length > 0) throw Error("Unknown option: " + i2.join(", "));
  let a2;
  if (e2) {
    const { type: t3, data: n3 } = await ye(e2, r2);
    if (t3 !== $.armor.privateKey) throw Error("Armored text not of type private key");
    a2 = n3;
  } else a2 = t2;
  const s2 = await yh.fromBinary(a2, fu, r2);
  return new pu(s2);
}
async function ku({ armoredKeys: e2, binaryKeys: t2, config: r2, ...n2 }) {
  r2 = { ...ie, ...r2 };
  let i2 = e2 || t2;
  if (!i2) throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
  if (e2 && !X.isString(e2)) throw Error("readKeys: options.armoredKeys must be a string");
  if (t2 && !X.isUint8Array(t2)) throw Error("readKeys: options.binaryKeys must be a Uint8Array");
  const a2 = Object.keys(n2);
  if (a2.length > 0) throw Error("Unknown option: " + a2.join(", "));
  if (e2) {
    const { type: t3, data: n3 } = await ye(e2, r2);
    if (t3 !== $.armor.publicKey && t3 !== $.armor.privateKey) throw Error("Armored text not of type key");
    i2 = n3;
  }
  const s2 = [], o2 = await yh.fromBinary(i2, fu, r2), c2 = o2.indexOfTag($.packet.publicKey, $.packet.secretKey);
  if (0 === c2.length) throw Error("No key packet found");
  for (let e3 = 0; e3 < c2.length; e3++) {
    const t3 = gu(o2.slice(c2[e3], c2[e3 + 1]));
    s2.push(t3);
  }
  return s2;
}
async function vu({ armoredKeys: e2, binaryKeys: t2, config: r2 }) {
  r2 = { ...ie, ...r2 };
  let n2 = e2 || t2;
  if (!n2) throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
  if (e2 && !X.isString(e2)) throw Error("readPrivateKeys: options.armoredKeys must be a string");
  if (t2 && !X.isUint8Array(t2)) throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");
  if (e2) {
    const { type: t3, data: i3 } = await ye(e2, r2);
    if (t3 !== $.armor.privateKey) throw Error("Armored text not of type private key");
    n2 = i3;
  }
  const i2 = [], a2 = await yh.fromBinary(n2, fu, r2), s2 = a2.indexOfTag($.packet.secretKey);
  if (0 === s2.length) throw Error("No secret key packet found");
  for (let e3 = 0; e3 < s2.length; e3++) {
    const t3 = a2.slice(s2[e3], s2[e3 + 1]), r3 = new pu(t3);
    i2.push(r3);
  }
  return i2;
}
var Au = X.constructAllowedPackets([ah, ph, Sh, _h, Ih, Kh, Uh, uh, ch]);
var _u = X.constructAllowedPackets([Uh]);
var Eu = X.constructAllowedPackets([ch]);
var Su = class _Su {
  constructor(e2) {
    this.packets = e2 || new yh();
  }
  getEncryptionKeyIDs() {
    const e2 = [];
    return this.packets.filterByTag($.packet.publicKeyEncryptedSessionKey).forEach(function(t2) {
      e2.push(t2.publicKeyID);
    }), e2;
  }
  getSigningKeyIDs() {
    const e2 = this.unwrapCompressed(), t2 = e2.packets.filterByTag($.packet.onePassSignature);
    if (t2.length > 0) return t2.map((e3) => e3.issuerKeyID);
    return e2.packets.filterByTag($.packet.signature).map((e3) => e3.issuerKeyID);
  }
  async decrypt(e2, t2, r2, n2 = /* @__PURE__ */ new Date(), i2 = ie) {
    const a2 = r2 || await this.decryptSessionKeys(e2, t2, n2, i2), s2 = this.packets.filterByTag($.packet.symmetricallyEncryptedData, $.packet.symEncryptedIntegrityProtectedData, $.packet.aeadEncryptedData);
    if (0 === s2.length) throw Error("No encrypted data found");
    const o2 = s2[0];
    let c2 = null;
    const h2 = Promise.all(a2.map(async ({ algorithm: e3, data: t3 }) => {
      if (!X.isUint8Array(t3) || !X.isString(e3)) throw Error("Invalid session key for decryption.");
      try {
        const r3 = $.write($.symmetric, e3);
        await o2.decrypt(r3, t3, i2);
      } catch (e4) {
        X.printDebugError(e4), c2 = e4;
      }
    }));
    if (j(o2.encrypted), o2.encrypted = null, await h2, !o2.packets || !o2.packets.length) throw c2 || Error("Decryption failed.");
    const u2 = new _Su(o2.packets);
    return o2.packets = new yh(), u2;
  }
  async decryptSessionKeys(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    let i2, a2 = [];
    if (t2) {
      const e3 = this.packets.filterByTag($.packet.symEncryptedSessionKey);
      if (0 === e3.length) throw Error("No symmetrically encrypted session key packet found.");
      await Promise.all(t2.map(async function(t3, r3) {
        let i3;
        i3 = r3 ? await yh.fromBinary(e3.write(), _u, n2) : e3, await Promise.all(i3.map(async function(e4) {
          try {
            await e4.decrypt(t3), a2.push(e4);
          } catch (e5) {
            X.printDebugError(e5);
          }
        }));
      }));
    } else {
      if (!e2) throw Error("No key or password specified.");
      {
        const t3 = this.packets.filterByTag($.packet.publicKeyEncryptedSessionKey);
        if (0 === t3.length) throw Error("No public key encrypted session key packet found.");
        await Promise.all(t3.map(async function(t4) {
          await Promise.all(e2.map(async function(e3) {
            let s2 = [$.symmetric.aes256, $.symmetric.aes128, $.symmetric.tripledes, $.symmetric.cast5];
            try {
              const t5 = await e3.getPrimaryUser(r2, void 0, n2);
              t5.selfCertification.preferredSymmetricAlgorithms && (s2 = s2.concat(t5.selfCertification.preferredSymmetricAlgorithms));
            } catch (e4) {
            }
            const o2 = (await e3.getDecryptionKeys(t4.publicKeyID, null, void 0, n2)).map((e4) => e4.keyPacket);
            await Promise.all(o2.map(async function(e4) {
              if (!e4 || e4.isDummy()) return;
              if (!e4.isDecrypted()) throw Error("Decryption key is not decrypted.");
              if (n2.constantTimePKCS1Decryption && (t4.publicKeyAlgorithm === $.publicKey.rsaEncrypt || t4.publicKeyAlgorithm === $.publicKey.rsaEncryptSign || t4.publicKeyAlgorithm === $.publicKey.rsaSign || t4.publicKeyAlgorithm === $.publicKey.elgamal)) {
                const r3 = t4.write();
                await Promise.all(Array.from(n2.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms).map(async (t5) => {
                  const n3 = new Kh();
                  n3.read(r3);
                  const s3 = { sessionKeyAlgorithm: t5, sessionKey: ma.generateSessionKey(t5) };
                  try {
                    await n3.decrypt(e4, s3), a2.push(n3);
                  } catch (e5) {
                    X.printDebugError(e5), i2 = e5;
                  }
                }));
              } else try {
                if (await t4.decrypt(e4), !s2.includes($.write($.symmetric, t4.sessionKeyAlgorithm))) throw Error("A non-preferred symmetric algorithm was used.");
                a2.push(t4);
              } catch (e5) {
                X.printDebugError(e5), i2 = e5;
              }
            }));
          })), j(t4.encrypted), t4.encrypted = null;
        }));
      }
    }
    if (a2.length > 0) {
      if (a2.length > 1) {
        const e3 = /* @__PURE__ */ new Set();
        a2 = a2.filter((t3) => {
          const r3 = t3.sessionKeyAlgorithm + X.uint8ArrayToString(t3.sessionKey);
          return !e3.has(r3) && (e3.add(r3), true);
        });
      }
      return a2.map((e3) => ({ data: e3.sessionKey, algorithm: $.read($.symmetric, e3.sessionKeyAlgorithm) }));
    }
    throw i2 || Error("Session key decryption failed.");
  }
  getLiteralData() {
    const e2 = this.unwrapCompressed().packets.findPacket($.packet.literalData);
    return e2 && e2.getBytes() || null;
  }
  getFilename() {
    const e2 = this.unwrapCompressed().packets.findPacket($.packet.literalData);
    return e2 && e2.getFilename() || null;
  }
  getText() {
    const e2 = this.unwrapCompressed().packets.findPacket($.packet.literalData);
    return e2 ? e2.getText() : null;
  }
  static async generateSessionKey(e2 = [], t2 = /* @__PURE__ */ new Date(), r2 = [], n2 = ie) {
    const i2 = await Qh("symmetric", e2, t2, r2, n2), a2 = $.read($.symmetric, i2), s2 = n2.aeadProtect && await async function(e3, t3 = /* @__PURE__ */ new Date(), r3 = [], n3 = ie) {
      let i3 = true;
      return await Promise.all(e3.map(async function(e4, a3) {
        const s3 = await e4.getPrimaryUser(t3, r3[a3], n3);
        s3.selfCertification.features && s3.selfCertification.features[0] & $.features.aead || (i3 = false);
      })), i3;
    }(e2, t2, r2, n2) ? $.read($.aead, await Qh("aead", e2, t2, r2, n2)) : void 0;
    await Promise.all(e2.map((e3) => e3.getEncryptionKey().catch(() => null).then((e4) => {
      if (e4 && e4.keyPacket.algorithm === $.publicKey.x25519 && !X.isAES(i2)) throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.");
    })));
    return { data: ma.generateSessionKey(i2), algorithm: a2, aeadAlgorithm: s2 };
  }
  async encrypt(e2, t2, r2, n2 = false, i2 = [], a2 = /* @__PURE__ */ new Date(), s2 = [], o2 = ie) {
    if (r2) {
      if (!X.isUint8Array(r2.data) || !X.isString(r2.algorithm)) throw Error("Invalid session key for encryption.");
    } else if (e2 && e2.length) r2 = await _Su.generateSessionKey(e2, a2, s2, o2);
    else {
      if (!t2 || !t2.length) throw Error("No keys, passwords, or session key provided.");
      r2 = await _Su.generateSessionKey(void 0, void 0, void 0, o2);
    }
    const { data: c2, algorithm: h2, aeadAlgorithm: u2 } = r2, l2 = await _Su.encryptSessionKey(c2, h2, u2, e2, t2, n2, i2, a2, s2, o2);
    let y2;
    u2 ? (y2 = new Sh(), y2.aeadAlgorithm = $.write($.aead, u2)) : y2 = new _h(), y2.packets = this.packets;
    const d2 = $.write($.symmetric, h2);
    return await y2.encrypt(d2, c2, o2), l2.packets.push(y2), y2.packets = new yh(), l2;
  }
  static async encryptSessionKey(e2, t2, r2, n2, i2, a2 = false, s2 = [], o2 = /* @__PURE__ */ new Date(), c2 = [], h2 = ie) {
    const u2 = new yh(), l2 = $.write($.symmetric, t2), y2 = r2 && $.write($.aead, r2);
    if (n2) {
      const t3 = await Promise.all(n2.map(async function(t4, r3) {
        const n3 = await t4.getEncryptionKey(s2[r3], o2, c2, h2), i3 = new Kh();
        return i3.publicKeyID = a2 ? pe.wildcard() : n3.getKeyID(), i3.publicKeyAlgorithm = n3.keyPacket.algorithm, i3.sessionKey = e2, i3.sessionKeyAlgorithm = l2, await i3.encrypt(n3.keyPacket), delete i3.sessionKey, i3;
      }));
      u2.push(...t3);
    }
    if (i2) {
      const t3 = async function(e3, t4) {
        try {
          return await e3.decrypt(t4), 1;
        } catch (e4) {
          return 0;
        }
      }, r3 = (e3, t4) => e3 + t4, n3 = async function(e3, a4, s3, o3) {
        const c3 = new Uh(h2);
        if (c3.sessionKey = e3, c3.sessionKeyAlgorithm = a4, s3 && (c3.aeadAlgorithm = s3), await c3.encrypt(o3, h2), h2.passwordCollisionCheck) {
          if (1 !== (await Promise.all(i2.map((e4) => t3(c3, e4)))).reduce(r3)) return n3(e3, a4, o3);
        }
        return delete c3.sessionKey, c3;
      }, a3 = await Promise.all(i2.map((t4) => n3(e2, l2, y2, t4)));
      u2.push(...a3);
    }
    return new _Su(u2);
  }
  async sign(e2 = [], t2 = null, r2 = [], n2 = /* @__PURE__ */ new Date(), i2 = [], a2 = [], s2 = ie) {
    const o2 = new yh(), c2 = this.packets.findPacket($.packet.literalData);
    if (!c2) throw Error("No literal data packet to sign.");
    let h2, u2;
    const l2 = null === c2.text ? $.signature.binary : $.signature.text;
    if (t2) for (u2 = t2.packets.filterByTag($.packet.signature), h2 = u2.length - 1; h2 >= 0; h2--) {
      const t3 = u2[h2], r3 = new uh();
      r3.signatureType = t3.signatureType, r3.hashAlgorithm = t3.hashAlgorithm, r3.publicKeyAlgorithm = t3.publicKeyAlgorithm, r3.issuerKeyID = t3.issuerKeyID, e2.length || 0 !== h2 || (r3.flags = 1), o2.push(r3);
    }
    return await Promise.all(Array.from(e2).reverse().map(async function(t3, a3) {
      if (!t3.isPrivate()) throw Error("Need private key for signing");
      const o3 = r2[e2.length - 1 - a3], c3 = await t3.getSigningKey(o3, n2, i2, s2), h3 = new uh();
      return h3.signatureType = l2, h3.hashAlgorithm = await Xh(t3, c3.keyPacket, n2, i2, s2), h3.publicKeyAlgorithm = c3.keyPacket.algorithm, h3.issuerKeyID = c3.getKeyID(), a3 === e2.length - 1 && (h3.flags = 1), h3;
    })).then((e3) => {
      e3.forEach((e4) => o2.push(e4));
    }), o2.push(c2), o2.push(...await Ku(c2, e2, t2, r2, n2, i2, a2, false, s2)), new _Su(o2);
  }
  compress(e2, t2 = ie) {
    if (e2 === $.compression.uncompressed) return this;
    const r2 = new ph(t2);
    r2.algorithm = e2, r2.packets = this.packets;
    const n2 = new yh();
    return n2.push(r2), new _Su(n2);
  }
  async signDetached(e2 = [], t2 = null, r2 = [], n2 = /* @__PURE__ */ new Date(), i2 = [], a2 = [], s2 = ie) {
    const o2 = this.packets.findPacket($.packet.literalData);
    if (!o2) throw Error("No literal data packet to sign.");
    return new jh(await Ku(o2, e2, t2, r2, n2, i2, a2, true, s2));
  }
  async verify(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = this.unwrapCompressed(), i2 = n2.packets.filterByTag($.packet.literalData);
    if (1 !== i2.length) throw Error("Can only verify message with one literal data packet.");
    s(n2.packets.stream) && n2.packets.push(...await H(n2.packets.stream, (e3) => e3 || []));
    const a2 = n2.packets.filterByTag($.packet.onePassSignature).reverse(), o2 = n2.packets.filterByTag($.packet.signature);
    return a2.length && !o2.length && X.isStream(n2.packets.stream) && !s(n2.packets.stream) ? (await Promise.all(a2.map(async (e3) => {
      e3.correspondingSig = new Promise((t3, r3) => {
        e3.correspondingSigResolve = t3, e3.correspondingSigReject = r3;
      }), e3.signatureData = q(async () => (await e3.correspondingSig).signatureData), e3.hashed = H(await e3.hash(e3.signatureType, i2[0], void 0, false)), e3.hashed.catch(() => {
      });
    })), n2.packets.stream = R(n2.packets.stream, async (e3, t3) => {
      const r3 = D(e3), n3 = C(t3);
      try {
        for (let e4 = 0; e4 < a2.length; e4++) {
          const { value: t4 } = await r3.read();
          a2[e4].correspondingSigResolve(t4);
        }
        await r3.readToEnd(), await n3.ready, await n3.close();
      } catch (e4) {
        a2.forEach((t4) => {
          t4.correspondingSigReject(e4);
        }), await n3.abort(e4);
      }
    }), xu(a2, i2, e2, t2, false, r2)) : xu(o2, i2, e2, t2, false, r2);
  }
  verifyDetached(e2, t2, r2 = /* @__PURE__ */ new Date(), n2 = ie) {
    const i2 = this.unwrapCompressed().packets.filterByTag($.packet.literalData);
    if (1 !== i2.length) throw Error("Can only verify message with one literal data packet.");
    return xu(e2.packets.filterByTag($.packet.signature), i2, t2, r2, true, n2);
  }
  unwrapCompressed() {
    const e2 = this.packets.filterByTag($.packet.compressedData);
    return e2.length ? new _Su(e2[0].packets) : this;
  }
  async appendSignature(e2, t2 = ie) {
    await this.packets.read(X.isUint8Array(e2) ? e2 : (await ye(e2)).data, Eu, t2);
  }
  write() {
    return this.packets.write();
  }
  armor(e2 = ie) {
    return de($.armor.message, this.write(), null, null, null, e2);
  }
};
async function Ku(e2, t2, r2 = null, n2 = [], i2 = /* @__PURE__ */ new Date(), a2 = [], s2 = [], o2 = false, c2 = ie) {
  const h2 = new yh(), u2 = null === e2.text ? $.signature.binary : $.signature.text;
  if (await Promise.all(t2.map(async (t3, r3) => {
    const h3 = a2[r3];
    if (!t3.isPrivate()) throw Error("Need private key for signing");
    const l2 = await t3.getSigningKey(n2[r3], i2, h3, c2);
    return Yh(e2, t3, l2.keyPacket, { signatureType: u2 }, i2, h3, s2, o2, c2);
  })).then((e3) => {
    h2.push(...e3);
  }), r2) {
    const e3 = r2.packets.filterByTag($.packet.signature);
    h2.push(...e3);
  }
  return h2;
}
async function xu(e2, t2, r2, n2 = /* @__PURE__ */ new Date(), i2 = false, a2 = ie) {
  return Promise.all(e2.filter(function(e3) {
    return ["text", "binary"].includes($.read($.signature, e3.signatureType));
  }).map(async function(e3) {
    return async function(e4, t3, r3, n3 = /* @__PURE__ */ new Date(), i3 = false, a3 = ie) {
      let s2, o2;
      for (const t4 of r3) {
        const r4 = t4.getKeys(e4.issuerKeyID);
        if (r4.length > 0) {
          s2 = t4, o2 = r4[0];
          break;
        }
      }
      const c2 = e4 instanceof uh ? e4.correspondingSig : e4, h2 = { keyID: e4.issuerKeyID, verified: (async () => {
        if (!o2) throw Error("Could not find signing key with key ID " + e4.issuerKeyID.toHex());
        await e4.verify(o2.keyPacket, e4.signatureType, t3[0], n3, i3, a3);
        const r4 = await c2;
        if (o2.getCreationTime() > r4.created) throw Error("Key is newer than the signature");
        try {
          await s2.getSigningKey(o2.getKeyID(), r4.created, void 0, a3);
        } catch (e5) {
          if (!a3.allowInsecureVerificationWithReformattedKeys || !e5.message.match(/Signature creation time is in the future/)) throw e5;
          await s2.getSigningKey(o2.getKeyID(), n3, void 0, a3);
        }
        return true;
      })(), signature: (async () => {
        const e5 = await c2, t4 = new yh();
        return e5 && t4.push(e5), new jh(t4);
      })() };
      return h2.signature.catch(() => {
      }), h2.verified.catch(() => {
      }), h2;
    }(e3, t2, r2, n2, i2, a2);
  }));
}
async function Pu({ armoredMessage: e2, binaryMessage: t2, config: r2, ...n2 }) {
  r2 = { ...ie, ...r2 };
  let i2 = e2 || t2;
  if (!i2) throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");
  if (e2 && !X.isString(e2) && !X.isStream(e2)) throw Error("readMessage: options.armoredMessage must be a string or stream");
  if (t2 && !X.isUint8Array(t2) && !X.isStream(t2)) throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");
  const a2 = Object.keys(n2);
  if (a2.length > 0) throw Error("Unknown option: " + a2.join(", "));
  const s2 = X.isStream(i2);
  if (s2 && (await S(), i2 = x(i2)), e2) {
    const { type: e3, data: t3 } = await ye(i2, r2);
    if (e3 !== $.armor.message) throw Error("Armored text not of type message");
    i2 = t3;
  }
  const o2 = await yh.fromBinary(i2, Au, r2), c2 = new Su(o2);
  return c2.fromStream = s2, c2;
}
async function Uu({ text: e2, binary: t2, filename: r2, date: n2 = /* @__PURE__ */ new Date(), format: i2 = void 0 !== e2 ? "utf8" : "binary", ...a2 }) {
  let s2 = void 0 !== e2 ? e2 : t2;
  if (void 0 === s2) throw Error("createMessage: must pass options object containing `text` or `binary`");
  if (e2 && !X.isString(e2) && !X.isStream(e2)) throw Error("createMessage: options.text must be a string or stream");
  if (t2 && !X.isUint8Array(t2) && !X.isStream(t2)) throw Error("createMessage: options.binary must be a Uint8Array or stream");
  const o2 = Object.keys(a2);
  if (o2.length > 0) throw Error("Unknown option: " + o2.join(", "));
  const c2 = X.isStream(s2);
  c2 && (await S(), s2 = x(s2));
  const h2 = new ah(n2);
  void 0 !== e2 ? h2.setText(s2, $.write($.literal, i2)) : h2.setBytes(s2, $.write($.literal, i2)), void 0 !== r2 && h2.setFilename(r2);
  const u2 = new yh();
  u2.push(h2);
  const l2 = new Su(u2);
  return l2.fromStream = c2, l2;
}
var Du = X.constructAllowedPackets([ch]);
var Cu = class _Cu {
  constructor(e2, t2) {
    if (this.text = X.removeTrailingSpaces(e2).replace(/\r?\n/g, "\r\n"), t2 && !(t2 instanceof jh)) throw Error("Invalid signature input");
    this.signature = t2 || new jh(new yh());
  }
  getSigningKeyIDs() {
    const e2 = [];
    return this.signature.packets.forEach(function(t2) {
      e2.push(t2.issuerKeyID);
    }), e2;
  }
  async sign(e2, t2 = null, r2 = [], n2 = /* @__PURE__ */ new Date(), i2 = [], a2 = [], s2 = ie) {
    const o2 = new ah();
    o2.setText(this.text);
    const c2 = new jh(await Ku(o2, e2, t2, r2, n2, i2, a2, true, s2));
    return new _Cu(this.text, c2);
  }
  verify(e2, t2 = /* @__PURE__ */ new Date(), r2 = ie) {
    const n2 = this.signature.packets.filterByTag($.packet.signature), i2 = new ah();
    return i2.setText(this.text), xu(n2, [i2], e2, t2, true, r2);
  }
  getText() {
    return this.text.replace(/\r\n/g, "\n");
  }
  armor(e2 = ie) {
    let t2 = this.signature.packets.map(function(e3) {
      return $.read($.hash, e3.hashAlgorithm).toUpperCase();
    });
    t2 = t2.filter(function(e3, t3, r3) {
      return r3.indexOf(e3) === t3;
    });
    const r2 = { hash: t2.join(), text: this.text, data: this.signature.packets.write() };
    return de($.armor.signed, r2, void 0, void 0, void 0, e2);
  }
};
async function Iu({ cleartextMessage: e2, config: t2, ...r2 }) {
  if (t2 = { ...ie, ...t2 }, !e2) throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");
  if (!X.isString(e2)) throw Error("readCleartextMessage: options.cleartextMessage must be a string");
  const n2 = Object.keys(r2);
  if (n2.length > 0) throw Error("Unknown option: " + n2.join(", "));
  const i2 = await ye(e2);
  if (i2.type !== $.armor.signed) throw Error("No cleartext signed message.");
  const a2 = await yh.fromBinary(i2.data, Du, t2);
  !function(e3, t3) {
    const r3 = function(e4) {
      const r4 = (e5) => (t4) => e5.hashAlgorithm === t4;
      for (let n4 = 0; n4 < t3.length; n4++) if (t3[n4].constructor.tag === $.packet.signature && !e4.some(r4(t3[n4]))) return false;
      return true;
    };
    let n3 = null, i3 = [];
    if (e3.forEach(function(e4) {
      if (n3 = e4.match(/^Hash: (.+)$/), !n3) throw Error('Only "Hash" header allowed in cleartext signed message');
      n3 = n3[1].replace(/\s/g, ""), n3 = n3.split(","), n3 = n3.map(function(e5) {
        e5 = e5.toLowerCase();
        try {
          return $.write($.hash, e5);
        } catch (t4) {
          throw Error("Unknown hash algorithm in armor header: " + e5);
        }
      }), i3 = i3.concat(n3);
    }), !i3.length && !r3([$.hash.md5])) throw Error('If no "Hash" header in cleartext signed message, then only MD5 signatures allowed');
    if (i3.length && !r3(i3)) throw Error("Hash algorithm mismatch in armor header and signature");
  }(i2.headers, a2);
  const s2 = new jh(a2);
  return new Cu(i2.text, s2);
}
async function Tu({ text: e2, ...t2 }) {
  if (!e2) throw Error("createCleartextMessage: must pass options object containing `text`");
  if (!X.isString(e2)) throw Error("createCleartextMessage: options.text must be a string");
  const r2 = Object.keys(t2);
  if (r2.length > 0) throw Error("Unknown option: " + r2.join(", "));
  return new Cu(e2);
}
async function Bu({ userIDs: e2 = [], passphrase: t2, type: r2 = "ecc", rsaBits: n2 = 4096, curve: i2 = "curve25519", keyExpirationTime: a2 = 0, date: s2 = /* @__PURE__ */ new Date(), subkeys: o2 = [{}], format: c2 = "armored", config: h2, ...u2 }) {
  Xu(h2 = { ...ie, ...h2 }), e2 = Qu(e2);
  const l2 = Object.keys(u2);
  if (l2.length > 0) throw Error("Unknown option: " + l2.join(", "));
  if (0 === e2.length) throw Error("UserIDs are required for key generation");
  if ("rsa" === r2 && n2 < h2.minRSABits) throw Error(`rsaBits should be at least ${h2.minRSABits}, got: ${n2}`);
  const y2 = { userIDs: e2, passphrase: t2, type: r2, rsaBits: n2, curve: i2, keyExpirationTime: a2, date: s2, subkeys: o2 };
  try {
    const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
      e4.sign = true, (e4 = ru(e4)).subkeys = e4.subkeys.map((t5, r4) => ru(e4.subkeys[r4], e4));
      let r3 = [Vh(e4, t4)];
      r3 = r3.concat(e4.subkeys.map((e5) => Gh(e5, t4)));
      const n3 = await Promise.all(r3), i3 = await mu(n3[0], n3.slice(1), e4, t4), a3 = await i3.getRevocationCertificate(e4.date, t4);
      return i3.revocationSignatures = [], { key: i3, revocationCertificate: a3 };
    }(y2, h2);
    return e3.getKeys().forEach(({ keyPacket: e4 }) => su(e4, h2)), { privateKey: el(e3, c2, h2), publicKey: el(e3.toPublic(), c2, h2), revocationCertificate: t3 };
  } catch (e3) {
    throw X.wrapError("Error generating keypair", e3);
  }
}
async function zu({ privateKey: e2, userIDs: t2 = [], passphrase: r2, keyExpirationTime: n2 = 0, date: i2, format: a2 = "armored", config: s2, ...o2 }) {
  Xu(s2 = { ...ie, ...s2 }), t2 = Qu(t2);
  const c2 = Object.keys(o2);
  if (c2.length > 0) throw Error("Unknown option: " + c2.join(", "));
  if (0 === t2.length) throw Error("UserIDs are required for key reformat");
  const h2 = { privateKey: e2, userIDs: t2, passphrase: r2, keyExpirationTime: n2, date: i2 };
  try {
    const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
      e4 = o3(e4);
      const { privateKey: r3 } = e4;
      if (!r3.isPrivate()) throw Error("Cannot reformat a public key");
      if (r3.keyPacket.isDummy()) throw Error("Cannot reformat a gnu-dummy primary key");
      if (!r3.getKeys().every(({ keyPacket: e5 }) => e5.isDecrypted())) throw Error("Key is not decrypted");
      const n3 = r3.keyPacket;
      e4.subkeys || (e4.subkeys = await Promise.all(r3.subkeys.map(async (e5) => {
        const r4 = e5.keyPacket, i4 = { key: n3, bind: r4 }, a4 = await Wh(e5.bindingSignatures, n3, $.signature.subkeyBinding, i4, null, t4).catch(() => ({}));
        return { sign: a4.keyFlags && a4.keyFlags[0] & $.keyFlags.signData };
      })));
      const i3 = r3.subkeys.map((e5) => e5.keyPacket);
      if (e4.subkeys.length !== i3.length) throw Error("Number of subkey options does not match number of subkeys");
      e4.subkeys = e4.subkeys.map((t5) => o3(t5, e4));
      const a3 = await mu(n3, i3, e4, t4), s3 = await a3.getRevocationCertificate(e4.date, t4);
      return a3.revocationSignatures = [], { key: a3, revocationCertificate: s3 };
      function o3(e5, t5 = {}) {
        return e5.keyExpirationTime = e5.keyExpirationTime || t5.keyExpirationTime, e5.passphrase = X.isString(e5.passphrase) ? e5.passphrase : t5.passphrase, e5.date = e5.date || t5.date, e5;
      }
    }(h2, s2);
    return { privateKey: el(e3, a2, s2), publicKey: el(e3.toPublic(), a2, s2), revocationCertificate: t3 };
  } catch (e3) {
    throw X.wrapError("Error reformatting keypair", e3);
  }
}
async function Ru({ key: e2, revocationCertificate: t2, reasonForRevocation: r2, date: n2 = /* @__PURE__ */ new Date(), format: i2 = "armored", config: a2, ...s2 }) {
  Xu(a2 = { ...ie, ...a2 });
  const o2 = Object.keys(s2);
  if (o2.length > 0) throw Error("Unknown option: " + o2.join(", "));
  try {
    const s3 = t2 ? await e2.applyRevocationCertificate(t2, n2, a2) : await e2.revoke(r2, n2, a2);
    return s3.isPrivate() ? { privateKey: el(s3, i2, a2), publicKey: el(s3.toPublic(), i2, a2) } : { privateKey: null, publicKey: el(s3, i2, a2) };
  } catch (e3) {
    throw X.wrapError("Error revoking key", e3);
  }
}
async function Mu({ privateKey: e2, passphrase: t2, config: r2, ...n2 }) {
  Xu(r2 = { ...ie, ...r2 });
  const i2 = Object.keys(n2);
  if (i2.length > 0) throw Error("Unknown option: " + i2.join(", "));
  if (!e2.isPrivate()) throw Error("Cannot decrypt a public key");
  const a2 = e2.clone(true), s2 = X.isArray(t2) ? t2 : [t2];
  try {
    return await Promise.all(a2.getKeys().map((e3) => X.anyPromise(s2.map((t3) => e3.keyPacket.decrypt(t3))))), await a2.validate(r2), a2;
  } catch (e3) {
    throw a2.clearPrivateParams(), X.wrapError("Error decrypting private key", e3);
  }
}
async function Lu({ privateKey: e2, passphrase: t2, config: r2, ...n2 }) {
  Xu(r2 = { ...ie, ...r2 });
  const i2 = Object.keys(n2);
  if (i2.length > 0) throw Error("Unknown option: " + i2.join(", "));
  if (!e2.isPrivate()) throw Error("Cannot encrypt a public key");
  const a2 = e2.clone(true), s2 = a2.getKeys(), o2 = X.isArray(t2) ? t2 : Array(s2.length).fill(t2);
  if (o2.length !== s2.length) throw Error("Invalid number of passphrases given for key encryption");
  try {
    return await Promise.all(s2.map(async (e3, t3) => {
      const { keyPacket: n3 } = e3;
      await n3.encrypt(o2[t3], r2), n3.clearPrivateParams();
    })), a2;
  } catch (e3) {
    throw a2.clearPrivateParams(), X.wrapError("Error encrypting private key", e3);
  }
}
async function Nu({ message: e2, encryptionKeys: t2, signingKeys: r2, passwords: n2, sessionKey: i2, format: a2 = "armored", signature: s2 = null, wildcard: o2 = false, signingKeyIDs: c2 = [], encryptionKeyIDs: h2 = [], date: u2 = /* @__PURE__ */ new Date(), signingUserIDs: l2 = [], encryptionUserIDs: y2 = [], signatureNotations: d2 = [], config: p2, ...f2 }) {
  if (Xu(p2 = { ...ie, ...p2 }), Vu(e2), $u(a2), t2 = Qu(t2), r2 = Qu(r2), n2 = Qu(n2), c2 = Qu(c2), h2 = Qu(h2), l2 = Qu(l2), y2 = Qu(y2), d2 = Qu(d2), f2.detached) throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");
  if (f2.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");
  if (f2.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");
  if (void 0 !== f2.armor) throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");
  const g2 = Object.keys(f2);
  if (g2.length > 0) throw Error("Unknown option: " + g2.join(", "));
  r2 || (r2 = []);
  const m2 = e2.fromStream;
  try {
    if ((r2.length || s2) && (e2 = await e2.sign(r2, s2, c2, u2, l2, d2, p2)), e2 = e2.compress(await Qh("compression", t2, u2, y2, p2), p2), e2 = await e2.encrypt(t2, n2, i2, o2, h2, u2, y2, p2), "object" === a2) return e2;
    const f3 = "armored" === a2;
    return Yu(f3 ? e2.armor(p2) : e2.write(), m2, f3 ? "utf8" : "binary");
  } catch (e3) {
    throw X.wrapError("Error encrypting message", e3);
  }
}
async function Ou({ message: e2, decryptionKeys: t2, passwords: r2, sessionKeys: n2, verificationKeys: i2, expectSigned: a2 = false, format: s2 = "utf8", signature: o2 = null, date: c2 = /* @__PURE__ */ new Date(), config: h2, ...u2 }) {
  if (Xu(h2 = { ...ie, ...h2 }), Vu(e2), i2 = Qu(i2), t2 = Qu(t2), r2 = Qu(r2), n2 = Qu(n2), u2.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");
  if (u2.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");
  const l2 = Object.keys(u2);
  if (l2.length > 0) throw Error("Unknown option: " + l2.join(", "));
  try {
    const u3 = await e2.decrypt(t2, r2, n2, c2, h2);
    i2 || (i2 = []);
    const l3 = {};
    if (l3.signatures = o2 ? await u3.verifyDetached(o2, i2, c2, h2) : await u3.verify(i2, c2, h2), l3.data = "binary" === s2 ? u3.getLiteralData() : u3.getText(), l3.filename = u3.getFilename(), Ju(l3, e2), a2) {
      if (0 === i2.length) throw Error("Verification keys are required to verify message signatures");
      if (0 === l3.signatures.length) throw Error("Message is not signed");
      l3.data = U([l3.data, q(async () => {
        await X.anyPromise(l3.signatures.map((e3) => e3.verified));
      })]);
    }
    return l3.data = await Yu(l3.data, e2.fromStream, s2), l3;
  } catch (e3) {
    throw X.wrapError("Error decrypting message", e3);
  }
}
async function Fu({ message: e2, signingKeys: t2, format: r2 = "armored", detached: n2 = false, signingKeyIDs: i2 = [], date: a2 = /* @__PURE__ */ new Date(), signingUserIDs: s2 = [], signatureNotations: o2 = [], config: c2, ...h2 }) {
  if (Xu(c2 = { ...ie, ...c2 }), Wu(e2), $u(r2), t2 = Qu(t2), i2 = Qu(i2), s2 = Qu(s2), o2 = Qu(o2), h2.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");
  if (void 0 !== h2.armor) throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");
  const u2 = Object.keys(h2);
  if (u2.length > 0) throw Error("Unknown option: " + u2.join(", "));
  if (e2 instanceof Cu && "binary" === r2) throw Error("Cannot return signed cleartext message in binary format");
  if (e2 instanceof Cu && n2) throw Error("Cannot detach-sign a cleartext message");
  if (!t2 || 0 === t2.length) throw Error("No signing keys provided");
  try {
    let h3;
    if (h3 = n2 ? await e2.signDetached(t2, void 0, i2, a2, s2, o2, c2) : await e2.sign(t2, void 0, i2, a2, s2, o2, c2), "object" === r2) return h3;
    const u3 = "armored" === r2;
    return h3 = u3 ? h3.armor(c2) : h3.write(), n2 && (h3 = R(e2.packets.write(), async (e3, t3) => {
      await Promise.all([I(h3, t3), H(e3).catch(() => {
      })]);
    })), Yu(h3, e2.fromStream, u3 ? "utf8" : "binary");
  } catch (e3) {
    throw X.wrapError("Error signing message", e3);
  }
}
async function Hu({ message: e2, verificationKeys: t2, expectSigned: r2 = false, format: n2 = "utf8", signature: i2 = null, date: a2 = /* @__PURE__ */ new Date(), config: s2, ...o2 }) {
  if (Xu(s2 = { ...ie, ...s2 }), Wu(e2), t2 = Qu(t2), o2.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");
  const c2 = Object.keys(o2);
  if (c2.length > 0) throw Error("Unknown option: " + c2.join(", "));
  if (e2 instanceof Cu && "binary" === n2) throw Error("Can't return cleartext message data as binary");
  if (e2 instanceof Cu && i2) throw Error("Can't verify detached cleartext signature");
  try {
    const o3 = {};
    if (o3.signatures = i2 ? await e2.verifyDetached(i2, t2, a2, s2) : await e2.verify(t2, a2, s2), o3.data = "binary" === n2 ? e2.getLiteralData() : e2.getText(), e2.fromStream && !i2 && Ju(o3, e2), r2) {
      if (0 === o3.signatures.length) throw Error("Message is not signed");
      o3.data = U([o3.data, q(async () => {
        await X.anyPromise(o3.signatures.map((e3) => e3.verified));
      })]);
    }
    return o3.data = await Yu(o3.data, e2.fromStream, n2), o3;
  } catch (e3) {
    throw X.wrapError("Error verifying signed message", e3);
  }
}
async function ju({ encryptionKeys: e2, date: t2 = /* @__PURE__ */ new Date(), encryptionUserIDs: r2 = [], config: n2, ...i2 }) {
  if (Xu(n2 = { ...ie, ...n2 }), e2 = Qu(e2), r2 = Qu(r2), i2.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");
  const a2 = Object.keys(i2);
  if (a2.length > 0) throw Error("Unknown option: " + a2.join(", "));
  try {
    return await Su.generateSessionKey(e2, t2, r2, n2);
  } catch (e3) {
    throw X.wrapError("Error generating session key", e3);
  }
}
async function qu({ data: e2, algorithm: t2, aeadAlgorithm: r2, encryptionKeys: n2, passwords: i2, format: a2 = "armored", wildcard: s2 = false, encryptionKeyIDs: o2 = [], date: c2 = /* @__PURE__ */ new Date(), encryptionUserIDs: h2 = [], config: u2, ...l2 }) {
  if (Xu(u2 = { ...ie, ...u2 }), function(e3, t3) {
    if (!X.isUint8Array(e3)) throw Error("Parameter [" + (t3 || "data") + "] must be of type Uint8Array");
  }(e2), function(e3, t3) {
    if (!X.isString(e3)) throw Error("Parameter [" + (t3 || "data") + "] must be of type String");
  }(t2, "algorithm"), $u(a2), n2 = Qu(n2), i2 = Qu(i2), o2 = Qu(o2), h2 = Qu(h2), l2.publicKeys) throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");
  const y2 = Object.keys(l2);
  if (y2.length > 0) throw Error("Unknown option: " + y2.join(", "));
  if (!(n2 && 0 !== n2.length || i2 && 0 !== i2.length)) throw Error("No encryption keys or passwords provided.");
  try {
    return el(await Su.encryptSessionKey(e2, t2, r2, n2, i2, s2, o2, c2, h2, u2), a2, u2);
  } catch (e3) {
    throw X.wrapError("Error encrypting session key", e3);
  }
}
async function Gu({ message: e2, decryptionKeys: t2, passwords: r2, date: n2 = /* @__PURE__ */ new Date(), config: i2, ...a2 }) {
  if (Xu(i2 = { ...ie, ...i2 }), Vu(e2), t2 = Qu(t2), r2 = Qu(r2), a2.privateKeys) throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");
  const s2 = Object.keys(a2);
  if (s2.length > 0) throw Error("Unknown option: " + s2.join(", "));
  try {
    return await e2.decryptSessionKeys(t2, r2, n2, i2);
  } catch (e3) {
    throw X.wrapError("Error decrypting session keys", e3);
  }
}
function Vu(e2) {
  if (!(e2 instanceof Su)) throw Error("Parameter [message] needs to be of type Message");
}
function Wu(e2) {
  if (!(e2 instanceof Cu || e2 instanceof Su)) throw Error("Parameter [message] needs to be of type Message or CleartextMessage");
}
function $u(e2) {
  if ("armored" !== e2 && "binary" !== e2 && "object" !== e2) throw Error("Unsupported format " + e2);
}
var Zu = Object.keys(ie).length;
function Xu(e2) {
  const t2 = Object.keys(e2);
  if (t2.length !== Zu) {
    for (const e3 of t2) if (void 0 === ie[e3]) throw Error("Unknown config property: " + e3);
  }
}
function Qu(e2) {
  return e2 && !X.isArray(e2) && (e2 = [e2]), e2;
}
async function Yu(e2, t2, r2 = "utf8") {
  const n2 = X.isStream(e2);
  return "array" === n2 ? H(e2) : "node" === t2 ? (e2 = g(e2), "binary" !== r2 && e2.setEncoding(r2), e2) : "web" === t2 && "ponyfill" === n2 ? v(e2) : e2;
}
function Ju(e2, t2) {
  e2.data = R(t2.packets.stream, async (t3, r2) => {
    await I(e2.data, r2, { preventClose: true });
    const n2 = C(r2);
    try {
      await H(t3, (e3) => e3), await n2.close();
    } catch (e3) {
      await n2.abort(e3);
    }
  });
}
function el(e2, t2, r2) {
  switch (t2) {
    case "object":
      return e2;
    case "armored":
      return e2.armor(r2);
    case "binary":
      return e2.write();
    default:
      throw Error("Unsupported format " + t2);
  }
}

export {
  $,
  ie,
  ye,
  de,
  Je,
  tt,
  rt,
  it,
  dt,
  gt,
  At,
  zt,
  Mt,
  Yt,
  yr,
  xr,
  gi,
  ah,
  ch,
  uh,
  yh,
  ph,
  _h,
  Sh,
  Kh,
  Uh,
  Dh,
  Ih,
  Th,
  Bh,
  zh,
  Rh,
  Nh,
  Oh,
  Fh,
  jh,
  qh,
  cu,
  du,
  pu,
  wu,
  bu,
  ku,
  vu,
  Su,
  Pu,
  Uu,
  Cu,
  Iu,
  Tu,
  Bu,
  zu,
  Ru,
  Mu,
  Lu,
  Nu,
  Ou,
  Fu,
  Hu,
  ju,
  qu,
  Gu
};
/*! Bundled license information:

openpgp/dist/lightweight/openpgp.min.mjs:
  (*! OpenPGP.js v5.11.2 - 2024-06-19 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. *)
*/
//# sourceMappingURL=chunk-ZB5RANMR.js.map

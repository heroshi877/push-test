"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgType = void 0;
const events_1 = require("events");
const cids_1 = __importDefault(require("cids"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const util_1 = require("util");
var MsgType;
(function (MsgType) {
    MsgType[MsgType["UPDATE"] = 0] = "UPDATE";
    MsgType[MsgType["REQUEST"] = 1] = "REQUEST";
    MsgType[MsgType["RESPONSE"] = 2] = "RESPONSE";
})(MsgType = exports.MsgType || (exports.MsgType = {}));
const TOPIC = '/ceramic';
class Dispatcher extends events_1.EventEmitter {
    constructor(_ipfs, topic = TOPIC) {
        super();
        this._ipfs = _ipfs;
        this.topic = topic;
        this._isRunning = true;
        this._documents = {};
        this.logger = ceramic_common_1.RootLogger.getLogger(Dispatcher.name);
    }
    async init() {
        this._peerId = this._peerId || (await this._ipfs.id()).id;
        await this._ipfs.pubsub.subscribe(this.topic, this.handleMessage.bind(this));
        this._log({ peer: this._peerId, event: 'subscribed', topic: this.topic });
    }
    async register(document) {
        this._documents[document.id.toString()] = document;
        const payload = { typ: MsgType.REQUEST, id: document.id.toString(), doctype: document.doctype.doctype };
        this._ipfs.pubsub.publish(this.topic, JSON.stringify(payload));
        this._log({ peer: this._peerId, event: 'published', topic: this.topic, message: payload });
    }
    unregister(id) {
        delete this._documents[id];
    }
    async storeRecord(data) {
        if (ceramic_common_1.DoctypeUtils.isSignedRecordDTO(data)) {
            const { jws, linkedBlock } = data;
            const cid = await this._ipfs.dag.put(jws, { format: 'dag-jose', hashAlg: 'sha2-256' });
            await this._ipfs.block.put(linkedBlock, { cid: jws.link.toString() });
            return cid;
        }
        return await this._ipfs.dag.put(data);
    }
    async retrieveRecord(cid) {
        return lodash_clonedeep_1.default((await this._ipfs.dag.get(cid)).value);
    }
    async publishHead(id, head, doctype) {
        if (!this._isRunning) {
            this.logger.error('Dispatcher has been closed');
            return;
        }
        const payload = { typ: MsgType.UPDATE, id, cid: head.toString(), doctype: doctype };
        await this._ipfs.pubsub.publish(this.topic, JSON.stringify(payload));
        this._log({ peer: this._peerId, event: 'published', topic: this.topic, message: payload });
    }
    async handleMessage(message) {
        if (!this._isRunning) {
            this.logger.error('Dispatcher has been closed');
            return;
        }
        if (message.from !== this._peerId) {
            let parsedMessageData;
            if (typeof message.data === 'string') {
                parsedMessageData = JSON.parse(message.data);
            }
            else {
                parsedMessageData = JSON.parse(new util_1.TextDecoder('utf-8').decode(message.data));
            }
            const logMessage = { ...message, data: parsedMessageData };
            this._log({ peer: this._peerId, event: 'received', topic: this.topic, message: logMessage });
            const { typ, id, cid } = parsedMessageData;
            if (this._documents[id]) {
                switch (typ) {
                    case MsgType.UPDATE:
                        if (typeof cid !== 'string')
                            break;
                        this._documents[id].emit('update', new cids_1.default(cid));
                        break;
                    case MsgType.REQUEST:
                        this._documents[id].emit('headreq');
                        break;
                }
            }
        }
    }
    _log(msg) {
        const timestampedMsg = { timestamp: Date.now(), ...msg };
        this.logger.debug(JSON.stringify(timestampedMsg));
    }
    async close() {
        this._isRunning = false;
        await Promise.all(Object.values(this._documents).map(async (doc) => await doc.close()));
        await this._ipfs.pubsub.unsubscribe(this.topic);
    }
}
exports.default = Dispatcher;
//# sourceMappingURL=dispatcher.js.map
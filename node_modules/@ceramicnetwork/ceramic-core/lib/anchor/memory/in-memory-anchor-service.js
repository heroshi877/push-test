"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cids_1 = __importDefault(require("cids"));
const didJwt = __importStar(require("did-jwt"));
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const base64url_1 = __importDefault(require("base64url"));
const DID_MATCHER = '^(did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?)([?][^#]*)?(#.*)?';
class Candidate {
    constructor(cid, docId, did) {
        this.cid = cid;
        this.docId = docId;
        this.did = did;
    }
    get key() {
        return this.docId + this.did;
    }
}
class InMemoryAnchorService extends ceramic_common_1.AnchorService {
    constructor(_config) {
        super();
        this._config = _config;
        this._anchorDelay = 0;
        this._anchorOnRequest = true;
        this._queue = [];
        this.SAMPLE_ETH_TX_HASH = 'bagjqcgzaday6dzalvmy5ady2m5a5legq5zrbsnlxfc2bfxej532ds7htpova';
        if (this._config) {
            this._anchorDelay = _config.anchorDelay ? _config.anchorDelay : 0;
            this._anchorOnRequest = 'anchorOnRequest' in _config ? _config.anchorOnRequest : true;
        }
    }
    async anchor() {
        const filtered = await this._filter();
        for (const candidate of filtered) {
            await this._process(candidate);
        }
        this._queue = [];
    }
    async _filter() {
        var _a, _b;
        const result = [];
        const validCandidates = {};
        let req = null;
        for (let index = 0; index < this._queue.length; index++) {
            try {
                req = this._queue[index];
                const record = (await this._ceramic.ipfs.dag.get(req.cid)).value;
                const did = await this.verifySignedRecord(record);
                const candidate = new Candidate(new cids_1.default(req.cid), req.docId, did);
                if (!validCandidates[candidate.key]) {
                    validCandidates[candidate.key] = [];
                }
                validCandidates[candidate.key].push(candidate);
            }
            catch (e) {
            }
        }
        for (const compositeKey of Object.keys(validCandidates)) {
            const candidates = validCandidates[compositeKey];
            let nonce = 0;
            let selected = null;
            for (const candidate of candidates) {
                const record = (await this._ceramic.ipfs.dag.get(candidate.cid)).value;
                let currentNonce;
                if (ceramic_common_1.DoctypeUtils.isSignedRecord(record)) {
                    const payload = (await this._ceramic.ipfs.dag.get(record.link)).value;
                    currentNonce = ((_a = payload.header) === null || _a === void 0 ? void 0 : _a.nonce) || 0;
                }
                else {
                    currentNonce = ((_b = record.header) === null || _b === void 0 ? void 0 : _b.nonce) || 0;
                }
                if (selected == null || currentNonce > nonce) {
                    selected = candidate;
                    nonce = currentNonce;
                }
            }
            result.push(selected);
        }
        return result;
    }
    set ceramic(ceramic) {
        this._ceramic = ceramic;
        this._dispatcher = this._ceramic.dispatcher;
    }
    async requestAnchor(docId, cid) {
        const candidate = new Candidate(cid, docId);
        if (this._anchorOnRequest) {
            await this._process(candidate);
        }
        else {
            this._queue.push(candidate);
        }
    }
    async _process(leaf) {
        const proofData = {
            chainId: 'eip155:1',
            blockNumber: Date.now(),
            blockTimestamp: Date.now(),
            txHash: new cids_1.default(this.SAMPLE_ETH_TX_HASH),
            root: leaf.cid,
        };
        const proof = await this._dispatcher.storeRecord(proofData);
        const record = { proof, path: '', prev: leaf.cid };
        const cid = await this._dispatcher.storeRecord(record);
        const handle = setTimeout(() => {
            this.emit(leaf.docId, { status: 'COMPLETED', message: 'CID successfully anchored.', anchorRecord: cid });
            clearTimeout(handle);
        }, this._anchorDelay);
    }
    async verifySignedRecord(record) {
        const { payload, signatures } = record;
        const { signature, protected: _protected } = signatures[0];
        const decodedHeader = JSON.parse(base64url_1.default.decode(_protected));
        const { kid } = decodedHeader;
        const didDoc = await this._ceramic.context.resolver.resolve(kid);
        const jws = [_protected, payload, signature].join(".");
        await didJwt.verifyJWS(jws, didDoc.publicKey);
        return kid.match(RegExp(DID_MATCHER))[1];
    }
    async validateChainInclusion(proof) {
    }
}
exports.default = InMemoryAnchorService;
//# sourceMappingURL=in-memory-anchor-service.js.map
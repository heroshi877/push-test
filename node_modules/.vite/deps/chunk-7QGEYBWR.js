import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_err_code
} from "./chunk-YAFUTRBD.js";
import {
  require_axiosUtil,
  require_constants,
  require_crypto_js,
  require_helpers2 as require_helpers,
  require_payloads
} from "./chunk-NYB2LBDY.js";
import {
  require_constants as require_constants2
} from "./chunk-R52GSNMP.js";
import {
  require_browser as require_browser2
} from "./chunk-NJUV6I7S.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-FOVVVYF4.js";
import {
  require_browser
} from "./chunk-7LYDIDA4.js";
import {
  require_readable_browser
} from "./chunk-D2UFQSSP.js";
import {
  dist_exports,
  init_dist
} from "./chunk-644CRGRM.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/get-browser-rtc/index.js
var require_get_browser_rtc = __commonJS({
  "node_modules/get-browser-rtc/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = function getBrowserRTC() {
      if (typeof globalThis === "undefined") return null;
      var wrtc = {
        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
      };
      if (!wrtc.RTCPeerConnection) return null;
      return wrtc;
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var promise;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/simple-peer/index.js
var require_simple_peer = __commonJS({
  "node_modules/simple-peer/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var debug = require_browser2()("simple-peer");
    var getBrowserRTC = require_get_browser_rtc();
    var randombytes = require_browser();
    var stream = require_readable_browser();
    var queueMicrotask2 = require_queue_microtask();
    var errCode = require_err_code();
    var { Buffer } = (init_dist(), __toCommonJS(dist_exports));
    var MAX_BUFFERED_AMOUNT = 64 * 1024;
    var ICECOMPLETE_TIMEOUT = 5 * 1e3;
    var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
    function filterTrickle(sdp) {
      return sdp.replace(/a=ice-options:trickle\s\n/g, "");
    }
    function warn(message) {
      console.warn(message);
    }
    var Peer = class _Peer extends stream.Duplex {
      constructor(opts) {
        opts = Object.assign({
          allowHalfOpen: false
        }, opts);
        super(opts);
        this._id = randombytes(4).toString("hex").slice(0, 7);
        this._debug("new peer %o", opts);
        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
        this.initiator = opts.initiator || false;
        this.channelConfig = opts.channelConfig || _Peer.channelConfig;
        this.channelNegotiated = this.channelConfig.negotiated;
        this.config = Object.assign({}, _Peer.config, opts.config);
        this.offerOptions = opts.offerOptions || {};
        this.answerOptions = opts.answerOptions || {};
        this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
        this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
        this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
        this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
        this.destroyed = false;
        this.destroying = false;
        this._connected = false;
        this.remoteAddress = void 0;
        this.remoteFamily = void 0;
        this.remotePort = void 0;
        this.localAddress = void 0;
        this.localFamily = void 0;
        this.localPort = void 0;
        this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
        if (!this._wrtc) {
          if (typeof window === "undefined") {
            throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
          } else {
            throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
          }
        }
        this._pcReady = false;
        this._channelReady = false;
        this._iceComplete = false;
        this._iceCompleteTimer = null;
        this._channel = null;
        this._pendingCandidates = [];
        this._isNegotiating = false;
        this._firstNegotiation = true;
        this._batchedNegotiation = false;
        this._queuedNegotiation = false;
        this._sendersAwaitingStable = [];
        this._senderMap = /* @__PURE__ */ new Map();
        this._closingInterval = null;
        this._remoteTracks = [];
        this._remoteStreams = [];
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        try {
          this._pc = new this._wrtc.RTCPeerConnection(this.config);
        } catch (err) {
          this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
          return;
        }
        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
        this._pc.oniceconnectionstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onicegatheringstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onconnectionstatechange = () => {
          this._onConnectionStateChange();
        };
        this._pc.onsignalingstatechange = () => {
          this._onSignalingStateChange();
        };
        this._pc.onicecandidate = (event) => {
          this._onIceCandidate(event);
        };
        if (typeof this._pc.peerIdentity === "object") {
          this._pc.peerIdentity.catch((err) => {
            this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
          });
        }
        if (this.initiator || this.channelNegotiated) {
          this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
          });
        } else {
          this._pc.ondatachannel = (event) => {
            this._setupData(event);
          };
        }
        if (this.streams) {
          this.streams.forEach((stream2) => {
            this.addStream(stream2);
          });
        }
        this._pc.ontrack = (event) => {
          this._onTrack(event);
        };
        this._debug("initial negotiation");
        this._needsNegotiation();
        this._onFinishBound = () => {
          this._onFinish();
        };
        this.once("finish", this._onFinishBound);
      }
      get bufferSize() {
        return this._channel && this._channel.bufferedAmount || 0;
      }
      // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
      // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
      get connected() {
        return this._connected && this._channel.readyState === "open";
      }
      address() {
        return { port: this.localPort, family: this.localFamily, address: this.localAddress };
      }
      signal(data) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (err) {
            data = {};
          }
        }
        this._debug("signal()");
        if (data.renegotiate && this.initiator) {
          this._debug("got request to renegotiate");
          this._needsNegotiation();
        }
        if (data.transceiverRequest && this.initiator) {
          this._debug("got request for transceiver");
          this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
        }
        if (data.candidate) {
          if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
            this._addIceCandidate(data.candidate);
          } else {
            this._pendingCandidates.push(data.candidate);
          }
        }
        if (data.sdp) {
          this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
            if (this.destroyed) return;
            this._pendingCandidates.forEach((candidate) => {
              this._addIceCandidate(candidate);
            });
            this._pendingCandidates = [];
            if (this._pc.remoteDescription.type === "offer") this._createAnswer();
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
          });
        }
        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
          this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
        }
      }
      _addIceCandidate(candidate) {
        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
        this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
          if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
            warn("Ignoring unsupported ICE candidate.");
          } else {
            this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
          }
        });
      }
      /**
       * Send text/binary data to the remote peer.
       * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
       */
      send(chunk) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
        this._channel.send(chunk);
      }
      /**
       * Add a Transceiver to the connection.
       * @param {String} kind
       * @param {Object} init
       */
      addTransceiver(kind, init) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTransceiver()");
        if (this.initiator) {
          try {
            this._pc.addTransceiver(kind, init);
            this._needsNegotiation();
          } catch (err) {
            this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
          }
        } else {
          this.emit("signal", {
            // request initiator to renegotiate
            type: "transceiverRequest",
            transceiverRequest: { kind, init }
          });
        }
      }
      /**
       * Add a MediaStream to the connection.
       * @param {MediaStream} stream
       */
      addStream(stream2) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addStream()");
        stream2.getTracks().forEach((track) => {
          this.addTrack(track, stream2);
        });
      }
      /**
       * Add a MediaStreamTrack to the connection.
       * @param {MediaStreamTrack} track
       * @param {MediaStream} stream
       */
      addTrack(track, stream2) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTrack()");
        const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
        let sender = submap.get(stream2);
        if (!sender) {
          sender = this._pc.addTrack(track, stream2);
          submap.set(stream2, sender);
          this._senderMap.set(track, submap);
          this._needsNegotiation();
        } else if (sender.removed) {
          throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
        } else {
          throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
        }
      }
      /**
       * Replace a MediaStreamTrack by another in the connection.
       * @param {MediaStreamTrack} oldTrack
       * @param {MediaStreamTrack} newTrack
       * @param {MediaStream} stream
       */
      replaceTrack(oldTrack, newTrack, stream2) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("replaceTrack()");
        const submap = this._senderMap.get(oldTrack);
        const sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        if (newTrack) this._senderMap.set(newTrack, submap);
        if (sender.replaceTrack != null) {
          sender.replaceTrack(newTrack);
        } else {
          this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
        }
      }
      /**
       * Remove a MediaStreamTrack from the connection.
       * @param {MediaStreamTrack} track
       * @param {MediaStream} stream
       */
      removeTrack(track, stream2) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSender()");
        const submap = this._senderMap.get(track);
        const sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        try {
          sender.removed = true;
          this._pc.removeTrack(sender);
        } catch (err) {
          if (err.name === "NS_ERROR_UNEXPECTED") {
            this._sendersAwaitingStable.push(sender);
          } else {
            this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
          }
        }
        this._needsNegotiation();
      }
      /**
       * Remove a MediaStream from the connection.
       * @param {MediaStream} stream
       */
      removeStream(stream2) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSenders()");
        stream2.getTracks().forEach((track) => {
          this.removeTrack(track, stream2);
        });
      }
      _needsNegotiation() {
        this._debug("_needsNegotiation");
        if (this._batchedNegotiation) return;
        this._batchedNegotiation = true;
        queueMicrotask2(() => {
          this._batchedNegotiation = false;
          if (this.initiator || !this._firstNegotiation) {
            this._debug("starting batched negotiation");
            this.negotiate();
          } else {
            this._debug("non-initiator initial negotiation request discarded");
          }
          this._firstNegotiation = false;
        });
      }
      negotiate() {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
        if (this.initiator) {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("start negotiation");
            setTimeout(() => {
              this._createOffer();
            }, 0);
          }
        } else {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("requesting negotiation from initiator");
            this.emit("signal", {
              // request initiator to renegotiate
              type: "renegotiate",
              renegotiate: true
            });
          }
        }
        this._isNegotiating = true;
      }
      // TODO: Delete this method once readable-stream is updated to contain a default
      // implementation of destroy() that automatically calls _destroy()
      // See: https://github.com/nodejs/readable-stream/issues/283
      destroy(err) {
        this._destroy(err, () => {
        });
      }
      _destroy(err, cb) {
        if (this.destroyed || this.destroying) return;
        this.destroying = true;
        this._debug("destroying (error: %s)", err && (err.message || err));
        queueMicrotask2(() => {
          this.destroyed = true;
          this.destroying = false;
          this._debug("destroy (error: %s)", err && (err.message || err));
          this.readable = this.writable = false;
          if (!this._readableState.ended) this.push(null);
          if (!this._writableState.finished) this.end();
          this._connected = false;
          this._pcReady = false;
          this._channelReady = false;
          this._remoteTracks = null;
          this._remoteStreams = null;
          this._senderMap = null;
          clearInterval(this._closingInterval);
          this._closingInterval = null;
          clearInterval(this._interval);
          this._interval = null;
          this._chunk = null;
          this._cb = null;
          if (this._onFinishBound) this.removeListener("finish", this._onFinishBound);
          this._onFinishBound = null;
          if (this._channel) {
            try {
              this._channel.close();
            } catch (err2) {
            }
            this._channel.onmessage = null;
            this._channel.onopen = null;
            this._channel.onclose = null;
            this._channel.onerror = null;
          }
          if (this._pc) {
            try {
              this._pc.close();
            } catch (err2) {
            }
            this._pc.oniceconnectionstatechange = null;
            this._pc.onicegatheringstatechange = null;
            this._pc.onsignalingstatechange = null;
            this._pc.onicecandidate = null;
            this._pc.ontrack = null;
            this._pc.ondatachannel = null;
          }
          this._pc = null;
          this._channel = null;
          if (err) this.emit("error", err);
          this.emit("close");
          cb();
        });
      }
      _setupData(event) {
        if (!event.channel) {
          return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
        }
        this._channel = event.channel;
        this._channel.binaryType = "arraybuffer";
        if (typeof this._channel.bufferedAmountLowThreshold === "number") {
          this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
        }
        this.channelName = this._channel.label;
        this._channel.onmessage = (event2) => {
          this._onChannelMessage(event2);
        };
        this._channel.onbufferedamountlow = () => {
          this._onChannelBufferedAmountLow();
        };
        this._channel.onopen = () => {
          this._onChannelOpen();
        };
        this._channel.onclose = () => {
          this._onChannelClose();
        };
        this._channel.onerror = (event2) => {
          const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
          this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
        };
        let isClosing = false;
        this._closingInterval = setInterval(() => {
          if (this._channel && this._channel.readyState === "closing") {
            if (isClosing) this._onChannelClose();
            isClosing = true;
          } else {
            isClosing = false;
          }
        }, CHANNEL_CLOSING_TIMEOUT);
      }
      _read() {
      }
      _write(chunk, encoding, cb) {
        if (this.destroyed) return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
        if (this._connected) {
          try {
            this.send(chunk);
          } catch (err) {
            return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
          }
          if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
            this._cb = cb;
          } else {
            cb(null);
          }
        } else {
          this._debug("write before connect");
          this._chunk = chunk;
          this._cb = cb;
        }
      }
      // When stream finishes writing, close socket. Half open connections are not
      // supported.
      _onFinish() {
        if (this.destroyed) return;
        const destroySoon = () => {
          setTimeout(() => this.destroy(), 1e3);
        };
        if (this._connected) {
          destroySoon();
        } else {
          this.once("connect", destroySoon);
        }
      }
      _startIceCompleteTimeout() {
        if (this.destroyed) return;
        if (this._iceCompleteTimer) return;
        this._debug("started iceComplete timeout");
        this._iceCompleteTimer = setTimeout(() => {
          if (!this._iceComplete) {
            this._iceComplete = true;
            this._debug("iceComplete timeout completed");
            this.emit("iceTimeout");
            this.emit("_iceComplete");
          }
        }, this.iceCompleteTimeout);
      }
      _createOffer() {
        if (this.destroyed) return;
        this._pc.createOffer(this.offerOptions).then((offer) => {
          if (this.destroyed) return;
          if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);
          offer.sdp = this.sdpTransform(offer.sdp);
          const sendOffer = () => {
            if (this.destroyed) return;
            const signal = this._pc.localDescription || offer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
          };
          const onSuccess = () => {
            this._debug("createOffer success");
            if (this.destroyed) return;
            if (this.trickle || this._iceComplete) sendOffer();
            else this.once("_iceComplete", sendOffer);
          };
          const onError = (err) => {
            this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode(err, "ERR_CREATE_OFFER"));
        });
      }
      _requestMissingTransceivers() {
        if (this._pc.getTransceivers) {
          this._pc.getTransceivers().forEach((transceiver) => {
            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
              transceiver.requested = true;
              this.addTransceiver(transceiver.sender.track.kind);
            }
          });
        }
      }
      _createAnswer() {
        if (this.destroyed) return;
        this._pc.createAnswer(this.answerOptions).then((answer) => {
          if (this.destroyed) return;
          if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);
          answer.sdp = this.sdpTransform(answer.sdp);
          const sendAnswer = () => {
            if (this.destroyed) return;
            const signal = this._pc.localDescription || answer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
            if (!this.initiator) this._requestMissingTransceivers();
          };
          const onSuccess = () => {
            if (this.destroyed) return;
            if (this.trickle || this._iceComplete) sendAnswer();
            else this.once("_iceComplete", sendAnswer);
          };
          const onError = (err) => {
            this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
        });
      }
      _onConnectionStateChange() {
        if (this.destroyed) return;
        if (this._pc.connectionState === "failed") {
          this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
        }
      }
      _onIceStateChange() {
        if (this.destroyed) return;
        const iceConnectionState = this._pc.iceConnectionState;
        const iceGatheringState = this._pc.iceGatheringState;
        this._debug(
          "iceStateChange (connection: %s) (gathering: %s)",
          iceConnectionState,
          iceGatheringState
        );
        this.emit("iceStateChange", iceConnectionState, iceGatheringState);
        if (iceConnectionState === "connected" || iceConnectionState === "completed") {
          this._pcReady = true;
          this._maybeReady();
        }
        if (iceConnectionState === "failed") {
          this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
        }
        if (iceConnectionState === "closed") {
          this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
        }
      }
      getStats(cb) {
        const flattenValues = (report) => {
          if (Object.prototype.toString.call(report.values) === "[object Array]") {
            report.values.forEach((value) => {
              Object.assign(report, value);
            });
          }
          return report;
        };
        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
          this._pc.getStats().then((res) => {
            const reports = [];
            res.forEach((report) => {
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else if (this._pc.getStats.length > 0) {
          this._pc.getStats((res) => {
            if (this.destroyed) return;
            const reports = [];
            res.result().forEach((result) => {
              const report = {};
              result.names().forEach((name) => {
                report[name] = result.stat(name);
              });
              report.id = result.id;
              report.type = result.type;
              report.timestamp = result.timestamp;
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else {
          cb(null, []);
        }
      }
      _maybeReady() {
        this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
        this._connecting = true;
        const findCandidatePair = () => {
          if (this.destroyed) return;
          this.getStats((err, items) => {
            if (this.destroyed) return;
            if (err) items = [];
            const remoteCandidates = {};
            const localCandidates = {};
            const candidatePairs = {};
            let foundSelectedCandidatePair = false;
            items.forEach((item) => {
              if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                remoteCandidates[item.id] = item;
              }
              if (item.type === "localcandidate" || item.type === "local-candidate") {
                localCandidates[item.id] = item;
              }
              if (item.type === "candidatepair" || item.type === "candidate-pair") {
                candidatePairs[item.id] = item;
              }
            });
            const setSelectedCandidatePair = (selectedCandidatePair) => {
              foundSelectedCandidatePair = true;
              let local = localCandidates[selectedCandidatePair.localCandidateId];
              if (local && (local.ip || local.address)) {
                this.localAddress = local.ip || local.address;
                this.localPort = Number(local.port);
              } else if (local && local.ipAddress) {
                this.localAddress = local.ipAddress;
                this.localPort = Number(local.portNumber);
              } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                local = selectedCandidatePair.googLocalAddress.split(":");
                this.localAddress = local[0];
                this.localPort = Number(local[1]);
              }
              if (this.localAddress) {
                this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
              }
              let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
              if (remote && (remote.ip || remote.address)) {
                this.remoteAddress = remote.ip || remote.address;
                this.remotePort = Number(remote.port);
              } else if (remote && remote.ipAddress) {
                this.remoteAddress = remote.ipAddress;
                this.remotePort = Number(remote.portNumber);
              } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                remote = selectedCandidatePair.googRemoteAddress.split(":");
                this.remoteAddress = remote[0];
                this.remotePort = Number(remote[1]);
              }
              if (this.remoteAddress) {
                this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
              }
              this._debug(
                "connect local: %s:%s remote: %s:%s",
                this.localAddress,
                this.localPort,
                this.remoteAddress,
                this.remotePort
              );
            };
            items.forEach((item) => {
              if (item.type === "transport" && item.selectedCandidatePairId) {
                setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
              }
              if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                setSelectedCandidatePair(item);
              }
            });
            if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
              setTimeout(findCandidatePair, 100);
              return;
            } else {
              this._connecting = false;
              this._connected = true;
            }
            if (this._chunk) {
              try {
                this.send(this._chunk);
              } catch (err2) {
                return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
              }
              this._chunk = null;
              this._debug('sent chunk from "write before connect"');
              const cb = this._cb;
              this._cb = null;
              cb(null);
            }
            if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
              this._interval = setInterval(() => this._onInterval(), 150);
              if (this._interval.unref) this._interval.unref();
            }
            this._debug("connect");
            this.emit("connect");
          });
        };
        findCandidatePair();
      }
      _onInterval() {
        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
          return;
        }
        this._onChannelBufferedAmountLow();
      }
      _onSignalingStateChange() {
        if (this.destroyed) return;
        if (this._pc.signalingState === "stable") {
          this._isNegotiating = false;
          this._debug("flushing sender queue", this._sendersAwaitingStable);
          this._sendersAwaitingStable.forEach((sender) => {
            this._pc.removeTrack(sender);
            this._queuedNegotiation = true;
          });
          this._sendersAwaitingStable = [];
          if (this._queuedNegotiation) {
            this._debug("flushing negotiation queue");
            this._queuedNegotiation = false;
            this._needsNegotiation();
          } else {
            this._debug("negotiated");
            this.emit("negotiated");
          }
        }
        this._debug("signalingStateChange %s", this._pc.signalingState);
        this.emit("signalingStateChange", this._pc.signalingState);
      }
      _onIceCandidate(event) {
        if (this.destroyed) return;
        if (event.candidate && this.trickle) {
          this.emit("signal", {
            type: "candidate",
            candidate: {
              candidate: event.candidate.candidate,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              sdpMid: event.candidate.sdpMid
            }
          });
        } else if (!event.candidate && !this._iceComplete) {
          this._iceComplete = true;
          this.emit("_iceComplete");
        }
        if (event.candidate) {
          this._startIceCompleteTimeout();
        }
      }
      _onChannelMessage(event) {
        if (this.destroyed) return;
        let data = event.data;
        if (data instanceof ArrayBuffer) data = Buffer.from(data);
        this.push(data);
      }
      _onChannelBufferedAmountLow() {
        if (this.destroyed || !this._cb) return;
        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        const cb = this._cb;
        this._cb = null;
        cb(null);
      }
      _onChannelOpen() {
        if (this._connected || this.destroyed) return;
        this._debug("on channel open");
        this._channelReady = true;
        this._maybeReady();
      }
      _onChannelClose() {
        if (this.destroyed) return;
        this._debug("on channel close");
        this.destroy();
      }
      _onTrack(event) {
        if (this.destroyed) return;
        event.streams.forEach((eventStream) => {
          this._debug("on track");
          this.emit("track", event.track, eventStream);
          this._remoteTracks.push({
            track: event.track,
            stream: eventStream
          });
          if (this._remoteStreams.some((remoteStream) => {
            return remoteStream.id === eventStream.id;
          })) return;
          this._remoteStreams.push(eventStream);
          queueMicrotask2(() => {
            this._debug("on stream");
            this.emit("stream", eventStream);
          });
        });
      }
      _debug() {
        const args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug.apply(null, args);
      }
    };
    Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
    Peer.config = {
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:global.stun.twilio.com:3478"
          ]
        }
      ],
      sdpSemantics: "unified-plan"
    };
    Peer.channelConfig = {};
    module.exports = Peer;
  }
});

// node_modules/immer/dist/cjs/immer.cjs.production.js
var require_immer_cjs_production = __commonJS({
  "node_modules/immer/dist/cjs/immer.cjs.production.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var ne = Object.defineProperty;
    var ge = Object.getOwnPropertyDescriptor;
    var be = Object.getOwnPropertyNames;
    var Te = Object.prototype.hasOwnProperty;
    var Ae = (e, t) => {
      for (var r in t) ne(e, r, { get: t[r], enumerable: true });
    };
    var Ie = (e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function") for (let i of be(t)) !Te.call(e, i) && i !== r && ne(e, i, { get: () => t[i], enumerable: !(n = ge(t, i)) || n.enumerable });
      return e;
    };
    var De = (e) => Ie(ne({}, "__esModule", { value: true }), e);
    var Be = {};
    Ae(Be, { Immer: () => J, applyPatches: () => Ce, castDraft: () => ke, castImmutable: () => Ke, createDraft: () => Re, current: () => re, enableMapSet: () => xe, enablePatches: () => Pe, finishDraft: () => ve, freeze: () => K, immerable: () => N, isDraft: () => O, isDraftable: () => A, nothing: () => j, original: () => le, produce: () => Fe, produceWithPatches: () => Ne, setAutoFreeze: () => ze, setUseStrictShallowCopy: () => je });
    module.exports = De(Be);
    var j = Symbol.for("immer-nothing");
    var N = Symbol.for("immer-draftable");
    var u = Symbol.for("immer-state");
    function h(e, ...t) {
      throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`);
    }
    var z = Object.getPrototypeOf;
    function O(e) {
      return !!e && !!e[u];
    }
    function A(e) {
      return e ? ye(e) || Array.isArray(e) || !!e[N] || !!e.constructor?.[N] || v(e) || k(e) : false;
    }
    var Oe = Object.prototype.constructor.toString();
    function ye(e) {
      if (!e || typeof e != "object") return false;
      let t = z(e);
      if (t === null) return true;
      let r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
      return r === Object ? true : typeof r == "function" && Function.toString.call(r) === Oe;
    }
    function le(e) {
      return O(e) || h(15, e), e[u].t;
    }
    function _(e, t) {
      C(e) === 0 ? Reflect.ownKeys(e).forEach((r) => {
        t(r, e[r], e);
      }) : e.forEach((r, n) => t(n, r, e));
    }
    function C(e) {
      let t = e[u];
      return t ? t.o : Array.isArray(e) ? 1 : v(e) ? 2 : k(e) ? 3 : 0;
    }
    function R(e, t) {
      return C(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
    }
    function X(e, t) {
      return C(e) === 2 ? e.get(t) : e[t];
    }
    function Q(e, t, r) {
      let n = C(e);
      n === 2 ? e.set(t, r) : n === 3 ? e.add(r) : e[t] = r;
    }
    function pe(e, t) {
      return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
    }
    function v(e) {
      return e instanceof Map;
    }
    function k(e) {
      return e instanceof Set;
    }
    function T(e) {
      return e.e || e.t;
    }
    function L(e, t) {
      if (v(e)) return new Map(e);
      if (k(e)) return new Set(e);
      if (Array.isArray(e)) return Array.prototype.slice.call(e);
      let r = ye(e);
      if (t === true || t === "class_only" && !r) {
        let n = Object.getOwnPropertyDescriptors(e);
        delete n[u];
        let i = Reflect.ownKeys(n);
        for (let f = 0; f < i.length; f++) {
          let l = i[f], c = n[l];
          c.writable === false && (c.writable = true, c.configurable = true), (c.get || c.set) && (n[l] = { configurable: true, writable: true, enumerable: c.enumerable, value: e[l] });
        }
        return Object.create(z(e), n);
      } else {
        let n = z(e);
        if (n !== null && r) return { ...e };
        let i = Object.create(n);
        return Object.assign(i, e);
      }
    }
    function K(e, t = false) {
      return $(e) || O(e) || !A(e) || (C(e) > 1 && (e.set = e.add = e.clear = e.delete = Me), Object.freeze(e), t && Object.entries(e).forEach(([r, n]) => K(n, true))), e;
    }
    function Me() {
      h(2);
    }
    function $(e) {
      return Object.isFrozen(e);
    }
    var ae = {};
    function w(e) {
      let t = ae[e];
      return t || h(0, e), t;
    }
    function Y(e, t) {
      ae[e] || (ae[e] = t);
    }
    var U;
    function B() {
      return U;
    }
    function _e(e, t) {
      return { a: [], i: e, p: t, P: true, d: 0 };
    }
    function oe(e, t) {
      t && (w("Patches"), e.f = [], e.h = [], e.b = t);
    }
    function V(e) {
      Z(e), e.a.forEach(we), e.a = null;
    }
    function Z(e) {
      e === U && (U = e.i);
    }
    function ie(e) {
      return U = _e(U, e);
    }
    function we(e) {
      let t = e[u];
      t.o === 0 || t.o === 1 ? t.x() : t.m = true;
    }
    function se(e, t) {
      t.d = t.a.length;
      let r = t.a[0];
      return e !== void 0 && e !== r ? (r[u].s && (V(t), h(4)), A(e) && (e = ee(t, e), t.i || te(t, e)), t.f && w("Patches").T(r[u].t, e, t.f, t.h)) : e = ee(t, r, []), V(t), t.f && t.b(t.f, t.h), e !== j ? e : void 0;
    }
    function ee(e, t, r) {
      if ($(t)) return t;
      let n = t[u];
      if (!n) return _(t, (i, f) => de(e, n, t, i, f, r)), t;
      if (n.n !== e) return t;
      if (!n.s) return te(e, n.t, true), n.t;
      if (!n.c) {
        n.c = true, n.n.d--;
        let i = n.e, f = i, l = false;
        n.o === 3 && (f = new Set(i), i.clear(), l = true), _(f, (c, b) => de(e, n, i, c, b, r, l)), te(e, i, false), r && e.f && w("Patches").g(n, r, e.f, e.h);
      }
      return n.e;
    }
    function de(e, t, r, n, i, f, l) {
      if (O(i)) {
        let c = f && t && t.o !== 3 && !R(t.r, n) ? f.concat(n) : void 0, b = ee(e, i, c);
        if (Q(r, n, b), O(b)) e.P = false;
        else return;
      } else l && r.add(i);
      if (A(i) && !$(i)) {
        if (!e.p.y && e.d < 1) return;
        ee(e, i), (!t || !t.n.i) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && te(e, i);
      }
    }
    function te(e, t, r = false) {
      !e.i && e.p.y && e.P && K(t, r);
    }
    function he(e, t) {
      let r = Array.isArray(e), n = { o: r ? 1 : 0, n: t ? t.n : B(), s: false, c: false, r: {}, i: t, t: e, u: null, e: null, x: null, l: false }, i = n, f = ue;
      r && (i = [n], f = q);
      let { revoke: l, proxy: c } = Proxy.revocable(i, f);
      return n.u = c, n.x = l, c;
    }
    var ue = { get(e, t) {
      if (t === u) return e;
      let r = T(e);
      if (!R(r, t)) return Ee(e, r, t);
      let n = r[t];
      return e.c || !A(n) ? n : n === ce(e.t, t) ? (fe(e), e.e[t] = W(n, e)) : n;
    }, has(e, t) {
      return t in T(e);
    }, ownKeys(e) {
      return Reflect.ownKeys(T(e));
    }, set(e, t, r) {
      let n = me(T(e), t);
      if (n?.set) return n.set.call(e.u, r), true;
      if (!e.s) {
        let i = ce(T(e), t), f = i?.[u];
        if (f && f.t === r) return e.e[t] = r, e.r[t] = false, true;
        if (pe(r, i) && (r !== void 0 || R(e.t, t))) return true;
        fe(e), E(e);
      }
      return e.e[t] === r && (r !== void 0 || t in e.e) || Number.isNaN(r) && Number.isNaN(e.e[t]) || (e.e[t] = r, e.r[t] = true), true;
    }, deleteProperty(e, t) {
      return ce(e.t, t) !== void 0 || t in e.t ? (e.r[t] = false, fe(e), E(e)) : delete e.r[t], e.e && delete e.e[t], true;
    }, getOwnPropertyDescriptor(e, t) {
      let r = T(e), n = Reflect.getOwnPropertyDescriptor(r, t);
      return n && { writable: true, configurable: e.o !== 1 || t !== "length", enumerable: n.enumerable, value: r[t] };
    }, defineProperty() {
      h(11);
    }, getPrototypeOf(e) {
      return z(e.t);
    }, setPrototypeOf() {
      h(12);
    } };
    var q = {};
    _(ue, (e, t) => {
      q[e] = function() {
        return arguments[0] = arguments[0][0], t.apply(this, arguments);
      };
    });
    q.deleteProperty = function(e, t) {
      return q.set.call(this, e, t, void 0);
    };
    q.set = function(e, t, r) {
      return ue.set.call(this, e[0], t, r, e[0]);
    };
    function ce(e, t) {
      let r = e[u];
      return (r ? T(r) : e)[t];
    }
    function Ee(e, t, r) {
      let n = me(t, r);
      return n ? "value" in n ? n.value : n.get?.call(e.u) : void 0;
    }
    function me(e, t) {
      if (!(t in e)) return;
      let r = z(e);
      for (; r; ) {
        let n = Object.getOwnPropertyDescriptor(r, t);
        if (n) return n;
        r = z(r);
      }
    }
    function E(e) {
      e.s || (e.s = true, e.i && E(e.i));
    }
    function fe(e) {
      e.e || (e.e = L(e.t, e.n.p.S));
    }
    var J = class {
      constructor(t) {
        this.y = true;
        this.S = false;
        this.produce = (t2, r, n) => {
          if (typeof t2 == "function" && typeof r != "function") {
            let f = r;
            r = t2;
            let l = this;
            return function(b = f, ...a) {
              return l.produce(b, (o) => r.call(this, o, ...a));
            };
          }
          typeof r != "function" && h(6), n !== void 0 && typeof n != "function" && h(7);
          let i;
          if (A(t2)) {
            let f = ie(this), l = W(t2, void 0), c = true;
            try {
              i = r(l), c = false;
            } finally {
              c ? V(f) : Z(f);
            }
            return oe(f, n), se(i, f);
          } else if (!t2 || typeof t2 != "object") {
            if (i = r(t2), i === void 0 && (i = t2), i === j && (i = void 0), this.y && K(i, true), n) {
              let f = [], l = [];
              w("Patches").T(t2, i, f, l), n(f, l);
            }
            return i;
          } else h(1, t2);
        };
        this.produceWithPatches = (t2, r) => {
          if (typeof t2 == "function") return (l, ...c) => this.produceWithPatches(l, (b) => t2(b, ...c));
          let n, i;
          return [this.produce(t2, r, (l, c) => {
            n = l, i = c;
          }), n, i];
        };
        typeof t?.autoFreeze == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof t?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
      }
      createDraft(t) {
        A(t) || h(8), O(t) && (t = re(t));
        let r = ie(this), n = W(t, void 0);
        return n[u].l = true, Z(r), n;
      }
      finishDraft(t, r) {
        let n = t && t[u];
        (!n || !n.l) && h(9);
        let { n: i } = n;
        return oe(i, r), se(void 0, i);
      }
      setAutoFreeze(t) {
        this.y = t;
      }
      setUseStrictShallowCopy(t) {
        this.S = t;
      }
      applyPatches(t, r) {
        let n;
        for (n = r.length - 1; n >= 0; n--) {
          let f = r[n];
          if (f.path.length === 0 && f.op === "replace") {
            t = f.value;
            break;
          }
        }
        n > -1 && (r = r.slice(n + 1));
        let i = w("Patches").A;
        return O(t) ? i(t, r) : this.produce(t, (f) => i(f, r));
      }
    };
    function W(e, t) {
      let r = v(e) ? w("MapSet").I(e, t) : k(e) ? w("MapSet").D(e, t) : he(e, t);
      return (t ? t.n : B()).a.push(r), r;
    }
    function re(e) {
      return O(e) || h(10, e), Se(e);
    }
    function Se(e) {
      if (!A(e) || $(e)) return e;
      let t = e[u], r;
      if (t) {
        if (!t.s) return t.t;
        t.c = true, r = L(e, t.n.p.S);
      } else r = L(e, true);
      return _(r, (n, i) => {
        Q(r, n, Se(i));
      }), t && (t.c = false), r;
    }
    function Pe() {
      let t = "replace", r = "add", n = "remove";
      function i(s, S, m, x) {
        switch (s.o) {
          case 0:
          case 2:
            return l(s, S, m, x);
          case 1:
            return f(s, S, m, x);
          case 3:
            return c(s, S, m, x);
        }
      }
      function f(s, S, m, x) {
        let { t: I, r: P } = s, g = s.e;
        g.length < I.length && ([I, g] = [g, I], [m, x] = [x, m]);
        for (let y = 0; y < I.length; y++) if (P[y] && g[y] !== I[y]) {
          let d = S.concat([y]);
          m.push({ op: t, path: d, value: p(g[y]) }), x.push({ op: t, path: d, value: p(I[y]) });
        }
        for (let y = I.length; y < g.length; y++) {
          let d = S.concat([y]);
          m.push({ op: r, path: d, value: p(g[y]) });
        }
        for (let y = g.length - 1; I.length <= y; --y) {
          let d = S.concat([y]);
          x.push({ op: n, path: d });
        }
      }
      function l(s, S, m, x) {
        let { t: I, e: P } = s;
        _(s.r, (g, y) => {
          let d = X(I, g), H = X(P, g), F = y ? R(I, g) ? t : r : n;
          if (d === H && F === t) return;
          let D = S.concat(g);
          m.push(F === n ? { op: F, path: D } : { op: F, path: D, value: H }), x.push(F === r ? { op: n, path: D } : F === n ? { op: r, path: D, value: p(d) } : { op: t, path: D, value: p(d) });
        });
      }
      function c(s, S, m, x) {
        let { t: I, e: P } = s, g = 0;
        I.forEach((y) => {
          if (!P.has(y)) {
            let d = S.concat([g]);
            m.push({ op: n, path: d, value: y }), x.unshift({ op: r, path: d, value: y });
          }
          g++;
        }), g = 0, P.forEach((y) => {
          if (!I.has(y)) {
            let d = S.concat([g]);
            m.push({ op: r, path: d, value: y }), x.unshift({ op: n, path: d, value: y });
          }
          g++;
        });
      }
      function b(s, S, m, x) {
        m.push({ op: t, path: [], value: S === j ? void 0 : S }), x.push({ op: t, path: [], value: s });
      }
      function a(s, S) {
        return S.forEach((m) => {
          let { path: x, op: I } = m, P = s;
          for (let H = 0; H < x.length - 1; H++) {
            let F = C(P), D = x[H];
            typeof D != "string" && typeof D != "number" && (D = "" + D), (F === 0 || F === 1) && (D === "__proto__" || D === "constructor") && h(16 + 3), typeof P == "function" && D === "prototype" && h(16 + 3), P = X(P, D), typeof P != "object" && h(16 + 2, x.join("/"));
          }
          let g = C(P), y = o(m.value), d = x[x.length - 1];
          switch (I) {
            case t:
              switch (g) {
                case 2:
                  return P.set(d, y);
                case 3:
                  h(16);
                default:
                  return P[d] = y;
              }
            case r:
              switch (g) {
                case 1:
                  return d === "-" ? P.push(y) : P.splice(d, 0, y);
                case 2:
                  return P.set(d, y);
                case 3:
                  return P.add(y);
                default:
                  return P[d] = y;
              }
            case n:
              switch (g) {
                case 1:
                  return P.splice(d, 1);
                case 2:
                  return P.delete(d);
                case 3:
                  return P.delete(m.value);
                default:
                  return delete P[d];
              }
            default:
              h(16 + 1, I);
          }
        }), s;
      }
      function o(s) {
        if (!A(s)) return s;
        if (Array.isArray(s)) return s.map(o);
        if (v(s)) return new Map(Array.from(s.entries()).map(([m, x]) => [m, o(x)]));
        if (k(s)) return new Set(Array.from(s).map(o));
        let S = Object.create(z(s));
        for (let m in s) S[m] = o(s[m]);
        return R(s, N) && (S[N] = s[N]), S;
      }
      function p(s) {
        return O(s) ? o(s) : s;
      }
      Y("Patches", { A: a, g: i, T: b });
    }
    function xe() {
      class e extends Map {
        constructor(a, o) {
          super();
          this[u] = { o: 2, i: o, n: o ? o.n : B(), s: false, c: false, e: void 0, r: void 0, t: a, u: this, l: false, m: false };
        }
        get size() {
          return T(this[u]).size;
        }
        has(a) {
          return T(this[u]).has(a);
        }
        set(a, o) {
          let p = this[u];
          return l(p), (!T(p).has(a) || T(p).get(a) !== o) && (r(p), E(p), p.r.set(a, true), p.e.set(a, o), p.r.set(a, true)), this;
        }
        delete(a) {
          if (!this.has(a)) return false;
          let o = this[u];
          return l(o), r(o), E(o), o.t.has(a) ? o.r.set(a, false) : o.r.delete(a), o.e.delete(a), true;
        }
        clear() {
          let a = this[u];
          l(a), T(a).size && (r(a), E(a), a.r = /* @__PURE__ */ new Map(), _(a.t, (o) => {
            a.r.set(o, false);
          }), a.e.clear());
        }
        forEach(a, o) {
          let p = this[u];
          T(p).forEach((s, S, m) => {
            a.call(o, this.get(S), S, this);
          });
        }
        get(a) {
          let o = this[u];
          l(o);
          let p = T(o).get(a);
          if (o.c || !A(p) || p !== o.t.get(a)) return p;
          let s = W(p, o);
          return r(o), o.e.set(a, s), s;
        }
        keys() {
          return T(this[u]).keys();
        }
        values() {
          let a = this.keys();
          return { [Symbol.iterator]: () => this.values(), next: () => {
            let o = a.next();
            return o.done ? o : { done: false, value: this.get(o.value) };
          } };
        }
        entries() {
          let a = this.keys();
          return { [Symbol.iterator]: () => this.entries(), next: () => {
            let o = a.next();
            if (o.done) return o;
            let p = this.get(o.value);
            return { done: false, value: [o.value, p] };
          } };
        }
        [(u, Symbol.iterator)]() {
          return this.entries();
        }
      }
      function t(c, b) {
        return new e(c, b);
      }
      function r(c) {
        c.e || (c.r = /* @__PURE__ */ new Map(), c.e = new Map(c.t));
      }
      class n extends Set {
        constructor(a, o) {
          super();
          this[u] = { o: 3, i: o, n: o ? o.n : B(), s: false, c: false, e: void 0, t: a, u: this, a: /* @__PURE__ */ new Map(), m: false, l: false };
        }
        get size() {
          return T(this[u]).size;
        }
        has(a) {
          let o = this[u];
          return l(o), o.e ? !!(o.e.has(a) || o.a.has(a) && o.e.has(o.a.get(a))) : o.t.has(a);
        }
        add(a) {
          let o = this[u];
          return l(o), this.has(a) || (f(o), E(o), o.e.add(a)), this;
        }
        delete(a) {
          if (!this.has(a)) return false;
          let o = this[u];
          return l(o), f(o), E(o), o.e.delete(a) || (o.a.has(a) ? o.e.delete(o.a.get(a)) : false);
        }
        clear() {
          let a = this[u];
          l(a), T(a).size && (f(a), E(a), a.e.clear());
        }
        values() {
          let a = this[u];
          return l(a), f(a), a.e.values();
        }
        entries() {
          let a = this[u];
          return l(a), f(a), a.e.entries();
        }
        keys() {
          return this.values();
        }
        [(u, Symbol.iterator)]() {
          return this.values();
        }
        forEach(a, o) {
          let p = this.values(), s = p.next();
          for (; !s.done; ) a.call(o, s.value, s.value, this), s = p.next();
        }
      }
      function i(c, b) {
        return new n(c, b);
      }
      function f(c) {
        c.e || (c.e = /* @__PURE__ */ new Set(), c.t.forEach((b) => {
          if (A(b)) {
            let a = W(b, c);
            c.a.set(b, a), c.e.add(a);
          } else c.e.add(b);
        }));
      }
      function l(c) {
        c.m && h(3, JSON.stringify(T(c)));
      }
      Y("MapSet", { I: t, D: i });
    }
    var M = new J();
    var Fe = M.produce;
    var Ne = M.produceWithPatches.bind(M);
    var ze = M.setAutoFreeze.bind(M);
    var je = M.setUseStrictShallowCopy.bind(M);
    var Ce = M.applyPatches.bind(M);
    var Re = M.createDraft.bind(M);
    var ve = M.finishDraft.bind(M);
    function ke(e) {
      return e;
    }
    function Ke(e) {
      return e;
    }
  }
});

// node_modules/immer/dist/cjs/immer.cjs.development.js
var require_immer_cjs_development = __commonJS({
  "node_modules/immer/dist/cjs/immer.cjs.development.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var immer_exports = {};
    __export(immer_exports, {
      Immer: () => Immer2,
      applyPatches: () => applyPatches2,
      castDraft: () => castDraft2,
      castImmutable: () => castImmutable2,
      createDraft: () => createDraft2,
      current: () => current2,
      enableMapSet: () => enableMapSet2,
      enablePatches: () => enablePatches2,
      finishDraft: () => finishDraft2,
      freeze: () => freeze2,
      immerable: () => DRAFTABLE,
      isDraft: () => isDraft2,
      isDraftable: () => isDraftable2,
      nothing: () => NOTHING,
      original: () => original2,
      produce: () => produce2,
      produceWithPatches: () => produceWithPatches2,
      setAutoFreeze: () => setAutoFreeze2,
      setUseStrictShallowCopy: () => setUseStrictShallowCopy2
    });
    module.exports = __toCommonJS2(immer_exports);
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    var errors = process.env.NODE_ENV !== "production" ? [
      // All error codes, starting by 0:
      function(plugin) {
        return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
      },
      function(thing) {
        return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
      },
      "This object has been frozen and should not be mutated",
      function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      "Immer forbids circular references",
      "The first or second argument to `produce` must be a function",
      "The third argument to `produce` must be a function or undefined",
      "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      "First argument to `finishDraft` must be a draft returned by `createDraft`",
      function(thing) {
        return `'current' expects a draft, got: ${thing}`;
      },
      "Object.defineProperty() cannot be used on an Immer draft",
      "Object.setPrototypeOf() cannot be used on an Immer draft",
      "Immer only supports deleting array indices",
      "Immer only supports setting array indices and the 'length' property",
      function(thing) {
        return `'original' expects a draft, got: ${thing}`;
      }
      // Note: if more errors are added, the errorOffset in Patches.ts should be increased
      // See Patches.ts for additional errors
    ] : [];
    function die(error, ...args) {
      if (process.env.NODE_ENV !== "production") {
        const e = errors[error];
        const msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error(`[Immer] ${msg}`);
      }
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft2(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable2(value) {
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      const proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original2(value) {
      if (!isDraft2(value))
        die(15, value);
      return value[DRAFT_STATE].base_;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0) {
        Reflect.ownKeys(obj).forEach((key) => {
          iter(key, obj[key], obj);
        });
      } else {
        obj.forEach((entry, index) => iter(index, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      const t = getArchtype(thing);
      if (t === 2)
        thing.set(propOrOldValue, value);
      else if (t === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function isMap(target) {
      return target instanceof Map;
    }
    function isSet(target) {
      return target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base, strict) {
      if (isMap(base)) {
        return new Map(base);
      }
      if (isSet(base)) {
        return new Set(base);
      }
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      const isPlain = isPlainObject(base);
      if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys = Reflect.ownKeys(descriptors);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const desc = descriptors[key];
          if (desc.writable === false) {
            desc.writable = true;
            desc.configurable = true;
          }
          if (desc.get || desc.set)
            descriptors[key] = {
              configurable: true,
              writable: true,
              // could live with !!desc.set as well here...
              enumerable: desc.enumerable,
              value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
      } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
          return { ...base };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
      }
    }
    function freeze2(obj, deep = false) {
      if (isFrozen(obj) || isDraft2(obj) || !isDraftable2(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        Object.entries(obj).forEach(([key, value]) => freeze2(value, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      const baseDraft = scope.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable2(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope.patches_,
            scope.inversePatches_
          );
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (process.env.NODE_ENV !== "production" && childValue === targetObject)
        die(5);
      if (isDraft2(childValue)) {
        const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft2(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable2(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep = false) {
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze2(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      const isArray = Array.isArray(base);
      const state = {
        type_: isArray ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target = state;
      let traps = objectTraps;
      if (isArray) {
        target = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value = source[prop];
        if (state.finalized_ || !isDraftable2(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value, state);
        }
        return value;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          const current22 = peek(latest(state), prop);
          const currentState = current22?.[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current22) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key, fn) => {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      const desc = getDescriptorFromProto(source, prop);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        desc.get?.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable2(base)) {
            const scope = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze2(result, true);
            if (patchListener) {
              const p = [];
              const ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p, ip) => {
            patches = p;
            inversePatches = ip;
          });
          return [result, patches, inversePatches];
        };
        if (typeof config?.autoFreeze === "boolean")
          this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean")
          this.setUseStrictShallowCopy(config.useStrictShallowCopy);
      }
      createDraft(base) {
        if (!isDraftable2(base))
          die(8);
        if (isDraft2(base))
          base = current2(base);
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope } = state;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value) {
        this.autoFreeze_ = value;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value) {
        this.useStrictShallowCopy_ = value;
      }
      applyPatches(base, patches) {
        let i;
        for (i = patches.length - 1; i >= 0; i--) {
          const patch = patches[i];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i > -1) {
          patches = patches.slice(i + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft2(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value, parent) {
      const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
      const scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current2(value) {
      if (!isDraft2(value))
        die(10, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable2(value) || isFrozen(value))
        return value;
      const state = value[DRAFT_STATE];
      let copy;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy = shallowCopy(value, true);
      }
      each(copy, (key, childValue) => {
        set(copy, key, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy;
    }
    function enablePatches2() {
      const errorOffset = 16;
      if (process.env.NODE_ENV !== "production") {
        errors.push(
          'Sets cannot have "replace" patches.',
          function(op) {
            return "Unsupported patch operation: " + op;
          },
          function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
          },
          "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
        );
      }
      const REPLACE = "replace";
      const ADD = "add";
      const REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 2:
            return generatePatchesFromAssigned(
              state,
              basePath,
              patches,
              inversePatches
            );
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(
              state,
              basePath,
              patches,
              inversePatches
            );
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        let { base_, assigned_ } = state;
        let copy_ = state.copy_;
        if (copy_.length < base_.length) {
          ;
          [base_, copy_] = [copy_, base_];
          [patches, inversePatches] = [inversePatches, patches];
        }
        for (let i = 0; i < base_.length; i++) {
          if (assigned_[i] && copy_[i] !== base_[i]) {
            const path = basePath.concat([i]);
            patches.push({
              op: REPLACE,
              path,
              // Need to maybe clone it, as it can in fact be the original value
              // due to the base/copy inversion at the start of this function
              value: clonePatchValueIfNeeded(copy_[i])
            });
            inversePatches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(base_[i])
            });
          }
        }
        for (let i = base_.length; i < copy_.length; i++) {
          const path = basePath.concat([i]);
          patches.push({
            op: ADD,
            path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[i])
          });
        }
        for (let i = copy_.length - 1; base_.length <= i; --i) {
          const path = basePath.concat([i]);
          inversePatches.push({
            op: REMOVE,
            path
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        const { base_, copy_ } = state;
        each(state.assigned_, (key, assignedValue) => {
          const origValue = get(base_, key);
          const value = get(copy_, key);
          const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          const path = basePath.concat(key);
          patches.push(op === REMOVE ? { op, path } : { op, path, value });
          inversePatches.push(
            op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
          );
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        let { base_, copy_ } = state;
        let i = 0;
        base_.forEach((value) => {
          if (!copy_.has(value)) {
            const path = basePath.concat([i]);
            patches.push({
              op: REMOVE,
              path,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path,
              value
            });
          }
          i++;
        });
        i = 0;
        copy_.forEach((value) => {
          if (!base_.has(value)) {
            const path = basePath.concat([i]);
            patches.push({
              op: ADD,
              path,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path,
              value
            });
          }
          i++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach((patch) => {
          const { path, op } = patch;
          let base = draft;
          for (let i = 0; i < path.length - 1; i++) {
            const parentType = getArchtype(base);
            let p = path[i];
            if (typeof p !== "string" && typeof p !== "number") {
              p = "" + p;
            }
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(errorOffset + 3);
            if (typeof base === "function" && p === "prototype")
              die(errorOffset + 3);
            base = get(base, p);
            if (typeof base !== "object")
              die(errorOffset + 2, path.join("/"));
          }
          const type = getArchtype(base);
          const value = deepClonePatchValue(patch.value);
          const key = path[path.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(errorOffset);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(errorOffset + 1, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable2(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(
            Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
          );
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        const cloned = Object.create(getPrototypeOf(obj));
        for (const key in obj)
          cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft2(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet2() {
      class DraftMap extends Map {
        constructor(target, parent) {
          super();
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
        }
        get size() {
          return latest(this[DRAFT_STATE]).size;
        }
        has(key) {
          return latest(this[DRAFT_STATE]).has(key);
        }
        set(key, value) {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        }
        delete(key) {
          if (!this.has(key)) {
            return false;
          }
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        }
        clear() {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, (key) => {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        }
        forEach(cb, thisArg) {
          const state = this[DRAFT_STATE];
          latest(state).forEach((_value, key, _map) => {
            cb.call(thisArg, this.get(key), key, this);
          });
        }
        get(key) {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          const value = latest(state).get(key);
          if (state.finalized_ || !isDraftable2(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          const draft = createProxy(value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        }
        keys() {
          return latest(this[DRAFT_STATE]).keys();
        }
        values() {
          const iterator = this.keys();
          return {
            [Symbol.iterator]: () => this.values(),
            next: () => {
              const r = iterator.next();
              if (r.done)
                return r;
              const value = this.get(r.value);
              return {
                done: false,
                value
              };
            }
          };
        }
        entries() {
          const iterator = this.keys();
          return {
            [Symbol.iterator]: () => this.entries(),
            next: () => {
              const r = iterator.next();
              if (r.done)
                return r;
              const value = this.get(r.value);
              return {
                done: false,
                value: [r.value, value]
              };
            }
          };
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
          return this.entries();
        }
      }
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      class DraftSet extends Set {
        constructor(target, parent) {
          super();
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
        }
        get size() {
          return latest(this[DRAFT_STATE]).size;
        }
        has(value) {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        }
        add(value) {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        }
        delete(value) {
          if (!this.has(value)) {
            return false;
          }
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
            /* istanbul ignore next */
            false
          ));
        }
        clear() {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        }
        values() {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        }
        entries() {
          const state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        }
        keys() {
          return this.values();
        }
        [(DRAFT_STATE, Symbol.iterator)]() {
          return this.values();
        }
        forEach(cb, thisArg) {
          const iterator = this.values();
          let result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        }
      }
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach((value) => {
            if (isDraftable2(value)) {
              const draft = createProxy(value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", { proxyMap_, proxySet_ });
    }
    var immer = new Immer2();
    var produce2 = immer.produce;
    var produceWithPatches2 = immer.produceWithPatches.bind(
      immer
    );
    var setAutoFreeze2 = immer.setAutoFreeze.bind(immer);
    var setUseStrictShallowCopy2 = immer.setUseStrictShallowCopy.bind(immer);
    var applyPatches2 = immer.applyPatches.bind(immer);
    var createDraft2 = immer.createDraft.bind(immer);
    var finishDraft2 = immer.finishDraft.bind(immer);
    function castDraft2(value) {
      return value;
    }
    function castImmutable2(value) {
      return value;
    }
  }
});

// node_modules/immer/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/immer/dist/cjs/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    if (process.env.NODE_ENV === "production") {
      module.exports = require_immer_cjs_production();
    } else {
      module.exports = require_immer_cjs_development();
    }
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/sendVideoCallNotification.js
var require_sendVideoCallNotification = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/sendVideoCallNotification.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers();
    var payloads_1 = require_payloads();
    var constants_1 = require_constants();
    var constants_2 = require_constants2();
    var sendVideoCallNotification = ({ signer, chainId, pgpPrivateKey }, { recipientAddress, senderAddress, chatId, rules, status, signalData = null, env = constants_1.default.ENV.PROD, callType = constants_2.VIDEO_CALL_TYPE.PUSH_VIDEO, callDetails }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a;
      try {
        const videoData = {
          recipientAddress,
          senderAddress,
          chatId: (_a = rules === null || rules === void 0 ? void 0 : rules.access.data.chatId) !== null && _a !== void 0 ? _a : chatId,
          signalData,
          status,
          callDetails
        };
        const senderAddressInCaip = (0, helpers_1.getCAIPWithChainId)(senderAddress, chainId);
        const recipientAddressInCaip = (0, helpers_1.getCAIPWithChainId)(recipientAddress, chainId);
        const notificationText = `Video Call from ${senderAddress}`;
        const notificationType = constants_2.NOTIFICATION_TYPE.TARGETTED;
        yield (0, payloads_1.sendNotification)({
          senderType: 1,
          signer,
          pgpPrivateKey,
          chatId,
          rules,
          type: notificationType,
          identityType: 2,
          notification: {
            title: notificationText,
            body: notificationText
          },
          payload: {
            title: "VideoCall",
            body: "VideoCall",
            cta: "",
            img: "",
            additionalMeta: {
              type: `${callType}+1`,
              data: JSON.stringify(videoData)
            }
          },
          recipients: recipientAddressInCaip,
          channel: senderAddressInCaip,
          env
        });
      } catch (err) {
        console.error("Error occured while sending notification for video call", err);
      }
    });
    exports.default = sendVideoCallNotification;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/mediaToggle.js
var require_mediaToggle = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/mediaToggle.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endStream = exports.stopAudioStream = exports.restartAudioStream = exports.stopVideoStream = exports.restartVideoStream = void 0;
    var restartVideoStream = (stream) => {
      const vidTracks = stream.getVideoTracks();
      vidTracks.forEach((track) => track.enabled = true);
    };
    exports.restartVideoStream = restartVideoStream;
    var stopVideoStream = (stream) => {
      const vidTracks = stream.getVideoTracks();
      vidTracks.forEach((track) => track.enabled = false);
    };
    exports.stopVideoStream = stopVideoStream;
    var restartAudioStream = (stream) => {
      const audTracks = stream.getAudioTracks();
      audTracks.forEach((track) => track.enabled = true);
    };
    exports.restartAudioStream = restartAudioStream;
    var stopAudioStream = (stream) => {
      const audTracks = stream.getAudioTracks();
      audTracks.forEach((track) => track.enabled = false);
    };
    exports.stopAudioStream = stopAudioStream;
    var endStream = (stream) => {
      stream.getTracks().forEach((track) => track.stop());
    };
    exports.endStream = endStream;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/isJSON.js
var require_isJSON = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/isJSON.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var isJSON = (inputStr) => {
      try {
        return JSON.parse(inputStr) && !!inputStr;
      } catch (e) {
        return false;
      }
    };
    exports.default = isJSON;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/getIceServerConfig.js
var require_getIceServerConfig = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/getIceServerConfig.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIceServerConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers();
    var constants_1 = require_constants();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var ENCRYPTION_KEY = "turnserversecret";
    var getIceServerConfig = (env = constants_1.default.ENV.PROD) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/turnserver/iceconfig`;
      const { data: encryptedData } = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
      const { config: decryptedData } = JSON.parse(CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8));
      return decryptedData;
    });
    exports.getIceServerConfig = getIceServerConfig;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/types/messageTypes.js
var require_messageTypes = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/types/messageTypes.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAT = void 0;
    exports.CHAT = {
      META: {
        GROUP: {
          CREATE: "CREATE_GROUP",
          MEMBER: {
            ADD: "ADD_MEMBER",
            REMOVE: "REMOVE_MEMBER",
            PRIVILEGE: "ASSIGN_MEMBER_PRIVILEGE"
          },
          ADMIN: {
            PRVILEGE: "ASSIGN_ADMIN_PRIVILEGE"
          },
          // todo: Why do we need update group when we already have profile and meta update
          UPDATE: "UPDATE_GROUP",
          PROFILE: {
            UPDATE: "UPDATE_GROUP_PROFILE"
          },
          // todo : this seems to be a wierd name CHAT.META.GROUP.META.UPDATE
          META: {
            UPDATE: "UPDATE_GROUP_META"
          },
          // todo : Remove this as it comes under UserActivity now ( remove after space changes )
          USER: {
            INTERACTION: "USER_INTERACTION"
          }
        },
        SPACE: {
          CREATE: "CREATE_SPACE",
          LISTENER: {
            ADD: "ADD_LISTENER",
            REMOVE: "REMOVE_LISTENER",
            PRVILEGE: "ASSIGN_LISTENER_PRIVILEGE"
          },
          SPEAKER: {
            PRVILEGE: "ASSIGN_SPEAKER_PRIVILEGE"
          },
          COHOST: {
            PRVILEGE: "ASSIGN_COHOST_PRIVILEGE"
          }
        }
      },
      REACTION: {
        THUMBSUP: "👍",
        THUMBSDOWN: "👎",
        HEART: "❤️",
        CLAP: "👏",
        LAUGH: "😂",
        SAD: "😢",
        ANGRY: "😡",
        SUPRISE: "😲",
        FIRE: "🔥"
      },
      RECEIPT: {
        READ: "READ_RECEIPT"
      },
      UA: {
        LISTENER: {
          JOIN: "LISTENER_JOIN",
          LEAVE: "LISTENER_LEAVE",
          MICREQUEST: "LISTENER_REQUEST_MIC"
        },
        SPEAKER: {
          MIC_ON: "SPEAKER_MIC_ON",
          MIC_OFF: "SPEAKER_MIC_OFF"
        }
      },
      INTENT: {
        ACCEPT: "ACCEPT_INTENT",
        REJECT: "REJECT_INTENT",
        JOIN: "JOIN_GROUP",
        LEAVE: "LEAVE_GROUP"
      }
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/types/videoTypes.js
var require_videoTypes = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/types/videoTypes.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/types/index.js
var require_types = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/types/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotifictaionType = exports.VideoCallStatus = exports.GROUP_INVITER_ROLE = exports.GROUP_RULES_PERMISSION = exports.GROUP_RULES_SUB_CATEGORY = exports.GROUP_RULES_CATEGORY = exports.ConditionType = exports.ChatStatus = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_messageTypes(), exports);
    tslib_1.__exportStar(require_videoTypes(), exports);
    var ChatStatus;
    (function(ChatStatus2) {
      ChatStatus2["ACTIVE"] = "ACTIVE";
      ChatStatus2["PENDING"] = "PENDING";
      ChatStatus2["ENDED"] = "ENDED";
    })(ChatStatus = exports.ChatStatus || (exports.ChatStatus = {}));
    var ConditionType;
    (function(ConditionType2) {
      ConditionType2["PUSH"] = "PUSH";
      ConditionType2["GUILD"] = "GUILD";
    })(ConditionType = exports.ConditionType || (exports.ConditionType = {}));
    var GROUP_RULES_CATEGORY;
    (function(GROUP_RULES_CATEGORY2) {
      GROUP_RULES_CATEGORY2["PUSH"] = "PUSH";
      GROUP_RULES_CATEGORY2["GUILD"] = "GUILD";
      GROUP_RULES_CATEGORY2["ERC721"] = "ERC721";
      GROUP_RULES_CATEGORY2["ERC20"] = "ERC20";
      GROUP_RULES_CATEGORY2["CUSTOM_ENDPOINT"] = "CustomEndpoint";
      GROUP_RULES_CATEGORY2["INVITE"] = "INVITE";
    })(GROUP_RULES_CATEGORY = exports.GROUP_RULES_CATEGORY || (exports.GROUP_RULES_CATEGORY = {}));
    var GROUP_RULES_SUB_CATEGORY;
    (function(GROUP_RULES_SUB_CATEGORY2) {
      GROUP_RULES_SUB_CATEGORY2["DEFAULT"] = "DEFAULT";
      GROUP_RULES_SUB_CATEGORY2["HOLDER"] = "holder";
      GROUP_RULES_SUB_CATEGORY2["GET"] = "GET";
    })(GROUP_RULES_SUB_CATEGORY = exports.GROUP_RULES_SUB_CATEGORY || (exports.GROUP_RULES_SUB_CATEGORY = {}));
    var GROUP_RULES_PERMISSION;
    (function(GROUP_RULES_PERMISSION2) {
      GROUP_RULES_PERMISSION2["ENTRY"] = "Entry";
      GROUP_RULES_PERMISSION2["CHAT"] = "Chat";
    })(GROUP_RULES_PERMISSION = exports.GROUP_RULES_PERMISSION || (exports.GROUP_RULES_PERMISSION = {}));
    var GROUP_INVITER_ROLE;
    (function(GROUP_INVITER_ROLE2) {
      GROUP_INVITER_ROLE2["ADMIN"] = "ADMIN";
      GROUP_INVITER_ROLE2["OWNER"] = "OWNER";
    })(GROUP_INVITER_ROLE = exports.GROUP_INVITER_ROLE || (exports.GROUP_INVITER_ROLE = {}));
    var VideoCallStatus;
    (function(VideoCallStatus2) {
      VideoCallStatus2[VideoCallStatus2["UNINITIALIZED"] = 0] = "UNINITIALIZED";
      VideoCallStatus2[VideoCallStatus2["INITIALIZED"] = 1] = "INITIALIZED";
      VideoCallStatus2[VideoCallStatus2["RECEIVED"] = 2] = "RECEIVED";
      VideoCallStatus2[VideoCallStatus2["CONNECTED"] = 3] = "CONNECTED";
      VideoCallStatus2[VideoCallStatus2["DISCONNECTED"] = 4] = "DISCONNECTED";
      VideoCallStatus2[VideoCallStatus2["ENDED"] = 5] = "ENDED";
      VideoCallStatus2[VideoCallStatus2["RETRY_INITIALIZED"] = 6] = "RETRY_INITIALIZED";
      VideoCallStatus2[VideoCallStatus2["RETRY_RECEIVED"] = 7] = "RETRY_RECEIVED";
    })(VideoCallStatus = exports.VideoCallStatus || (exports.VideoCallStatus = {}));
    var NotifictaionType;
    (function(NotifictaionType2) {
      NotifictaionType2[NotifictaionType2["BROADCAT"] = 1] = "BROADCAT";
      NotifictaionType2[NotifictaionType2["TARGETTED"] = 3] = "TARGETTED";
      NotifictaionType2[NotifictaionType2["SUBSET"] = 4] = "SUBSET";
    })(NotifictaionType = exports.NotifictaionType || (exports.NotifictaionType = {}));
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/getIncomingIndexFromAddress.js
var require_getIncomingIndexFromAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/getIncomingIndexFromAddress.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var getIncomingIndexFromAddress = (incomingPeers, address) => {
      return incomingPeers.findIndex((incomingPeer) => incomingPeer.address === address);
    };
    exports.default = getIncomingIndexFromAddress;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/helpers/getPlainAddress.js
var require_getPlainAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/helpers/getPlainAddress.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var getPlainAddress = (prefixedAddress) => {
      return prefixedAddress.replace("eip155:", "");
    };
    exports.default = getPlainAddress;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/getConnectedAddresses.js
var require_getConnectedAddresses = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/getConnectedAddresses.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var getPlainAddress_1 = require_getPlainAddress();
    var types_1 = require_types();
    var getConnectedAddresses = ({ incomingPeers }) => {
      const connectedAddresses = [];
      incomingPeers.forEach((incomingPeer) => {
        if (incomingPeer.status === types_1.VideoCallStatus.CONNECTED) {
          connectedAddresses.push((0, getPlainAddress_1.default)(incomingPeer.address));
        }
      });
      return connectedAddresses;
    };
    exports.default = getConnectedAddresses;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/getConnectToAddresses.js
var require_getConnectToAddresses = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/getConnectToAddresses.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var getConnectToAddresses = ({ localAddress, localConnectedAddresses, receivedConnectedAddresses }) => {
      return receivedConnectedAddresses.filter((receivedConnectedAddress) => !localConnectedAddresses.includes(receivedConnectedAddress) && receivedConnectedAddress !== localAddress);
    };
    exports.default = getConnectToAddresses;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/validateVideoRules.js
var require_validateVideoRules = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/validateVideoRules.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateVideoRules = void 0;
    var constants_1 = require_constants2();
    var validateVideoRules = (rules) => {
      if (rules.access.type === constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT && (!rules.access.data.chatId || rules.access.data.chatId === "")) {
        throw new Error("Invalid rules object recieved. For access as Push Chat, chatId is required!");
      }
    };
    exports.validateVideoRules = validateVideoRules;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/Video.js
var require_Video = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/Video.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Video = exports.initVideoCallData = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Peer = require_simple_peer();
    var immer_1 = require_cjs();
    var constants_1 = require_constants();
    var sendVideoCallNotification_1 = require_sendVideoCallNotification();
    var mediaToggle_1 = require_mediaToggle();
    var isJSON_1 = require_isJSON();
    var getIceServerConfig_1 = require_getIceServerConfig();
    var types_1 = require_types();
    var getIncomingIndexFromAddress_1 = require_getIncomingIndexFromAddress();
    var getConnectedAddresses_1 = require_getConnectedAddresses();
    var getConnectToAddresses_1 = require_getConnectToAddresses();
    var constants_2 = require_constants2();
    var validateVideoRules_1 = require_validateVideoRules();
    exports.initVideoCallData = {
      meta: {
        chatId: "",
        initiator: {
          address: "",
          signal: null
        },
        broadcast: {
          livepeerInfo: null,
          hostAddress: "",
          coHostAddress: ""
        }
      },
      local: {
        stream: null,
        audio: null,
        video: null,
        address: ""
      },
      // TODO: Remove the default element in incoming array
      incoming: [
        {
          stream: null,
          audio: null,
          video: null,
          address: "",
          status: types_1.VideoCallStatus.UNINITIALIZED,
          retryCount: 0
        }
      ]
    };
    var Video = class {
      constructor({ signer, chainId, pgpPrivateKey, env = constants_1.default.ENV.PROD, setData, callType = constants_2.VIDEO_CALL_TYPE.PUSH_VIDEO, onReceiveStream = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
        return Promise.resolve();
      }) }) {
        this.peerInstances = {};
        this.signer = signer;
        this.chainId = chainId;
        this.pgpPrivateKey = pgpPrivateKey;
        this.env = env;
        this.callType = callType;
        this.onReceiveStream = onReceiveStream;
        setData(() => exports.initVideoCallData);
        this.data = exports.initVideoCallData;
        this.setData = function(fn) {
          setData(fn);
          this.data = fn(this.data);
        };
      }
      create(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { audio = true, video = true, stream = null } = options || {};
          try {
            const localStream = stream !== null ? stream : yield navigator.mediaDevices.getUserMedia({
              // for frontend
              video,
              audio
            });
            this.setData((oldData) => {
              return (0, immer_1.produce)(oldData, (draft) => {
                draft.local.stream = localStream;
                draft.local.video = video;
                draft.local.audio = audio;
              });
            });
          } catch (err) {
            console.error("error in create", err);
          }
        });
      }
      request(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { senderAddress, recipientAddress, chatId, rules, onReceiveMessage, retry = false, details } = options || {};
          rules && (0, validateVideoRules_1.validateVideoRules)(rules);
          const recipientAddresses = Array.isArray(recipientAddress) ? recipientAddress : [recipientAddress];
          for (const recipientAddress2 of recipientAddresses) {
            try {
              this.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                  draft.local.address = senderAddress;
                  draft.meta.chatId = chatId !== null && chatId !== void 0 ? chatId : rules.access.data.chatId;
                  draft.meta.initiator.address = senderAddress;
                  const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress2);
                  if (incomingIndex === -1) {
                    draft.incoming.push({
                      stream: null,
                      audio: null,
                      video: null,
                      address: recipientAddress2,
                      status: retry ? types_1.VideoCallStatus.RETRY_INITIALIZED : types_1.VideoCallStatus.INITIALIZED,
                      retryCount: retry ? 1 : 0
                    });
                  } else {
                    draft.incoming[incomingIndex].address = recipientAddress2;
                    draft.incoming[incomingIndex].status = retry ? types_1.VideoCallStatus.RETRY_INITIALIZED : types_1.VideoCallStatus.INITIALIZED;
                    draft.incoming[incomingIndex].retryCount += retry ? 1 : 0;
                  }
                });
              });
              const iceServerConfig = yield (0, getIceServerConfig_1.getIceServerConfig)(this.env);
              this.peerInstances[recipientAddress2] = new Peer({
                initiator: true,
                trickle: false,
                stream: this.data.local.stream,
                config: {
                  iceServers: iceServerConfig
                }
              });
              this.peerInstances[recipientAddress2].on("signal", (data) => {
                this.setData((oldData) => {
                  return (0, immer_1.produce)(oldData, (draft) => {
                    draft.meta.initiator.signal = data;
                  });
                });
                (0, sendVideoCallNotification_1.default)({
                  signer: this.signer,
                  chainId: this.chainId,
                  pgpPrivateKey: this.pgpPrivateKey
                }, {
                  senderAddress,
                  recipientAddress: recipientAddress2,
                  status: retry ? types_1.VideoCallStatus.RETRY_INITIALIZED : types_1.VideoCallStatus.INITIALIZED,
                  chatId,
                  rules,
                  signalData: data,
                  env: this.env,
                  callType: this.callType,
                  callDetails: details
                });
              });
              this.peerInstances[recipientAddress2].on("connect", () => {
                this.peerInstances[recipientAddress2].send(`initial message from ${senderAddress}`);
                this.peerInstances[recipientAddress2].send(JSON.stringify({
                  type: "isVideoOn",
                  value: this.data.local.video
                }));
                this.peerInstances[recipientAddress2].send(JSON.stringify({
                  type: "isAudioOn",
                  value: this.data.local.audio
                }));
                const connectedAddresses = (0, getConnectedAddresses_1.default)({
                  incomingPeers: this.data.incoming
                });
                this.peerInstances[recipientAddress2].send(JSON.stringify({
                  type: "connectedAddresses",
                  value: connectedAddresses
                }));
              });
              this.peerInstances[recipientAddress2].on("data", (data) => {
                var _a, _b, _c, _d, _e;
                if ((0, isJSON_1.default)(data)) {
                  const parsedData = JSON.parse(data);
                  if (parsedData.type === "connectedAddresses") {
                    const receivedConnectedAddresses = parsedData.value;
                    const localConnectedAddresses = (0, getConnectedAddresses_1.default)({
                      incomingPeers: this.data.incoming
                    });
                    const connectToAddresses = (0, getConnectToAddresses_1.default)({
                      localAddress: senderAddress,
                      localConnectedAddresses,
                      receivedConnectedAddresses
                    });
                    this.request({
                      senderAddress,
                      recipientAddress: connectToAddresses,
                      chatId,
                      rules,
                      details: {
                        type: constants_2.SPACE_REQUEST_TYPE.ESTABLISH_MESH,
                        data: {}
                      }
                    });
                  }
                  if (parsedData.type === "isVideoOn") {
                    this.setData((oldData) => {
                      return (0, immer_1.produce)(oldData, (draft) => {
                        const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress2);
                        draft.incoming[incomingIndex].video = parsedData.value;
                      });
                    });
                  }
                  if (parsedData.type === "isAudioOn") {
                    this.setData((oldData) => {
                      return (0, immer_1.produce)(oldData, (draft) => {
                        const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress2);
                        draft.incoming[incomingIndex].audio = parsedData.value;
                      });
                    });
                  }
                  if (parsedData.type === "endCall") {
                    if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_SPACE && ((_a = parsedData === null || parsedData === void 0 ? void 0 : parsedData.details) === null || _a === void 0 ? void 0 : _a.type) === constants_2.SPACE_DISCONNECT_TYPE.LEAVE) {
                      (_b = this.peerInstances[recipientAddress2]) === null || _b === void 0 ? void 0 : _b.destroy();
                      this.peerInstances[recipientAddress2] = null;
                      this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                          const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress2);
                          draft.incoming.splice(incomingIndex, 1);
                        });
                      });
                    }
                    if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_SPACE && ((_c = parsedData === null || parsedData === void 0 ? void 0 : parsedData.details) === null || _c === void 0 ? void 0 : _c.type) === constants_2.SPACE_DISCONNECT_TYPE.STOP) {
                      for (const connectedAddress in this.peerInstances) {
                        (_d = this.peerInstances[connectedAddress]) === null || _d === void 0 ? void 0 : _d.destroy();
                        this.peerInstances[connectedAddress] = null;
                      }
                      if (this.data.local.stream) {
                        (0, mediaToggle_1.endStream)(this.data.local.stream);
                      }
                      this.setData(() => exports.initVideoCallData);
                    }
                    if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_VIDEO) {
                      (_e = this.peerInstances[recipientAddress2]) === null || _e === void 0 ? void 0 : _e.destroy();
                      this.peerInstances[recipientAddress2] = null;
                      if (this.data.local.stream) {
                        (0, mediaToggle_1.endStream)(this.data.local.stream);
                      }
                      this.setData(() => exports.initVideoCallData);
                    }
                  }
                } else if (onReceiveMessage) {
                  onReceiveMessage(data);
                }
              });
              this.peerInstances[recipientAddress2].on("stream", (currentStream) => {
                const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, recipientAddress2);
                this.onReceiveStream(currentStream, recipientAddress2, this.data.incoming[incomingIndex].audio);
                this.setData((oldData) => {
                  return (0, immer_1.produce)(oldData, (draft) => {
                    draft.incoming[incomingIndex].stream = currentStream;
                  });
                });
              });
            } catch (err) {
              console.error("error in request", err);
            }
          }
        });
      }
      acceptRequest(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { signalData, senderAddress, recipientAddress, chatId, rules, onReceiveMessage, retry = false, details } = options || {};
          rules && (0, validateVideoRules_1.validateVideoRules)(rules);
          try {
            if (this.peerInstances[recipientAddress]) {
              return Promise.resolve();
            }
            const iceServerConfig = yield (0, getIceServerConfig_1.getIceServerConfig)(this.env);
            this.peerInstances[recipientAddress] = new Peer({
              initiator: false,
              trickle: false,
              stream: this.data.local.stream,
              config: {
                iceServers: iceServerConfig
              }
            });
            this.setData((oldData) => {
              return (0, immer_1.produce)(oldData, (draft) => {
                draft.local.address = senderAddress;
                draft.meta.chatId = chatId !== null && chatId !== void 0 ? chatId : rules.access.data.chatId;
                draft.meta.initiator.address = senderAddress;
                const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress);
                if (incomingIndex === -1) {
                  draft.incoming.push({
                    stream: null,
                    audio: null,
                    video: null,
                    address: recipientAddress,
                    status: retry ? types_1.VideoCallStatus.RETRY_INITIALIZED : types_1.VideoCallStatus.INITIALIZED,
                    retryCount: retry ? 1 : 0
                  });
                } else {
                  draft.incoming[incomingIndex].address = recipientAddress;
                  draft.incoming[incomingIndex].status = retry ? types_1.VideoCallStatus.RETRY_RECEIVED : types_1.VideoCallStatus.RECEIVED;
                  draft.incoming[incomingIndex].retryCount += retry ? 1 : 0;
                }
              });
            });
            this.peerInstances[recipientAddress].on("error", (err) => {
              if (this.data.incoming[0].retryCount >= 5) {
                this.disconnect({ peerAddress: recipientAddress });
              }
              (0, sendVideoCallNotification_1.default)({
                signer: this.signer,
                chainId: this.chainId,
                pgpPrivateKey: this.pgpPrivateKey
              }, {
                senderAddress,
                recipientAddress,
                status: types_1.VideoCallStatus.RETRY_INITIALIZED,
                chatId,
                rules,
                signalData: null,
                callType: this.callType,
                env: this.env
              });
            });
            this.peerInstances[recipientAddress].signal(signalData);
            this.peerInstances[recipientAddress].on("signal", (data) => {
              this.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                  draft.meta.initiator.signal = data;
                });
              });
              (0, sendVideoCallNotification_1.default)({
                signer: this.signer,
                chainId: this.chainId,
                pgpPrivateKey: this.pgpPrivateKey
              }, {
                senderAddress,
                recipientAddress,
                status: retry ? types_1.VideoCallStatus.RETRY_RECEIVED : types_1.VideoCallStatus.RECEIVED,
                chatId,
                rules,
                signalData: data,
                env: this.env,
                callType: this.callType,
                callDetails: details
              });
            });
            this.peerInstances[recipientAddress].on("connect", () => {
              this.peerInstances[recipientAddress].send(JSON.stringify({
                type: "isVideoOn",
                value: this.data.local.video
              }));
              this.peerInstances[recipientAddress].send(JSON.stringify({
                type: "isAudioOn",
                value: this.data.local.audio
              }));
              const connectedAddresses = (0, getConnectedAddresses_1.default)({
                incomingPeers: this.data.incoming
              });
              this.peerInstances[recipientAddress].send(JSON.stringify({
                type: "connectedAddresses",
                value: connectedAddresses
              }));
              this.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                  const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress);
                  draft.incoming[incomingIndex].status = types_1.VideoCallStatus.CONNECTED;
                });
              });
            });
            this.peerInstances[recipientAddress].on("data", (data) => {
              var _a, _b, _c, _d, _e;
              if ((0, isJSON_1.default)(data)) {
                const parsedData = JSON.parse(data);
                if (parsedData.type === "connectedAddresses") {
                  const receivedConnectedAddresses = parsedData.value;
                  const localConnectedAddresses = (0, getConnectedAddresses_1.default)({
                    incomingPeers: this.data.incoming
                  });
                  const connectToAddresses = (0, getConnectToAddresses_1.default)({
                    localAddress: senderAddress,
                    localConnectedAddresses,
                    receivedConnectedAddresses
                  });
                  this.request({
                    senderAddress,
                    recipientAddress: connectToAddresses,
                    chatId,
                    rules,
                    details: {
                      type: constants_2.SPACE_REQUEST_TYPE.ESTABLISH_MESH,
                      data: {}
                    }
                  });
                }
                if (parsedData.type === "isVideoOn") {
                  this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                      const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress);
                      draft.incoming[incomingIndex].video = parsedData.value;
                    });
                  });
                }
                if (parsedData.type === "isAudioOn") {
                  this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                      const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress);
                      draft.incoming[incomingIndex].audio = parsedData.value;
                    });
                  });
                }
                if (parsedData.type === "endCall") {
                  if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_SPACE && ((_a = parsedData === null || parsedData === void 0 ? void 0 : parsedData.details) === null || _a === void 0 ? void 0 : _a.type) === constants_2.SPACE_DISCONNECT_TYPE.LEAVE) {
                    (_b = this.peerInstances[recipientAddress]) === null || _b === void 0 ? void 0 : _b.destroy();
                    this.peerInstances[recipientAddress] = null;
                    this.setData((oldData) => {
                      return (0, immer_1.produce)(oldData, (draft) => {
                        const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, recipientAddress);
                        draft.incoming.splice(incomingIndex, 1);
                      });
                    });
                  }
                  if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_SPACE && ((_c = parsedData === null || parsedData === void 0 ? void 0 : parsedData.details) === null || _c === void 0 ? void 0 : _c.type) === constants_2.SPACE_DISCONNECT_TYPE.STOP) {
                    for (const connectedAddress in this.peerInstances) {
                      (_d = this.peerInstances[connectedAddress]) === null || _d === void 0 ? void 0 : _d.destroy();
                      this.peerInstances[connectedAddress] = null;
                    }
                    if (this.data.local.stream) {
                      (0, mediaToggle_1.endStream)(this.data.local.stream);
                    }
                    this.setData(() => exports.initVideoCallData);
                  }
                  if (this.callType === constants_2.VIDEO_CALL_TYPE.PUSH_VIDEO) {
                    (_e = this.peerInstances[recipientAddress]) === null || _e === void 0 ? void 0 : _e.destroy();
                    this.peerInstances[recipientAddress] = null;
                    if (this.data.local.stream) {
                      (0, mediaToggle_1.endStream)(this.data.local.stream);
                    }
                    this.setData(() => exports.initVideoCallData);
                  }
                }
              } else if (onReceiveMessage) {
                onReceiveMessage(data);
              }
            });
            this.peerInstances[recipientAddress].on("stream", (currentStream) => {
              const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, recipientAddress);
              this.onReceiveStream(currentStream, recipientAddress, this.data.incoming[incomingIndex].audio);
              this.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                  draft.incoming[incomingIndex].stream = currentStream;
                });
              });
            });
          } catch (err) {
            console.error("error in accept request", err);
          }
        });
      }
      connect(options) {
        var _a;
        const { peerAddress, signalData } = options || {};
        try {
          if (!peerAddress) {
            console.warn("disconnect requires a peer address");
          }
          this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address].on("error", (err) => {
            const incomingIndex = peerAddress ? (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, peerAddress) : 0;
            if (this.data.incoming[incomingIndex].retryCount >= 5) {
              this.disconnect({
                peerAddress: peerAddress ? peerAddress : this.data.incoming[0].address
              });
            }
            this.request({
              senderAddress: this.data.local.address,
              recipientAddress: this.data.incoming[incomingIndex].address,
              chatId: this.data.meta.chatId,
              retry: true
            });
          });
          (_a = this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address]) === null || _a === void 0 ? void 0 : _a.signal(signalData);
          this.setData((oldData) => {
            return (0, immer_1.produce)(oldData, (draft) => {
              const incomingIndex = peerAddress ? (0, getIncomingIndexFromAddress_1.default)(oldData.incoming, peerAddress) : 0;
              draft.incoming[incomingIndex].status = types_1.VideoCallStatus.CONNECTED;
            });
          });
          (0, sendVideoCallNotification_1.default)({
            signer: this.signer,
            chainId: this.chainId,
            pgpPrivateKey: this.pgpPrivateKey
          }, {
            senderAddress: this.data.local.address,
            recipientAddress: peerAddress ? peerAddress : this.data.incoming[0].address,
            status: types_1.VideoCallStatus.CONNECTED,
            rules: {
              access: {
                type: constants_2.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT,
                data: {
                  chatId: this.data.meta.chatId
                }
              }
            },
            signalData,
            env: this.env
          });
        } catch (err) {
          console.error("error in connect", err);
        }
      }
      disconnect(options) {
        var _a, _b, _c;
        const { peerAddress, details } = options || {};
        try {
          if (!(options === null || options === void 0 ? void 0 : options.peerAddress)) {
            console.warn("disconnect requires a peer address");
          }
          const incomingIndex = peerAddress ? (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, peerAddress) : 0;
          const isCallConnected = this.data.incoming[incomingIndex].status === types_1.VideoCallStatus.CONNECTED;
          if (isCallConnected) {
            (_a = this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address]) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({ type: "endCall", value: true, details }));
            (_b = this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address]) === null || _b === void 0 ? void 0 : _b.destroy();
          }
          (0, sendVideoCallNotification_1.default)({
            signer: this.signer,
            chainId: this.chainId,
            pgpPrivateKey: this.pgpPrivateKey
          }, {
            senderAddress: this.data.local.address,
            recipientAddress: this.data.incoming[incomingIndex].address,
            status: isCallConnected ? types_1.VideoCallStatus.ENDED : types_1.VideoCallStatus.DISCONNECTED,
            chatId: this.data.meta.chatId,
            signalData: null,
            env: this.env,
            callType: this.callType,
            callDetails: details
          });
          (_c = this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address]) === null || _c === void 0 ? void 0 : _c.destroy();
          this.peerInstances[peerAddress ? peerAddress : this.data.incoming[0].address] = null;
          if (this.data.local.stream) {
            (0, mediaToggle_1.endStream)(this.data.local.stream);
          }
          this.setData(() => exports.initVideoCallData);
        } catch (err) {
          console.error("error in disconnect", err);
        }
      }
      // functions for enabling/disabling local audio and video
      enableVideo(options) {
        var _a;
        const { state } = options || {};
        if (this.data.local.video !== state) {
          for (const incomingPeer of this.data.incoming) {
            if (incomingPeer.status === types_1.VideoCallStatus.CONNECTED) {
              (_a = this.peerInstances[incomingPeer.address]) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({
                type: "isVideoOn",
                value: state
              }));
            }
          }
          if (this.data.local.stream) {
            if (state) {
              (0, mediaToggle_1.restartVideoStream)(this.data.local.stream);
            } else {
              (0, mediaToggle_1.stopVideoStream)(this.data.local.stream);
            }
            this.setData((oldData) => {
              return (0, immer_1.produce)(oldData, (draft) => {
                draft.local.video = state;
              });
            });
          }
        }
      }
      enableAudio(options) {
        const { state } = options || {};
        if (this.data.local.audio !== state) {
          for (const incomingPeer of this.data.incoming) {
            if (incomingPeer.status === types_1.VideoCallStatus.CONNECTED && this.peerInstances[incomingPeer.address]) {
              try {
                this.peerInstances[incomingPeer.address].send(JSON.stringify({ type: "isAudioOn", value: state }));
              } catch (error) {
                console.error("Error sending data:", error);
              }
            }
          }
          if (this.data.local.stream) {
            if (state) {
              (0, mediaToggle_1.restartAudioStream)(this.data.local.stream);
            } else {
              (0, mediaToggle_1.stopAudioStream)(this.data.local.stream);
            }
            this.setData((oldData) => {
              return (0, immer_1.produce)(oldData, (draft) => {
                draft.local.audio = state;
              });
            });
          }
        }
      }
      // helper functions
      isInitiator() {
        if (this.data.meta.initiator.address === "" || this.data.local.address === "")
          return false;
        return this.data.meta.initiator.address === this.data.local.address;
      }
    };
    exports.Video = Video;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/index.js
var require_video = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_Video(), exports);
  }
});

export {
  require_getPlainAddress,
  require_messageTypes,
  require_types,
  require_cjs,
  require_mediaToggle,
  require_getIncomingIndexFromAddress,
  require_Video,
  require_video
};
/*! Bundled license information:

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

simple-peer/index.js:
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-7QGEYBWR.js.map

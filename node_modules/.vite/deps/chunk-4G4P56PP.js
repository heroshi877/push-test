import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  init_stylis_browser_esm,
  init_unitless_browser_esm,
  stylis_browser_esm_default,
  unitless_browser_esm_default
} from "./chunk-7EI76V3K.js";
import {
  _inheritsLoose,
  init_inheritsLoose
} from "./chunk-E7ALBJQD.js";
import {
  require_react
} from "./chunk-DTW63AUM.js";
import {
  __esm,
  __export,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/@emotion/sheet/dist/sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  return tag;
}
var import_dist, import_dist2, import_dist3, StyleSheet;
var init_sheet_browser_esm = __esm({
  "node_modules/@emotion/sheet/dist/sheet.browser.esm.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    StyleSheet = function() {
      function StyleSheet2(options) {
        this.isSpeedy = options.speedy === void 0 ? process.env.NODE_ENV === "production" : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          var _tag = createStyleElement(this);
          var before;
          if (this.tags.length === 0) {
            before = this.before;
          } else {
            before = this.tags[this.tags.length - 1].nextSibling;
          }
          this.container.insertBefore(_tag, before);
          this.tags.push(_tag);
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            var isImportRule = rule.charCodeAt(1) === 105 && rule.charCodeAt(0) === 64;
            sheet.insertRule(
              rule,
              // we need to insert @import rules before anything else
              // otherwise there will be an error
              // technically this means that the @import rules will
              // _usually_(not always since there could be multiple style tags)
              // be the first ones in prod and generally later in dev
              // this shouldn't really matter in the real world though
              // @import is generally only used for font faces from google fonts and etc.
              // so while this could be technically correct then it would be slower and larger
              // for a tiny bit of correctness that won't matter in the real world
              isImportRule ? 0 : sheet.cssRules.length
            );
          } catch (e) {
            if (process.env.NODE_ENV !== "production") {
              console.warn('There was a problem inserting the following rule: "' + rule + '"', e);
            }
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      };
      return StyleSheet2;
    }();
  }
});

// node_modules/@emotion/core/node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js
var import_dist4, import_dist5, import_dist6;
var init_weak_memoize_browser_esm = __esm({
  "node_modules/@emotion/core/node_modules/@emotion/weak-memoize/dist/weak-memoize.browser.esm.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
  }
});

// node_modules/@emotion/core/node_modules/@emotion/cache/dist/cache.browser.esm.js
function toSheet(block) {
  if (block) {
    Sheet.current.insert(block + "}");
  }
}
var import_dist7, import_dist8, import_dist9, delimiter, needle, Sheet, ruleSheet, createCache, cache_browser_esm_default;
var init_cache_browser_esm = __esm({
  "node_modules/@emotion/core/node_modules/@emotion/cache/dist/cache.browser.esm.js"() {
    import_dist7 = __toESM(require_dist());
    import_dist8 = __toESM(require_dist2());
    import_dist9 = __toESM(require_dist3());
    init_sheet_browser_esm();
    init_stylis_browser_esm();
    init_weak_memoize_browser_esm();
    delimiter = "/*|*/";
    needle = delimiter + "}";
    Sheet = {
      current: null
    };
    ruleSheet = function ruleSheet2(context, content, selectors, parents, line, column, length, ns, depth, at) {
      switch (context) {
        case 1: {
          switch (content.charCodeAt(0)) {
            case 64: {
              Sheet.current.insert(content + ";");
              return "";
            }
            case 108: {
              if (content.charCodeAt(2) === 98) {
                return "";
              }
            }
          }
          break;
        }
        case 2: {
          if (ns === 0) return content + delimiter;
          break;
        }
        case 3: {
          switch (ns) {
            case 102:
            case 112: {
              Sheet.current.insert(selectors[0] + content);
              return "";
            }
            default: {
              return content + (at === 0 ? delimiter : "");
            }
          }
        }
        case -2: {
          content.split(needle).forEach(toSheet);
        }
      }
    };
    createCache = function createCache2(options) {
      if (options === void 0) options = {};
      var key = options.key || "css";
      var stylisOptions;
      if (options.prefix !== void 0) {
        stylisOptions = {
          prefix: options.prefix
        };
      }
      var stylis = new stylis_browser_esm_default(stylisOptions);
      if (process.env.NODE_ENV !== "production") {
        if (/[^a-z-]/.test(key)) {
          throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
        }
      }
      var inserted = {};
      var container;
      {
        container = options.container || document.head;
        var nodes = document.querySelectorAll("style[data-emotion-" + key + "]");
        Array.prototype.forEach.call(nodes, function(node) {
          var attrib = node.getAttribute("data-emotion-" + key);
          attrib.split(" ").forEach(function(id) {
            inserted[id] = true;
          });
          if (node.parentNode !== container) {
            container.appendChild(node);
          }
        });
      }
      var _insert;
      {
        stylis.use(options.stylisPlugins)(ruleSheet);
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          var name = serialized.name;
          Sheet.current = sheet;
          if (process.env.NODE_ENV !== "production" && serialized.map !== void 0) {
            var map = serialized.map;
            Sheet.current = {
              insert: function insert2(rule) {
                sheet.insert(rule + map);
              }
            };
          }
          stylis(selector, serialized.styles);
          if (shouldCache) {
            cache.inserted[name] = true;
          }
        };
      }
      if (process.env.NODE_ENV !== "production") {
        var commentStart = /\/\*/g;
        var commentEnd = /\*\//g;
        stylis.use(function(context, content) {
          switch (context) {
            case -1: {
              while (commentStart.test(content)) {
                commentEnd.lastIndex = commentStart.lastIndex;
                if (commentEnd.test(content)) {
                  commentStart.lastIndex = commentEnd.lastIndex;
                  continue;
                }
                throw new Error('Your styles have an unterminated comment ("/*" without corresponding "*/").');
              }
              commentStart.lastIndex = 0;
              break;
            }
          }
        });
        stylis.use(function(context, content, selectors) {
          switch (context) {
            case -1: {
              var flag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
              var unsafePseudoClasses = content.match(/(:first|:nth|:nth-last)-child/g);
              if (unsafePseudoClasses && cache.compat !== true) {
                unsafePseudoClasses.forEach(function(unsafePseudoClass) {
                  var ignoreRegExp = new RegExp(unsafePseudoClass + ".*\\/\\* " + flag + " \\*\\/");
                  var ignore = ignoreRegExp.test(content);
                  if (unsafePseudoClass && !ignore) {
                    console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
                  }
                });
              }
              break;
            }
          }
        });
      }
      var cache = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      return cache;
    };
    cache_browser_esm_default = createCache;
  }
});

// node_modules/@emotion/utils/dist/utils.browser.esm.js
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className]);
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var import_dist10, import_dist11, import_dist12, isBrowser, insertStyles;
var init_utils_browser_esm = __esm({
  "node_modules/@emotion/utils/dist/utils.browser.esm.js"() {
    import_dist10 = __toESM(require_dist());
    import_dist11 = __toESM(require_dist2());
    import_dist12 = __toESM(require_dist3());
    isBrowser = true;
    insertStyles = function insertStyles2(cache, serialized, isStringTag) {
      var className = cache.key + "-" + serialized.name;
      if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser === false && cache.compat !== void 0) && cache.registered[className] === void 0
      ) {
        cache.registered[className] = serialized.styles;
      }
      if (cache.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
          var maybeStyles = cache.insert("." + className, current, cache.sheet, true);
          current = current.next;
        } while (current !== void 0);
      }
    };
  }
});

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var import_dist13, import_dist14, import_dist15, hash_browser_esm_default;
var init_hash_browser_esm = __esm({
  "node_modules/@emotion/hash/dist/hash.browser.esm.js"() {
    import_dist13 = __toESM(require_dist());
    import_dist14 = __toESM(require_dist2());
    import_dist15 = __toESM(require_dist3());
    hash_browser_esm_default = murmur2;
  }
});

// node_modules/@emotion/serialize/node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var import_dist16, import_dist17, import_dist18, memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "node_modules/@emotion/serialize/node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    import_dist16 = __toESM(require_dist());
    import_dist17 = __toESM(require_dist2());
    import_dist18 = __toESM(require_dist3());
    memoize_browser_esm_default = memoize;
  }
});

// node_modules/@emotion/serialize/dist/serialize.browser.esm.js
function handleInterpolation(mergedProps, registered, interpolation, couldBeSelectorInterpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error("Component selectors can only be used in conjunction with babel-plugin-emotion.");
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next = interpolation.next;
        if (next !== void 0) {
          while (next !== void 0) {
            cursor = {
              name: next.name,
              styles: next.styles,
              next: cursor
            };
            next = next.next;
          }
        }
        var styles = interpolation.styles + ";";
        if (process.env.NODE_ENV !== "production" && interpolation.map !== void 0) {
          styles += interpolation.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result, couldBeSelectorInterpolation);
      } else if (process.env.NODE_ENV !== "production") {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  if (process.env.NODE_ENV !== "production" && couldBeSelectorInterpolation && shouldWarnAboutInterpolatingClassNameFromCss && cached !== void 0) {
    console.error("Interpolating a className from css`` is not recommended and will cause problems with composition.\nInterpolating a className from css`` will be completely unsupported in a future major version of Emotion");
    shouldWarnAboutInterpolatingClassNameFromCss = false;
  }
  return cached !== void 0 && !couldBeSelectorInterpolation ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i], false);
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production") {
          throw new Error("Component selectors can only be used in conjunction with babel-plugin-emotion.");
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value, false);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (process.env.NODE_ENV !== "production" && _key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var import_dist19, import_dist20, import_dist21, ILLEGAL_ESCAPE_SEQUENCE_ERROR, UNDEFINED_AS_OBJECT_KEY_ERROR, hyphenateRegex, animationRegex, isCustomProperty, isProcessableValue, processStyleName, processStyleValue, contentValuePattern, contentValues, oldProcessStyleValue, msPattern, hyphenPattern, hyphenatedCache, shouldWarnAboutInterpolatingClassNameFromCss, labelPattern, sourceMapPattern, cursor, serializeStyles;
var init_serialize_browser_esm = __esm({
  "node_modules/@emotion/serialize/dist/serialize.browser.esm.js"() {
    import_dist19 = __toESM(require_dist());
    import_dist20 = __toESM(require_dist2());
    import_dist21 = __toESM(require_dist3());
    init_hash_browser_esm();
    init_unitless_browser_esm();
    init_memoize_browser_esm();
    ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
    UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    hyphenateRegex = /[A-Z]|^ms/g;
    animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    processStyleName = memoize_browser_esm_default(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitless_browser_esm_default[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    if (process.env.NODE_ENV !== "production") {
      contentValuePattern = /(attr|calc|counters?|url)\(/;
      contentValues = ["normal", "none", "counter", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "initial", "inherit", "unset"];
      oldProcessStyleValue = processStyleValue;
      msPattern = /^-ms-/;
      hyphenPattern = /-(.)/g;
      hyphenatedCache = {};
      processStyleValue = function processStyleValue3(key, value) {
        if (key === "content") {
          if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
            console.error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
          }
        }
        var processed = oldProcessStyleValue(key, value);
        if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
          hyphenatedCache[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }
        return processed;
      };
    }
    shouldWarnAboutInterpolatingClassNameFromCss = true;
    labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
    if (process.env.NODE_ENV !== "production") {
      sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//;
    }
    serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings, false);
      } else {
        if (process.env.NODE_ENV !== "production" && strings[0] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles += strings[0];
      }
      for (var i = 1; i < args.length; i++) {
        styles += handleInterpolation(mergedProps, registered, args[i], styles.charCodeAt(styles.length - 1) === 46);
        if (stringMode) {
          if (process.env.NODE_ENV !== "production" && strings[i] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }
          styles += strings[i];
        }
      }
      var sourceMap;
      if (process.env.NODE_ENV !== "production") {
        styles = styles.replace(sourceMapPattern, function(match2) {
          sourceMap = match2;
          return "";
        });
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match;
      while ((match = labelPattern.exec(styles)) !== null) {
        identifierName += "-" + // $FlowFixMe we know it's not null
        match[1];
      }
      var name = hash_browser_esm_default(styles) + identifierName;
      if (process.env.NODE_ENV !== "production") {
        return {
          name,
          styles,
          map: sourceMap,
          next: cursor,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }
      return {
        name,
        styles,
        next: cursor
      };
    };
  }
});

// node_modules/@emotion/core/dist/emotion-element-04d85134.browser.esm.js
var import_dist22, import_dist23, import_dist24, import_react, hasOwnProperty, EmotionCacheContext, ThemeContext, CacheProvider, withEmotionCache, sanitizeIdentifier, typePropName, labelPropName, createEmotionProps, Noop, render, Emotion;
var init_emotion_element_04d85134_browser_esm = __esm({
  "node_modules/@emotion/core/dist/emotion-element-04d85134.browser.esm.js"() {
    import_dist22 = __toESM(require_dist());
    import_dist23 = __toESM(require_dist2());
    import_dist24 = __toESM(require_dist3());
    init_inheritsLoose();
    import_react = __toESM(require_react());
    init_cache_browser_esm();
    init_utils_browser_esm();
    init_serialize_browser_esm();
    hasOwnProperty = Object.prototype.hasOwnProperty;
    EmotionCacheContext = (0, import_react.createContext)(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement !== "undefined" ? cache_browser_esm_default() : null
    );
    ThemeContext = (0, import_react.createContext)({});
    CacheProvider = EmotionCacheContext.Provider;
    withEmotionCache = function withEmotionCache2(func) {
      var render3 = function render4(props, ref) {
        return (0, import_react.createElement)(EmotionCacheContext.Consumer, null, function(cache) {
          return func(props, cache, ref);
        });
      };
      return (0, import_react.forwardRef)(render3);
    };
    sanitizeIdentifier = function sanitizeIdentifier2(identifier) {
      return identifier.replace(/\$/g, "-");
    };
    typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
    labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
    createEmotionProps = function createEmotionProps2(type, props) {
      if (process.env.NODE_ENV !== "production" && typeof props.css === "string" && // check if there is a css declaration
      props.css.indexOf(":") !== -1) {
        throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/css' like this: css`" + props.css + "`");
      }
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty.call(props, key)) {
          newProps[key] = props[key];
        }
      }
      newProps[typePropName] = type;
      if (process.env.NODE_ENV !== "production") {
        var error = new Error();
        if (error.stack) {
          var match = error.stack.match(/at (?:Object\.|Module\.|)(?:jsx|createEmotionProps).*\n\s+at (?:Object\.|)([A-Z][A-Za-z$]+) /);
          if (!match) {
            match = error.stack.match(/.*\n([A-Z][A-Za-z$]+)@/);
          }
          if (match) {
            newProps[labelPropName] = sanitizeIdentifier(match[1]);
          }
        }
      }
      return newProps;
    };
    Noop = function Noop2() {
      return null;
    };
    render = function render2(cache, props, theme, ref) {
      var cssProp = theme === null ? props.css : props.css(theme);
      if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
        cssProp = cache.registered[cssProp];
      }
      var type = props[typePropName];
      var registeredStyles = [cssProp];
      var className = "";
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(registeredStyles);
      if (process.env.NODE_ENV !== "production" && serialized.name.indexOf("-") === -1) {
        var labelFromStack = props[labelPropName];
        if (labelFromStack) {
          serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
        }
      }
      var rules = insertStyles(cache, serialized, typeof type === "string");
      className += cache.key + "-" + serialized.name;
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && (process.env.NODE_ENV === "production" || key !== labelPropName)) {
          newProps[key] = props[key];
        }
      }
      newProps.ref = ref;
      newProps.className = className;
      var ele = (0, import_react.createElement)(type, newProps);
      var possiblyStyleElement = (0, import_react.createElement)(Noop, null);
      return (0, import_react.createElement)(import_react.Fragment, null, possiblyStyleElement, ele);
    };
    Emotion = withEmotionCache(function(props, cache, ref) {
      if (typeof props.css === "function") {
        return (0, import_react.createElement)(ThemeContext.Consumer, null, function(theme) {
          return render(cache, props, theme, ref);
        });
      }
      return render(cache, props, null, ref);
    });
    if (process.env.NODE_ENV !== "production") {
      Emotion.displayName = "EmotionCssPropInternal";
    }
  }
});

// node_modules/@emotion/css/dist/css.browser.esm.js
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var import_dist25, import_dist26, import_dist27, css_browser_esm_default;
var init_css_browser_esm = __esm({
  "node_modules/@emotion/css/dist/css.browser.esm.js"() {
    import_dist25 = __toESM(require_dist());
    import_dist26 = __toESM(require_dist2());
    import_dist27 = __toESM(require_dist3());
    init_serialize_browser_esm();
    css_browser_esm_default = css;
  }
});

// node_modules/@emotion/core/dist/core.browser.esm.js
var core_browser_esm_exports = {};
__export(core_browser_esm_exports, {
  CacheProvider: () => CacheProvider,
  ClassNames: () => ClassNames,
  Global: () => Global,
  ThemeContext: () => ThemeContext,
  createElement: () => jsx,
  css: () => css_browser_esm_default,
  jsx: () => jsx,
  keyframes: () => keyframes,
  withEmotionCache: () => withEmotionCache
});
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var import_dist28, import_dist29, import_dist30, import_react2, jsx, warnedAboutCssPropForGlobal, Global, InnerGlobal, keyframes, classnames, Noop3, ClassNames;
var init_core_browser_esm = __esm({
  "node_modules/@emotion/core/dist/core.browser.esm.js"() {
    import_dist28 = __toESM(require_dist());
    import_dist29 = __toESM(require_dist2());
    import_dist30 = __toESM(require_dist3());
    init_inheritsLoose();
    import_react2 = __toESM(require_react());
    init_cache_browser_esm();
    init_emotion_element_04d85134_browser_esm();
    init_emotion_element_04d85134_browser_esm();
    init_utils_browser_esm();
    init_serialize_browser_esm();
    init_sheet_browser_esm();
    init_css_browser_esm();
    init_css_browser_esm();
    jsx = function jsx2(type, props) {
      var args = arguments;
      if (props == null || !hasOwnProperty.call(props, "css")) {
        return import_react2.createElement.apply(void 0, args);
      }
      var argsLength = args.length;
      var createElementArgArray = new Array(argsLength);
      createElementArgArray[0] = Emotion;
      createElementArgArray[1] = createEmotionProps(type, props);
      for (var i = 2; i < argsLength; i++) {
        createElementArgArray[i] = args[i];
      }
      return import_react2.createElement.apply(null, createElementArgArray);
    };
    warnedAboutCssPropForGlobal = false;
    Global = withEmotionCache(function(props, cache) {
      if (process.env.NODE_ENV !== "production" && !warnedAboutCssPropForGlobal && // check for className as well since the user is
      // probably using the custom createElement which
      // means it will be turned into a className prop
      // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
      (props.className || props.css)) {
        console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
        warnedAboutCssPropForGlobal = true;
      }
      var styles = props.styles;
      if (typeof styles === "function") {
        return (0, import_react2.createElement)(ThemeContext.Consumer, null, function(theme) {
          var serialized2 = serializeStyles([styles(theme)]);
          return (0, import_react2.createElement)(InnerGlobal, {
            serialized: serialized2,
            cache
          });
        });
      }
      var serialized = serializeStyles([styles]);
      return (0, import_react2.createElement)(InnerGlobal, {
        serialized,
        cache
      });
    });
    InnerGlobal = function(_React$Component) {
      _inheritsLoose(InnerGlobal2, _React$Component);
      function InnerGlobal2(props, context, updater) {
        return _React$Component.call(this, props, context, updater) || this;
      }
      var _proto = InnerGlobal2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.sheet = new StyleSheet({
          key: this.props.cache.key + "-global",
          nonce: this.props.cache.sheet.nonce,
          container: this.props.cache.sheet.container
        });
        var node = document.querySelector("style[data-emotion-" + this.props.cache.key + '="' + this.props.serialized.name + '"]');
        if (node !== null) {
          this.sheet.tags.push(node);
        }
        if (this.props.cache.sheet.tags.length) {
          this.sheet.before = this.props.cache.sheet.tags[0];
        }
        this.insertStyles();
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (prevProps.serialized.name !== this.props.serialized.name) {
          this.insertStyles();
        }
      };
      _proto.insertStyles = function insertStyles$1() {
        if (this.props.serialized.next !== void 0) {
          insertStyles(this.props.cache, this.props.serialized.next, true);
        }
        if (this.sheet.tags.length) {
          var element = this.sheet.tags[this.sheet.tags.length - 1].nextElementSibling;
          this.sheet.before = element;
          this.sheet.flush();
        }
        this.props.cache.insert("", this.props.serialized, this.sheet, false);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.sheet.flush();
      };
      _proto.render = function render3() {
        return null;
      };
      return InnerGlobal2;
    }(import_react2.Component);
    keyframes = function keyframes2() {
      var insertable = css_browser_esm_default.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    classnames = function classnames2(args) {
      var len = args.length;
      var i = 0;
      var cls = "";
      for (; i < len; i++) {
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;
        switch (typeof arg) {
          case "boolean":
            break;
          case "object": {
            if (Array.isArray(arg)) {
              toAdd = classnames2(arg);
            } else {
              toAdd = "";
              for (var k in arg) {
                if (arg[k] && k) {
                  toAdd && (toAdd += " ");
                  toAdd += k;
                }
              }
            }
            break;
          }
          default: {
            toAdd = arg;
          }
        }
        if (toAdd) {
          cls && (cls += " ");
          cls += toAdd;
        }
      }
      return cls;
    };
    Noop3 = function Noop4() {
      return null;
    };
    ClassNames = withEmotionCache(function(props, context) {
      return (0, import_react2.createElement)(ThemeContext.Consumer, null, function(theme) {
        var hasRendered = false;
        var css2 = function css3() {
          if (hasRendered && process.env.NODE_ENV !== "production") {
            throw new Error("css can only be used during render");
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var serialized = serializeStyles(args, context.registered);
          {
            insertStyles(context, serialized, false);
          }
          return context.key + "-" + serialized.name;
        };
        var cx = function cx2() {
          if (hasRendered && process.env.NODE_ENV !== "production") {
            throw new Error("cx can only be used during render");
          }
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return merge(context.registered, css2, classnames(args));
        };
        var content = {
          css: css2,
          cx,
          theme
        };
        var ele = props.children(content);
        hasRendered = true;
        var possiblyStyleElement = (0, import_react2.createElement)(Noop3, null);
        return (0, import_react2.createElement)(import_react2.Fragment, null, possiblyStyleElement, ele);
      });
    });
  }
});

export {
  getRegisteredStyles,
  insertStyles,
  init_utils_browser_esm,
  serializeStyles,
  init_serialize_browser_esm,
  ThemeContext,
  withEmotionCache,
  core_browser_esm_exports,
  init_core_browser_esm
};
//# sourceMappingURL=chunk-4G4P56PP.js.map

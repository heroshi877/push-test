"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cids_1 = __importDefault(require("cids"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const typestub_multihashes_1 = require("typestub-multihashes");
const providers = __importStar(require("@ethersproject/providers"));
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const DEFAULT_POLL_TIME = 5000;
const DEFAULT_MAX_POLL_TIME = 7200000;
const ETH_CHAIN_ID_MAPPINGS = {
    "eip155:1": { network: "mainnet", chain: "ETH", chainId: 1, networkId: 1, type: "Production" },
    "eip155:3": { network: "ropsten", chain: "ETH", chainId: 3, networkId: 3, type: "Test" },
};
class EthereumAnchorService extends ceramic_common_1.AnchorService {
    constructor(_config) {
        super();
        this._config = _config;
        this.cidToResMap = new Map();
    }
    set ceramic(ceramic) {
        this._ceramic = ceramic;
    }
    async requestAnchor(docId, head) {
        const cidDocPair = { cid: head, docId };
        await this._sendReq(cidDocPair);
        this._poll(cidDocPair);
    }
    async _sendReq(cidDocPair) {
        const response = await cross_fetch_1.default(this._config.anchorServiceUrl, {
            method: "POST", body: JSON.stringify({
                docId: cidDocPair.docId, cid: cidDocPair.cid.toString()
            }), headers: {
                "Content-Type": "application/json"
            }
        });
        if (!response.ok) {
            this.emit(cidDocPair.docId, {
                status: 'FAILED',
                message: `Failed to send request. Status ${response.statusText}`
            });
            return;
        }
        const json = await response.json();
        const res = { status: json.status, message: json.message, anchorScheduledFor: json.scheduledAt };
        this.cidToResMap.set(cidDocPair, res);
        this.emit(cidDocPair.docId, res);
    }
    async _poll(cidDoc, pollTime, maxPollingTime) {
        const started = new Date().getTime();
        const maxTime = started + (maxPollingTime | DEFAULT_MAX_POLL_TIME);
        let poll = true;
        while (poll) {
            if (started > maxTime) {
                const failedRes = { status: 'FAILED', message: 'exceeded max timeout' };
                this.cidToResMap.set(cidDoc, failedRes);
                this.emit(cidDoc.docId, failedRes);
                return;
            }
            await new Promise(resolve => setTimeout(resolve, DEFAULT_POLL_TIME));
            try {
                const requestUrl = [this._config.anchorServiceUrl, cidDoc.cid.toString()].join('/');
                const response = await cross_fetch_1.default(requestUrl);
                const json = await response.json();
                switch (json.status) {
                    case "PENDING": {
                        break;
                    }
                    case "PROCESSING": {
                        this.emit(cidDoc.docId, { status: json.status, message: json.message });
                        break;
                    }
                    case "FAILED": {
                        this.emit(cidDoc.docId, { status: json.status, message: json.message });
                        poll = false;
                        break;
                    }
                    case "COMPLETED": {
                        const { anchorRecord } = json;
                        const anchorRecordCid = new cids_1.default(anchorRecord.cid.toString());
                        this.emit(cidDoc.docId, {
                            status: json.status, message: json.message, anchorRecord: anchorRecordCid
                        });
                        poll = false;
                        break;
                    }
                }
            }
            catch (e) {
            }
        }
    }
    async validateChainInclusion(anchorProof) {
        const decoded = typestub_multihashes_1.decode(Buffer.from(anchorProof.txHash.multihash));
        const txHash = decoded.digest.toString("hex");
        const provider = this._getEthProvider(anchorProof.chainId);
        const transaction = await provider.getTransaction('0x' + txHash);
        const block = await provider.getBlock(transaction.blockHash);
        const txValueHexNumber = parseInt(transaction.data, 16);
        const rootValueHexNumber = parseInt('0x' + anchorProof.root.toBaseEncodedString('base16'), 16);
        if (txValueHexNumber !== rootValueHexNumber) {
            throw new Error(`The root CID ${anchorProof.root.toString()} is not in the transaction`);
        }
        if (anchorProof.blockNumber !== transaction.blockNumber) {
            throw new Error(`Block numbers are not the same`);
        }
        if (anchorProof.blockTimestamp !== block.timestamp) {
            throw new Error(`Block timestamps are not the same`);
        }
    }
    _getEthProvider(chain) {
        if (!chain.startsWith('eip155')) {
            throw new Error('Invalid chain ID according to CAIP-2');
        }
        const ethNetwork = ETH_CHAIN_ID_MAPPINGS[chain];
        if (ethNetwork == null) {
            return new providers.JsonRpcProvider(this._config.ethereumRpcUrl);
        }
        return providers.getDefaultProvider(ethNetwork.network);
    }
}
exports.default = EthereumAnchorService;
//# sourceMappingURL=ethereum-anchor-service.js.map
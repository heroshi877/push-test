{
  "version": 3,
  "sources": ["../../@reach/combobox/dist/reach-combobox.mjs", "../../@reach/popover/dist/reach-popover.mjs", "../../@reach/portal/dist/reach-portal.mjs", "../../@reach/rect/dist/reach-rect.mjs", "../../@reach/observe-rect/src/index.ts", "../../tabbable/src/index.js"],
  "sourcesContent": ["\"use strict\";\n/**\n  * @reach/combobox v0.18.0\n  *\n  * Copyright (c) 2018-2022, React Training LLC\n  *\n  * This source code is licensed under the MIT license found in the\n  * LICENSE.md file in the root directory of this source tree.\n  *\n  * @license MIT\n  */\n\n\n// src/reach-combobox.tsx\nimport * as React from \"react\";\nimport {\n  createNamedContext,\n  composeEventHandlers,\n  isFunction,\n  makeId,\n  noop,\n  useComposedRefs,\n  useIsomorphicLayoutEffect as useLayoutEffect,\n  useStatefulRefValue,\n  useUpdateEffect\n} from \"@reach/utils\";\nimport {\n  createDescendantContext,\n  DescendantProvider,\n  useDescendant,\n  useDescendants,\n  useDescendantsInit\n} from \"@reach/descendants\";\n\n// src/utils.ts\nfunction findAll({\n  autoEscape,\n  caseSensitive = false,\n  findChunks = defaultFindChunks,\n  sanitize,\n  searchWords,\n  textToHighlight\n}) {\n  return fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape,\n        caseSensitive,\n        sanitize,\n        searchWords,\n        textToHighlight\n      })\n    }),\n    totalLength: textToHighlight ? textToHighlight.length : 0\n  });\n}\nfunction combineChunks({ chunks }) {\n  return chunks.sort((first, second) => first.start - second.start).reduce((processedChunks, nextChunk) => {\n    if (processedChunks.length === 0) {\n      return [nextChunk];\n    } else {\n      const prevChunk = processedChunks.pop();\n      if (nextChunk.start <= prevChunk.end) {\n        const endIndex = Math.max(prevChunk.end, nextChunk.end);\n        processedChunks.push({\n          highlight: false,\n          start: prevChunk.start,\n          end: endIndex\n        });\n      } else {\n        processedChunks.push(prevChunk, nextChunk);\n      }\n      return processedChunks;\n    }\n  }, []);\n}\nfunction defaultFindChunks({\n  autoEscape,\n  caseSensitive,\n  sanitize = defaultSanitize,\n  searchWords,\n  textToHighlight\n}) {\n  textToHighlight = sanitize(textToHighlight || \"\");\n  return searchWords.filter((searchWord) => searchWord).reduce((chunks, searchWord) => {\n    searchWord = sanitize(searchWord);\n    if (autoEscape) {\n      searchWord = escapeRegExpFn(searchWord);\n    }\n    const regex = new RegExp(searchWord, caseSensitive ? \"g\" : \"gi\");\n    let match;\n    while (match = regex.exec(textToHighlight || \"\")) {\n      let start = match.index;\n      let end = regex.lastIndex;\n      if (end > start) {\n        chunks.push({ highlight: false, start, end });\n      }\n      if (match.index === regex.lastIndex) {\n        regex.lastIndex++;\n      }\n    }\n    return chunks;\n  }, []);\n}\nfunction fillInChunks({\n  chunksToHighlight,\n  totalLength\n}) {\n  const allChunks = [];\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false);\n  } else {\n    let lastIndex = 0;\n    chunksToHighlight.forEach((chunk) => {\n      append(lastIndex, chunk.start, false);\n      append(chunk.start, chunk.end, true);\n      lastIndex = chunk.end;\n    });\n    append(lastIndex, totalLength, false);\n  }\n  return allChunks;\n  function append(start, end, highlight) {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      });\n    }\n  }\n}\nfunction defaultSanitize(string) {\n  return string;\n}\nfunction escapeRegExpFn(string) {\n  return string.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, \"\\\\$&\");\n}\nvar HighlightWords = {\n  combineChunks,\n  fillInChunks,\n  findAll,\n  findChunks: defaultFindChunks\n};\n\n// src/reach-combobox.tsx\nimport { useId } from \"@reach/auto-id\";\nimport { Popover, positionMatchWidth } from \"@reach/popover\";\nvar IDLE = \"IDLE\";\nvar SUGGESTING = \"SUGGESTING\";\nvar NAVIGATING = \"NAVIGATING\";\nvar INTERACTING = \"INTERACTING\";\nvar CLEAR = \"CLEAR\";\nvar CHANGE = \"CHANGE\";\nvar INITIAL_CHANGE = \"INITIAL_CHANGE\";\nvar NAVIGATE = \"NAVIGATE\";\nvar SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nvar SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\";\nvar ESCAPE = \"ESCAPE\";\nvar BLUR = \"BLUR\";\nvar INTERACT = \"INTERACT\";\nvar FOCUS = \"FOCUS\";\nvar OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\nvar OPEN_WITH_INPUT_CLICK = \"OPEN_WITH_INPUT_CLICK\";\nvar CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\";\nvar stateChart = {\n  initial: IDLE,\n  states: {\n    [IDLE]: {\n      on: {\n        [BLUR]: IDLE,\n        [CLEAR]: IDLE,\n        [CHANGE]: SUGGESTING,\n        [INITIAL_CHANGE]: IDLE,\n        [FOCUS]: SUGGESTING,\n        [NAVIGATE]: NAVIGATING,\n        [OPEN_WITH_BUTTON]: SUGGESTING,\n        [OPEN_WITH_INPUT_CLICK]: SUGGESTING\n      }\n    },\n    [SUGGESTING]: {\n      on: {\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [NAVIGATE]: NAVIGATING,\n        [CLEAR]: IDLE,\n        [ESCAPE]: IDLE,\n        [BLUR]: IDLE,\n        [SELECT_WITH_CLICK]: IDLE,\n        [INTERACT]: INTERACTING,\n        [CLOSE_WITH_BUTTON]: IDLE\n      }\n    },\n    [NAVIGATING]: {\n      on: {\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [CLEAR]: IDLE,\n        [BLUR]: IDLE,\n        [ESCAPE]: IDLE,\n        [NAVIGATE]: NAVIGATING,\n        [SELECT_WITH_CLICK]: IDLE,\n        [SELECT_WITH_KEYBOARD]: IDLE,\n        [CLOSE_WITH_BUTTON]: IDLE,\n        [INTERACT]: INTERACTING\n      }\n    },\n    [INTERACTING]: {\n      on: {\n        [CLEAR]: IDLE,\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [BLUR]: IDLE,\n        [ESCAPE]: IDLE,\n        [NAVIGATE]: NAVIGATING,\n        [CLOSE_WITH_BUTTON]: IDLE,\n        [SELECT_WITH_CLICK]: IDLE\n      }\n    }\n  }\n};\nvar reducer = (data, event) => {\n  let nextState = { ...data, lastEventType: event.type };\n  switch (event.type) {\n    case CHANGE:\n    case INITIAL_CHANGE:\n      return {\n        ...nextState,\n        navigationValue: null,\n        value: event.value\n      };\n    case NAVIGATE:\n    case OPEN_WITH_BUTTON:\n    case OPEN_WITH_INPUT_CLICK:\n      return {\n        ...nextState,\n        navigationValue: findNavigationValue(nextState, event)\n      };\n    case CLEAR:\n      return {\n        ...nextState,\n        value: \"\",\n        navigationValue: null\n      };\n    case BLUR:\n    case ESCAPE:\n      return {\n        ...nextState,\n        navigationValue: null\n      };\n    case SELECT_WITH_CLICK:\n      return {\n        ...nextState,\n        value: event.isControlled ? data.value : event.value,\n        navigationValue: null\n      };\n    case SELECT_WITH_KEYBOARD:\n      return {\n        ...nextState,\n        value: event.isControlled ? data.value : data.navigationValue,\n        navigationValue: null\n      };\n    case CLOSE_WITH_BUTTON:\n      return {\n        ...nextState,\n        navigationValue: null\n      };\n    case INTERACT:\n      return nextState;\n    case FOCUS:\n      return {\n        ...nextState,\n        navigationValue: findNavigationValue(nextState, event)\n      };\n    default:\n      return nextState;\n  }\n};\nfunction popoverIsExpanded(state) {\n  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\nfunction findNavigationValue(stateData, event) {\n  if (event.value) {\n    return event.value;\n  } else if (event.persistSelection) {\n    return stateData.value;\n  } else {\n    return null;\n  }\n}\nvar ComboboxDescendantContext = createDescendantContext(\"ComboboxDescendantContext\");\nvar ComboboxContext = createNamedContext(\"ComboboxContext\", {});\nvar OptionContext = createNamedContext(\"OptionContext\", {});\nvar Combobox = React.forwardRef(({\n  onSelect,\n  openOnFocus = false,\n  children,\n  as: Comp = \"div\",\n  \"aria-label\": ariaLabel,\n  \"aria-labelledby\": ariaLabelledby,\n  ...props\n}, forwardedRef) => {\n  let [options, setOptions] = useDescendantsInit();\n  let inputRef = React.useRef();\n  let popoverRef = React.useRef();\n  let buttonRef = React.useRef();\n  let autocompletePropRef = React.useRef(false);\n  let persistSelectionRef = React.useRef(false);\n  let defaultData = {\n    value: \"\",\n    navigationValue: null\n  };\n  let [state, data, transition] = useReducerMachine(stateChart, reducer, defaultData);\n  useFocusManagement(data.lastEventType, inputRef);\n  let id = useId(props.id);\n  let listboxId = id ? makeId(\"listbox\", id) : \"listbox\";\n  let isControlledRef = React.useRef(false);\n  let isExpanded = popoverIsExpanded(state);\n  let context = {\n    ariaLabel,\n    ariaLabelledby,\n    autocompletePropRef,\n    buttonRef,\n    comboboxId: id,\n    data,\n    inputRef,\n    isExpanded,\n    listboxId,\n    onSelect: onSelect || noop,\n    openOnFocus,\n    persistSelectionRef,\n    popoverRef,\n    state,\n    transition,\n    isControlledRef\n  };\n  return /* @__PURE__ */ React.createElement(DescendantProvider, {\n    context: ComboboxDescendantContext,\n    items: options,\n    set: setOptions\n  }, /* @__PURE__ */ React.createElement(ComboboxContext.Provider, {\n    value: context\n  }, /* @__PURE__ */ React.createElement(Comp, {\n    ...props,\n    \"data-reach-combobox\": \"\",\n    \"data-state\": getDataState(state),\n    \"data-expanded\": isExpanded || void 0,\n    ref: forwardedRef\n  }, isFunction(children) ? children({\n    id,\n    isExpanded,\n    navigationValue: data.navigationValue ?? null,\n    state\n  }) : children)));\n});\nCombobox.displayName = \"Combobox\";\nvar ComboboxInput = React.forwardRef(({\n  as: Comp = \"input\",\n  selectOnClick = false,\n  autocomplete = true,\n  onClick,\n  onChange,\n  onKeyDown,\n  onBlur,\n  onFocus,\n  value: controlledValue,\n  ...props\n}, forwardedRef) => {\n  let { current: initialControlledValue } = React.useRef(controlledValue);\n  let controlledValueChangedRef = React.useRef(false);\n  useUpdateEffect(() => {\n    controlledValueChangedRef.current = true;\n  }, [controlledValue]);\n  let {\n    data: { navigationValue, value, lastEventType },\n    inputRef,\n    state,\n    transition,\n    listboxId,\n    autocompletePropRef,\n    openOnFocus,\n    isExpanded,\n    ariaLabel,\n    ariaLabelledby,\n    persistSelectionRef,\n    isControlledRef\n  } = React.useContext(ComboboxContext);\n  let ref = useComposedRefs(inputRef, forwardedRef);\n  let selectOnClickRef = React.useRef(false);\n  let handleKeyDown = useKeyDown();\n  let handleBlur = useBlur();\n  let isControlled = typeof controlledValue !== \"undefined\";\n  let wasInitiallyControlled = typeof initialControlledValue !== \"undefined\";\n  if (true) {\n    if (!isControlled && wasInitiallyControlled) {\n      console.warn(\"ComboboxInput is changing from controlled to uncontrolled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\");\n    }\n    if (isControlled && !wasInitiallyControlled) {\n      console.warn(\"ComboboxInput is changing from uncontrolled to controlled. ComboboxInput should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled ComboboxInput for the lifetime of the component. Check the `value` prop being passed in.\");\n    }\n  }\n  React.useEffect(() => {\n    isControlledRef.current = isControlled;\n  }, [isControlled]);\n  useLayoutEffect(() => {\n    autocompletePropRef.current = autocomplete;\n  }, [autocomplete, autocompletePropRef]);\n  let handleValueChange = React.useCallback((value2) => {\n    if (value2.trim() === \"\") {\n      transition(CLEAR, { isControlled });\n    } else if (value2 === initialControlledValue && !controlledValueChangedRef.current) {\n      transition(INITIAL_CHANGE, { value: value2 });\n    } else {\n      transition(CHANGE, { value: value2 });\n    }\n  }, [initialControlledValue, transition, isControlled]);\n  React.useEffect(() => {\n    if (isControlled && controlledValue !== value && (controlledValue.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)) {\n      handleValueChange(controlledValue);\n    }\n  }, [controlledValue, handleValueChange, isControlled, value]);\n  React.useEffect(() => {\n    let form = inputRef.current?.form;\n    if (!form)\n      return;\n    function handleReset(event) {\n      transition(CLEAR, { isControlled });\n    }\n    form.addEventListener(\"reset\", handleReset);\n    return () => {\n      form?.removeEventListener(\"reset\", handleReset);\n    };\n  }, [inputRef, isControlled, transition]);\n  function handleChange(event) {\n    let { value: value2 } = event.target;\n    if (!isControlled) {\n      handleValueChange(value2);\n    }\n  }\n  function handleFocus() {\n    if (selectOnClick) {\n      selectOnClickRef.current = true;\n    }\n    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n      transition(FOCUS, {\n        persistSelection: persistSelectionRef.current\n      });\n    }\n  }\n  function handleClick() {\n    if (selectOnClickRef.current) {\n      selectOnClickRef.current = false;\n      inputRef.current?.select();\n    }\n    if (openOnFocus && state === IDLE) {\n      transition(OPEN_WITH_INPUT_CLICK);\n    }\n  }\n  let inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? navigationValue || controlledValue || value : controlledValue || value;\n  return /* @__PURE__ */ React.createElement(Comp, {\n    \"aria-activedescendant\": navigationValue ? String(makeHash(navigationValue)) : void 0,\n    \"aria-autocomplete\": \"both\",\n    \"aria-controls\": listboxId,\n    \"aria-expanded\": isExpanded,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? void 0 : ariaLabelledby,\n    role: \"combobox\",\n    ...props,\n    \"data-reach-combobox-input\": \"\",\n    \"data-state\": getDataState(state),\n    ref,\n    onBlur: composeEventHandlers(onBlur, handleBlur),\n    onChange: composeEventHandlers(onChange, handleChange),\n    onClick: composeEventHandlers(onClick, handleClick),\n    onFocus: composeEventHandlers(onFocus, handleFocus),\n    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),\n    value: inputValue || \"\"\n  });\n});\nComboboxInput.displayName = \"ComboboxInput\";\nvar ComboboxPopover = React.forwardRef(({\n  as: Comp = \"div\",\n  children,\n  portal = true,\n  onKeyDown,\n  onBlur,\n  position = positionMatchWidth,\n  ...props\n}, forwardedRef) => {\n  let { popoverRef, inputRef, isExpanded, state } = React.useContext(ComboboxContext);\n  let ref = useComposedRefs(popoverRef, forwardedRef);\n  let handleKeyDown = useKeyDown();\n  let handleBlur = useBlur();\n  let sharedProps = {\n    \"data-reach-combobox-popover\": \"\",\n    \"data-state\": getDataState(state),\n    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),\n    onBlur: composeEventHandlers(onBlur, handleBlur),\n    hidden: !isExpanded,\n    tabIndex: -1,\n    children\n  };\n  return portal ? /* @__PURE__ */ React.createElement(Popover, {\n    as: Comp,\n    ...props,\n    ref,\n    \"data-expanded\": isExpanded || void 0,\n    position,\n    targetRef: inputRef,\n    unstable_skipInitialPortalRender: true,\n    ...sharedProps\n  }) : /* @__PURE__ */ React.createElement(Comp, {\n    ref,\n    ...props,\n    ...sharedProps\n  });\n});\nComboboxPopover.displayName = \"ComboboxPopover\";\nvar ComboboxList = React.forwardRef(({\n  persistSelection = false,\n  as: Comp = \"ul\",\n  ...props\n}, forwardedRef) => {\n  let { persistSelectionRef, listboxId } = React.useContext(ComboboxContext);\n  if (persistSelection) {\n    persistSelectionRef.current = true;\n  }\n  return /* @__PURE__ */ React.createElement(Comp, {\n    role: \"listbox\",\n    ...props,\n    ref: forwardedRef,\n    \"data-reach-combobox-list\": \"\",\n    id: listboxId\n  });\n});\nComboboxList.displayName = \"ComboboxList\";\nvar ComboboxOption = React.forwardRef(({ as: Comp = \"li\", children, index: indexProp, value, onClick, ...props }, forwardedRef) => {\n  let {\n    onSelect,\n    data: { navigationValue },\n    transition,\n    isControlledRef\n  } = React.useContext(ComboboxContext);\n  let ownRef = React.useRef(null);\n  let [element, handleRefSet] = useStatefulRefValue(ownRef, null);\n  let descendant = React.useMemo(() => {\n    return {\n      element,\n      value\n    };\n  }, [value, element]);\n  let index = useDescendant(descendant, ComboboxDescendantContext, indexProp);\n  let ref = useComposedRefs(forwardedRef, handleRefSet);\n  let isActive = navigationValue === value;\n  let handleClick = () => {\n    onSelect && onSelect(value);\n    transition(SELECT_WITH_CLICK, {\n      value,\n      isControlled: isControlledRef.current\n    });\n  };\n  return /* @__PURE__ */ React.createElement(OptionContext.Provider, {\n    value: { value, index }\n  }, /* @__PURE__ */ React.createElement(Comp, {\n    \"aria-selected\": isActive,\n    role: \"option\",\n    ...props,\n    \"data-reach-combobox-option\": \"\",\n    ref,\n    id: String(makeHash(value)),\n    \"data-highlighted\": isActive ? \"\" : void 0,\n    tabIndex: -1,\n    onClick: composeEventHandlers(onClick, handleClick)\n  }, children ? isFunction(children) ? children({ value, index }) : children : /* @__PURE__ */ React.createElement(ComboboxOptionText, null)));\n});\nComboboxOption.displayName = \"ComboboxOption\";\nfunction ComboboxOptionText() {\n  let { value } = React.useContext(OptionContext);\n  let {\n    data: { value: contextValue }\n  } = React.useContext(ComboboxContext);\n  let results = React.useMemo(() => HighlightWords.findAll({\n    searchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n    textToHighlight: value\n  }), [contextValue, value]);\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, results.length ? results.map((result, index) => {\n    let str = value.slice(result.start, result.end);\n    return /* @__PURE__ */ React.createElement(\"span\", {\n      key: index,\n      \"data-reach-combobox-option-text\": \"\",\n      \"data-user-value\": result.highlight ? true : void 0,\n      \"data-suggested-value\": result.highlight ? void 0 : true\n    }, str);\n  }) : value);\n}\nComboboxOptionText.displayName = \"ComboboxOptionText\";\nvar ComboboxButton = React.forwardRef(({ as: Comp = \"button\", onClick, onKeyDown, ...props }, forwardedRef) => {\n  let { transition, state, buttonRef, listboxId, isExpanded } = React.useContext(ComboboxContext);\n  let ref = useComposedRefs(buttonRef, forwardedRef);\n  let handleKeyDown = useKeyDown();\n  let handleClick = () => {\n    if (state === IDLE) {\n      transition(OPEN_WITH_BUTTON);\n    } else {\n      transition(CLOSE_WITH_BUTTON);\n    }\n  };\n  return /* @__PURE__ */ React.createElement(Comp, {\n    \"aria-controls\": listboxId,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-expanded\": isExpanded,\n    ...props,\n    \"data-reach-combobox-button\": \"\",\n    ref,\n    onClick: composeEventHandlers(onClick, handleClick),\n    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)\n  });\n});\nComboboxButton.displayName = \"ComboboxButton\";\nfunction useFocusManagement(lastEventType, inputRef) {\n  useLayoutEffect(() => {\n    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {\n      inputRef.current?.focus();\n    }\n  }, [inputRef, lastEventType]);\n}\nfunction useKeyDown() {\n  let {\n    data: { navigationValue },\n    onSelect,\n    state,\n    transition,\n    autocompletePropRef,\n    persistSelectionRef,\n    inputRef,\n    isControlledRef\n  } = React.useContext(ComboboxContext);\n  let options = useDescendants(ComboboxDescendantContext);\n  return function handleKeyDown(event) {\n    let index = options.findIndex(({ value }) => value === navigationValue);\n    function getNextOption() {\n      let atBottom = index === options.length - 1;\n      if (atBottom) {\n        if (autocompletePropRef.current) {\n          return null;\n        } else {\n          return getFirstOption();\n        }\n      } else {\n        return options[(index + 1) % options.length];\n      }\n    }\n    function getPreviousOption() {\n      let atTop = index === 0;\n      if (atTop) {\n        if (autocompletePropRef.current) {\n          return null;\n        } else {\n          return getLastOption();\n        }\n      } else if (index === -1) {\n        return getLastOption();\n      } else {\n        return options[(index - 1 + options.length) % options.length];\n      }\n    }\n    function getFirstOption() {\n      return options[0];\n    }\n    function getLastOption() {\n      return options[options.length - 1];\n    }\n    let textareaHasMultilineValue = inputRef.current?.tagName.toUpperCase() === \"TEXTAREA\" && inputRef.current.value.includes(`\n`);\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (!options || !options.length) {\n          return;\n        }\n        if (state === IDLE) {\n          if (textareaHasMultilineValue) {\n            return;\n          }\n          event.preventDefault();\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current\n          });\n        } else {\n          event.preventDefault();\n          let next = getNextOption();\n          transition(NAVIGATE, { value: next ? next.value : null });\n        }\n        break;\n      case \"ArrowUp\":\n        if (!options || !options.length) {\n          return;\n        }\n        if (state === IDLE) {\n          if (textareaHasMultilineValue) {\n            return;\n          }\n          event.preventDefault();\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current\n          });\n        } else {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          transition(NAVIGATE, { value: prev ? prev.value : null });\n        }\n        break;\n      case \"Home\":\n      case \"PageUp\":\n        event.preventDefault();\n        if (!options || options.length === 0) {\n          return;\n        }\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, { value: getFirstOption().value });\n        }\n        break;\n      case \"End\":\n      case \"PageDown\":\n        event.preventDefault();\n        if (!options || options.length === 0) {\n          return;\n        }\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, { value: getLastOption().value });\n        }\n        break;\n      case \"Escape\":\n        if (state !== IDLE) {\n          transition(ESCAPE);\n        }\n        break;\n      case \"Enter\":\n        if (state === NAVIGATING && navigationValue !== null) {\n          event.preventDefault();\n          onSelect && onSelect(navigationValue);\n          transition(SELECT_WITH_KEYBOARD, {\n            isControlled: isControlledRef.current\n          });\n        }\n        break;\n    }\n  };\n}\nfunction useBlur() {\n  let { state, transition, popoverRef, inputRef, buttonRef } = React.useContext(ComboboxContext);\n  return function handleBlur(event) {\n    let popover = popoverRef.current;\n    let input = inputRef.current;\n    let button = buttonRef.current;\n    let activeElement = event.relatedTarget;\n    if (activeElement !== input && activeElement !== button && popover) {\n      if (popover.contains(activeElement)) {\n        if (state !== INTERACTING) {\n          transition(INTERACT);\n        }\n      } else {\n        transition(BLUR);\n      }\n    }\n  };\n}\nfunction useReducerMachine(chart, reducer2, initialData) {\n  let [state, setState] = React.useState(chart.initial);\n  let [data, dispatch] = React.useReducer(reducer2, initialData);\n  let transition = (event, payload = {}) => {\n    let currentState = chart.states[state];\n    let nextState = currentState && currentState.on[event];\n    if (nextState) {\n      dispatch({ type: event, state, nextState: state, ...payload });\n      setState(nextState);\n      return;\n    }\n  };\n  return [state, data, transition];\n}\nfunction makeHash(str) {\n  let hash = 0;\n  if (str.length === 0) {\n    return hash;\n  }\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash << 5) - hash + str.charCodeAt(i);\n    hash = hash & hash;\n  }\n  return hash;\n}\nfunction getDataState(state) {\n  return state.toLowerCase();\n}\nfunction escapeRegexp(str) {\n  return String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n}\nfunction useComboboxContext() {\n  let { isExpanded, comboboxId, data, state } = React.useContext(ComboboxContext);\n  let { navigationValue } = data;\n  return React.useMemo(() => ({\n    id: comboboxId,\n    isExpanded,\n    navigationValue: navigationValue ?? null,\n    state\n  }), [comboboxId, isExpanded, navigationValue, state]);\n}\nfunction useComboboxOptionContext() {\n  let { value, index } = React.useContext(OptionContext);\n  return React.useMemo(() => ({\n    value,\n    index\n  }), [value, index]);\n}\nexport {\n  Combobox,\n  ComboboxButton,\n  ComboboxInput,\n  ComboboxList,\n  ComboboxOption,\n  ComboboxOptionText,\n  ComboboxPopover,\n  escapeRegexp,\n  useKeyDown as unstable_useKeyDown,\n  useComboboxContext,\n  useComboboxOptionContext\n};\n", "\"use strict\";\n/**\n  * @reach/popover v0.18.0\n  *\n  * Copyright (c) 2018-2022, React Training LLC\n  *\n  * This source code is licensed under the MIT license found in the\n  * LICENSE.md file in the root directory of this source tree.\n  *\n  * @license MIT\n  */\n\n\n// src/reach-popover.tsx\nimport * as React from \"react\";\nimport { Portal } from \"@reach/portal\";\nimport { useRect } from \"@reach/rect\";\nimport { getOwnerDocument, useComposedRefs } from \"@reach/utils\";\nimport { tabbable } from \"tabbable\";\nvar Popover = React.forwardRef(function Popover2({ unstable_skipInitialPortalRender, ...props }, ref) {\n  return /* @__PURE__ */ React.createElement(Portal, {\n    unstable_skipInitialRender: unstable_skipInitialPortalRender\n  }, /* @__PURE__ */ React.createElement(PopoverImpl, {\n    ref,\n    ...props\n  }));\n});\nPopover.displayName = \"Popover\";\nvar PopoverImpl = React.forwardRef(function PopoverImpl2({\n  as: Comp = \"div\",\n  targetRef,\n  position = positionDefault,\n  unstable_observableRefs = [],\n  ...props\n}, forwardedRef) {\n  const popoverRef = React.useRef(null);\n  const popoverRect = useRect(popoverRef, { observe: !props.hidden });\n  const targetRect = useRect(targetRef, { observe: true });\n  const ref = useComposedRefs(popoverRef, forwardedRef);\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n  return /* @__PURE__ */ React.createElement(Comp, {\n    \"data-reach-popover\": \"\",\n    ref,\n    ...props,\n    style: {\n      position: \"absolute\",\n      ...getStyles(position, targetRect, popoverRect, ...unstable_observableRefs),\n      ...props.style\n    }\n  });\n});\nPopoverImpl.displayName = \"PopoverImpl\";\nfunction getStyles(position, targetRect, popoverRect, ...unstable_observableRefs) {\n  return popoverRect ? position(targetRect, popoverRect, ...unstable_observableRefs.map((ref) => ref.current)) : { visibility: \"hidden\" };\n}\nfunction getTopPosition(targetRect, popoverRect, isDirectionUp) {\n  return {\n    top: isDirectionUp ? `${targetRect.top - popoverRect.height + window.pageYOffset}px` : `${targetRect.top + targetRect.height + window.pageYOffset}px`\n  };\n}\nvar positionDefault = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n  const { directionRight, directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionRight ? `${targetRect.right - popoverRect.width + window.pageXOffset}px` : `${targetRect.left + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect, directionUp)\n  };\n};\nvar positionRight = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n  const { directionLeft, directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    left: directionLeft ? `${targetRect.left + window.pageXOffset}px` : `${targetRect.right - popoverRect.width + window.pageXOffset}px`,\n    ...getTopPosition(targetRect, popoverRect, directionUp)\n  };\n};\nvar positionMatchWidth = (targetRect, popoverRect) => {\n  if (!targetRect || !popoverRect) {\n    return {};\n  }\n  const { directionUp } = getCollisions(targetRect, popoverRect);\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    ...getTopPosition(targetRect, popoverRect, directionUp)\n  };\n};\nfunction getCollisions(targetRect, popoverRect, offsetLeft = 0, offsetBottom = 0) {\n  const collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left + targetRect.width - popoverRect.width < 0\n  };\n  const directionRight = collisions.right && !collisions.left;\n  const directionLeft = collisions.left && !collisions.right;\n  const directionUp = collisions.bottom && !collisions.top;\n  const directionDown = collisions.top && !collisions.bottom;\n  return { directionRight, directionLeft, directionUp, directionDown };\n}\nfunction useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {\n  const ownerDocument = getOwnerDocument(triggerRef.current);\n  function handleKeyDown(event) {\n    if (event.key === \"Tab\" && popoverRef.current && tabbable(popoverRef.current).length === 0) {\n      return;\n    }\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover()) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover()) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover();\n      }\n    }\n  }\n  React.useEffect(() => {\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      ownerDocument.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, []);\n  function getElementAfterTrigger() {\n    const elements = tabbable(ownerDocument);\n    const targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;\n    const elementAfterTrigger = elements && elements[targetIndex + 1];\n    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;\n  }\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;\n  }\n  function focusFirstPopoverTabbable(event) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements && elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n  function tabbedOutOfPopover() {\n    const inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;\n    if (inPopover) {\n      const elements = popoverRef.current && tabbable(popoverRef.current);\n      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);\n    }\n    return false;\n  }\n  function focusTabbableAfterTrigger(event) {\n    const elementAfterTrigger = getElementAfterTrigger();\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n  function shiftTabbedFromElementAfterTrigger(event) {\n    if (!event.shiftKey)\n      return;\n    const elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n  function focusLastTabbableInPopover(event) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    const last = elements && elements[elements.length - 1];\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n  function shiftTabbedOutOfPopover(event) {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      return elements.length === 0 ? false : event.target === elements[0];\n    }\n    return false;\n  }\n  function focusTriggerRef(event) {\n    event.preventDefault();\n    triggerRef.current?.focus();\n  }\n  function tabbedToBrowserChrome(event) {\n    const elements = popoverRef.current ? tabbable(ownerDocument).filter((element) => !popoverRef.current.contains(element)) : null;\n    return elements ? event.target === elements[elements.length - 1] : false;\n  }\n  function shiftTabbedToBrowserChrome(event) {\n    return event.target === tabbable(ownerDocument)[0];\n  }\n  let restoreTabIndexTupl\\u00E9s = [];\n  function disableTabbablesInPopover() {\n    const elements = popoverRef.current && tabbable(popoverRef.current);\n    if (elements) {\n      elements.forEach((element) => {\n        restoreTabIndexTupl\\u00E9s.push([element, element.tabIndex]);\n        element.tabIndex = -1;\n      });\n      ownerDocument.addEventListener(\"focusin\", enableTabbablesInPopover);\n    }\n  }\n  function enableTabbablesInPopover() {\n    ownerDocument.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTupl\\u00E9s.forEach(([element, tabIndex]) => {\n      element.tabIndex = tabIndex;\n    });\n  }\n}\nexport {\n  Popover,\n  getCollisions,\n  positionDefault,\n  positionMatchWidth,\n  positionRight\n};\n", "\"use strict\";\n/**\n  * @reach/portal v0.18.0\n  *\n  * Copyright (c) 2018-2022, React Training LLC\n  *\n  * This source code is licensed under the MIT license found in the\n  * LICENSE.md file in the root directory of this source tree.\n  *\n  * @license MIT\n  */\n\n\n// src/reach-portal.tsx\nimport * as React from \"react\";\nimport {\n  useForceUpdate,\n  useIsomorphicLayoutEffect as useLayoutEffect\n} from \"@reach/utils\";\nimport { createPortal } from \"react-dom\";\nvar PortalImpl = ({\n  children,\n  type = \"reach-portal\",\n  containerRef\n}) => {\n  let mountNode = React.useRef(null);\n  let portalNode = React.useRef(null);\n  let forceUpdate = useForceUpdate();\n  if (true) {\n    React.useEffect(() => {\n      if (containerRef != null) {\n        if (typeof containerRef !== \"object\" || !(\"current\" in containerRef)) {\n          console.warn(\"@reach/portal: Invalid value passed to the `containerRef` of a `Portal`. The portal will be appended to the document body, but if you want to attach it to another DOM node you must pass a valid React ref object to `containerRef`.\");\n        } else if (containerRef.current == null) {\n          console.warn(\"@reach/portal: A ref was passed to the `containerRef` prop of a `Portal`, but no DOM node was attached to it. Be sure to pass the ref to a DOM component.\\n\\nIf you are forwarding the ref from another component, be sure to use the React.forwardRef API. See https://reactjs.org/docs/forwarding-refs.html.\");\n        }\n      }\n    }, [containerRef]);\n  }\n  useLayoutEffect(() => {\n    if (!mountNode.current)\n      return;\n    let ownerDocument = mountNode.current.ownerDocument;\n    let body = containerRef?.current || ownerDocument.body;\n    portalNode.current = ownerDocument?.createElement(type);\n    body.appendChild(portalNode.current);\n    forceUpdate();\n    return () => {\n      if (portalNode.current && body) {\n        body.removeChild(portalNode.current);\n      }\n    };\n  }, [type, forceUpdate, containerRef]);\n  return portalNode.current ? createPortal(children, portalNode.current) : /* @__PURE__ */ React.createElement(\"span\", {\n    ref: mountNode\n  });\n};\nvar Portal = ({\n  unstable_skipInitialRender,\n  ...props\n}) => {\n  let [hydrated, setHydrated] = React.useState(false);\n  React.useEffect(() => {\n    if (unstable_skipInitialRender) {\n      setHydrated(true);\n    }\n  }, [unstable_skipInitialRender]);\n  if (unstable_skipInitialRender && !hydrated) {\n    return null;\n  }\n  return /* @__PURE__ */ React.createElement(PortalImpl, {\n    ...props\n  });\n};\nPortal.displayName = \"Portal\";\nexport {\n  Portal\n};\n", "\"use strict\";\n/**\n  * @reach/rect v0.18.0\n  *\n  * Copyright (c) 2018-2022, React Training LLC\n  *\n  * This source code is licensed under the MIT license found in the\n  * LICENSE.md file in the root directory of this source tree.\n  *\n  * @license MIT\n  */\n\n\n// src/reach-rect.tsx\nimport * as React from \"react\";\nimport observeRect from \"@reach/observe-rect\";\nimport {\n  useIsomorphicLayoutEffect as useLayoutEffect,\n  isBoolean,\n  isFunction\n} from \"@reach/utils\";\nvar Rect = ({ onChange, observe = true, children }) => {\n  const ref = React.useRef(null);\n  const rect = useRect(ref, { observe, onChange });\n  return children({ ref, rect });\n};\nRect.displayName = \"Rect\";\nfunction useRect(nodeRef, observeOrOptions, deprecated_onChange) {\n  let observe;\n  let onChange;\n  if (isBoolean(observeOrOptions)) {\n    observe = observeOrOptions;\n  } else {\n    observe = observeOrOptions?.observe ?? true;\n    onChange = observeOrOptions?.onChange;\n  }\n  if (isFunction(deprecated_onChange)) {\n    onChange = deprecated_onChange;\n  }\n  if (true) {\n    React.useEffect(() => {\n      if (isBoolean(observeOrOptions)) {\n        console.warn(\"Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\\nSee https://reach.tech/rect#userect-observe\");\n      }\n    }, [observeOrOptions]);\n    React.useEffect(() => {\n      if (isFunction(deprecated_onChange)) {\n        console.warn(\"Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\\nSee https://reach.tech/rect#userect-onchange\");\n      }\n    }, [deprecated_onChange]);\n  }\n  let [element, setElement] = React.useState(nodeRef.current);\n  let initialRectIsSet = React.useRef(false);\n  let initialRefIsSet = React.useRef(false);\n  let [rect, setRect] = React.useState(null);\n  let onChangeRef = React.useRef(onChange);\n  useLayoutEffect(() => {\n    onChangeRef.current = onChange;\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useLayoutEffect(() => {\n    if (element && !initialRectIsSet.current) {\n      initialRectIsSet.current = true;\n      setRect(element.getBoundingClientRect());\n    }\n  }, [element]);\n  useLayoutEffect(() => {\n    if (!observe) {\n      return;\n    }\n    let elem = element;\n    if (!initialRefIsSet.current) {\n      initialRefIsSet.current = true;\n      elem = nodeRef.current;\n    }\n    if (!elem) {\n      if (true) {\n        console.warn(\"You need to place the ref\");\n      }\n      return;\n    }\n    let observer = observeRect(elem, (rect2) => {\n      onChangeRef.current?.(rect2);\n      setRect(rect2);\n    });\n    observer.observe();\n    return () => {\n      observer.unobserve();\n    };\n  }, [observe, element, nodeRef]);\n  return rect;\n}\nexport {\n  Rect,\n  useRect\n};\n", "let props: (keyof DOMRect)[] = [\n\t\"bottom\",\n\t\"height\",\n\t\"left\",\n\t\"right\",\n\t\"top\",\n\t\"width\",\n];\n\nlet rectChanged = (a: DOMRect = {} as DOMRect, b: DOMRect = {} as DOMRect) =>\n\tprops.some((prop) => a[prop] !== b[prop]);\n\nlet observedNodes = new Map<Element, RectProps>();\nlet rafId: number;\n\nlet run = () => {\n\tconst changedStates: RectProps[] = [];\n\tobservedNodes.forEach((state, node) => {\n\t\tlet newRect = node.getBoundingClientRect();\n\t\tif (rectChanged(newRect, state.rect)) {\n\t\t\tstate.rect = newRect;\n\t\t\tchangedStates.push(state);\n\t\t}\n\t});\n\n\tchangedStates.forEach((state) => {\n\t\tstate.callbacks.forEach((cb) => cb(state.rect));\n\t});\n\n\trafId = window.requestAnimationFrame(run);\n};\n\nexport default function observeRect(\n\tnode: Element,\n\tcb: (rect: DOMRect) => void\n) {\n\treturn {\n\t\tobserve() {\n\t\t\tlet wasEmpty = observedNodes.size === 0;\n\t\t\tif (observedNodes.has(node)) {\n\t\t\t\tobservedNodes.get(node)!.callbacks.push(cb);\n\t\t\t} else {\n\t\t\t\tobservedNodes.set(node, {\n\t\t\t\t\trect: undefined,\n\t\t\t\t\thasRectChanged: false,\n\t\t\t\t\tcallbacks: [cb],\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (wasEmpty) run();\n\t\t},\n\n\t\tunobserve() {\n\t\t\tlet state = observedNodes.get(node);\n\t\t\tif (state) {\n\t\t\t\t// Remove the callback\n\t\t\t\tconst index = state.callbacks.indexOf(cb);\n\t\t\t\tif (index >= 0) state.callbacks.splice(index, 1);\n\n\t\t\t\t// Remove the node reference\n\t\t\t\tif (!state.callbacks.length) observedNodes.delete(node);\n\n\t\t\t\t// Stop the loop\n\t\t\t\tif (!observedNodes.size) cancelAnimationFrame(rafId);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport type PartialRect = Partial<DOMRect>;\n\nexport type RectProps = {\n\trect: DOMRect | undefined;\n\thasRectChanged: boolean;\n\tcallbacks: Function[];\n};\n", "const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]:not(slot)',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element.getRootNode()\n    : (element) => element.ownerDocument;\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      const validShadowRoot =\n        !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\nconst getTabindex = function (node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if (\n      (isScope ||\n        /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        node.isContentEditable) &&\n      isNaN(parseInt(node.getAttribute('tabindex'), 10))\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  const nodeRootHost = getRootNode(node).host;\n  const nodeIsAttached =\n    nodeRootHost?.ownerDocument.contains(nodeRootHost) ||\n    node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck` mode\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scope;\n    const element = isScope ? item.scope : item;\n    const candidateTabindex = getTabindex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n"],
  "mappings": "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",
  "names": ["import_dist", "React", "import_dist", "React", "import_dist", "props", "import_dist", "React", "import_dist", "props", "rectChanged", "a", "b", "some", "prop", "observedNodes", "Map", "rafId", "run", "changedStates", "forEach", "state", "node", "newRect", "getBoundingClientRect", "rect", "push", "callbacks", "cb", "window", "requestAnimationFrame", "observeRect", "observe", "wasEmpty", "size", "has", "get", "set", "undefined", "hasRectChanged", "unobserve", "index", "indexOf", "splice", "length", "cancelAnimationFrame", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "ownerDocument", "getCandidates", "el", "includeContainer", "filter", "candidates", "Array", "slice", "apply", "querySelectorAll", "call", "unshift", "getCandidatesIteratively", "elements", "options", "elementsToCheck", "from", "length", "shift", "tagName", "assigned", "assignedElements", "content", "children", "nestedCandidates", "flatten", "push", "scope", "validCandidate", "includes", "shadowRoot", "getShadowRoot", "validShadowRoot", "shadowRootFilter", "getTabindex", "node", "isScope", "tabIndex", "test", "isContentEditable", "isNaN", "parseInt", "getAttribute", "sortOrderedTabbables", "a", "b", "documentOrder", "isInput", "isHiddenInput", "type", "isDetailsWithSummary", "r", "some", "child", "getCheckedRadio", "nodes", "form", "i", "checked", "isTabbableRadio", "name", "radioScope", "queryRadios", "radioSet", "window", "CSS", "escape", "err", "console", "error", "message", "isRadio", "isNonTabbableRadio", "isZeroArea", "getBoundingClientRect", "width", "height", "isHidden", "displayCheck", "getComputedStyle", "visibility", "isDirectSummary", "nodeUnderDetails", "parentElement", "nodeRootHost", "host", "nodeIsAttached", "contains", "originalNode", "rootNode", "assignedSlot", "getClientRects", "isDisabledFromFieldset", "parentNode", "disabled", "item", "isNodeMatchingSelectorFocusable", "isNodeMatchingSelectorTabbable", "isValidShadowRootTabbable", "shadowHostNode", "sortByOrder", "regularTabbables", "orderedTabbables", "forEach", "candidateTabindex", "sort", "reduce", "acc", "sortable", "concat", "tabbable", "bind", "focusableCandidateSelector", "candidateSelectors", "concat", "join", "props", "props"]
}

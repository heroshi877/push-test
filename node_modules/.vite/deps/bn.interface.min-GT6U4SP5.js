import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  bn_min_default
} from "./chunk-TRCH6JH3.js";
import "./chunk-ZB5RANMR.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/openpgp/dist/lightweight/bn.interface.min.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var t = class _t {
  constructor(t2) {
    if (void 0 === t2) throw Error("Invalid BigInteger input");
    this.value = new bn_min_default(t2);
  }
  clone() {
    const e = new _t(null);
    return this.value.copy(e.value), e;
  }
  iinc() {
    return this.value.iadd(new bn_min_default(1)), this;
  }
  inc() {
    return this.clone().iinc();
  }
  idec() {
    return this.value.isub(new bn_min_default(1)), this;
  }
  dec() {
    return this.clone().idec();
  }
  iadd(e) {
    return this.value.iadd(e.value), this;
  }
  add(e) {
    return this.clone().iadd(e);
  }
  isub(e) {
    return this.value.isub(e.value), this;
  }
  sub(e) {
    return this.clone().isub(e);
  }
  imul(e) {
    return this.value.imul(e.value), this;
  }
  mul(e) {
    return this.clone().imul(e);
  }
  imod(e) {
    return this.value = this.value.umod(e.value), this;
  }
  mod(e) {
    return this.clone().imod(e);
  }
  modExp(t2, i) {
    const r = i.isEven() ? bn_min_default.red(i.value) : bn_min_default.mont(i.value), u = this.clone();
    return u.value = u.value.toRed(r).redPow(t2.value).fromRed(), u;
  }
  modInv(e) {
    if (!this.gcd(e).isOne()) throw Error("Inverse does not exist");
    return new _t(this.value.invm(e.value));
  }
  gcd(e) {
    return new _t(this.value.gcd(e.value));
  }
  ileftShift(e) {
    return this.value.ishln(e.value.toNumber()), this;
  }
  leftShift(e) {
    return this.clone().ileftShift(e);
  }
  irightShift(e) {
    return this.value.ishrn(e.value.toNumber()), this;
  }
  rightShift(e) {
    return this.clone().irightShift(e);
  }
  equal(e) {
    return this.value.eq(e.value);
  }
  lt(e) {
    return this.value.lt(e.value);
  }
  lte(e) {
    return this.value.lte(e.value);
  }
  gt(e) {
    return this.value.gt(e.value);
  }
  gte(e) {
    return this.value.gte(e.value);
  }
  isZero() {
    return this.value.isZero();
  }
  isOne() {
    return this.value.eq(new bn_min_default(1));
  }
  isNegative() {
    return this.value.isNeg();
  }
  isEven() {
    return this.value.isEven();
  }
  abs() {
    const e = this.clone();
    return e.value = e.value.abs(), e;
  }
  toString() {
    return this.value.toString();
  }
  toNumber() {
    return this.value.toNumber();
  }
  getBit(e) {
    return this.value.testn(e) ? 1 : 0;
  }
  bitLength() {
    return this.value.bitLength();
  }
  byteLength() {
    return this.value.byteLength();
  }
  toUint8Array(e = "be", t2) {
    return this.value.toArrayLike(Uint8Array, e, t2);
  }
};
var bn_interface_min_default = t;
export {
  bn_interface_min_default as default
};
/*! Bundled license information:

openpgp/dist/lightweight/bn.interface.min.mjs:
  (*! OpenPGP.js v5.11.2 - 2024-06-19 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. *)
*/
//# sourceMappingURL=bn.interface.min-GT6U4SP5.js.map

{
  "version": 3,
  "sources": ["../../openpgp/node_modules/@openpgp/web-stream-tools/node_modules/web-streams-polyfill/dist/ponyfill.es6.mjs"],
  "sourcesContent": ["/**\n * web-streams-polyfill v3.0.3\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nlet AsyncIteratorPrototype;\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.\n    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.\n    AsyncIteratorPrototype = {\n        // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\n        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator\n        [SymbolPolyfill.asyncIterator]() {\n            return this;\n        }\n    };\n    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction IsFiniteNonNegativeNumber(v) {\n    if (!IsNonNegativeNumber(v)) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (view.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (view.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === null && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (!IsFiniteNonNegativeNumber(bytesWritten)) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writer’s lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writer’s lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: value => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    reading = false;\n                    const value1 = value;\n                    const value2 = value;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\nconst byteLengthSizeFunction = function size(chunk) {\n    return chunk.byteLength;\n};\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nconst countSizeFunction = function size() {\n    return 1;\n};\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es6.mjs.map\n"],
  "mappings": "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",
  "names": ["SymbolPolyfill", "Symbol", "iterator", "description", "noop", "globals", "self", "window", "global", "typeIsObject", "x", "rethrowAssertionErrorRejection", "originalPromise", "Promise", "originalPromiseThen", "prototype", "then", "originalPromiseResolve", "resolve", "bind", "originalPromiseReject", "reject", "newPromise", "executor", "promiseResolvedWith", "value", "promiseRejectedWith", "reason", "PerformPromiseThen", "promise", "onFulfilled", "onRejected", "call", "uponPromise", "uponFulfillment", "uponRejection", "transformPromiseWith", "fulfillmentHandler", "rejectionHandler", "setPromiseIsHandledToTrue", "queueMicrotask", "globalQueueMicrotask", "resolvedPromise", "undefined", "fn", "reflectCall", "F", "V", "args", "TypeError", "Function", "apply", "promiseCall", "SimpleQueue", "constructor", "this", "_cursor", "_size", "_front", "_elements", "_next", "_back", "length", "push", "element", "oldBack", "newBack", "QUEUE_MAX_ARRAY_SIZE", "shift", "oldFront", "newFront", "oldCursor", "newCursor", "elements", "forEach", "callback", "i", "node", "peek", "front", "cursor", "ReadableStreamReaderGenericInitialize", "reader", "stream", "_ownerReadableStream", "_reader", "_state", "defaultReaderClosedPromiseInitialize", "defaultReaderClosedPromiseResolve", "defaultReaderClosedPromiseInitializeAsRejected", "_storedError", "ReadableStreamReaderGenericCancel", "ReadableStreamCancel", "ReadableStreamReaderGenericRelease", "defaultReaderClosedPromiseReject", "readerLockException", "name", "_closedPromise", "_closedPromise_resolve", "_closedPromise_reject", "AbortSteps", "ErrorSteps", "CancelSteps", "PullSteps", "NumberIsFinite", "Number", "isFinite", "MathTrunc", "Math", "trunc", "v", "ceil", "floor", "assertDictionary", "obj", "context", "assertFunction", "assertObject", "assertRequiredArgument", "position", "assertRequiredField", "field", "convertUnrestrictedDouble", "censorNegativeZero", "convertUnsignedLongLongWithEnforceRange", "upperBound", "MAX_SAFE_INTEGER", "assertReadableStream", "IsReadableStream", "AcquireReadableStreamDefaultReader", "ReadableStreamDefaultReader", "ReadableStreamAddReadRequest", "readRequest", "_readRequests", "ReadableStreamFulfillReadRequest", "chunk", "done", "_closeSteps", "_chunkSteps", "ReadableStreamGetNumReadRequests", "ReadableStreamHasDefaultReader", "IsReadableStreamDefaultReader", "IsReadableStreamLocked", "closed", "defaultReaderBrandCheckException", "cancel", "read", "resolvePromise", "rejectPromise", "ReadableStreamDefaultReaderRead", "_errorSteps", "e", "releaseLock", "Object", "hasOwnProperty", "_disturbed", "_readableStreamController", "AsyncIteratorPrototype", "defineProperties", "enumerable", "toStringTag", "defineProperty", "configurable", "asyncIterator", "ReadableStreamAsyncIteratorImpl", "preventCancel", "_ongoingPromise", "_isFinished", "_preventCancel", "next", "nextSteps", "_nextSteps", "return", "returnSteps", "_returnSteps", "result", "ReadableStreamAsyncIteratorPrototype", "IsReadableStreamAsyncIterator", "_asyncIteratorImpl", "streamAsyncIteratorBrandCheckException", "setPrototypeOf", "NumberIsNaN", "isNaN", "IsFiniteNonNegativeNumber", "Infinity", "DequeueValue", "container", "pair", "_queue", "_queueTotalSize", "size", "EnqueueValueWithSize", "RangeError", "ResetQueue", "CreateArrayFromList", "slice", "ReadableStreamBYOBRequest", "view", "IsReadableStreamBYOBRequest", "byobRequestBrandCheckException", "_view", "respond", "bytesWritten", "_associatedReadableByteStreamController", "buffer", "controller", "ReadableByteStreamControllerRespondInternal", "respondWithNewView", "ArrayBuffer", "isView", "byteLength", "firstDescriptor", "_pendingPullIntos", "byteOffset", "bytesFilled", "ReadableByteStreamController", "byobRequest", "IsReadableByteStreamController", "byteStreamControllerBrandCheckException", "_byobRequest", "Uint8Array", "create", "request", "desiredSize", "ReadableByteStreamControllerGetDesiredSize", "close", "_closeRequested", "state", "_controlledReadableByteStream", "ReadableByteStreamControllerError", "ReadableByteStreamControllerClearAlgorithms", "ReadableStreamClose", "enqueue", "transferredBuffer", "ReadableByteStreamControllerEnqueueChunkToQueue", "ReadableStreamHasBYOBReader", "ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue", "ReadableByteStreamControllerCallPullIfNeeded", "error", "_cancelAlgorithm", "entry", "ReadableByteStreamControllerHandleQueueDrain", "autoAllocateChunkSize", "_autoAllocateChunkSize", "bufferE", "pullIntoDescriptor", "elementSize", "viewConstructor", "readerType", "shouldPull", "_started", "ReadableStreamGetNumReadIntoRequests", "_pulling", "_pullAgain", "_pullAlgorithm", "ReadableByteStreamControllerCommitPullIntoDescriptor", "filledView", "ReadableByteStreamControllerConvertPullIntoDescriptor", "readIntoRequest", "_readIntoRequests", "ReadableByteStreamControllerFillPullIntoDescriptorFromQueue", "currentAlignedBytes", "maxBytesToCopy", "min", "maxBytesFilled", "maxAlignedBytes", "totalBytesToCopyRemaining", "ready", "queue", "headOfQueue", "bytesToCopy", "destStart", "dest", "destOffset", "src", "srcOffset", "n", "set", "ReadableByteStreamControllerFillHeadPullIntoDescriptor", "ReadableByteStreamControllerInvalidateBYOBRequest", "ReadableByteStreamControllerShiftPendingPullInto", "remainderSize", "end", "remainder", "descriptor", "ReadableStreamError", "_strategyHWM", "SetUpReadableByteStreamControllerFromUnderlyingSource", "underlyingByteSource", "highWaterMark", "startAlgorithm", "pullAlgorithm", "cancelAlgorithm", "start", "pull", "r", "ReadableStreamAddReadIntoRequest", "IsReadableStreamBYOBReader", "ReadableStreamBYOBReader", "byobReaderBrandCheckException", "DataView", "BYTES_PER_ELEMENT", "ctor", "emptyView", "ExtractHighWaterMark", "strategy", "defaultHWM", "ExtractSizeAlgorithm", "convertQueuingStrategy", "init", "convertQueuingStrategySize", "convertUnderlyingSinkAbortCallback", "original", "convertUnderlyingSinkCloseCallback", "convertUnderlyingSinkStartCallback", "convertUnderlyingSinkWriteCallback", "assertWritableStream", "IsWritableStream", "WritableStream", "rawUnderlyingSink", "rawStrategy", "underlyingSink", "abort", "type", "write", "InitializeWritableStream", "sizeAlgorithm", "WritableStreamDefaultController", "writeAlgorithm", "closeAlgorithm", "abortAlgorithm", "SetUpWritableStreamDefaultController", "locked", "streamBrandCheckException$2", "IsWritableStreamLocked", "WritableStreamAbort", "WritableStreamCloseQueuedOrInFlight", "WritableStreamClose", "getWriter", "AcquireWritableStreamDefaultWriter", "WritableStreamDefaultWriter", "_writer", "_writableStreamController", "_writeRequests", "_inFlightWriteRequest", "_closeRequest", "_inFlightCloseRequest", "_pendingAbortRequest", "_backpressure", "_promise", "wasAlreadyErroring", "_resolve", "_reject", "_reason", "_wasAlreadyErroring", "WritableStreamStartErroring", "closeRequest", "writer", "defaultWriterReadyPromiseResolve", "closeSentinel", "WritableStreamDefaultControllerAdvanceQueueIfNeeded", "WritableStreamDealWithRejection", "WritableStreamFinishErroring", "WritableStreamDefaultWriterEnsureReadyPromiseRejected", "storedError", "writeRequest", "WritableStreamRejectCloseAndClosedPromiseIfNeeded", "abortRequest", "defaultWriterClosedPromiseReject", "WritableStreamUpdateBackpressure", "backpressure", "defaultWriterReadyPromiseInitialize", "_ownerWritableStream", "defaultWriterReadyPromiseInitializeAsResolved", "defaultWriterClosedPromiseInitialize", "defaultWriterReadyPromiseInitializeAsRejected", "defaultWriterClosedPromiseResolve", "defaultWriterClosedPromiseInitializeAsRejected", "IsWritableStreamDefaultWriter", "defaultWriterBrandCheckException", "defaultWriterLockException", "WritableStreamDefaultControllerGetDesiredSize", "_readyPromise", "WritableStreamDefaultWriterClose", "WritableStreamDefaultWriterRelease", "WritableStreamDefaultWriterWrite", "WritableStreamDefaultWriterEnsureClosedPromiseRejected", "_closedPromiseState", "_readyPromiseState", "defaultWriterReadyPromiseReject", "releasedError", "chunkSize", "_strategySizeAlgorithm", "chunkSizeE", "WritableStreamDefaultControllerErrorIfNeeded", "enqueueE", "_controlledWritableStream", "WritableStreamDefaultControllerGetBackpressure", "WritableStreamDefaultControllerError", "_abortAlgorithm", "WritableStreamDefaultControllerClearAlgorithms", "_writeAlgorithm", "_closeAlgorithm", "sinkClosePromise", "sinkWritePromise", "_readyPromise_resolve", "_readyPromise_reject", "NativeDOMException", "DOMException", "DOMException$1", "_a", "message", "Error", "captureStackTrace", "writable", "createDOMExceptionPolyfill", "ReadableStreamPipeTo", "source", "preventClose", "preventAbort", "signal", "shuttingDown", "currentWrite", "actions", "shutdownWithAction", "all", "map", "action", "aborted", "addEventListener", "isOrBecomesErrored", "shutdown", "destClosed", "waitForWritesToFinish", "oldCurrentWrite", "originalIsError", "originalError", "doTheRest", "finalize", "newError", "isError", "removeEventListener", "resolveLoop", "rejectLoop", "resolveRead", "rejectRead", "ReadableStreamDefaultController", "IsReadableStreamDefaultController", "defaultControllerBrandCheckException$1", "ReadableStreamDefaultControllerGetDesiredSize", "ReadableStreamDefaultControllerCanCloseOrEnqueue", "ReadableStreamDefaultControllerClose", "ReadableStreamDefaultControllerEnqueue", "ReadableStreamDefaultControllerError", "ReadableStreamDefaultControllerClearAlgorithms", "_controlledReadableStream", "ReadableStreamDefaultControllerCallPullIfNeeded", "ReadableStreamDefaultControllerShouldCallPull", "SetUpReadableStreamDefaultController", "convertUnderlyingSourceCancelCallback", "convertUnderlyingSourcePullCallback", "convertUnderlyingSourceStartCallback", "convertReadableStreamType", "convertReadableStreamReaderMode", "mode", "convertPipeOptions", "options", "ReadableStream", "rawUnderlyingSource", "underlyingSource", "InitializeReadableStream", "streamBrandCheckException$1", "getReader", "rawOptions", "pipeThrough", "rawTransform", "transform", "readable", "pipeTo", "destination", "tee", "branches", "cloneForBranch2", "reason1", "reason2", "branch1", "branch2", "resolveCancelPromise", "reading", "canceled1", "canceled2", "cancelPromise", "value1", "value2", "CreateReadableStream", "compositeReason", "cancelResult", "values", "impl", "convertQueuingStrategyInit", "byteLengthSizeFunction", "ByteLengthQueuingStrategy", "_byteLengthQueuingStrategyHighWaterMark", "IsByteLengthQueuingStrategy", "byteLengthBrandCheckException", "countSizeFunction", "CountQueuingStrategy", "_countQueuingStrategyHighWaterMark", "IsCountQueuingStrategy", "countBrandCheckException", "convertTransformerFlushCallback", "convertTransformerStartCallback", "convertTransformerTransformCallback", "TransformStream", "rawTransformer", "rawWritableStrategy", "rawReadableStrategy", "writableStrategy", "readableStrategy", "transformer", "flush", "readableType", "writableType", "readableHighWaterMark", "readableSizeAlgorithm", "writableHighWaterMark", "writableSizeAlgorithm", "startPromise_resolve", "startPromise", "_transformStreamController", "_backpressureChangePromise", "_writable", "TransformStreamDefaultControllerPerformTransform", "TransformStreamError", "_readable", "flushPromise", "_flushAlgorithm", "TransformStreamDefaultControllerClearAlgorithms", "TransformStreamSetBackpressure", "TransformStreamErrorWritableAndUnblockWrite", "_backpressureChangePromise_resolve", "TransformStreamDefaultController", "transformAlgorithm", "TransformStreamDefaultControllerEnqueue", "transformResultE", "flushAlgorithm", "_controlledTransformStream", "_transformAlgorithm", "IsTransformStream", "streamBrandCheckException", "IsTransformStreamDefaultController", "defaultControllerBrandCheckException", "terminate", "readableController"]
}

import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/openpgp/dist/lightweight/ponyfill.es6.min.mjs
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : (e2) => `Symbol(${e2})`;
function t() {
}
var r = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0;
function o(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
var n = t;
var i = Promise;
var a = Promise.prototype.then;
var s = Promise.resolve.bind(i);
var l = Promise.reject.bind(i);
function u(e2) {
  return new i(e2);
}
function c(e2) {
  return s(e2);
}
function d(e2) {
  return l(e2);
}
function f(e2, t2, r2) {
  return a.call(e2, t2, r2);
}
function h(e2, t2, r2) {
  f(f(e2, t2, r2), void 0, n);
}
function _(e2, t2) {
  h(e2, t2);
}
function b(e2, t2) {
  h(e2, void 0, t2);
}
function p(e2, t2, r2) {
  return f(e2, t2, r2);
}
function m(e2) {
  f(e2, void 0, n);
}
var y = (() => {
  const e2 = r && r.queueMicrotask;
  if ("function" == typeof e2) return e2;
  const t2 = c(void 0);
  return (e3) => f(t2, e3);
})();
function g(e2, t2, r2) {
  if ("function" != typeof e2) throw new TypeError("Argument is not a function");
  return Function.prototype.apply.call(e2, t2, r2);
}
function w(e2, t2, r2) {
  try {
    return c(g(e2, t2, r2));
  } catch (e3) {
    return d(e3);
  }
}
var v = class {
  constructor() {
    this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(e2) {
    const t2 = this._back;
    let r2 = t2;
    16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
  }
  shift() {
    const e2 = this._front;
    let t2 = e2;
    const r2 = this._cursor;
    let o2 = r2 + 1;
    const n2 = e2._elements, i2 = n2[r2];
    return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, i2;
  }
  forEach(e2) {
    let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
    for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); ) e2(o2[t2]), ++t2;
  }
  peek() {
    const e2 = this._front, t2 = this._cursor;
    return e2._elements[t2];
  }
};
function S(e2, t2) {
  e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? q(e2) : "closed" === t2._state ? function(e3) {
    q(e3), k(e3);
  }(e2) : E(e2, t2._storedError);
}
function R(e2, t2) {
  return ar(e2._ownerReadableStream, t2);
}
function T(e2) {
  "readable" === e2._ownerReadableStream._state ? C(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t2) {
    E(e3, t2);
  }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e2._ownerReadableStream._reader = void 0, e2._ownerReadableStream = void 0;
}
function P(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released reader");
}
function q(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
  });
}
function E(e2, t2) {
  q(e2), C(e2, t2);
}
function C(e2, t2) {
  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
function k(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
}
var O = e("[[AbortSteps]]");
var j = e("[[ErrorSteps]]");
var W = e("[[CancelSteps]]");
var A = e("[[PullSteps]]");
var z = Number.isFinite || function(e2) {
  return "number" == typeof e2 && isFinite(e2);
};
var F = Math.trunc || function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
};
function B(e2, t2) {
  if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2)) throw new TypeError(t2 + " is not an object.");
  var r2;
}
function I(e2, t2) {
  if ("function" != typeof e2) throw new TypeError(t2 + " is not a function.");
}
function L(e2, t2) {
  if (!/* @__PURE__ */ function(e3) {
    return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
  }(e2)) throw new TypeError(t2 + " is not an object.");
}
function M(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
}
function $(e2, t2, r2) {
  if (void 0 === e2) throw new TypeError(`${t2} is required in '${r2}'.`);
}
function D(e2) {
  return Number(e2);
}
function x(e2) {
  return 0 === e2 ? 0 : e2;
}
function N(e2, t2) {
  const r2 = Number.MAX_SAFE_INTEGER;
  let o2 = Number(e2);
  if (o2 = x(o2), !z(o2)) throw new TypeError(t2 + " is not a finite number");
  if (o2 = function(e3) {
    return x(F(e3));
  }(o2), o2 < 0 || o2 > r2) throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
  return z(o2) && 0 !== o2 ? o2 : 0;
}
function Q(e2, t2) {
  if (!nr(e2)) throw new TypeError(t2 + " is not a ReadableStream.");
}
function H(e2) {
  return new X(e2);
}
function Y(e2, t2) {
  e2._reader._readRequests.push(t2);
}
function V(e2, t2, r2) {
  const o2 = e2._reader._readRequests.shift();
  r2 ? o2._closeSteps() : o2._chunkSteps(t2);
}
function U(e2) {
  return e2._reader._readRequests.length;
}
function G(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!J(t2);
}
var X = class {
  constructor(e2) {
    if (M(e2, 1, "ReadableStreamDefaultReader"), Q(e2, "First parameter"), ir(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    S(this, e2), this._readRequests = new v();
  }
  get closed() {
    return J(this) ? this._closedPromise : d(Z("closed"));
  }
  cancel(e2 = void 0) {
    return J(this) ? void 0 === this._ownerReadableStream ? d(P("cancel")) : R(this, e2) : d(Z("cancel"));
  }
  read() {
    if (!J(this)) return d(Z("read"));
    if (void 0 === this._ownerReadableStream) return d(P("read from"));
    let e2, t2;
    const r2 = u((r3, o2) => {
      e2 = r3, t2 = o2;
    });
    return K(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
  }
  releaseLock() {
    if (!J(this)) throw Z("releaseLock");
    if (void 0 !== this._ownerReadableStream) {
      if (this._readRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
      T(this);
    }
  }
};
function J(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readRequests");
}
function K(e2, t2) {
  const r2 = e2._ownerReadableStream;
  r2._disturbed = true, "closed" === r2._state ? t2._closeSteps() : "errored" === r2._state ? t2._errorSteps(r2._storedError) : r2._readableStreamController[A](t2);
}
function Z(e2) {
  return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
}
var ee;
Object.defineProperties(X.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(X.prototype, e.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true }), "symbol" == typeof e.asyncIterator && (ee = { [e.asyncIterator]() {
  return this;
} }, Object.defineProperty(ee, e.asyncIterator, { enumerable: false }));
var te = class {
  constructor(e2, t2) {
    this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
  }
  next() {
    const e2 = () => this._nextSteps();
    return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
  }
  return(e2) {
    const t2 = () => this._returnSteps(e2);
    return this._ongoingPromise ? p(this._ongoingPromise, t2, t2) : t2();
  }
  _nextSteps() {
    if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
    const e2 = this._reader;
    if (void 0 === e2._ownerReadableStream) return d(P("iterate"));
    let t2, r2;
    const o2 = u((e3, o3) => {
      t2 = e3, r2 = o3;
    });
    return K(e2, { _chunkSteps: (e3) => {
      this._ongoingPromise = void 0, y(() => t2({ value: e3, done: false }));
    }, _closeSteps: () => {
      this._ongoingPromise = void 0, this._isFinished = true, T(e2), t2({ value: void 0, done: true });
    }, _errorSteps: (t3) => {
      this._ongoingPromise = void 0, this._isFinished = true, T(e2), r2(t3);
    } }), o2;
  }
  _returnSteps(e2) {
    if (this._isFinished) return Promise.resolve({ value: e2, done: true });
    this._isFinished = true;
    const t2 = this._reader;
    if (void 0 === t2._ownerReadableStream) return d(P("finish iterating"));
    if (!this._preventCancel) {
      const r2 = R(t2, e2);
      return T(t2), p(r2, () => ({ value: e2, done: true }));
    }
    return T(t2), c({ value: e2, done: true });
  }
};
var re = { next() {
  return oe(this) ? this._asyncIteratorImpl.next() : d(ne("next"));
}, return(e2) {
  return oe(this) ? this._asyncIteratorImpl.return(e2) : d(ne("return"));
} };
function oe(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl");
}
function ne(e2) {
  return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
}
void 0 !== ee && Object.setPrototypeOf(re, ee);
var ie = Number.isNaN || function(e2) {
  return e2 != e2;
};
function ae(e2) {
  return !!function(e3) {
    if ("number" != typeof e3) return false;
    if (ie(e3)) return false;
    if (e3 < 0) return false;
    return true;
  }(e2) && e2 !== 1 / 0;
}
function se(e2) {
  const t2 = e2._queue.shift();
  return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
}
function le(e2, t2, r2) {
  if (!ae(r2 = Number(r2))) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
  e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
}
function ue(e2) {
  e2._queue = new v(), e2._queueTotalSize = 0;
}
function ce(e2) {
  return e2.slice();
}
var de = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get view() {
    if (!_e(this)) throw Oe("view");
    return this._view;
  }
  respond(e2) {
    if (!_e(this)) throw Oe("respond");
    if (M(e2, 1, "respond"), e2 = N(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
    this._view.buffer, function(e3, t2) {
      if (t2 = Number(t2), !ae(t2)) throw new RangeError("bytesWritten must be a finite");
      Te(e3, t2);
    }(this._associatedReadableByteStreamController, e2);
  }
  respondWithNewView(e2) {
    if (!_e(this)) throw Oe("respondWithNewView");
    if (M(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2)) throw new TypeError("You can only respond with array buffer views");
    if (0 === e2.byteLength) throw new TypeError("chunk must have non-zero byteLength");
    if (0 === e2.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
    if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
    !function(e3, t2) {
      const r2 = e3._pendingPullIntos.peek();
      if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
      if (r2.byteLength !== t2.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
      r2.buffer = t2.buffer, Te(e3, t2.byteLength);
    }(this._associatedReadableByteStreamController, e2);
  }
};
Object.defineProperties(de.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(de.prototype, e.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
var fe = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get byobRequest() {
    if (!he(this)) throw je("byobRequest");
    if (null === this._byobRequest && this._pendingPullIntos.length > 0) {
      const e2 = this._pendingPullIntos.peek(), t2 = new Uint8Array(e2.buffer, e2.byteOffset + e2.bytesFilled, e2.byteLength - e2.bytesFilled), r2 = Object.create(de.prototype);
      !function(e3, t3, r3) {
        e3._associatedReadableByteStreamController = t3, e3._view = r3;
      }(r2, this, t2), this._byobRequest = r2;
    }
    return this._byobRequest;
  }
  get desiredSize() {
    if (!he(this)) throw je("desiredSize");
    return Ce(this);
  }
  close() {
    if (!he(this)) throw je("close");
    if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
    const e2 = this._controlledReadableByteStream._state;
    if ("readable" !== e2) throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
    !function(e3) {
      const t2 = e3._controlledReadableByteStream;
      if (e3._closeRequested || "readable" !== t2._state) return;
      if (e3._queueTotalSize > 0) return void (e3._closeRequested = true);
      if (e3._pendingPullIntos.length > 0) {
        if (e3._pendingPullIntos.peek().bytesFilled > 0) {
          const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
          throw Ee(e3, t3), t3;
        }
      }
      qe(e3), sr(t2);
    }(this);
  }
  enqueue(e2) {
    if (!he(this)) throw je("enqueue");
    if (M(e2, 1, "enqueue"), !ArrayBuffer.isView(e2)) throw new TypeError("chunk must be an array buffer view");
    if (0 === e2.byteLength) throw new TypeError("chunk must have non-zero byteLength");
    if (0 === e2.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
    if (this._closeRequested) throw new TypeError("stream is closed or draining");
    const t2 = this._controlledReadableByteStream._state;
    if ("readable" !== t2) throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
    !function(e3, t3) {
      const r2 = e3._controlledReadableByteStream;
      if (e3._closeRequested || "readable" !== r2._state) return;
      const o2 = t3.buffer, n2 = t3.byteOffset, i2 = t3.byteLength, a2 = o2;
      if (G(r2)) if (0 === U(r2)) ye(e3, a2, n2, i2);
      else {
        V(r2, new Uint8Array(a2, n2, i2), false);
      }
      else ze(r2) ? (ye(e3, a2, n2, i2), Re(e3)) : ye(e3, a2, n2, i2);
      be(e3);
    }(this, e2);
  }
  error(e2 = void 0) {
    if (!he(this)) throw je("error");
    Ee(this, e2);
  }
  [W](e2) {
    if (this._pendingPullIntos.length > 0) {
      this._pendingPullIntos.peek().bytesFilled = 0;
    }
    ue(this);
    const t2 = this._cancelAlgorithm(e2);
    return qe(this), t2;
  }
  [A](e2) {
    const t2 = this._controlledReadableByteStream;
    if (this._queueTotalSize > 0) {
      const t3 = this._queue.shift();
      this._queueTotalSize -= t3.byteLength, ve(this);
      const r3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
      return void e2._chunkSteps(r3);
    }
    const r2 = this._autoAllocateChunkSize;
    if (void 0 !== r2) {
      let t3;
      try {
        t3 = new ArrayBuffer(r2);
      } catch (t4) {
        return void e2._errorSteps(t4);
      }
      const o2 = { buffer: t3, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
      this._pendingPullIntos.push(o2);
    }
    Y(t2, e2), be(this);
  }
};
function he(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream");
}
function _e(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController");
}
function be(e2) {
  const t2 = function(e3) {
    const t3 = e3._controlledReadableByteStream;
    if ("readable" !== t3._state) return false;
    if (e3._closeRequested) return false;
    if (!e3._started) return false;
    if (G(t3) && U(t3) > 0) return true;
    if (ze(t3) && Ae(t3) > 0) return true;
    const r2 = Ce(e3);
    if (r2 > 0) return true;
    return false;
  }(e2);
  if (!t2) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  h(e2._pullAlgorithm(), () => {
    e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, be(e2));
  }, (t3) => {
    Ee(e2, t3);
  });
}
function pe(e2, t2) {
  let r2 = false;
  "closed" === e2._state && (r2 = true);
  const o2 = me(t2);
  "default" === t2.readerType ? V(e2, o2, r2) : function(e3, t3, r3) {
    const o3 = e3._reader, n2 = o3._readIntoRequests.shift();
    r3 ? n2._closeSteps(t3) : n2._chunkSteps(t3);
  }(e2, o2, r2);
}
function me(e2) {
  const t2 = e2.bytesFilled, r2 = e2.elementSize;
  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
}
function ye(e2, t2, r2, o2) {
  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;
}
function ge(e2, t2) {
  const r2 = t2.elementSize, o2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), i2 = t2.bytesFilled + n2, a2 = i2 - i2 % r2;
  let s2 = n2, l2 = false;
  a2 > o2 && (s2 = a2 - t2.bytesFilled, l2 = true);
  const u2 = e2._queue;
  for (; s2 > 0; ) {
    const r3 = u2.peek(), o3 = Math.min(s2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
    c2 = t2.buffer, d2 = n3, f2 = r3.buffer, h2 = r3.byteOffset, _2 = o3, new Uint8Array(c2).set(new Uint8Array(f2, h2, _2), d2), r3.byteLength === o3 ? u2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, we(e2, o3, t2), s2 -= o3;
  }
  var c2, d2, f2, h2, _2;
  return l2;
}
function we(e2, t2, r2) {
  Se(e2), r2.bytesFilled += t2;
}
function ve(e2) {
  0 === e2._queueTotalSize && e2._closeRequested ? (qe(e2), sr(e2._controlledReadableByteStream)) : be(e2);
}
function Se(e2) {
  null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
}
function Re(e2) {
  for (; e2._pendingPullIntos.length > 0; ) {
    if (0 === e2._queueTotalSize) return;
    const t2 = e2._pendingPullIntos.peek();
    ge(e2, t2) && (Pe(e2), pe(e2._controlledReadableByteStream, t2));
  }
}
function Te(e2, t2) {
  const r2 = e2._pendingPullIntos.peek();
  if ("closed" === e2._controlledReadableByteStream._state) {
    if (0 !== t2) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
    !function(e3, t3) {
      t3.buffer = t3.buffer;
      const r3 = e3._controlledReadableByteStream;
      if (ze(r3)) for (; Ae(r3) > 0; ) pe(r3, Pe(e3));
    }(e2, r2);
  } else !function(e3, t3, r3) {
    if (r3.bytesFilled + t3 > r3.byteLength) throw new RangeError("bytesWritten out of range");
    if (we(e3, t3, r3), r3.bytesFilled < r3.elementSize) return;
    Pe(e3);
    const o2 = r3.bytesFilled % r3.elementSize;
    if (o2 > 0) {
      const t4 = r3.byteOffset + r3.bytesFilled, n2 = r3.buffer.slice(t4 - o2, t4);
      ye(e3, n2, 0, n2.byteLength);
    }
    r3.buffer = r3.buffer, r3.bytesFilled -= o2, pe(e3._controlledReadableByteStream, r3), Re(e3);
  }(e2, t2, r2);
  be(e2);
}
function Pe(e2) {
  const t2 = e2._pendingPullIntos.shift();
  return Se(e2), t2;
}
function qe(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
}
function Ee(e2, t2) {
  const r2 = e2._controlledReadableByteStream;
  "readable" === r2._state && (!function(e3) {
    Se(e3), e3._pendingPullIntos = new v();
  }(e2), ue(e2), qe(e2), lr(r2, t2));
}
function Ce(e2) {
  const t2 = e2._controlledReadableByteStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function ke(e2, t2, r2) {
  const o2 = Object.create(fe.prototype);
  let n2 = () => {
  }, i2 = () => c(void 0), a2 = () => c(void 0);
  void 0 !== t2.start && (n2 = () => t2.start(o2)), void 0 !== t2.pull && (i2 = () => t2.pull(o2)), void 0 !== t2.cancel && (a2 = (e3) => t2.cancel(e3));
  const s2 = t2.autoAllocateChunkSize;
  if (0 === s2) throw new TypeError("autoAllocateChunkSize must be greater than 0");
  !function(e3, t3, r3, o3, n3, i3, a3) {
    t3._controlledReadableByteStream = e3, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = void 0, ue(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = i3, t3._pullAlgorithm = o3, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = a3, t3._pendingPullIntos = new v(), e3._readableStreamController = t3, h(c(r3()), () => {
      t3._started = true, be(t3);
    }, (e4) => {
      Ee(t3, e4);
    });
  }(e2, o2, n2, i2, a2, r2, s2);
}
function Oe(e2) {
  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
}
function je(e2) {
  return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
}
function We(e2, t2) {
  e2._reader._readIntoRequests.push(t2);
}
function Ae(e2) {
  return e2._reader._readIntoRequests.length;
}
function ze(e2) {
  const t2 = e2._reader;
  return void 0 !== t2 && !!Be(t2);
}
Object.defineProperties(fe.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(fe.prototype, e.toStringTag, { value: "ReadableByteStreamController", configurable: true });
var Fe = class {
  constructor(e2) {
    if (M(e2, 1, "ReadableStreamBYOBReader"), Q(e2, "First parameter"), ir(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
    if (!he(e2._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
    S(this, e2), this._readIntoRequests = new v();
  }
  get closed() {
    return Be(this) ? this._closedPromise : d(Ie("closed"));
  }
  cancel(e2 = void 0) {
    return Be(this) ? void 0 === this._ownerReadableStream ? d(P("cancel")) : R(this, e2) : d(Ie("cancel"));
  }
  read(e2) {
    if (!Be(this)) return d(Ie("read"));
    if (!ArrayBuffer.isView(e2)) return d(new TypeError("view must be an array buffer view"));
    if (0 === e2.byteLength) return d(new TypeError("view must have non-zero byteLength"));
    if (0 === e2.buffer.byteLength) return d(new TypeError("view's buffer must have non-zero byteLength"));
    if (void 0 === this._ownerReadableStream) return d(P("read from"));
    let t2, r2;
    const o2 = u((e3, o3) => {
      t2 = e3, r2 = o3;
    });
    return function(e3, t3, r3) {
      const o3 = e3._ownerReadableStream;
      o3._disturbed = true, "errored" === o3._state ? r3._errorSteps(o3._storedError) : function(e4, t4, r4) {
        const o4 = e4._controlledReadableByteStream;
        let n2 = 1;
        t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);
        const i2 = t4.constructor, a2 = { buffer: t4.buffer, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: i2, readerType: "byob" };
        if (e4._pendingPullIntos.length > 0) return e4._pendingPullIntos.push(a2), void We(o4, r4);
        if ("closed" !== o4._state) {
          if (e4._queueTotalSize > 0) {
            if (ge(e4, a2)) {
              const t5 = me(a2);
              return ve(e4), void r4._chunkSteps(t5);
            }
            if (e4._closeRequested) {
              const t5 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              return Ee(e4, t5), void r4._errorSteps(t5);
            }
          }
          e4._pendingPullIntos.push(a2), We(o4, r4), be(e4);
        } else {
          const e5 = new i2(a2.buffer, a2.byteOffset, 0);
          r4._closeSteps(e5);
        }
      }(o3._readableStreamController, t3, r3);
    }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), o2;
  }
  releaseLock() {
    if (!Be(this)) throw Ie("releaseLock");
    if (void 0 !== this._ownerReadableStream) {
      if (this._readIntoRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
      T(this);
    }
  }
};
function Be(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests");
}
function Ie(e2) {
  return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
}
function Le(e2, t2) {
  const { highWaterMark: r2 } = e2;
  if (void 0 === r2) return t2;
  if (ie(r2) || r2 < 0) throw new RangeError("Invalid highWaterMark");
  return r2;
}
function Me(e2) {
  const { size: t2 } = e2;
  return t2 || (() => 1);
}
function $e(e2, t2) {
  B(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;
  return { highWaterMark: void 0 === r2 ? void 0 : D(r2), size: void 0 === o2 ? void 0 : De(o2, t2 + " has member 'size' that") };
}
function De(e2, t2) {
  return I(e2, t2), (t3) => D(e2(t3));
}
function xe(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function Ne(e2, t2, r2) {
  return I(e2, r2), () => w(e2, t2, []);
}
function Qe(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function He(e2, t2, r2) {
  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);
}
function Ye(e2, t2) {
  if (!Xe(e2)) throw new TypeError(t2 + " is not a WritableStream.");
}
Object.defineProperties(Fe.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(Fe.prototype, e.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
var Ve = class {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : L(e2, "First parameter");
    const r2 = $e(t2, "Second parameter"), o2 = function(e3, t3) {
      B(e3, t3);
      const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, i2 = null == e3 ? void 0 : e3.type, a2 = null == e3 ? void 0 : e3.write;
      return { abort: void 0 === r3 ? void 0 : xe(r3, e3, t3 + " has member 'abort' that"), close: void 0 === o3 ? void 0 : Ne(o3, e3, t3 + " has member 'close' that"), start: void 0 === n3 ? void 0 : Qe(n3, e3, t3 + " has member 'start' that"), write: void 0 === a2 ? void 0 : He(a2, e3, t3 + " has member 'write' that"), type: i2 };
    }(e2, "First parameter");
    Ge(this);
    if (void 0 !== o2.type) throw new RangeError("Invalid type is specified");
    const n2 = Me(r2);
    !function(e3, t3, r3, o3) {
      const n3 = Object.create(_t.prototype);
      let i2 = () => {
      }, a2 = () => c(void 0), s2 = () => c(void 0), l2 = () => c(void 0);
      void 0 !== t3.start && (i2 = () => t3.start(n3));
      void 0 !== t3.write && (a2 = (e4) => t3.write(e4, n3));
      void 0 !== t3.close && (s2 = () => t3.close());
      void 0 !== t3.abort && (l2 = (e4) => t3.abort(e4));
      bt(e3, n3, i2, a2, s2, l2, r3, o3);
    }(this, o2, Le(r2, 1), n2);
  }
  get locked() {
    if (!Xe(this)) throw St("locked");
    return Je(this);
  }
  abort(e2 = void 0) {
    return Xe(this) ? Je(this) ? d(new TypeError("Cannot abort a stream that already has a writer")) : Ke(this, e2) : d(St("abort"));
  }
  close() {
    return Xe(this) ? Je(this) ? d(new TypeError("Cannot close a stream that already has a writer")) : ot(this) ? d(new TypeError("Cannot close an already-closing stream")) : Ze(this) : d(St("close"));
  }
  getWriter() {
    if (!Xe(this)) throw St("getWriter");
    return Ue(this);
  }
};
function Ue(e2) {
  return new at(e2);
}
function Ge(e2) {
  e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new v(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
}
function Xe(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController");
}
function Je(e2) {
  return void 0 !== e2._writer;
}
function Ke(e2, t2) {
  const r2 = e2._state;
  if ("closed" === r2 || "errored" === r2) return c(void 0);
  if (void 0 !== e2._pendingAbortRequest) return e2._pendingAbortRequest._promise;
  let o2 = false;
  "erroring" === r2 && (o2 = true, t2 = void 0);
  const n2 = u((r3, n3) => {
    e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: n3, _reason: t2, _wasAlreadyErroring: o2 };
  });
  return e2._pendingAbortRequest._promise = n2, o2 || tt(e2, t2), n2;
}
function Ze(e2) {
  const t2 = e2._state;
  if ("closed" === t2 || "errored" === t2) return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
  const r2 = u((t3, r3) => {
    const o3 = { _resolve: t3, _reject: r3 };
    e2._closeRequest = o3;
  }), o2 = e2._writer;
  var n2;
  return void 0 !== o2 && e2._backpressure && "writable" === t2 && At(o2), le(n2 = e2._writableStreamController, ht, 0), yt(n2), r2;
}
function et(e2, t2) {
  "writable" !== e2._state ? rt(e2) : tt(e2, t2);
}
function tt(e2, t2) {
  const r2 = e2._writableStreamController;
  e2._state = "erroring", e2._storedError = t2;
  const o2 = e2._writer;
  void 0 !== o2 && ct(o2, t2), !function(e3) {
    if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest) return false;
    return true;
  }(e2) && r2._started && rt(e2);
}
function rt(e2) {
  e2._state = "errored", e2._writableStreamController[j]();
  const t2 = e2._storedError;
  if (e2._writeRequests.forEach((e3) => {
    e3._reject(t2);
  }), e2._writeRequests = new v(), void 0 === e2._pendingAbortRequest) return void nt(e2);
  const r2 = e2._pendingAbortRequest;
  if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring) return r2._reject(t2), void nt(e2);
  h(e2._writableStreamController[O](r2._reason), () => {
    r2._resolve(), nt(e2);
  }, (t3) => {
    r2._reject(t3), nt(e2);
  });
}
function ot(e2) {
  return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
}
function nt(e2) {
  void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
  const t2 = e2._writer;
  void 0 !== t2 && Et(t2, e2._storedError);
}
function it(e2, t2) {
  const r2 = e2._writer;
  void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
    kt(e3);
  }(r2) : At(r2)), e2._backpressure = t2;
}
Object.defineProperties(Ve.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(Ve.prototype, e.toStringTag, { value: "WritableStream", configurable: true });
var at = class {
  constructor(e2) {
    if (M(e2, 1, "WritableStreamDefaultWriter"), Ye(e2, "First parameter"), Je(e2)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
    this._ownerWritableStream = e2, e2._writer = this;
    const t2 = e2._state;
    if ("writable" === t2) !ot(e2) && e2._backpressure ? kt(this) : jt(this), Pt(this);
    else if ("erroring" === t2) Ot(this, e2._storedError), Pt(this);
    else if ("closed" === t2) jt(this), Pt(r2 = this), Ct(r2);
    else {
      const t3 = e2._storedError;
      Ot(this, t3), qt(this, t3);
    }
    var r2;
  }
  get closed() {
    return st(this) ? this._closedPromise : d(Rt("closed"));
  }
  get desiredSize() {
    if (!st(this)) throw Rt("desiredSize");
    if (void 0 === this._ownerWritableStream) throw Tt("desiredSize");
    return function(e2) {
      const t2 = e2._ownerWritableStream, r2 = t2._state;
      if ("errored" === r2 || "erroring" === r2) return null;
      if ("closed" === r2) return 0;
      return mt(t2._writableStreamController);
    }(this);
  }
  get ready() {
    return st(this) ? this._readyPromise : d(Rt("ready"));
  }
  abort(e2 = void 0) {
    return st(this) ? void 0 === this._ownerWritableStream ? d(Tt("abort")) : function(e3, t2) {
      return Ke(e3._ownerWritableStream, t2);
    }(this, e2) : d(Rt("abort"));
  }
  close() {
    if (!st(this)) return d(Rt("close"));
    const e2 = this._ownerWritableStream;
    return void 0 === e2 ? d(Tt("close")) : ot(e2) ? d(new TypeError("Cannot close an already-closing stream")) : lt(this);
  }
  releaseLock() {
    if (!st(this)) throw Rt("releaseLock");
    void 0 !== this._ownerWritableStream && dt(this);
  }
  write(e2 = void 0) {
    return st(this) ? void 0 === this._ownerWritableStream ? d(Tt("write to")) : ft(this, e2) : d(Rt("write"));
  }
};
function st(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream");
}
function lt(e2) {
  return Ze(e2._ownerWritableStream);
}
function ut(e2, t2) {
  "pending" === e2._closedPromiseState ? Et(e2, t2) : function(e3, t3) {
    qt(e3, t3);
  }(e2, t2);
}
function ct(e2, t2) {
  "pending" === e2._readyPromiseState ? Wt(e2, t2) : function(e3, t3) {
    Ot(e3, t3);
  }(e2, t2);
}
function dt(e2) {
  const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
  ct(e2, r2), ut(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
}
function ft(e2, t2) {
  const r2 = e2._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e3, t3) {
    try {
      return e3._strategySizeAlgorithm(t3);
    } catch (t4) {
      return gt(e3, t4), 1;
    }
  }(o2, t2);
  if (r2 !== e2._ownerWritableStream) return d(Tt("write to"));
  const i2 = r2._state;
  if ("errored" === i2) return d(r2._storedError);
  if (ot(r2) || "closed" === i2) return d(new TypeError("The stream is closing or closed and cannot be written to"));
  if ("erroring" === i2) return d(r2._storedError);
  const a2 = function(e3) {
    return u((t3, r3) => {
      const o3 = { _resolve: t3, _reject: r3 };
      e3._writeRequests.push(o3);
    });
  }(r2);
  return function(e3, t3, r3) {
    try {
      le(e3, t3, r3);
    } catch (t4) {
      return void gt(e3, t4);
    }
    const o3 = e3._controlledWritableStream;
    if (!ot(o3) && "writable" === o3._state) {
      it(o3, wt(e3));
    }
    yt(e3);
  }(o2, t2, n2), a2;
}
Object.defineProperties(at.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(at.prototype, e.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
var ht = {};
var _t = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  error(e2 = void 0) {
    if (!function(e3) {
      if (!o(e3)) return false;
      if (!Object.prototype.hasOwnProperty.call(e3, "_controlledWritableStream")) return false;
      return true;
    }(this)) throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
    "writable" === this._controlledWritableStream._state && vt(this, e2);
  }
  [O](e2) {
    const t2 = this._abortAlgorithm(e2);
    return pt(this), t2;
  }
  [j]() {
    ue(this);
  }
};
function bt(e2, t2, r2, o2, n2, i2, a2, s2) {
  t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, ue(t2), t2._started = false, t2._strategySizeAlgorithm = s2, t2._strategyHWM = a2, t2._writeAlgorithm = o2, t2._closeAlgorithm = n2, t2._abortAlgorithm = i2;
  const l2 = wt(t2);
  it(e2, l2);
  h(c(r2()), () => {
    t2._started = true, yt(t2);
  }, (r3) => {
    t2._started = true, et(e2, r3);
  });
}
function pt(e2) {
  e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function mt(e2) {
  return e2._strategyHWM - e2._queueTotalSize;
}
function yt(e2) {
  const t2 = e2._controlledWritableStream;
  if (!e2._started) return;
  if (void 0 !== t2._inFlightWriteRequest) return;
  if ("erroring" === t2._state) return void rt(t2);
  if (0 === e2._queue.length) return;
  const r2 = e2._queue.peek().value;
  r2 === ht ? function(e3) {
    const t3 = e3._controlledWritableStream;
    (function(e4) {
      e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
    })(t3), se(e3);
    const r3 = e3._closeAlgorithm();
    pt(e3), h(r3, () => {
      !function(e4) {
        e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
        const t4 = e4._writer;
        void 0 !== t4 && Ct(t4);
      }(t3);
    }, (e4) => {
      !function(e5, t4) {
        e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), et(e5, t4);
      }(t3, e4);
    });
  }(e2) : function(e3, t3) {
    const r3 = e3._controlledWritableStream;
    !function(e4) {
      e4._inFlightWriteRequest = e4._writeRequests.shift();
    }(r3);
    const o2 = e3._writeAlgorithm(t3);
    h(o2, () => {
      !function(e4) {
        e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
      }(r3);
      const t4 = r3._state;
      if (se(e3), !ot(r3) && "writable" === t4) {
        const t5 = wt(e3);
        it(r3, t5);
      }
      yt(e3);
    }, (t4) => {
      "writable" === r3._state && pt(e3), function(e4, t5) {
        e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, et(e4, t5);
      }(r3, t4);
    });
  }(e2, r2);
}
function gt(e2, t2) {
  "writable" === e2._controlledWritableStream._state && vt(e2, t2);
}
function wt(e2) {
  return mt(e2) <= 0;
}
function vt(e2, t2) {
  const r2 = e2._controlledWritableStream;
  pt(e2), tt(r2, t2);
}
function St(e2) {
  return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
}
function Rt(e2) {
  return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
}
function Tt(e2) {
  return new TypeError("Cannot " + e2 + " a stream using a released writer");
}
function Pt(e2) {
  e2._closedPromise = u((t2, r2) => {
    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
  });
}
function qt(e2, t2) {
  Pt(e2), Et(e2, t2);
}
function Et(e2, t2) {
  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
}
function Ct(e2) {
  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
}
function kt(e2) {
  e2._readyPromise = u((t2, r2) => {
    e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
  }), e2._readyPromiseState = "pending";
}
function Ot(e2, t2) {
  kt(e2), Wt(e2, t2);
}
function jt(e2) {
  kt(e2), At(e2);
}
function Wt(e2, t2) {
  void 0 !== e2._readyPromise_reject && (m(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
}
function At(e2) {
  void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
}
Object.defineProperties(_t.prototype, { error: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(_t.prototype, e.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
var zt = "undefined" != typeof DOMException ? DOMException : void 0;
var Ft = function(e2) {
  if ("function" != typeof e2 && "object" != typeof e2) return false;
  try {
    return new e2(), true;
  } catch (e3) {
    return false;
  }
}(zt) ? zt : function() {
  const e2 = function(e3, t2) {
    this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  };
  return Object.defineProperty(e2.prototype = Object.create(Error.prototype), "constructor", { value: e2, writable: true, configurable: true }), e2;
}();
function Bt(e2, r2, o2, n2, i2, a2) {
  const s2 = H(e2), l2 = Ue(r2);
  e2._disturbed = true;
  let p2 = false, y2 = c(void 0);
  return u((g2, w2) => {
    let v2;
    if (void 0 !== a2) {
      if (v2 = () => {
        const t2 = new Ft("Aborted", "AbortError"), o3 = [];
        n2 || o3.push(() => "writable" === r2._state ? Ke(r2, t2) : c(void 0)), i2 || o3.push(() => "readable" === e2._state ? ar(e2, t2) : c(void 0)), C2(() => Promise.all(o3.map((e3) => e3())), true, t2);
      }, a2.aborted) return void v2();
      a2.addEventListener("abort", v2);
    }
    var S2, R2, P2;
    if (E2(e2, s2._closedPromise, (e3) => {
      n2 ? k2(true, e3) : C2(() => Ke(r2, e3), true, e3);
    }), E2(r2, l2._closedPromise, (t2) => {
      i2 ? k2(true, t2) : C2(() => ar(e2, t2), true, t2);
    }), S2 = e2, R2 = s2._closedPromise, P2 = () => {
      o2 ? k2() : C2(() => function(e3) {
        const t2 = e3._ownerWritableStream, r3 = t2._state;
        return ot(t2) || "closed" === r3 ? c(void 0) : "errored" === r3 ? d(t2._storedError) : lt(e3);
      }(l2));
    }, "closed" === S2._state ? P2() : _(R2, P2), ot(r2) || "closed" === r2._state) {
      const t2 = new TypeError("the destination writable stream closed before all data could be piped to it");
      i2 ? k2(true, t2) : C2(() => ar(e2, t2), true, t2);
    }
    function q2() {
      const e3 = y2;
      return f(y2, () => e3 !== y2 ? q2() : void 0);
    }
    function E2(e3, t2, r3) {
      "errored" === e3._state ? r3(e3._storedError) : b(t2, r3);
    }
    function C2(e3, t2, o3) {
      function n3() {
        h(e3(), () => O2(t2, o3), (e4) => O2(true, e4));
      }
      p2 || (p2 = true, "writable" !== r2._state || ot(r2) ? n3() : _(q2(), n3));
    }
    function k2(e3, t2) {
      p2 || (p2 = true, "writable" !== r2._state || ot(r2) ? O2(e3, t2) : _(q2(), () => O2(e3, t2)));
    }
    function O2(e3, t2) {
      dt(l2), T(s2), void 0 !== a2 && a2.removeEventListener("abort", v2), e3 ? w2(t2) : g2(void 0);
    }
    m(u((e3, r3) => {
      !function o3(n3) {
        n3 ? e3() : f(p2 ? c(true) : f(l2._readyPromise, () => u((e4, r4) => {
          K(s2, { _chunkSteps: (r5) => {
            y2 = f(ft(l2, r5), void 0, t), e4(false);
          }, _closeSteps: () => e4(true), _errorSteps: r4 });
        })), o3, r3);
      }(false);
    }));
  });
}
var It = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!Lt(this)) throw Ut("desiredSize");
    return Ht(this);
  }
  close() {
    if (!Lt(this)) throw Ut("close");
    if (!Yt(this)) throw new TypeError("The stream is not in a state that permits close");
    xt(this);
  }
  enqueue(e2 = void 0) {
    if (!Lt(this)) throw Ut("enqueue");
    if (!Yt(this)) throw new TypeError("The stream is not in a state that permits enqueue");
    return Nt(this, e2);
  }
  error(e2 = void 0) {
    if (!Lt(this)) throw Ut("error");
    Qt(this, e2);
  }
  [W](e2) {
    ue(this);
    const t2 = this._cancelAlgorithm(e2);
    return Dt(this), t2;
  }
  [A](e2) {
    const t2 = this._controlledReadableStream;
    if (this._queue.length > 0) {
      const r2 = se(this);
      this._closeRequested && 0 === this._queue.length ? (Dt(this), sr(t2)) : Mt(this), e2._chunkSteps(r2);
    } else Y(t2, e2), Mt(this);
  }
};
function Lt(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream");
}
function Mt(e2) {
  if (!$t(e2)) return;
  if (e2._pulling) return void (e2._pullAgain = true);
  e2._pulling = true;
  h(e2._pullAlgorithm(), () => {
    e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, Mt(e2));
  }, (t2) => {
    Qt(e2, t2);
  });
}
function $t(e2) {
  const t2 = e2._controlledReadableStream;
  if (!Yt(e2)) return false;
  if (!e2._started) return false;
  if (ir(t2) && U(t2) > 0) return true;
  return Ht(e2) > 0;
}
function Dt(e2) {
  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
}
function xt(e2) {
  if (!Yt(e2)) return;
  const t2 = e2._controlledReadableStream;
  e2._closeRequested = true, 0 === e2._queue.length && (Dt(e2), sr(t2));
}
function Nt(e2, t2) {
  if (!Yt(e2)) return;
  const r2 = e2._controlledReadableStream;
  if (ir(r2) && U(r2) > 0) V(r2, t2, false);
  else {
    let r3;
    try {
      r3 = e2._strategySizeAlgorithm(t2);
    } catch (t3) {
      throw Qt(e2, t3), t3;
    }
    try {
      le(e2, t2, r3);
    } catch (t3) {
      throw Qt(e2, t3), t3;
    }
  }
  Mt(e2);
}
function Qt(e2, t2) {
  const r2 = e2._controlledReadableStream;
  "readable" === r2._state && (ue(e2), Dt(e2), lr(r2, t2));
}
function Ht(e2) {
  const t2 = e2._controlledReadableStream._state;
  return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
}
function Yt(e2) {
  const t2 = e2._controlledReadableStream._state;
  return !e2._closeRequested && "readable" === t2;
}
function Vt(e2, t2, r2, o2, n2, i2, a2) {
  t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, ue(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = a2, t2._strategyHWM = i2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
  h(c(r2()), () => {
    t2._started = true, Mt(t2);
  }, (e3) => {
    Qt(t2, e3);
  });
}
function Ut(e2) {
  return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
}
function Gt(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function Xt(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function Jt(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function Kt(e2, t2) {
  if ("bytes" !== (e2 = "" + e2)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
  return e2;
}
function Zt(e2, t2) {
  if ("byob" !== (e2 = "" + e2)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
  return e2;
}
function er(e2, t2) {
  B(e2, t2);
  const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, i2 = null == e2 ? void 0 : e2.signal;
  return void 0 !== i2 && function(e3, t3) {
    if (!function(e4) {
      if ("object" != typeof e4 || null === e4) return false;
      try {
        return "boolean" == typeof e4.aborted;
      } catch (e5) {
        return false;
      }
    }(e3)) throw new TypeError(t3 + " is not an AbortSignal.");
  }(i2, t2 + " has member 'signal' that"), { preventAbort: !!r2, preventCancel: !!o2, preventClose: !!n2, signal: i2 };
}
Object.defineProperties(It.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(It.prototype, e.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
var tr = class {
  constructor(e2 = {}, t2 = {}) {
    void 0 === e2 ? e2 = null : L(e2, "First parameter");
    const r2 = $e(t2, "Second parameter"), o2 = function(e3, t3) {
      B(e3, t3);
      const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n2 = null == r3 ? void 0 : r3.cancel, i2 = null == r3 ? void 0 : r3.pull, a2 = null == r3 ? void 0 : r3.start, s2 = null == r3 ? void 0 : r3.type;
      return { autoAllocateChunkSize: void 0 === o3 ? void 0 : N(o3, t3 + " has member 'autoAllocateChunkSize' that"), cancel: void 0 === n2 ? void 0 : Gt(n2, r3, t3 + " has member 'cancel' that"), pull: void 0 === i2 ? void 0 : Xt(i2, r3, t3 + " has member 'pull' that"), start: void 0 === a2 ? void 0 : Jt(a2, r3, t3 + " has member 'start' that"), type: void 0 === s2 ? void 0 : Kt(s2, t3 + " has member 'type' that") };
    }(e2, "First parameter");
    if (or(this), "bytes" === o2.type) {
      if (void 0 !== r2.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
      ke(this, o2, Le(r2, 0));
    } else {
      const e3 = Me(r2);
      !function(e4, t3, r3, o3) {
        const n2 = Object.create(It.prototype);
        let i2 = () => {
        }, a2 = () => c(void 0), s2 = () => c(void 0);
        void 0 !== t3.start && (i2 = () => t3.start(n2)), void 0 !== t3.pull && (a2 = () => t3.pull(n2)), void 0 !== t3.cancel && (s2 = (e5) => t3.cancel(e5)), Vt(e4, n2, i2, a2, s2, r3, o3);
      }(this, o2, Le(r2, 1), e3);
    }
  }
  get locked() {
    if (!nr(this)) throw ur("locked");
    return ir(this);
  }
  cancel(e2 = void 0) {
    return nr(this) ? ir(this) ? d(new TypeError("Cannot cancel a stream that already has a reader")) : ar(this, e2) : d(ur("cancel"));
  }
  getReader(e2 = void 0) {
    if (!nr(this)) throw ur("getReader");
    return void 0 === function(e3, t2) {
      B(e3, t2);
      const r2 = null == e3 ? void 0 : e3.mode;
      return { mode: void 0 === r2 ? void 0 : Zt(r2, t2 + " has member 'mode' that") };
    }(e2, "First parameter").mode ? H(this) : new Fe(this);
  }
  pipeThrough(e2, t2 = {}) {
    if (!nr(this)) throw ur("pipeThrough");
    M(e2, 1, "pipeThrough");
    const r2 = function(e3, t3) {
      B(e3, t3);
      const r3 = null == e3 ? void 0 : e3.readable;
      $(r3, "readable", "ReadableWritablePair"), Q(r3, t3 + " has member 'readable' that");
      const o3 = null == e3 ? void 0 : e3.writable;
      return $(o3, "writable", "ReadableWritablePair"), Ye(o3, t3 + " has member 'writable' that"), { readable: r3, writable: o3 };
    }(e2, "First parameter"), o2 = er(t2, "Second parameter");
    if (ir(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
    if (Je(r2.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
    return m(Bt(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
  }
  pipeTo(e2, t2 = {}) {
    if (!nr(this)) return d(ur("pipeTo"));
    if (void 0 === e2) return d("Parameter 1 is required in 'pipeTo'.");
    if (!Xe(e2)) return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
    let r2;
    try {
      r2 = er(t2, "Second parameter");
    } catch (e3) {
      return d(e3);
    }
    return ir(this) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : Je(e2) ? d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Bt(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
  }
  tee() {
    if (!nr(this)) throw ur("tee");
    const e2 = function(e3, t2) {
      const r2 = H(e3);
      let o2, n2, i2, a2, s2, l2 = false, d2 = false, f2 = false;
      const h2 = u((e4) => {
        s2 = e4;
      });
      function _2() {
        return l2 || (l2 = true, K(r2, { _chunkSteps: (e4) => {
          y(() => {
            l2 = false;
            const t3 = e4, r3 = e4;
            d2 || Nt(i2._readableStreamController, t3), f2 || Nt(a2._readableStreamController, r3);
          });
        }, _closeSteps: () => {
          l2 = false, d2 || xt(i2._readableStreamController), f2 || xt(a2._readableStreamController), d2 && f2 || s2(void 0);
        }, _errorSteps: () => {
          l2 = false;
        } })), c(void 0);
      }
      function p2() {
      }
      return i2 = rr(p2, _2, function(t3) {
        if (d2 = true, o2 = t3, f2) {
          const t4 = ce([o2, n2]), r3 = ar(e3, t4);
          s2(r3);
        }
        return h2;
      }), a2 = rr(p2, _2, function(t3) {
        if (f2 = true, n2 = t3, d2) {
          const t4 = ce([o2, n2]), r3 = ar(e3, t4);
          s2(r3);
        }
        return h2;
      }), b(r2._closedPromise, (e4) => {
        Qt(i2._readableStreamController, e4), Qt(a2._readableStreamController, e4), d2 && f2 || s2(void 0);
      }), [i2, a2];
    }(this);
    return ce(e2);
  }
  values(e2 = void 0) {
    if (!nr(this)) throw ur("values");
    return function(e3, t2) {
      const r2 = H(e3), o2 = new te(r2, t2), n2 = Object.create(re);
      return n2._asyncIteratorImpl = o2, n2;
    }(this, function(e3, t2) {
      return B(e3, t2), { preventCancel: !!(null == e3 ? void 0 : e3.preventCancel) };
    }(e2, "First parameter").preventCancel);
  }
};
function rr(e2, t2, r2, o2 = 1, n2 = () => 1) {
  const i2 = Object.create(tr.prototype);
  or(i2);
  return Vt(i2, Object.create(It.prototype), e2, t2, r2, o2, n2), i2;
}
function or(e2) {
  e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
}
function nr(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController");
}
function ir(e2) {
  return void 0 !== e2._reader;
}
function ar(e2, r2) {
  if (e2._disturbed = true, "closed" === e2._state) return c(void 0);
  if ("errored" === e2._state) return d(e2._storedError);
  sr(e2);
  return p(e2._readableStreamController[W](r2), t);
}
function sr(e2) {
  e2._state = "closed";
  const t2 = e2._reader;
  void 0 !== t2 && (k(t2), J(t2) && (t2._readRequests.forEach((e3) => {
    e3._closeSteps();
  }), t2._readRequests = new v()));
}
function lr(e2, t2) {
  e2._state = "errored", e2._storedError = t2;
  const r2 = e2._reader;
  void 0 !== r2 && (C(r2, t2), J(r2) ? (r2._readRequests.forEach((e3) => {
    e3._errorSteps(t2);
  }), r2._readRequests = new v()) : (r2._readIntoRequests.forEach((e3) => {
    e3._errorSteps(t2);
  }), r2._readIntoRequests = new v()));
}
function ur(e2) {
  return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
}
function cr(e2, t2) {
  B(e2, t2);
  const r2 = null == e2 ? void 0 : e2.highWaterMark;
  return $(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: D(r2) };
}
Object.defineProperties(tr.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(tr.prototype, e.toStringTag, { value: "ReadableStream", configurable: true }), "symbol" == typeof e.asyncIterator && Object.defineProperty(tr.prototype, e.asyncIterator, { value: tr.prototype.values, writable: true, configurable: true });
var dr = function(e2) {
  return e2.byteLength;
};
var fr = class {
  constructor(e2) {
    M(e2, 1, "ByteLengthQueuingStrategy"), e2 = cr(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!_r(this)) throw hr("highWaterMark");
    return this._byteLengthQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!_r(this)) throw hr("size");
    return dr;
  }
};
function hr(e2) {
  return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
}
function _r(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark");
}
Object.defineProperties(fr.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(fr.prototype, e.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
var br = function() {
  return 1;
};
var pr = class {
  constructor(e2) {
    M(e2, 1, "CountQueuingStrategy"), e2 = cr(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
  }
  get highWaterMark() {
    if (!yr(this)) throw mr("highWaterMark");
    return this._countQueuingStrategyHighWaterMark;
  }
  get size() {
    if (!yr(this)) throw mr("size");
    return br;
  }
};
function mr(e2) {
  return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
}
function yr(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark");
}
function gr(e2, t2, r2) {
  return I(e2, r2), (r3) => w(e2, t2, [r3]);
}
function wr(e2, t2, r2) {
  return I(e2, r2), (r3) => g(e2, t2, [r3]);
}
function vr(e2, t2, r2) {
  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);
}
Object.defineProperties(pr.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(pr.prototype, e.toStringTag, { value: "CountQueuingStrategy", configurable: true });
var Sr = class {
  constructor(e2 = {}, t2 = {}, r2 = {}) {
    void 0 === e2 && (e2 = null);
    const o2 = $e(t2, "Second parameter"), n2 = $e(r2, "Third parameter"), i2 = function(e3, t3) {
      B(e3, t3);
      const r3 = null == e3 ? void 0 : e3.flush, o3 = null == e3 ? void 0 : e3.readableType, n3 = null == e3 ? void 0 : e3.start, i3 = null == e3 ? void 0 : e3.transform, a3 = null == e3 ? void 0 : e3.writableType;
      return { flush: void 0 === r3 ? void 0 : gr(r3, e3, t3 + " has member 'flush' that"), readableType: o3, start: void 0 === n3 ? void 0 : wr(n3, e3, t3 + " has member 'start' that"), transform: void 0 === i3 ? void 0 : vr(i3, e3, t3 + " has member 'transform' that"), writableType: a3 };
    }(e2, "First parameter");
    if (void 0 !== i2.readableType) throw new RangeError("Invalid readableType specified");
    if (void 0 !== i2.writableType) throw new RangeError("Invalid writableType specified");
    const a2 = Le(n2, 0), s2 = Me(n2), l2 = Le(o2, 1), f2 = Me(o2);
    let h2;
    !function(e3, t3, r3, o3, n3, i3) {
      function a3() {
        return t3;
      }
      function s3(t4) {
        return function(e4, t5) {
          const r4 = e4._transformStreamController;
          if (e4._backpressure) {
            return p(e4._backpressureChangePromise, () => {
              const o4 = e4._writable;
              if ("erroring" === o4._state) throw o4._storedError;
              return jr(r4, t5);
            });
          }
          return jr(r4, t5);
        }(e3, t4);
      }
      function l3(t4) {
        return function(e4, t5) {
          return Tr(e4, t5), c(void 0);
        }(e3, t4);
      }
      function u2() {
        return function(e4) {
          const t4 = e4._readable, r4 = e4._transformStreamController, o4 = r4._flushAlgorithm();
          return kr(r4), p(o4, () => {
            if ("errored" === t4._state) throw t4._storedError;
            xt(t4._readableStreamController);
          }, (r5) => {
            throw Tr(e4, r5), t4._storedError;
          });
        }(e3);
      }
      function d2() {
        return function(e4) {
          return qr(e4, false), e4._backpressureChangePromise;
        }(e3);
      }
      function f3(t4) {
        return Pr(e3, t4), c(void 0);
      }
      e3._writable = function(e4, t4, r4, o4, n4 = 1, i4 = () => 1) {
        const a4 = Object.create(Ve.prototype);
        return Ge(a4), bt(a4, Object.create(_t.prototype), e4, t4, r4, o4, n4, i4), a4;
      }(a3, s3, u2, l3, r3, o3), e3._readable = rr(a3, d2, f3, n3, i3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, qr(e3, true), e3._transformStreamController = void 0;
    }(this, u((e3) => {
      h2 = e3;
    }), l2, f2, a2, s2), function(e3, t3) {
      const r3 = Object.create(Er.prototype);
      let o3 = (e4) => {
        try {
          return Or(r3, e4), c(void 0);
        } catch (e5) {
          return d(e5);
        }
      }, n3 = () => c(void 0);
      void 0 !== t3.transform && (o3 = (e4) => t3.transform(e4, r3));
      void 0 !== t3.flush && (n3 = () => t3.flush(r3));
      !function(e4, t4, r4, o4) {
        t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4;
      }(e3, r3, o3, n3);
    }(this, i2), void 0 !== i2.start ? h2(i2.start(this._transformStreamController)) : h2(void 0);
  }
  get readable() {
    if (!Rr(this)) throw Ar("readable");
    return this._readable;
  }
  get writable() {
    if (!Rr(this)) throw Ar("writable");
    return this._writable;
  }
};
function Rr(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController");
}
function Tr(e2, t2) {
  Qt(e2._readable._readableStreamController, t2), Pr(e2, t2);
}
function Pr(e2, t2) {
  kr(e2._transformStreamController), gt(e2._writable._writableStreamController, t2), e2._backpressure && qr(e2, false);
}
function qr(e2, t2) {
  void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = u((t3) => {
    e2._backpressureChangePromise_resolve = t3;
  }), e2._backpressure = t2;
}
Object.defineProperties(Sr.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(Sr.prototype, e.toStringTag, { value: "TransformStream", configurable: true });
var Er = class {
  constructor() {
    throw new TypeError("Illegal constructor");
  }
  get desiredSize() {
    if (!Cr(this)) throw Wr("desiredSize");
    return Ht(this._controlledTransformStream._readable._readableStreamController);
  }
  enqueue(e2 = void 0) {
    if (!Cr(this)) throw Wr("enqueue");
    Or(this, e2);
  }
  error(e2 = void 0) {
    if (!Cr(this)) throw Wr("error");
    var t2;
    t2 = e2, Tr(this._controlledTransformStream, t2);
  }
  terminate() {
    if (!Cr(this)) throw Wr("terminate");
    !function(e2) {
      const t2 = e2._controlledTransformStream;
      xt(t2._readable._readableStreamController);
      Pr(t2, new TypeError("TransformStream terminated"));
    }(this);
  }
};
function Cr(e2) {
  return !!o(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream");
}
function kr(e2) {
  e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0;
}
function Or(e2, t2) {
  const r2 = e2._controlledTransformStream, o2 = r2._readable._readableStreamController;
  if (!Yt(o2)) throw new TypeError("Readable side is not in a state that permits enqueue");
  try {
    Nt(o2, t2);
  } catch (e3) {
    throw Pr(r2, e3), r2._readable._storedError;
  }
  const n2 = function(e3) {
    return !$t(e3);
  }(o2);
  n2 !== r2._backpressure && qr(r2, true);
}
function jr(e2, t2) {
  return p(e2._transformAlgorithm(t2), void 0, (t3) => {
    throw Tr(e2._controlledTransformStream, t3), t3;
  });
}
function Wr(e2) {
  return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
}
function Ar(e2) {
  return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
}
Object.defineProperties(Er.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof e.toStringTag && Object.defineProperty(Er.prototype, e.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
export {
  fr as ByteLengthQueuingStrategy,
  pr as CountQueuingStrategy,
  fe as ReadableByteStreamController,
  tr as ReadableStream,
  Fe as ReadableStreamBYOBReader,
  de as ReadableStreamBYOBRequest,
  It as ReadableStreamDefaultController,
  X as ReadableStreamDefaultReader,
  Sr as TransformStream,
  Er as TransformStreamDefaultController,
  Ve as WritableStream,
  _t as WritableStreamDefaultController,
  at as WritableStreamDefaultWriter
};
/*! Bundled license information:

openpgp/dist/lightweight/ponyfill.es6.min.mjs:
  (*! OpenPGP.js v5.11.2 - 2024-06-19 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. *)
*/
//# sourceMappingURL=ponyfill.es6.min-GONLAZFS.js.map

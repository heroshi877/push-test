"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cids_1 = __importDefault(require("cids"));
const multibase_1 = __importDefault(require("multibase"));
const doctype_table_1 = __importDefault(require("./doctype-table"));
const varint_1 = __importDefault(require("varint"));
const concat_1 = __importDefault(require("uint8arrays/concat"));
const to_string_1 = __importDefault(require("uint8arrays/to-string"));
const DOCID_CODEC = 206;
const getKey = (obj, value) => {
    for (const [k, v] of Object.entries(obj)) {
        if (v === value)
            return k;
    }
};
class DocID {
    constructor(doctype, cid, version = null, multibaseName = 'base36') {
        this._doctype = (typeof doctype === 'string') ? doctype_table_1.default[doctype] : doctype;
        if (!doctype && doctype !== 0)
            throw new Error('constructor: doctype required');
        this._multibaseName = multibaseName;
        this._cid = (typeof cid === 'string') ? new cids_1.default(cid) : cid;
        if (version === '0' || typeof version === 'number') {
            this._version = this._cid;
        }
        else {
            this._version = (typeof version === 'string') ? new cids_1.default(version) : version;
        }
        if (!cid)
            throw new Error('constructor: cid required');
    }
    static fromBytes(bytes, version, multibaseName) {
        const docCodec = varint_1.default.decode(bytes);
        if (docCodec !== DOCID_CODEC)
            throw new Error('fromBytes: invalid docid, does not include docid codec');
        bytes = bytes.slice(varint_1.default.decode.bytes);
        const docType = varint_1.default.decode(bytes);
        bytes = bytes.slice(varint_1.default.decode.bytes);
        let cid;
        try {
            cid = new cids_1.default(bytes);
            if (version === '0')
                version = cid;
        }
        catch (e) {
            const cidLength = DocID._genesisCIDLength(bytes);
            cid = new cids_1.default(bytes.slice(0, cidLength));
            const versionBytes = bytes.slice(cidLength);
            version = versionBytes.length === 1 ? cid : new cids_1.default(versionBytes);
        }
        return new DocID(docType, cid, version, multibaseName);
    }
    static _genesisCIDLength(bytes) {
        let offset = 0;
        varint_1.default.decode(bytes);
        offset += varint_1.default.decode.bytes;
        varint_1.default.decode(bytes.slice(offset));
        offset += varint_1.default.decode.bytes;
        varint_1.default.decode(bytes.slice(offset));
        offset += varint_1.default.decode.bytes;
        const length = varint_1.default.decode(bytes.slice(offset));
        return offset + length + 1;
    }
    static fromString(docId, version) {
        docId = docId.split('ceramic://').pop();
        docId = docId.split('/ceramic/').pop();
        if (docId.includes('version')) {
            version = docId.split('?')[1].split('=')[1];
            docId = docId.split('?')[0];
        }
        const multibaseName = multibase_1.default.isEncoded(docId);
        if (!multibaseName)
            throw new Error('fromString: requires base encoded string');
        const bytes = multibase_1.default.decode(docId);
        return DocID.fromBytes(bytes, version, multibaseName);
    }
    get baseID() {
        if (!this.version)
            return this;
        return new DocID(this.type, this.cid, null, this.multibaseName);
    }
    get type() {
        return this._doctype;
    }
    get typeName() {
        const name = getKey(doctype_table_1.default, this._doctype);
        if (!name)
            throw new Error('docTypeName: no registered name available');
        return name;
    }
    get cid() {
        return this._cid;
    }
    get version() {
        return this._version;
    }
    get multibaseName() {
        return this._multibaseName;
    }
    get multihash() {
        return this._cid.multihash;
    }
    get codec() {
        return this._cid.codec;
    }
    get bytes() {
        if (this._bytes == null) {
            const codec = varint_1.default.encode(DOCID_CODEC);
            const doctype = varint_1.default.encode(this.type);
            let versionBytes;
            if (this.version) {
                versionBytes = this.cid.equals(this.version) ? varint_1.default.encode(0) : this.version.bytes;
            }
            else {
                versionBytes = new Uint8Array(0);
            }
            this._bytes = concat_1.default([
                codec, doctype, this.cid.bytes, versionBytes
            ]);
        }
        return this._bytes;
    }
    equals(other) {
        let otherDocID;
        if (typeof other === 'string')
            otherDocID = DocID.fromString(other);
        else if (other instanceof Uint8Array) {
            otherDocID = DocID.fromBytes(other);
        }
        else {
            otherDocID = other;
        }
        return this.type === otherDocID.type &&
            (this.version ? this.version.equals(otherDocID.version) : !otherDocID.version) &&
            this.cid.equals(otherDocID.cid);
    }
    toBaseEncodedString(base = this.multibaseName) {
        return to_string_1.default(multibase_1.default.encode(base, this.bytes));
    }
    toString(base) {
        return this.toBaseEncodedString(base);
    }
    toUrl(base) {
        return `ceramic://${this.toBaseEncodedString(base)}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `DocID(${this.toString()})`;
    }
    [Symbol.toPrimitive]() {
        return this.toString();
    }
    static isDocID(other) {
        try {
            if (typeof other === 'string') {
                DocID.fromString(other);
                return true;
            }
            else if (other instanceof Uint8Array) {
                DocID.fromBytes(other);
                return true;
            }
            else {
                return (other.type || other.type === 0) && Boolean(other.cid);
            }
        }
        catch (e) {
            return false;
        }
    }
}
exports.default = DocID;
//# sourceMappingURL=index.js.map
import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/refractor/lang/ocaml.js
var require_ocaml = __commonJS({
  "node_modules/refractor/lang/ocaml.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = ocaml;
    ocaml.displayName = "ocaml";
    ocaml.aliases = [];
    function ocaml(Prism) {
      Prism.languages.ocaml = {
        comment: {
          pattern: /\(\*[\s\S]*?\*\)/,
          greedy: true
        },
        char: {
          pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
          greedy: true
        },
        string: [
          {
            pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
            greedy: true
          },
          {
            pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
            greedy: true
          }
        ],
        number: [
          // binary and octal
          /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
          // hexadecimal
          /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
          // decimal
          /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
        ],
        directive: {
          pattern: /\B#\w+/,
          alias: "property"
        },
        label: {
          pattern: /\B~\w+/,
          alias: "property"
        },
        "type-variable": {
          pattern: /\B'\w+/,
          alias: "function"
        },
        variant: {
          pattern: /`\w+/,
          alias: "symbol"
        },
        // For the list of keywords and operators,
        // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
        keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
        boolean: /\b(?:false|true)\b/,
        "operator-like-punctuation": {
          pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
          alias: "punctuation"
        },
        // Custom operators are allowed
        operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
        punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
      };
    }
  }
});

export {
  require_ocaml
};
//# sourceMappingURL=chunk-KRQ4BOEV.js.map

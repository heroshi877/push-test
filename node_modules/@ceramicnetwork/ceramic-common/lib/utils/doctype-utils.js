"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DoctypeUtils = void 0;
const cids_1 = __importDefault(require("cids"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const u8a = __importStar(require("uint8arrays"));
const doctype_1 = require("../doctype");
class DoctypeUtils {
    static serializeRecord(record) {
        const cloned = lodash_clonedeep_1.default(record);
        if (DoctypeUtils.isSignedRecordDTO(cloned)) {
            cloned.jws.link = cloned.jws.link.toString();
            cloned.linkedBlock = u8a.toString(cloned.linkedBlock, 'base64');
            return cloned;
        }
        if (DoctypeUtils.isSignedRecord(cloned)) {
            cloned.link = cloned.link.toString();
        }
        if (DoctypeUtils.isAnchorRecord(cloned)) {
            cloned.proof = cloned.proof.toString();
        }
        if (cloned.id) {
            cloned.id = cloned.id.toString();
        }
        if (cloned.prev) {
            cloned.prev = cloned.prev.toString();
        }
        return cloned;
    }
    static deserializeRecord(record) {
        const cloned = lodash_clonedeep_1.default(record);
        if (DoctypeUtils.isSignedRecordDTO(cloned)) {
            cloned.jws.link = new cids_1.default(cloned.jws.link);
            cloned.linkedBlock = u8a.fromString(cloned.linkedBlock, 'base64');
            return cloned;
        }
        if (DoctypeUtils.isSignedRecord(cloned)) {
            cloned.link = new cids_1.default(cloned.link);
        }
        if (DoctypeUtils.isAnchorRecord(cloned)) {
            cloned.proof = new cids_1.default(cloned.proof);
        }
        if (cloned.id) {
            cloned.id = new cids_1.default(cloned.id);
        }
        if (cloned.prev) {
            cloned.prev = new cids_1.default(cloned.prev);
        }
        return cloned;
    }
    static serializeState(state) {
        const cloned = lodash_clonedeep_1.default(state);
        cloned.log = cloned.log.map((cid) => cid.toString());
        if (cloned.anchorStatus) {
            cloned.anchorStatus = doctype_1.AnchorStatus[cloned.anchorStatus];
        }
        if (cloned.anchorScheduledFor) {
            cloned.anchorScheduledFor = new Date(cloned.anchorScheduledFor).toLocaleString();
        }
        if (cloned.anchorProof) {
            cloned.anchorProof.txHash = cloned.anchorProof.txHash.toString();
            cloned.anchorProof.root = cloned.anchorProof.root.toString();
        }
        return cloned;
    }
    static deserializeState(state) {
        const cloned = lodash_clonedeep_1.default(state);
        cloned.log = cloned.log.map((cidStr) => new cids_1.default(cidStr));
        if (cloned.anchorProof) {
            cloned.anchorProof.txHash = new cids_1.default(cloned.anchorProof.txHash);
            cloned.anchorProof.root = new cids_1.default(cloned.anchorProof.root);
        }
        let showScheduledFor = true;
        if (cloned.anchorStatus) {
            cloned.anchorStatus = doctype_1.AnchorStatus[cloned.anchorStatus];
            showScheduledFor = cloned.anchorStatus !== doctype_1.AnchorStatus.FAILED && cloned.anchorStatus !== doctype_1.AnchorStatus.ANCHORED;
        }
        if (cloned.anchorScheduledFor) {
            if (showScheduledFor) {
                cloned.anchorScheduledFor = Date.parse(cloned.anchorScheduledFor);
            }
            else {
                cloned.anchorScheduledFor = null;
            }
        }
        return cloned;
    }
    static makeReadOnly(doctype) {
        doctype.change = () => {
            throw new Error('The version of the document is readonly. Checkout the latest HEAD in order to update.');
        };
        return doctype;
    }
    static async convertRecordToDTO(record, ipfs) {
        if (DoctypeUtils.isSignedRecord(record)) {
            const block = await ipfs.block.get(record.link);
            const linkedBlock = block.data instanceof Uint8Array ? block.data : new Uint8Array(block.data.buffer);
            return {
                jws: record,
                linkedBlock,
            };
        }
        return record;
    }
    static isSignedRecordDTO(record) {
        return typeof record === 'object' && 'jws' in record && 'linkedBlock' in record;
    }
    static isSignedRecord(record) {
        return typeof record === 'object' && 'link' in record && 'payload' in record && 'signatures' in record;
    }
    static isAnchorRecord(record) {
        return typeof record === 'object' && 'proof' in record && 'path' in record;
    }
}
exports.DoctypeUtils = DoctypeUtils;
//# sourceMappingURL=doctype-utils.js.map
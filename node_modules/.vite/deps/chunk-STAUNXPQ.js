import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_browser_ponyfill
} from "./chunk-GTEWWCCM.js";
import {
  init_lib12 as init_lib,
  lib_exports12 as lib_exports
} from "./chunk-GRI4EYTM.js";
import {
  require_sha3
} from "./chunk-BLRZAMSF.js";
import {
  require_bn,
  require_crypto_browserify,
  require_elliptic
} from "./chunk-7LYDIDA4.js";
import {
  __commonJS,
  __require,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/core.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto_browserify();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/sha256.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/enc-hex.js
var require_enc_hex = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/enc-hex.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.enc.Hex;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/znsUtils.js
var require_znsUtils = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/znsUtils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromBech32Address = exports.toBech32Address = exports.toChecksumAddress = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var sha256_1 = __importDefault(require_sha256());
    var enc_hex_1 = __importDefault(require_enc_hex());
    var CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var GENERATOR = [996825010, 642813549, 513874426, 1027748829, 705979059];
    var HRP = "zil";
    var tHRP = "tzil";
    function isByteString(str, len) {
      return !!str.replace("0x", "").match("^[0-9a-fA-F]{".concat(len, "}$"));
    }
    function isAddress(address) {
      return isByteString(address, 40);
    }
    function convertBits(data, fromWidth, toWidth, pad) {
      if (pad === void 0) {
        pad = true;
      }
      var acc = 0;
      var bits = 0;
      var ret = [];
      var maxv = (1 << toWidth) - 1;
      for (var p = 0; p < data.length; ++p) {
        var value = data[p];
        if (value < 0 || value >> fromWidth !== 0) {
          return null;
        }
        acc = acc << fromWidth | value;
        bits += fromWidth;
        while (bits >= toWidth) {
          bits -= toWidth;
          ret.push(acc >> bits & maxv);
        }
      }
      if (pad) {
        if (bits > 0) {
          ret.push(acc << toWidth - bits & maxv);
        }
      } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {
        return null;
      }
      return Buffer.from(ret);
    }
    function hrpExpand(hrp) {
      var ret = [];
      var p;
      for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) >> 5);
      }
      ret.push(0);
      for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) & 31);
      }
      return Buffer.from(ret);
    }
    function polymod(values) {
      var chk = 1;
      for (var p = 0; p < values.length; ++p) {
        var top_1 = chk >> 25;
        chk = (chk & 33554431) << 5 ^ values[p];
        for (var i = 0; i < 5; ++i) {
          if (top_1 >> i & 1) {
            chk ^= GENERATOR[i];
          }
        }
      }
      return chk;
    }
    function createChecksum(hrp, data) {
      var values = Buffer.concat([
        Buffer.from(hrpExpand(hrp)),
        data,
        Buffer.from([0, 0, 0, 0, 0, 0])
      ]);
      var mod = polymod(values) ^ 1;
      var ret = [];
      for (var p = 0; p < 6; ++p) {
        ret.push(mod >> 5 * (5 - p) & 31);
      }
      return Buffer.from(ret);
    }
    function verifyChecksum(hrp, data) {
      return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;
    }
    function encode(hrp, data) {
      var combined = Buffer.concat([data, createChecksum(hrp, data)]);
      var ret = hrp + "1";
      for (var p = 0; p < combined.length; ++p) {
        ret += CHARSET.charAt(combined[p]);
      }
      return ret;
    }
    function decode(bechString) {
      var p;
      var hasLower = false;
      var hasUpper = false;
      for (p = 0; p < bechString.length; ++p) {
        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
          return null;
        }
        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
          hasLower = true;
        }
        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
          hasUpper = true;
        }
      }
      if (hasLower && hasUpper) {
        return null;
      }
      bechString = bechString.toLowerCase();
      var pos = bechString.lastIndexOf("1");
      if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
        return null;
      }
      var hrp = bechString.substring(0, pos);
      var data = [];
      for (p = pos + 1; p < bechString.length; ++p) {
        var d = CHARSET.indexOf(bechString.charAt(p));
        if (d === -1) {
          return null;
        }
        data.push(d);
      }
      if (!verifyChecksum(hrp, Buffer.from(data))) {
        return null;
      }
      return { hrp, data: Buffer.from(data.slice(0, data.length - 6)) };
    }
    var toChecksumAddress = function(address) {
      if (!isAddress(address)) {
        throw new Error("".concat(address, " is not a valid base 16 address"));
      }
      address = address.toLowerCase().replace("0x", "");
      var hash = enc_hex_1.default.stringify((0, sha256_1.default)(enc_hex_1.default.parse(address)));
      var v = new bn_js_1.default(hash, "hex", "be");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if ("0123456789".indexOf(address[i]) !== -1) {
          ret += address[i];
        } else {
          ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1)) ? address[i].toUpperCase() : address[i].toLowerCase();
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    function toBech32Address(address, testnet) {
      if (testnet === void 0) {
        testnet = false;
      }
      if (!isAddress(address)) {
        throw new Error("Invalid address format.");
      }
      var addrBz = convertBits(Buffer.from(address.replace("0x", ""), "hex"), 8, 5);
      if (addrBz === null) {
        throw new Error("Could not convert byte Buffer to 5-bit Buffer");
      }
      return encode(testnet ? tHRP : HRP, addrBz);
    }
    exports.toBech32Address = toBech32Address;
    function fromBech32Address(address, testnet) {
      if (testnet === void 0) {
        testnet = false;
      }
      var res = decode(address);
      if (res === null) {
        throw new Error("Invalid bech32 address");
      }
      var hrp = res.hrp, data = res.data;
      var shouldBe = testnet ? tHRP : HRP;
      if (hrp !== shouldBe) {
        throw new Error("Expected hrp to be ".concat(shouldBe, " but got ").concat(hrp));
      }
      var buf = convertBits(data, 5, 8, false);
      if (buf === null) {
        throw new Error("Could not convert buffer to bytes");
      }
      return (0, exports.toChecksumAddress)(buf.toString("hex"));
    }
    exports.fromBech32Address = fromBech32Address;
  }
});

// node_modules/@unstoppabledomains/resolution/build/types/publicTypes.js
var require_publicTypes = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/types/publicTypes.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockchainType = exports.DnsRecordType = exports.NamehashOptionsDefault = exports.UDApiDefaultUrl = exports.UnclaimedDomainResponse = exports.NamingServiceName = exports.UnsLocation = void 0;
    var UnsLocation;
    (function(UnsLocation2) {
      UnsLocation2["Layer1"] = "UNSLayer1";
      UnsLocation2["Layer2"] = "UNSLayer2";
    })(UnsLocation = exports.UnsLocation || (exports.UnsLocation = {}));
    var NamingServiceName;
    (function(NamingServiceName2) {
      NamingServiceName2["UNS"] = "UNS";
      NamingServiceName2["ZNS"] = "ZNS";
    })(NamingServiceName = exports.NamingServiceName || (exports.NamingServiceName = {}));
    exports.UnclaimedDomainResponse = {
      addresses: {},
      meta: {
        domain: "",
        namehash: "",
        resolver: "",
        owner: null,
        type: "",
        ttl: 0,
        blockchain: null
      },
      records: {}
    };
    exports.UDApiDefaultUrl = "https://unstoppabledomains.com/api/v1";
    exports.NamehashOptionsDefault = {
      format: "hex",
      prefix: true,
      zns: false
    };
    var DnsRecordType;
    (function(DnsRecordType2) {
      DnsRecordType2["A"] = "A";
      DnsRecordType2["AAAA"] = "AAAA";
      DnsRecordType2["AFSDB"] = "AFSDB";
      DnsRecordType2["APL"] = "APL";
      DnsRecordType2["CAA"] = "CAA";
      DnsRecordType2["CDNSKEY"] = "CDNSKEY";
      DnsRecordType2["CDS"] = "CDS";
      DnsRecordType2["CERT"] = "CERT";
      DnsRecordType2["CNAME"] = "CNAME";
      DnsRecordType2["CSYNC"] = "CSYNC";
      DnsRecordType2["DHCID"] = "DHCID";
      DnsRecordType2["DLV"] = "DLV";
      DnsRecordType2["DNAME"] = "DNAME";
      DnsRecordType2["DNSKEY"] = "DNSKEY";
      DnsRecordType2["DS"] = "DS";
      DnsRecordType2["EUI48"] = "EUI48";
      DnsRecordType2["EUI64"] = "EUI64";
      DnsRecordType2["HINFO"] = "HINFO";
      DnsRecordType2["HIP"] = "HIP";
      DnsRecordType2["HTTPS"] = "HTTPS";
      DnsRecordType2["IPSECKEY"] = "IPSECKEY";
      DnsRecordType2["KEY"] = "KEY";
      DnsRecordType2["KX"] = "KX";
      DnsRecordType2["LOC"] = "LOC";
      DnsRecordType2["MX"] = "MX";
      DnsRecordType2["NAPTR"] = "NAPTR";
      DnsRecordType2["NS"] = "NS";
      DnsRecordType2["NSEC"] = "NSEC";
      DnsRecordType2["NSEC3"] = "NSEC3";
      DnsRecordType2["NSEC3PARAM"] = "NSEC3PARAM";
      DnsRecordType2["OPENPGPKEY"] = "OPENPGPKEY";
      DnsRecordType2["PTR"] = "PTR";
      DnsRecordType2["RP"] = "RP";
      DnsRecordType2["RRSIG"] = "RRSIG";
      DnsRecordType2["SIG"] = "SIG";
      DnsRecordType2["SMIMEA"] = "SMIMEA";
      DnsRecordType2["SOA"] = "SOA";
      DnsRecordType2["SRV"] = "SRV";
      DnsRecordType2["SSHFP"] = "SSHFP";
      DnsRecordType2["SVCB"] = "SVCB";
      DnsRecordType2["TA"] = "TA";
      DnsRecordType2["TKEY"] = "TKEY";
      DnsRecordType2["TLSA"] = "TLSA";
      DnsRecordType2["TSIG"] = "TSIG";
      DnsRecordType2["TXT"] = "TXT";
      DnsRecordType2["URI"] = "URI";
      DnsRecordType2["ZONEMD"] = "ZONEMD";
    })(DnsRecordType = exports.DnsRecordType || (exports.DnsRecordType = {}));
    var BlockchainType;
    (function(BlockchainType2) {
      BlockchainType2["ETH"] = "ETH";
      BlockchainType2["MATIC"] = "MATIC";
      BlockchainType2["ZIL"] = "ZIL";
    })(BlockchainType = exports.BlockchainType || (exports.BlockchainType = {}));
  }
});

// node_modules/@unstoppabledomains/resolution/build/types/index.js
var require_types = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/types/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasProvider = exports.ZnsSupportedNetwork = exports.UnsSupportedNetwork = exports.NullAddresses = exports.NullAddress = void 0;
    exports.NullAddress = "0x0000000000000000000000000000000000000000";
    var NullAddresses;
    (function(NullAddresses2) {
      NullAddresses2[NullAddresses2["0x"] = 0] = "0x";
      NullAddresses2[NullAddresses2["0x0000000000000000000000000000000000000000"] = 1] = "0x0000000000000000000000000000000000000000";
      NullAddresses2[NullAddresses2["0x0000000000000000000000000000000000000000000000000000000000000000"] = 2] = "0x0000000000000000000000000000000000000000000000000000000000000000";
    })(NullAddresses = exports.NullAddresses || (exports.NullAddresses = {}));
    var StringUnion = function() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      Object.freeze(values);
      var valueSet = new Set(values);
      var guard = function(value) {
        return valueSet.has(value);
      };
      var check = function(value) {
        if (!guard(value)) {
          var actual = JSON.stringify(value);
          var expected = values.map(function(s) {
            return JSON.stringify(s);
          }).join(" | ");
          throw new TypeError("Value '".concat(actual, "' is not assignable to type '").concat(expected, "'."));
        }
        return value;
      };
      var unionNamespace = { guard, check, values };
      return Object.freeze(unionNamespace);
    };
    exports.UnsSupportedNetwork = StringUnion("mainnet", "rinkeby", "goerli", "polygon-mainnet", "polygon-mumbai");
    exports.ZnsSupportedNetwork = StringUnion("mainnet", "testnet");
    function hasProvider(obj) {
      return obj && !!obj.provider;
    }
    exports.hasProvider = hasProvider;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/index.js
var require_utils = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapResult = exports.wrapResult = exports.EthereumNetworksInverted = exports.EthereumNetworks = exports.findNamingServiceName = exports.domainExtensionToNamingServiceName = exports.constructRecords = exports.isNullAddress = exports.hexToBytes = exports.signedLink = void 0;
    var publicTypes_1 = require_publicTypes();
    var types_1 = require_types();
    var ProviderURLMap = {
      infura: {
        mainnet: "https://mainnet.infura.io/v3/",
        rinkeby: "https://rinkeby.infura.io/v3/",
        goerli: "https://goerli.infura.io/v3/",
        "polygon-mainnet": "https://polygon-mainnet.infura.io/v3/",
        "polygon-mumbai": "https://polygon-mumbai.infura.io/v3/"
      },
      alchemy: {
        mainnet: "https://eth-mainnet.alchemyapi.io/v2/",
        rinkeby: "https://eth-rinkeby.alchemyapi.io/v2/",
        goerli: "https://eth-goerli.alchemyapi.io/v2/",
        "polygon-mainnet": "https://polygon-mainnet.g.alchemy.com/v2/",
        "polygon-mumbai": "https://polygon-mumbai.g.alchemy.com/v2/"
      }
    };
    function signedLink(key, network, provider) {
      if (network === void 0) {
        network = "mainnet";
      }
      if (provider === void 0) {
        provider = "alchemy";
      }
      var url = ProviderURLMap[provider][network];
      return "".concat(url).concat(key);
    }
    exports.signedLink = signedLink;
    function hexToBytes(hexString) {
      var hex = hexString.replace(/^0x/i, "");
      var bytes = [];
      for (var c = 0; c < hex.length; c += 2) {
        bytes.push(parseInt(hex.substr(c, 2), 16));
      }
      return bytes;
    }
    exports.hexToBytes = hexToBytes;
    function isNullAddress(key) {
      if (!key) {
        return true;
      }
      return Object.values(types_1.NullAddresses).includes(key);
    }
    exports.isNullAddress = isNullAddress;
    function constructRecords(keys, values) {
      var records = {};
      keys.forEach(function(key, index) {
        records[key] = (values instanceof Array ? values[index] : values === null || values === void 0 ? void 0 : values[key]) || "";
      });
      return records;
    }
    exports.constructRecords = constructRecords;
    exports.domainExtensionToNamingServiceName = {
      crypto: publicTypes_1.NamingServiceName.UNS,
      zil: publicTypes_1.NamingServiceName.ZNS
    };
    var findNamingServiceName = function(domain) {
      var extension = domain.split(".").pop();
      if (!extension) {
        return "";
      } else if (extension in exports.domainExtensionToNamingServiceName) {
        return exports.domainExtensionToNamingServiceName[extension];
      } else {
        return exports.domainExtensionToNamingServiceName.crypto;
      }
    };
    exports.findNamingServiceName = findNamingServiceName;
    exports.EthereumNetworks = {
      mainnet: 1,
      ropsten: 3,
      rinkeby: 4,
      goerli: 5,
      "polygon-mainnet": 137,
      "polygon-mumbai": 80001
    };
    exports.EthereumNetworksInverted = {
      1: "mainnet",
      3: "ropsten",
      4: "rinkeby",
      5: "goerli",
      137: "polygon-mainnet",
      80001: "polygon-mumbai"
    };
    var wrapResult = function(func) {
      var callResult;
      try {
        callResult = func();
      } catch (error) {
        return Promise.resolve({ result: null, error });
      }
      var promise = callResult instanceof Promise ? callResult : Promise.resolve(callResult);
      return promise.then(function(result) {
        return { result, error: null };
      }, function(error) {
        return { result: null, error };
      });
    };
    exports.wrapResult = wrapResult;
    var unwrapResult = function(wrappedResult) {
      if (wrappedResult.error !== null) {
        throw wrappedResult.error;
      }
      return wrappedResult.result;
    };
    exports.unwrapResult = unwrapResult;
  }
});

// node_modules/@unstoppabledomains/resolution/build/errors/resolutionError.js
var require_resolutionError = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/errors/resolutionError.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolutionError = exports.ResolutionErrorCode = void 0;
    var ResolutionErrorCode;
    (function(ResolutionErrorCode2) {
      ResolutionErrorCode2["UnregisteredDomain"] = "UnregisteredDomain";
      ResolutionErrorCode2["UnspecifiedResolver"] = "UnspecifiedResolver";
      ResolutionErrorCode2["UnsupportedDomain"] = "UnsupportedDomain";
      ResolutionErrorCode2["UnsupportedService"] = "UnsupportedService";
      ResolutionErrorCode2["UnsupportedMethod"] = "UnsupportedMethod";
      ResolutionErrorCode2["UnspecifiedCurrency"] = "UnspecifiedCurrency";
      ResolutionErrorCode2["UnsupportedCurrency"] = "UnsupportedCurrency";
      ResolutionErrorCode2["IncorrectResolverInterface"] = "IncorrectResolverInterface";
      ResolutionErrorCode2["RecordNotFound"] = "RecordNotFound";
      ResolutionErrorCode2["MetadataEndpointError"] = "MetadataEndpointError";
      ResolutionErrorCode2["ServiceProviderError"] = "ServiceProviderError";
      ResolutionErrorCode2["InvalidTwitterVerification"] = "InvalidTwitterVerification";
      ResolutionErrorCode2["InconsistentDomainArray"] = "InconsistentDomainArray";
      ResolutionErrorCode2["InvalidDomainAddress"] = "InvalidDomainAddress";
    })(ResolutionErrorCode = exports.ResolutionErrorCode || (exports.ResolutionErrorCode = {}));
    var HandlersByCode = (_a = {}, _a[ResolutionErrorCode.UnregisteredDomain] = function(params) {
      return "Domain ".concat(params.domain, " is not registered");
    }, _a[ResolutionErrorCode.UnspecifiedResolver] = function(params) {
      return "".concat(params.location ? "".concat(params.location, ": ") : "", "Domain ").concat(params.domain, " is not configured");
    }, _a[ResolutionErrorCode.UnsupportedDomain] = function(params) {
      return "Domain ".concat(params.domain, " is not supported");
    }, _a[ResolutionErrorCode.UnsupportedMethod] = function(params) {
      var _a2;
      var zilHelp = ((_a2 = params.domain) === null || _a2 === void 0 ? void 0 : _a2.endsWith(".zil")) ? " (if this method was called via the Resolution class with both UNS and ZNS providers configured not in the API mode, this error also means that the domain doesn't exist in UNS)" : "";
      return "Method ".concat(params.methodName, " is not supported for ").concat(params.domain).concat(zilHelp);
    }, _a[ResolutionErrorCode.InvalidTwitterVerification] = function(params) {
      return "".concat(params.location ? "".concat(params.location, ": ") : "", "Domain ").concat(params.domain, " has invalid Twitter signature verification");
    }, _a[ResolutionErrorCode.UnsupportedCurrency] = function(params) {
      return "".concat(params.currencyTicker, " is not supported");
    }, _a[ResolutionErrorCode.IncorrectResolverInterface] = function(params) {
      return "Domain resolver is configured incorrectly for ".concat(params.method);
    }, _a[ResolutionErrorCode.RecordNotFound] = function(params) {
      return "".concat(params.location ? "".concat(params.location, ": ") : "", "No ").concat(params.recordName, " record found for ").concat(params.domain);
    }, _a[ResolutionErrorCode.ServiceProviderError] = function(params) {
      return "< ".concat(params.providerMessage, " >");
    }, _a[ResolutionErrorCode.MetadataEndpointError] = function(params) {
      return "Failed to query tokenUri ".concat(params.tokenUri, ". Error: ").concat(params.errorMessage);
    }, _a[ResolutionErrorCode.UnsupportedService] = function(params) {
      return "Naming service ".concat(params.namingService, " is not supported");
    }, _a[ResolutionErrorCode.InvalidDomainAddress] = function(params) {
      return "Domain address ".concat(params.domain, " is invalid");
    }, _a);
    var ResolutionError = (
      /** @class */
      function(_super) {
        __extends(ResolutionError2, _super);
        function ResolutionError2(code, options) {
          if (options === void 0) {
            options = {};
          }
          var _this = this;
          var resolutionErrorHandler = HandlersByCode[code];
          var domain = options.domain, method = options.method, currencyTicker = options.currencyTicker;
          var message = resolutionErrorHandler(options);
          _this = _super.call(this, message) || this;
          _this.code = code;
          _this.domain = domain;
          _this.method = method;
          _this.currencyTicker = currencyTicker;
          _this.name = "ResolutionError";
          Object.setPrototypeOf(_this, ResolutionError2.prototype);
          return _this;
        }
        return ResolutionError2;
      }(Error)
    );
    exports.ResolutionError = ResolutionError;
    exports.default = ResolutionError;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/Networking.js
var require_Networking = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/Networking.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var Networking = (
      /** @class */
      function() {
        function Networking2() {
        }
        Networking2.fetch = function(url, options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, (0, cross_fetch_1.default)(url, options)];
            });
          });
        };
        return Networking2;
      }()
    );
    exports.default = Networking;
  }
});

// node_modules/@unstoppabledomains/resolution/build/FetchProvider.js
var require_FetchProvider = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/FetchProvider.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolutionError_1 = __importStar(require_resolutionError());
    var Networking_1 = __importDefault(require_Networking());
    var FetchProvider = (
      /** @class */
      function() {
        function FetchProvider2(name, url) {
          this.url = url;
          this.name = name;
        }
        FetchProvider2.factory = function(name, url) {
          return new this(name, url);
        };
        FetchProvider2.prototype.request = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var json;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetchJson(args)];
                case 1:
                  json = _a.sent();
                  if (json.error) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                      providerMessage: json.error.message
                    });
                  }
                  return [2, json.result];
              }
            });
          });
        };
        FetchProvider2.prototype.fetchJson = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Networking_1.default.fetch(this.url, {
                    method: "POST",
                    body: JSON.stringify({
                      jsonrpc: "2.0",
                      id: "1",
                      method: args.method,
                      params: args.params || []
                    }),
                    headers: {
                      "Content-Type": "application/json"
                    }
                  })];
                case 1:
                  response = _a.sent();
                  if (response.status !== 200) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                      providerMessage: "Request to ".concat(this.url, " failed with response status ").concat(response.status)
                    });
                  }
                  return [2, response.json()];
              }
            });
          });
        };
        return FetchProvider2;
      }()
    );
    exports.default = FetchProvider;
  }
});

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/x64-core.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/sha3.js
var require_sha32 = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/sha3.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/@unstoppabledomains/resolution/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/namehash.js
var require_namehash = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/namehash.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromDecStringToHex = exports.fromHexStringToDecimals = exports.znsChildhash = exports.znsNamehash = exports.eip137Childhash = exports.eip137Namehash = void 0;
    var sha256_1 = __importDefault(require_sha256());
    var sha3_1 = __importDefault(require_sha32());
    var enc_hex_1 = __importDefault(require_enc_hex());
    var lib_typedarrays_1 = __importDefault(require_lib_typedarrays());
    var bn_js_1 = __importDefault(require_bn());
    function eip137Namehash(domain) {
      var arr = hashArray(domain, "sha3");
      return arrayToHex(arr);
    }
    exports.eip137Namehash = eip137Namehash;
    function eip137Childhash(parentHash, label) {
      return childhash(parentHash, label, "sha3");
    }
    exports.eip137Childhash = eip137Childhash;
    function znsNamehash(domain) {
      var arr = hashArray(domain, "sha256");
      return arrayToHex(arr);
    }
    exports.znsNamehash = znsNamehash;
    function znsChildhash(parentHash, label) {
      return childhash(parentHash, label, "sha256");
    }
    exports.znsChildhash = znsChildhash;
    function childhash(parentHash, label, hashingAlgo) {
      var hash = hashingAlgo === "sha256" ? sha256_1.default : sha3_1.default;
      var opts = { outputLength: 256 };
      var parent = parentHash.replace(/^0x/, "");
      var childHash = enc_hex_1.default.stringify(hash(label, opts));
      return "0x".concat(enc_hex_1.default.stringify(hash(enc_hex_1.default.parse("".concat(parent).concat(childHash)), opts)));
    }
    function hashArray(domain, hashingAlgo) {
      if (!domain) {
        return lib_typedarrays_1.default.create(Array.from(new Uint8Array(8)));
      }
      var hash = hashingAlgo === "sha256" ? sha256_1.default : sha3_1.default;
      var opts = { outputLength: 256 };
      var _a = domain.split("."), label = _a[0], remainder = _a.slice(1);
      var labelHash = hash(label, opts);
      var remainderHash = hashArray(remainder.join("."), hashingAlgo);
      return hash(remainderHash.concat(labelHash), opts);
    }
    function arrayToHex(arr) {
      return "0x".concat(enc_hex_1.default.stringify(arr));
    }
    function fromHexStringToDecimals(value) {
      if (value.startsWith("0x")) {
        var valueWithoutPrefix = value.slice(2, value.length);
        var bn = new bn_js_1.default(valueWithoutPrefix, 16);
        return bn.toString(10);
      }
      return value;
    }
    exports.fromHexStringToDecimals = fromHexStringToDecimals;
    function fromDecStringToHex(value) {
      if (!value.startsWith("0x")) {
        var bn = new bn_js_1.default(value, 10);
        var bnString = bn.toString(16);
        return "0x".concat(bnString.padStart(64, "0"));
      }
      return value;
    }
    exports.fromDecStringToHex = fromDecStringToHex;
  }
});

// node_modules/@unstoppabledomains/resolution/build/NamingService.js
var require_NamingService = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/NamingService.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamingService = void 0;
    var NamingService = (
      /** @class */
      /* @__PURE__ */ function() {
        function NamingService2() {
        }
        return NamingService2;
      }()
    );
    exports.NamingService = NamingService;
  }
});

// node_modules/@unstoppabledomains/resolution/build/errors/configurationError.js
var require_configurationError = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/errors/configurationError.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationError = exports.ConfigurationErrorCode = void 0;
    var ConfigurationErrorCode;
    (function(ConfigurationErrorCode2) {
      ConfigurationErrorCode2["IncorrectProvider"] = "IncorrectProvider";
      ConfigurationErrorCode2["UnsupportedNetwork"] = "UnsupportedNetwork";
      ConfigurationErrorCode2["UnspecifiedUrl"] = "UnspecifiedUrl";
      ConfigurationErrorCode2["NetworkConfigMissing"] = "NetworkConfigMissing";
      ConfigurationErrorCode2["CustomNetworkConfigMissing"] = "CustomNetworkConfigMissing";
      ConfigurationErrorCode2["InvalidConfigurationField"] = "InvalidProxyReader";
    })(ConfigurationErrorCode = exports.ConfigurationErrorCode || (exports.ConfigurationErrorCode = {}));
    var HandlersByCode = (_a = {}, _a[ConfigurationErrorCode.IncorrectProvider] = function() {
      return "Provider doesn't implement sendAsync or send method";
    }, _a[ConfigurationErrorCode.UnsupportedNetwork] = function(params) {
      return "Unsupported network in Resolution ".concat(params.method || "", " configuration");
    }, _a[ConfigurationErrorCode.UnspecifiedUrl] = function(params) {
      return "Unspecified url in Resolution ".concat(params.method, " configuration");
    }, _a[ConfigurationErrorCode.NetworkConfigMissing] = function(params) {
      return "Missing configuration in Resolution ".concat(params.method, ". Please specify ").concat(params.config);
    }, _a[ConfigurationErrorCode.CustomNetworkConfigMissing] = function(params) {
      return "Missing configuration in Resolution ".concat(params.method, ". Please specify ").concat(params.config, " when using a custom network");
    }, _a[ConfigurationErrorCode.InvalidConfigurationField] = function(params) {
      return "Invalid '".concat(params.field, "' in Resolution ").concat(params.method);
    }, _a);
    var ConfigurationError = (
      /** @class */
      function(_super) {
        __extends(ConfigurationError2, _super);
        function ConfigurationError2(code, options) {
          if (options === void 0) {
            options = {};
          }
          var _this = this;
          var configurationErrorHandler = HandlersByCode[code];
          _this = _super.call(this, configurationErrorHandler(options)) || this;
          _this.code = code;
          _this.method = options.method;
          _this.name = "ConfigurationError";
          Object.setPrototypeOf(_this, ConfigurationError2.prototype);
          return _this;
        }
        return ConfigurationError2;
      }(Error)
    );
    exports.ConfigurationError = ConfigurationError;
    exports.default = ConfigurationError;
  }
});

// node_modules/@unstoppabledomains/resolution/build/Zns.js
var require_Zns = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/Zns.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var znsUtils_1 = require_znsUtils();
    var utils_1 = require_utils();
    var types_1 = require_types();
    var resolutionError_1 = require_resolutionError();
    var publicTypes_1 = require_publicTypes();
    var FetchProvider_1 = __importDefault(require_FetchProvider());
    var namehash_1 = require_namehash();
    var NamingService_1 = require_NamingService();
    var configurationError_1 = __importStar(require_configurationError());
    var Zns = (
      /** @class */
      function(_super) {
        __extends(Zns2, _super);
        function Zns2(source) {
          if (source === void 0) {
            source = {
              url: Zns2.UrlMap[1],
              network: "mainnet"
            };
          }
          var _this = _super.call(this) || this;
          _this.name = publicTypes_1.NamingServiceName.ZNS;
          _this.checkNetworkConfig(source);
          _this.network = Zns2.NetworkNameMap[source.network];
          _this.url = source["url"] || Zns2.UrlMap[_this.network];
          _this.provider = source["provider"] || new FetchProvider_1.default(_this.name, _this.url);
          _this.registryAddr = source["registryAddress"] || Zns2.RegistryMap[_this.network];
          _this.checkRegistryAddress(_this.registryAddr);
          if (_this.registryAddr.startsWith("0x")) {
            _this.registryAddr = (0, znsUtils_1.toBech32Address)(_this.registryAddr);
          }
          return _this;
        }
        Zns2.prototype.owner = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var recordAddresses, ownerAddress;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getRecordsAddresses(domain)];
                case 1:
                  recordAddresses = _a.sent();
                  if (!recordAddresses) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  ownerAddress = recordAddresses[0];
                  if (!ownerAddress) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  return [2, ownerAddress];
              }
            });
          });
        };
        Zns2.prototype.resolver = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var recordsAddresses, resolverAddress;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getRecordsAddresses(domain)];
                case 1:
                  recordsAddresses = _a.sent();
                  if (!recordsAddresses || !recordsAddresses[0]) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  resolverAddress = recordsAddresses[1];
                  if ((0, utils_1.isNullAddress)(resolverAddress)) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                      domain
                    });
                  }
                  return [2, resolverAddress];
              }
            });
          });
        };
        Zns2.prototype.namehash = function(domain) {
          if (!this.checkDomain(domain)) {
            throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
              domain
            });
          }
          return (0, namehash_1.znsNamehash)(domain);
        };
        Zns2.prototype.childhash = function(parentHash, label) {
          return (0, namehash_1.znsChildhash)(parentHash, label);
        };
        Zns2.prototype.isSupportedDomain = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.checkDomain(domain)];
            });
          });
        };
        Zns2.prototype.record = function(domain, key) {
          return __awaiter(this, void 0, void 0, function() {
            var records, record;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.records(domain, [key])];
                case 1:
                  records = _a.sent();
                  record = records[key];
                  if (!record) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      domain,
                      recordName: key
                    });
                  }
                  return [2, record];
              }
            });
          });
        };
        Zns2.prototype.records = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            var records;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.allRecords(domain)];
                case 1:
                  records = _a.sent();
                  return [2, (0, utils_1.constructRecords)(keys, records)];
              }
            });
          });
        };
        Zns2.prototype.allRecords = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var resolverAddress;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.resolver(domain)];
                case 1:
                  resolverAddress = _a.sent();
                  return [2, this.getResolverRecords(resolverAddress)];
              }
            });
          });
        };
        Zns2.prototype.twitter = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                domain,
                methodName: "twitter"
              });
            });
          });
        };
        Zns2.prototype.reverse = function(address, currencyTicker) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "reverse"
              });
            });
          });
        };
        Zns2.prototype.reverseOf = function(address, location) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "reverseOf"
              });
            });
          });
        };
        Zns2.prototype.isRegistered = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var recordAddresses;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getRecordsAddresses(domain)];
                case 1:
                  recordAddresses = _a.sent();
                  return [2, Boolean(recordAddresses && recordAddresses[0])];
              }
            });
          });
        };
        Zns2.prototype.getTokenUri = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "getTokenUri"
              });
            });
          });
        };
        Zns2.prototype.getDomainFromTokenId = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "getDomainFromTokenId"
              });
            });
          });
        };
        Zns2.prototype.isAvailable = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.isRegistered(domain)];
                case 1:
                  return [2, !_a.sent()];
              }
            });
          });
        };
        Zns2.prototype.registryAddress = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.registryAddr];
            });
          });
        };
        Zns2.prototype.locations = function(domains) {
          return __awaiter(this, void 0, void 0, function() {
            var recordsAddresses;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Promise.all(domains.map(function(domain) {
                    return _this.getRecordsAddresses(domain);
                  }))];
                case 1:
                  recordsAddresses = _a.sent();
                  return [2, domains.reduce(function(locations, domain, i) {
                    var _a2;
                    var location = null;
                    var domainRecordsAddresses = recordsAddresses[i];
                    if (domainRecordsAddresses) {
                      var ownerAddress = domainRecordsAddresses[0], resolverAddress = domainRecordsAddresses[1];
                      location = {
                        registryAddress: _this.registryAddr,
                        resolverAddress,
                        networkId: _this.network,
                        blockchain: publicTypes_1.BlockchainType.ZIL,
                        ownerAddress,
                        blockchainProviderUrl: _this.url
                      };
                    }
                    return __assign(__assign({}, locations), (_a2 = {}, _a2[domain] = location, _a2));
                  }, {})];
              }
            });
          });
        };
        Zns2.prototype.getRecordsAddresses = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var registryRecord, _a, ownerAddress, resolverAddress;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!this.isSupportedDomain(domain)) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                      domain
                    });
                  }
                  return [4, this.getContractMapValue(this.registryAddr, "records", this.namehash(domain))];
                case 1:
                  registryRecord = _b.sent();
                  if (!registryRecord) {
                    return [2, void 0];
                  }
                  _a = registryRecord.arguments, ownerAddress = _a[0], resolverAddress = _a[1];
                  return [2, [
                    ownerAddress.startsWith("0x") ? (0, znsUtils_1.toBech32Address)(ownerAddress) : ownerAddress,
                    resolverAddress
                  ]];
              }
            });
          });
        };
        Zns2.prototype.getResolverRecords = function(resolverAddress) {
          return __awaiter(this, void 0, void 0, function() {
            var resolver;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if ((0, utils_1.isNullAddress)(resolverAddress)) {
                    return [2, {}];
                  }
                  resolver = (0, znsUtils_1.toChecksumAddress)(resolverAddress);
                  return [4, this.getContractField(resolver, "records")];
                case 1:
                  return [2, _a.sent() || {}];
              }
            });
          });
        };
        Zns2.prototype.fetchSubState = function(contractAddress, field, keys) {
          if (keys === void 0) {
            keys = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var params, method;
            return __generator(this, function(_a) {
              params = [contractAddress.replace("0x", ""), field, keys];
              method = "GetSmartContractSubState";
              return [2, this.provider.request({ method, params })];
            });
          });
        };
        Zns2.prototype.getContractField = function(contractAddress, field, keys) {
          if (keys === void 0) {
            keys = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var contractAddr, result;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  contractAddr = contractAddress.startsWith("zil1") ? (0, znsUtils_1.fromBech32Address)(contractAddress) : contractAddress;
                  return [4, this.fetchSubState(contractAddr, field, keys)];
                case 1:
                  result = _a.sent() || {};
                  return [2, result[field]];
              }
            });
          });
        };
        Zns2.prototype.getContractMapValue = function(contractAddress, field, key) {
          return __awaiter(this, void 0, void 0, function() {
            var record;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getContractField(contractAddress, field, [key])];
                case 1:
                  record = _a.sent();
                  return [2, record && record[key] || null];
              }
            });
          });
        };
        Zns2.prototype.checkDomain = function(domain) {
          var tokens = domain.split(".");
          return !!tokens.length && tokens[tokens.length - 1] === "zil" && tokens.every(function(v) {
            return !!v.length;
          });
        };
        Zns2.prototype.checkNetworkConfig = function(source) {
          if (!source.network) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnsupportedNetwork, {
              method: publicTypes_1.NamingServiceName.ZNS
            });
          }
          if (!types_1.ZnsSupportedNetwork.guard(source.network)) {
            this.checkCustomNetworkConfig(source);
          }
        };
        Zns2.prototype.checkRegistryAddress = function(address) {
          var addressValidator = new RegExp("^0x[a-fA-F0-9]{40}$|^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$");
          if (!addressValidator.test(address)) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.InvalidConfigurationField, {
              method: this.name,
              field: "registryAddress"
            });
          }
        };
        Zns2.prototype.checkCustomNetworkConfig = function(source) {
          if (!source.registryAddress) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.CustomNetworkConfigMissing, {
              method: publicTypes_1.NamingServiceName.ZNS,
              config: "registryAddress"
            });
          }
          if (!source["url"] && !source["provider"]) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.CustomNetworkConfigMissing, {
              method: publicTypes_1.NamingServiceName.ZNS,
              config: "url or provider"
            });
          }
        };
        Zns2.UrlMap = {
          1: "https://api.zilliqa.com",
          333: "https://dev-api.zilliqa.com",
          111: "http://localhost:4201"
        };
        Zns2.NetworkNameMap = {
          mainnet: 1,
          testnet: 333,
          localnet: 111
        };
        Zns2.RegistryMap = {
          1: "zil1jcgu2wlx6xejqk9jw3aaankw6lsjzeunx2j0jz",
          333: "zil1hyj6m5w4atcn7s806s69r0uh5g4t84e8gp6nps"
        };
        return Zns2;
      }(NamingService_1.NamingService)
    );
    exports.default = Zns;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/recoverSignature.js
var require_recoverSignature = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/recoverSignature.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recover = exports.hashMessage = void 0;
    var js_sha3_1 = require_sha3();
    var index_1 = require_utils();
    var elliptic_1 = require_elliptic();
    var secp256k1 = new elliptic_1.ec("secp256k1");
    var bytesLength = function(a) {
      return (a.length - 2) / 2;
    };
    var bytesSlice = function(i, j, bs) {
      return "0x" + bs.slice(i * 2 + 2, j * 2 + 2);
    };
    var bytesToNumber = function(hex) {
      return parseInt(hex.slice(2), 16);
    };
    var decodeSignature = function(hex) {
      return [
        bytesSlice(64, bytesLength(hex), hex),
        bytesSlice(0, 32, hex),
        bytesSlice(32, 64, hex)
      ];
    };
    var toChecksum = function(address) {
      var addressHash = (0, js_sha3_1.keccak256)(address.slice(2));
      var checksumAddress = "0x";
      for (var i = 0; i < 40; i++) {
        checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];
      }
      return checksumAddress;
    };
    var hashMessage = function(message) {
      var messageBytes = (0, index_1.hexToBytes)(Buffer.from(message, "utf8").toString("hex"));
      var messageBuffer = Buffer.from(messageBytes);
      var preamble = "Ethereum Signed Message:\n" + messageBytes.length;
      var preambleBuffer = Buffer.from(preamble);
      var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
      return "0x" + (0, js_sha3_1.keccak256)(ethMessage.toString());
    };
    exports.hashMessage = hashMessage;
    var recover = function(message, signature) {
      var hash = (0, exports.hashMessage)(message);
      var vals = decodeSignature(signature);
      var vrs = {
        v: bytesToNumber(vals[0]),
        r: vals[1].slice(2),
        s: vals[2].slice(2)
      };
      var ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), "hex"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2);
      var publicKey = "0x" + ecPublicKey.encode("hex", false).slice(2);
      var publicHash = "0x" + (0, js_sha3_1.keccak256)((0, index_1.hexToBytes)(publicKey));
      return toChecksum("0x" + publicHash.slice(-40));
    };
    exports.recover = recover;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/TwitterSignatureValidator.js
var require_TwitterSignatureValidator = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/TwitterSignatureValidator.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidTwitterSignature = void 0;
    var index_1 = require_utils();
    var js_sha3_1 = require_sha3();
    var recoverSignature_1 = require_recoverSignature();
    var namehash_1 = require_namehash();
    var TwitterVerificationAddress = "0x12cfb13522F13a78b650a8bCbFCf50b7CB899d82";
    var isValidTwitterSignature = function(_a) {
      var tokenId = _a.tokenId, owner = _a.owner, twitterHandle = _a.twitterHandle, validationSignature = _a.validationSignature;
      var tokenIdInDecimals = (0, namehash_1.fromHexStringToDecimals)(tokenId);
      var message = [
        tokenIdInDecimals,
        owner,
        "social.twitter.username",
        twitterHandle
      ].map(function(value) {
        return "0x" + (0, js_sha3_1.keccak256)(value.startsWith("0x") ? (0, index_1.hexToBytes)(value) : value);
      }).reduce(function(message2, hashedValue) {
        return message2 + hashedValue;
      }, "");
      var signerAddress = (0, recoverSignature_1.recover)(message, validationSignature);
      return signerAddress === TwitterVerificationAddress;
    };
    exports.isValidTwitterSignature = isValidTwitterSignature;
  }
});

// node_modules/@unstoppabledomains/resolution/build/contracts/EthereumContract.js
var require_EthereumContract = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/contracts/EthereumContract.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var abi_1 = (init_lib(), __toCommonJS(lib_exports));
    var EthereumContract = (
      /** @class */
      function() {
        function EthereumContract2(abi, address, provider) {
          this.abi = abi;
          this.address = address;
          this.provider = provider;
          this.coder = new abi_1.Interface(this.abi);
        }
        EthereumContract2.prototype.call = function(method, args) {
          return __awaiter(this, void 0, void 0, function() {
            var inputParam, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  inputParam = this.coder.encodeFunctionData(method, args);
                  return [4, this.callEth(inputParam)];
                case 1:
                  response = _a.sent();
                  if (!response || response === "0x") {
                    return [2, []];
                  }
                  return [2, this.coder.decodeFunctionResult(method, response)];
              }
            });
          });
        };
        EthereumContract2.prototype.multicall = function(callArgs) {
          return __awaiter(this, void 0, void 0, function() {
            var methods, _i, callArgs_1, call, inputParam, response, multicallResult, results, i;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  methods = [];
                  for (_i = 0, callArgs_1 = callArgs; _i < callArgs_1.length; _i++) {
                    call = callArgs_1[_i];
                    methods.push(this.coder.encodeFunctionData(call.method, call.args));
                  }
                  inputParam = this.coder.encodeFunctionData("multicall", [methods]);
                  return [4, this.callEth(inputParam)];
                case 1:
                  response = _a.sent();
                  if (!response || response === "0x") {
                    return [2, []];
                  }
                  multicallResult = this.coder.decodeFunctionResult("multicall", response);
                  results = [];
                  for (i = 0; i < multicallResult.results.length; i++) {
                    results.push(this.coder.decodeFunctionResult(callArgs[i].method, multicallResult.results[i]));
                  }
                  return [2, results];
              }
            });
          });
        };
        EthereumContract2.prototype.fetchLogs = function(eventName, tokenId, fromBlock) {
          if (fromBlock === void 0) {
            fromBlock = "earliest";
          }
          return __awaiter(this, void 0, void 0, function() {
            var topic, params, request;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  topic = this.coder.getEventTopic(eventName);
                  params = [
                    {
                      fromBlock,
                      toBlock: "latest",
                      address: this.address,
                      topics: [topic, tokenId]
                    }
                  ];
                  request = {
                    method: "eth_getLogs",
                    params
                  };
                  return [4, this.provider.request(request)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        EthereumContract2.prototype.callEth = function(data) {
          return __awaiter(this, void 0, void 0, function() {
            var params, request;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  params = [
                    {
                      data,
                      to: this.address
                    },
                    "latest"
                  ];
                  request = {
                    method: "eth_call",
                    params
                  };
                  return [4, this.provider.request(request)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return EthereumContract2;
      }()
    );
    exports.default = EthereumContract;
  }
});

// node_modules/@unstoppabledomains/resolution/build/contracts/uns/proxyReader.js
var require_proxyReader = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/contracts/uns/proxyReader.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = [
      {
        inputs: [
          {
            internalType: "contract IUNSRegistry",
            name: "unsRegistry",
            type: "address"
          },
          {
            internalType: "contract ICNSRegistry",
            name: "cnsRegistry",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "NAME",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "VERSION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "label",
            type: "string"
          }
        ],
        name: "childIdOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "exists",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "key",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "get",
        outputs: [
          {
            internalType: "string",
            name: "value",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "keyHash",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getByHash",
        outputs: [
          {
            internalType: "string",
            name: "key",
            type: "string"
          },
          {
            internalType: "string",
            name: "value",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getData",
        outputs: [
          {
            internalType: "address",
            name: "resolver",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "string[]",
            name: "values",
            type: "string[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256[]",
            name: "keyHashes",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getDataByHash",
        outputs: [
          {
            internalType: "address",
            name: "resolver",
            type: "address"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "string[]",
            name: "values",
            type: "string[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256[]",
            name: "keyHashes",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
          }
        ],
        name: "getDataByHashForMany",
        outputs: [
          {
            internalType: "address[]",
            name: "resolvers",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          },
          {
            internalType: "string[][]",
            name: "keys",
            type: "string[][]"
          },
          {
            internalType: "string[][]",
            name: "values",
            type: "string[][]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
          }
        ],
        name: "getDataForMany",
        outputs: [
          {
            internalType: "address[]",
            name: "resolvers",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          },
          {
            internalType: "string[][]",
            name: "values",
            type: "string[][]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getMany",
        outputs: [
          {
            internalType: "string[]",
            name: "values",
            type: "string[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256[]",
            name: "keyHashes",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "getManyByHash",
        outputs: [
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "string[]",
            name: "values",
            type: "string[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "isApprovedOrOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "results",
            type: "bytes[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
          }
        ],
        name: "ownerOfForMany",
        outputs: [
          {
            internalType: "address[]",
            name: "owners",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "registryOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "resolverOf",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "addr", type: "address" }],
        name: "reverseOf",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// node_modules/@unstoppabledomains/resolution/build/config/uns-config.json
var require_uns_config = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/config/uns-config.json"(exports, module) {
    module.exports = {
      version: "0.4.0",
      networks: {
        "1": {
          contracts: {
            UNSRegistry: {
              address: "0x049aba7510f45BA5b64ea9E658E342F904DB358D",
              implementation: "0xa715562307AA8AEDCba976b3793b3337F371c14a",
              legacyAddresses: [],
              deploymentBlock: "0xd62e9d",
              forwarder: "0x049aba7510f45BA5b64ea9E658E342F904DB358D"
            },
            CNSRegistry: {
              address: "0xD1E5b0FF1287aA9f9A268759062E4Ab08b9Dacbe",
              legacyAddresses: [],
              deploymentBlock: "0x8a958b",
              forwarder: "0x97B0E89fC1B7eD4A8B237D9d8Fcce9b234f25A37"
            },
            MintingManager: {
              address: "0x2a7084870bB724175a3C96Da8FaA55128fa3E19D",
              implementation: "0x8caAeaD19aab5f54C94BB9F4be32e200E54AC8D7",
              legacyAddresses: [],
              deploymentBlock: "0xc2fee0",
              forwarder: "0xb970fbCF52cd8111c76c379D4f2FE12E7f8AE7fb"
            },
            ProxyAdmin: {
              address: "0xAA16DA78110D9A9742c760a1a064F28654Ab93de",
              legacyAddresses: [],
              deploymentBlock: "0xc2fedc"
            },
            SignatureController: {
              address: "0x82EF94294C95aD0930055f31e53A34509227c5f7",
              legacyAddresses: [],
              deploymentBlock: "0x8a95a6"
            },
            MintingController: {
              address: "0xb0EE56339C3253361730F50c08d3d7817ecD60Ca",
              legacyAddresses: [],
              deploymentBlock: "0x8a95aa",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0xd3fF3377b0ceade1303dAF9Db04068ef8a650757",
              legacyAddresses: [],
              deploymentBlock: "0xa76ad3",
              deprecated: true
            },
            URIPrefixController: {
              address: "0x09B091492759737C03da9dB7eDF1CD6BCC3A9d91",
              legacyAddresses: [],
              deploymentBlock: "0x8a95ae",
              deprecated: true
            },
            DomainZoneController: {
              address: "0xeA70777e28E00E81f58b8921fC47F78B8a72eFE7",
              legacyAddresses: [],
              deploymentBlock: "0x98ca20",
              deprecated: true
            },
            Resolver: {
              address: "0xb66DcE2DA6afAAa98F2013446dBCB0f4B0ab2842",
              legacyAddresses: [
                "0xa1cac442be6673c49f8e74ffc7c4fd746f3cbd0d",
                "0x878bc2f3f717766ab69c0a5f9a6144931e61aed3"
              ],
              deploymentBlock: "0x960844",
              forwarder: "0x486eb10E4F48C038513ECAf11585Ca2779768CF2"
            },
            ProxyReader: {
              address: "0x1BDc0fD4fbABeed3E611fd6195fCd5d41dcEF393",
              legacyAddresses: [
                "0x58034A288D2E56B661c9056A0C27273E5460B63c",
                "0xc3C2BAB5e3e52DBF311b2aAcEf2e40344f19494E",
                "0xfEe4D4F0aDFF8D84c12170306507554bC7045878",
                "0xa6E7cEf2EDDEA66352Fd68E5915b60BDbb7309f5",
                "0x7ea9Ee21077F84339eDa9C80048ec6db678642B1"
              ],
              deploymentBlock: "0xde71cd"
            },
            TwitterValidationOperator: {
              address: "0x2F659766E3D08561CA3408FbAba7C0749ab2c402",
              legacyAddresses: ["0xbb486C6E9cF1faA86a6E3eAAFE2e5665C0507855"],
              deploymentBlock: "0xc300b5"
            },
            FreeMinter: {
              address: "0x1fC985cAc641ED5846b631f96F35d9b48Bc3b834",
              legacyAddresses: [],
              deploymentBlock: "0xacc390",
              deprecated: true
            },
            MintableERC721Predicate: {
              address: "0x932532aA4c0174b8453839A6E44eE09Cc615F2b7",
              legacyAddresses: [],
              deploymentBlock: "0xa3cf69"
            },
            RootChainManager: {
              address: "0xA0c68C638235ee32657e8f720a23ceC1bFc77C77",
              legacyAddresses: [],
              deploymentBlock: "0xa3cf4d"
            }
          }
        },
        "4": {
          contracts: {
            UNSRegistry: {
              address: "0x7fb83000B8eD59D3eAD22f0D584Df3a85fBC0086",
              implementation: "0xc479D7A65243f7Eb1641F06a6C04E5F06cb5c4F7",
              legacyAddresses: [],
              deploymentBlock: "0x85e628",
              forwarder: "0x7fb83000B8eD59D3eAD22f0D584Df3a85fBC0086"
            },
            CNSRegistry: {
              address: "0xAad76bea7CFEc82927239415BB18D2e93518ecBB",
              legacyAddresses: [],
              deploymentBlock: "0x7232bc",
              forwarder: "0xdf5CC97216785398D5C77348e68fc9461108f85d"
            },
            MintingManager: {
              address: "0xdAAf99A920D31F4f5720e4667b12b24e54A03070",
              implementation: "0x38Fa95a0AC0E59D6e2845eFADBc17aF0FF9c7089",
              legacyAddresses: [],
              deploymentBlock: "0x85e629",
              forwarder: "0xfB13e29C4D31a48B4Cd61131Cf3b681416e11681"
            },
            ProxyAdmin: {
              address: "0xaf9815005A208d1460b6fC60B4f90B9f2185E88c",
              legacyAddresses: [],
              deploymentBlock: "0x85e627"
            },
            SignatureController: {
              address: "0x66a5e3e2C27B4ce4F46BBd975270BE154748D164",
              legacyAddresses: [],
              deploymentBlock: "0x7232be"
            },
            MintingController: {
              address: "0x51765307AeB3Df2E647014a2C501d5324212467c",
              legacyAddresses: [],
              deploymentBlock: "0x7232bf",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0xbcB32f13f90978a9e059E8Cb40FaA9e6619d98e7",
              legacyAddresses: [],
              deploymentBlock: "0x7232c6",
              deprecated: true
            },
            URIPrefixController: {
              address: "0xe1d2e4B9f0518CA5c803073C3dFa886470627237",
              legacyAddresses: [],
              deploymentBlock: "0x7232c0",
              deprecated: true
            },
            DomainZoneController: {
              address: "0x6f8F96A566663C1d4fEe70edD37E9b62Fe39dE5D",
              legacyAddresses: [],
              deploymentBlock: "0x7232c2",
              deprecated: true
            },
            Resolver: {
              address: "0x95AE1515367aa64C462c71e87157771165B1287A",
              legacyAddresses: [],
              deploymentBlock: "0x7232cf",
              forwarder: "0xE172D8557d6F342b1b2976dE784F6Dff6ABC0a37"
            },
            ProxyReader: {
              address: "0xE6729D224D00b3dd4FC731C4Ee3274E35Da06578",
              legacyAddresses: [
                "0x299974AeD8911bcbd2C61262605b89F591a53E83",
                "0x9F19473F6a98a715176291c930558E1954fd3D1e",
                "0x3A2e74CF832cbA3d77E72708d55370119E4323a6"
              ],
              deploymentBlock: "0x8dc79a"
            },
            TwitterValidationOperator: {
              address: "0x9ea4A63184ebE9CBA55CD1af473D98075Aa02b4C",
              legacyAddresses: ["0x1CB337b3b208dc29a6AcE8d11Bb591b66c5Dd83d"],
              deploymentBlock: "0x86935e"
            },
            FreeMinter: {
              address: "0x84214215904cDEbA9044ECf95F3eBF009185AAf4",
              legacyAddresses: [],
              deploymentBlock: "0x740d93",
              deprecated: true
            }
          }
        },
        "5": {
          contracts: {
            UNSRegistry: {
              address: "0x070e83FCed225184E67c86302493ffFCDB953f71",
              implementation: "0x4473e84898E3F58feEFb7529dfF9E83Ff26CCae9",
              legacyAddresses: [],
              deploymentBlock: "0x5b57ea",
              forwarder: "0x070e83FCed225184E67c86302493ffFCDB953f71"
            },
            CNSRegistry: {
              address: "0x801452cFAC27e79a11c6b185986fdE09e8637589",
              legacyAddresses: [],
              deploymentBlock: "0x5b57d7",
              forwarder: "0x00443017FFaa4C840Caf5Dc7d3CB59147f363080"
            },
            MintingManager: {
              address: "0x9ee42D3EB042e06F8Cd241890C4fA0d51e4DA345",
              implementation: "0xFB11410f3067BB6Db61bC335f0de23bE87A1767e",
              legacyAddresses: [],
              deploymentBlock: "0x5b57ec",
              forwarder: "0x7F9F48cF94C69ce91D4b442DA186F31118ac0185"
            },
            ProxyAdmin: {
              address: "0xf4906E210523F9dA79E33811A44EE000441F4E04",
              legacyAddresses: [],
              deploymentBlock: "0x5b57e8"
            },
            SignatureController: {
              address: "0x5199dAE4B24B987ba18FcE1b64664D1B798d372B",
              legacyAddresses: [],
              deploymentBlock: "0x5b57d8"
            },
            MintingController: {
              address: "0xCEC41677be322049cC885c0DAe2fE0D52CA195ca",
              legacyAddresses: [],
              deploymentBlock: "0x5b57d9",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            URIPrefixController: {
              address: "0x29465e3d2daA588E62375977bCe9b3f51406a794",
              legacyAddresses: [],
              deploymentBlock: "0x5b57da",
              deprecated: true
            },
            DomainZoneController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            Resolver: {
              address: "0x0555344A5F440Bd1d8cb6B42db46c5e5D4070437",
              legacyAddresses: [],
              deploymentBlock: "0x5b57dc",
              forwarder: "0xFCc1A95B7287Ae7a8B7cA813F12991dF5714d4C7"
            },
            ProxyReader: {
              address: "0xE3b961856C417d081a02cBa0161a051268F52677",
              legacyAddresses: [
                "0x9A70ff906D422C2FD0F7B94244D6b36DB62Ee982",
                "0xFc5f608149f4D9e2Ed0733efFe9DD57ee24BCF68"
              ],
              deploymentBlock: "0x65bdfe"
            },
            TwitterValidationOperator: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            FreeMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            MintableERC721Predicate: {
              address: "0x56E14C4C1748a818a5564D33cF774c59EB3eDF59",
              legacyAddresses: [],
              deploymentBlock: "0x2fc240"
            },
            RootChainManager: {
              address: "0xBbD7cBFA79faee899Eaf900F13C9065bF03B1A74",
              legacyAddresses: [],
              deploymentBlock: "0x2dc9b9"
            }
          }
        },
        "137": {
          contracts: {
            UNSRegistry: {
              address: "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f",
              legacyAddresses: [],
              deploymentBlock: "0x019d6188",
              implementation: "0x5442953b0BFFf69FC945f5f1387cbFD2e2673447",
              forwarder: "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f"
            },
            CNSRegistry: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              forwarder: "0x0000000000000000000000000000000000000000"
            },
            MintingManager: {
              address: "0x7be83293BeeDc9Eba1bd76c66A65F10F3efaeC26",
              legacyAddresses: [],
              deploymentBlock: "0x01272f41",
              implementation: "0xBb45a6E10224Aa36EAcd812205F3763D353e9783",
              forwarder: "0xC37d3c4326ab0E1D2b9D8b916bBdf5715f780fcF"
            },
            ProxyAdmin: {
              address: "0xe1D668052D52388F52b90f4d1798DB2b04bC3b88",
              legacyAddresses: [],
              deploymentBlock: "0x01272d15"
            },
            SignatureController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            MintingController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            URIPrefixController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            DomainZoneController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            Resolver: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              forwarder: "0x0000000000000000000000000000000000000000"
            },
            ProxyReader: {
              address: "0x3E67b8c702a1292d1CEb025494C84367fcb12b45",
              legacyAddresses: [
                "0x423F2531bd5d3C3D4EF7C318c2D1d9BEDE67c680",
                "0xA3f32c8cd786dc089Bd1fC175F2707223aeE5d00"
              ],
              deploymentBlock: "0x019d61a9"
            },
            TwitterValidationOperator: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            FreeMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            MintableERC721Predicate: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            RootChainManager: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            }
          }
        },
        "1337": {
          contracts: {
            UNSRegistry: {
              address: "0x58a175BEbc8ec21A94ea63Aa5a28743945940EE6",
              legacyAddresses: [],
              deploymentBlock: "0x0d",
              implementation: "0xe0aFC4e9E03e4aa67257Df7A2Eca77454309789D",
              forwarder: "0x58a175BEbc8ec21A94ea63Aa5a28743945940EE6"
            },
            CNSRegistry: {
              address: "0xC58206842E4030a3B2CaBC78780Ae7635173C533",
              legacyAddresses: [],
              deploymentBlock: "0x01",
              forwarder: "0xAc52F68f31577E44aE0C7E95A42dC9eb574B9383"
            },
            MintingManager: {
              address: "0x27935e7e85db3c4e7885eB828B9e889BA69a4e7f",
              legacyAddresses: [],
              deploymentBlock: "0x0f",
              implementation: "0xa1A2114B0C4bDF9AEe05fdd80801e6267639FAd9",
              forwarder: "0xC20631145b77a58018E2b10f2282Dd048E12fC81"
            },
            ProxyAdmin: {
              address: "0xbE5dEAC45dd1ca4ee18Dc2D585D84D3d3CB82B0D",
              legacyAddresses: [],
              deploymentBlock: "0x01"
            },
            SignatureController: {
              address: "0x7bB6Cd9be29fab783c0b494A06FED8b2E2596B7a",
              legacyAddresses: [],
              deploymentBlock: "0x02"
            },
            MintingController: {
              address: "0x4a3C194eB88966178bfDD81744ddDafED611B830",
              legacyAddresses: [],
              deploymentBlock: "0x03",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            URIPrefixController: {
              address: "0x4872CC1be60A9DB9c880A0A437Da7a6AF134F08f",
              legacyAddresses: [],
              deploymentBlock: "0x04",
              deprecated: true
            },
            DomainZoneController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            Resolver: {
              address: "0xF8C26340C1eAeA6c7fF1760B25005e1306953572",
              legacyAddresses: [],
              deploymentBlock: "0x08",
              forwarder: "0x11dD97b7Ca847DfB6504e61B7B9Eb30F55E554a0"
            },
            ProxyReader: {
              address: "0x4e44E79e0cEc05D9e62e952B2088c02A3C450aeC",
              legacyAddresses: [],
              deploymentBlock: "0x14"
            },
            TwitterValidationOperator: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            FreeMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            MintableERC721Predicate: {
              address: "0x7c3c91245769c8B7450aD522792deC4bd4bf797f",
              legacyAddresses: [],
              deploymentBlock: "0x1b"
            },
            RootChainManager: {
              address: "0x2f5e6eed50C839835BD2873d428E1683793Ad09D",
              legacyAddresses: [],
              deploymentBlock: "0x1d"
            }
          }
        },
        "80001": {
          contracts: {
            UNSRegistry: {
              address: "0x2a93C52E7B6E7054870758e15A1446E769EdfB93",
              legacyAddresses: [],
              deploymentBlock: "0x0189f713",
              implementation: "0xAc1a1F2136BfDe3a353a95C0676Cd0d55f311ee3",
              forwarder: "0x2a93C52E7B6E7054870758e15A1446E769EdfB93"
            },
            CNSRegistry: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              forwarder: "0x0000000000000000000000000000000000000000"
            },
            MintingManager: {
              address: "0x428189346bb3CC52f031A1092fd47C919AC30A9f",
              legacyAddresses: [],
              deploymentBlock: "0x01213f4a",
              implementation: "0xCC17E698bA21bae4277579F22cA51135AaF00777",
              forwarder: "0xEf3a491A8750BEC2Dff5339CF6Df94436d432C4d"
            },
            ProxyAdmin: {
              address: "0x460d63117c7Ab1624b7474C45BF46eC6702f57ce",
              legacyAddresses: [],
              deploymentBlock: "0x01213b22"
            },
            SignatureController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            MintingController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            WhitelistedMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            URIPrefixController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            DomainZoneController: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            Resolver: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              forwarder: "0x0000000000000000000000000000000000000000"
            },
            ProxyReader: {
              address: "0x6fe7c857C1B0E54492C8762f27e0a45CA7ff264B",
              legacyAddresses: [
                "0xbd9e01F6513E7C05f71Bf21d419a3bDF1EA9104b",
                "0x332A8191905fA8E6eeA7350B5799F225B8ed30a9"
              ],
              deploymentBlock: "0x0189f72d"
            },
            TwitterValidationOperator: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            FreeMinter: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0",
              deprecated: true
            },
            MintableERC721Predicate: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            },
            RootChainManager: {
              address: "0x0000000000000000000000000000000000000000",
              legacyAddresses: [],
              deploymentBlock: "0x0"
            }
          }
        }
      }
    };
  }
});

// node_modules/@unstoppabledomains/resolution/build/UnsInternal.js
var require_UnsInternal = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/UnsInternal.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var configurationError_1 = __importDefault(require_configurationError());
    var configurationError_2 = require_configurationError();
    var utils_1 = require_utils();
    var FetchProvider_1 = __importDefault(require_FetchProvider());
    var EthereumContract_1 = __importDefault(require_EthereumContract());
    var proxyReader_1 = __importDefault(require_proxyReader());
    var uns_config_json_1 = __importDefault(require_uns_config());
    var resolutionError_1 = __importStar(require_resolutionError());
    var namehash_1 = require_namehash();
    var UnsInternal = (
      /** @class */
      function() {
        function UnsInternal2(unsLocation, source, blockchain) {
          this.unsLocation = unsLocation;
          this.checkNetworkConfig(unsLocation, source);
          this.network = source.network;
          this.blockchain = blockchain;
          this.url = source["url"] || UnsInternal2.UrlMap[this.network];
          this.provider = source["provider"] || new FetchProvider_1.default(this.unsLocation, this.url);
          this.readerContract = new EthereumContract_1.default(proxyReader_1.default, source.proxyReaderAddress || UnsInternal2.ProxyReaderMap[utils_1.EthereumNetworks[this.network]], this.provider);
        }
        UnsInternal2.prototype.exists = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var exists;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.readerContract.call("exists", [
                    this.namehash(domain)
                  ])];
                case 1:
                  exists = _a.sent()[0];
                  return [2, exists];
              }
            });
          });
        };
        UnsInternal2.prototype.reverseOf = function(addr) {
          return __awaiter(this, void 0, void 0, function() {
            var reverseHash;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.readerContract.call("reverseOf", [addr])];
                case 1:
                  reverseHash = _a.sent()[0];
                  return [2, reverseHash];
              }
            });
          });
        };
        UnsInternal2.prototype.getTokenUri = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenURI;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.readerContract.call("tokenURI", [tokenId])];
                case 1:
                  tokenURI = _a.sent()[0];
                  return [2, tokenURI];
              }
            });
          });
        };
        UnsInternal2.prototype.registryAddress = function(domainOrNamehash) {
          return __awaiter(this, void 0, void 0, function() {
            var isNamehash, namehash, address;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  isNamehash = !domainOrNamehash.includes(".");
                  if (!this.checkDomain(domainOrNamehash, isNamehash)) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                      domain: domainOrNamehash
                    });
                  }
                  namehash = isNamehash ? domainOrNamehash : this.namehash(domainOrNamehash);
                  return [4, this.readerContract.call("registryOf", [namehash])];
                case 1:
                  address = _a.sent()[0];
                  if ((0, utils_1.isNullAddress)(address)) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain: domainOrNamehash
                    });
                  }
                  return [2, address];
              }
            });
          });
        };
        UnsInternal2.prototype.resolver = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getVerifiedData(domain)];
                case 1:
                  return [2, _a.sent().resolver];
              }
            });
          });
        };
        UnsInternal2.prototype.get = function(tokenId, keys) {
          if (keys === void 0) {
            keys = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a, resolver, owner, values;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.readerContract.call("getData", [keys, tokenId])];
                case 1:
                  _a = _b.sent(), resolver = _a[0], owner = _a[1], values = _a[2];
                  return [2, {
                    owner,
                    resolver,
                    records: (0, utils_1.constructRecords)(keys, values),
                    location: this.unsLocation
                  }];
              }
            });
          });
        };
        UnsInternal2.prototype.locations = function(domains) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenIds, _a, _b, resolvers, owners, registries, locations;
            var _this = this;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  tokenIds = domains.map(function(d) {
                    return _this.namehash(d);
                  });
                  return [4, this.readerContract.multicall(__spreadArray([
                    {
                      method: "getDataForMany",
                      args: [[], tokenIds]
                    }
                  ], tokenIds.map(function(id) {
                    return {
                      method: "registryOf",
                      args: [id]
                    };
                  }), true))];
                case 1:
                  _a = _c.sent(), _b = _a[0], resolvers = _b[0], owners = _b[1], registries = _a.slice(1);
                  locations = domains.reduce(function(locations2, domain, i) {
                    locations2[domain] = null;
                    if (owners && owners[i] !== types_1.NullAddress) {
                      locations2[domain] = {
                        resolverAddress: resolvers[i],
                        registryAddress: registries[i][0],
                        ownerAddress: owners[i],
                        networkId: utils_1.EthereumNetworks[_this.network],
                        blockchain: _this.blockchain,
                        blockchainProviderUrl: _this.url
                      };
                    }
                    return locations2;
                  }, {});
                  return [2, locations];
              }
            });
          });
        };
        UnsInternal2.prototype.namehash = function(domain) {
          if (!this.checkDomain(domain)) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
              domain
            });
          }
          return (0, namehash_1.eip137Namehash)(domain);
        };
        UnsInternal2.prototype.checkDomain = function(domain, passIfTokenID) {
          if (passIfTokenID === void 0) {
            passIfTokenID = false;
          }
          if (passIfTokenID) {
            return true;
          }
          var tokens = domain.split(".");
          return !!tokens.length && !(domain === "eth" || /^[^-]*[^-]*\.(eth|luxe|xyz|kred|addr\.reverse)$/.test(domain)) && tokens.every(function(v) {
            return !!v.length;
          });
        };
        UnsInternal2.prototype.getVerifiedData = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId, data;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = this.namehash(domain);
                  return [4, this.get(tokenId, keys)];
                case 1:
                  data = _a.sent();
                  if ((0, utils_1.isNullAddress)(data.resolver)) {
                    if ((0, utils_1.isNullAddress)(data.owner)) {
                      throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                        domain
                      });
                    }
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                      location: this.unsLocation,
                      domain
                    });
                  }
                  return [2, data];
              }
            });
          });
        };
        UnsInternal2.prototype.checkNetworkConfig = function(location, source) {
          if (!source.network) {
            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.UnsupportedNetwork, {
              method: location
            });
          }
          if (source.proxyReaderAddress && !this.isValidProxyReader(source.proxyReaderAddress)) {
            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.InvalidConfigurationField, {
              method: this.unsLocation,
              field: "proxyReaderAddress"
            });
          }
          if (!types_1.UnsSupportedNetwork.guard(source.network)) {
            this.checkCustomNetworkConfig(source);
          }
        };
        UnsInternal2.prototype.checkCustomNetworkConfig = function(source) {
          if (!this.isValidProxyReader(source.proxyReaderAddress)) {
            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.InvalidConfigurationField, {
              method: this.unsLocation,
              field: "proxyReaderAddress"
            });
          }
          if (!source["url"] && !source["provider"]) {
            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.CustomNetworkConfigMissing, {
              method: this.unsLocation,
              config: "url or provider"
            });
          }
        };
        UnsInternal2.prototype.isValidProxyReader = function(address) {
          if (!address) {
            throw new configurationError_1.default(configurationError_2.ConfigurationErrorCode.CustomNetworkConfigMissing, {
              method: this.unsLocation,
              config: "proxyReaderAddress"
            });
          }
          var ethLikePattern = new RegExp("^0x[a-fA-F0-9]{40}$");
          return ethLikePattern.test(address);
        };
        UnsInternal2.ProxyReaderMap = getProxyReaderMap();
        UnsInternal2.UrlMap = {
          mainnet: "https://mainnet.infura.io/v3/c4bb906ed6904c42b19c95825fe55f39",
          rinkeby: "https://eth-rinkeby.alchemyapi.io/v2/ZDERxOLIj120dh2-Io2Q9RTh9RfWEssT",
          goerli: "https://goerli.infura.io/v3/c4bb906ed6904c42b19c95825fe55f39",
          "polygon-mainnet": "https://polygon-mainnet.infura.io/v3/c4bb906ed6904c42b19c95825fe55f39",
          "polygon-mumbai": "https://polygon-mumbai.infura.io/v3/c4bb906ed6904c42b19c95825fe55f39"
        };
        return UnsInternal2;
      }()
    );
    exports.default = UnsInternal;
    function getProxyReaderMap() {
      var map = {};
      for (var _i = 0, _a = Object.keys(uns_config_json_1.default.networks); _i < _a.length; _i++) {
        var id = _a[_i];
        map[id] = uns_config_json_1.default.networks[id].contracts.ProxyReader.address.toLowerCase();
      }
      return map;
    }
  }
});

// node_modules/@unstoppabledomains/resolution/build/config/resolver-keys.json
var require_resolver_keys = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/config/resolver-keys.json"(exports, module) {
    module.exports = {
      version: "2.1.1",
      information: {
        description: "This file desribes all resolver keys with a defined meaning and related metadata used by Unstoppable Domains UNS Registry",
        documentation: "https://docs.unstoppabledomains.com/domain-registry-essentials/records-reference",
        contribution: "https://github.com/unstoppabledomains/uns/blob/main/resolver-keys.json"
      },
      keys: {
        "crypto.BTC.address": {
          deprecatedKeyName: "BTC",
          deprecated: false,
          validationRegex: "^bc1[ac-hj-np-z02-9]{6,87}$|^[13][a-km-zA-HJ-NP-Z1-9]{25,39}$"
        },
        "crypto.ETH.address": {
          deprecatedKeyName: "ETH",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.ZIL.address": {
          deprecatedKeyName: "ZIL",
          deprecated: false,
          validationRegex: "^zil1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}$"
        },
        "crypto.LTC.address": {
          deprecatedKeyName: "LTC",
          deprecated: false,
          validationRegex: "^[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}$|^ltc1[a-zA-HJ-NP-Z0-9]{25,39}$"
        },
        "crypto.ETC.address": {
          deprecatedKeyName: "ETC",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.EQL.address": {
          deprecatedKeyName: "EQL",
          deprecated: false,
          validationRegex: "^bnb[0-9a-z]{39}$"
        },
        "crypto.LINK.address": {
          deprecatedKeyName: "LINK",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.USDC.address": {
          deprecatedKeyName: "USDC",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.BAT.address": {
          deprecatedKeyName: "BAT",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.REP.address": {
          deprecatedKeyName: "REP",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.ZRX.address": {
          deprecatedKeyName: "ZRX",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.DAI.address": {
          deprecatedKeyName: "DAI",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.BCH.address": {
          deprecatedKeyName: "BCH",
          deprecated: false,
          validationRegex: "^[13][a-km-zA-HJ-NP-Z1-9]{33}$|^((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}$|^((BITCOINCASH:)?(Q|P)[A-Z0-9]{41})$"
        },
        "crypto.XMR.address": {
          deprecatedKeyName: "XMR",
          deprecated: false,
          validationRegex: "^[48]{1}[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$"
        },
        "crypto.DASH.address": {
          deprecatedKeyName: "DASH",
          deprecated: false,
          validationRegex: "^X[1-9A-HJ-NP-Za-km-z]{33}$"
        },
        "crypto.NEO.address": {
          deprecatedKeyName: "NEO",
          deprecated: false,
          validationRegex: "^A[0-9a-zA-Z]{33}$"
        },
        "crypto.SWTH.address": {
          deprecatedKeyName: "SWTH",
          deprecated: false,
          validationRegex: "^A[0-9a-zA-Z]{33}$"
        },
        "crypto.DOGE.address": {
          deprecatedKeyName: "DOGE",
          deprecated: false,
          validationRegex: "^D[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}$"
        },
        "crypto.XRP.address": {
          deprecatedKeyName: "XRP",
          deprecated: false,
          validationRegex: "^r[1-9a-km-zA-HJ-NP-Z]{24,34}$"
        },
        "crypto.ZEC.address": {
          deprecatedKeyName: "ZEC",
          deprecated: false,
          validationRegex: "^z([a-zA-Z0-9]){94}$|^zs1([a-zA-Z0-9]){75}$|^t([a-zA-Z0-9]){34}$"
        },
        "crypto.YEC.address": {
          deprecatedKeyName: "YEC",
          deprecated: false,
          validationRegex: "^y([a-zA-Z0-9]){94}$|^ys1([a-zA-Z0-9]){75}$|^s([a-zA-Z0-9]){34}$"
        },
        "crypto.ADA.address": {
          deprecatedKeyName: "ADA",
          deprecated: false,
          validationRegex: "^[1-9a-km-zA-HJ-NP-Z]{104}$|^A[1-9A-HJ-NP-Za-km-z]{58}$|^addr[0-9a-zA-Z]{99}$"
        },
        "crypto.EOS.address": {
          deprecatedKeyName: "EOS",
          deprecated: false,
          validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$"
        },
        "crypto.XLM.address": {
          deprecatedKeyName: "XLM",
          deprecated: false,
          validationRegex: "^G[A-Z2-7]{55}$"
        },
        "crypto.BNB.address": {
          deprecatedKeyName: "BNB",
          deprecated: false,
          validationRegex: "^bnb[0-9a-z]{39}$"
        },
        "crypto.BTG.address": {
          deprecatedKeyName: "BTG",
          deprecated: false,
          validationRegex: "^[GA][a-km-zA-HJ-NP-Z1-9]{33}$"
        },
        "crypto.NANO.address": {
          deprecatedKeyName: "NANO",
          deprecated: false,
          validationRegex: "^nano_[1-9a-z]{60}$"
        },
        "crypto.WAVES.address": {
          deprecatedKeyName: "WAVES",
          deprecated: false,
          validationRegex: "^3[a-km-zA-HJ-NP-Z1-9]{34}$"
        },
        "crypto.KMD.address": {
          deprecatedKeyName: "KMD",
          deprecated: false,
          validationRegex: "^R[a-km-zA-Z1-9]{33}$"
        },
        "crypto.AE.address": {
          deprecatedKeyName: "AE",
          deprecated: false,
          validationRegex: "^ak_[a-km-zA-Z1-9]{48,52}$"
        },
        "crypto.RSK.address": {
          deprecatedKeyName: "RSK",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.WAN.address": {
          deprecatedKeyName: "WAN",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.STRAT.address": {
          deprecatedKeyName: "STRAT",
          deprecated: false,
          validationRegex: "^S[a-km-zA-HJ-NP-Z1-9]{33}$"
        },
        "crypto.UBQ.address": {
          deprecatedKeyName: "UBQ",
          deprecated: false,
          validationRegex: "^0x[a-km-zA-HJ-NP-Z0-9]{40}$"
        },
        "crypto.XTZ.address": {
          deprecatedKeyName: "XTZ",
          deprecated: false,
          validationRegex: "^(tz|KT)[a-km-zA-HJ-NP-Z1-9]{34}$"
        },
        "crypto.IOTA.address": {
          deprecatedKeyName: "IOTA",
          deprecated: false,
          validationRegex: "^[A-Z0-9]{90}$|^iota1[a-z0-9]{59}$"
        },
        "crypto.VET.address": {
          deprecatedKeyName: "VET",
          deprecated: false,
          validationRegex: "^0x[a-km-zA-HJ-NP-Z0-9]{40}$"
        },
        "crypto.QTUM.address": {
          deprecatedKeyName: "QTUM",
          deprecated: false,
          validationRegex: "^Q[a-km-zA-HJ-NP-Z1-9]{33}$"
        },
        "crypto.ICX.address": {
          deprecatedKeyName: "ICX",
          deprecated: false,
          validationRegex: "^[a-km-zA-HJ-NP-Z0-9]{42}$"
        },
        "crypto.DGB.address": {
          deprecatedKeyName: "DGB",
          deprecated: false,
          validationRegex: "(^[a-km-zA-HJ-NP-Z1-9]{34}$)|(^[a-zA-Z1-9]{42}$)|(^dgb1[a-zA-Z0-9]{39}$)"
        },
        "crypto.XZC.address": {
          deprecatedKeyName: "XZC",
          deprecated: false,
          validationRegex: "^[a-km-zA-HJ-NP-Z1-9]{34}$"
        },
        "crypto.BURST.address": {
          deprecatedKeyName: "BURST",
          deprecated: false,
          validationRegex: "^BURST-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{5}"
        },
        "crypto.DCR.address": {
          deprecatedKeyName: "DCR",
          deprecated: false,
          validationRegex: null
        },
        "crypto.XEM.address": {
          deprecatedKeyName: "XEM",
          deprecated: false,
          validationRegex: "^N[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{39}$"
        },
        "crypto.LSK.address": {
          deprecatedKeyName: "LSK",
          deprecated: false,
          validationRegex: "^\\d{1,21}[L]$"
        },
        "crypto.ATOM.address": {
          deprecatedKeyName: "ATOM",
          deprecated: false,
          validationRegex: "^(cosmos)1([qpzry9x8gf2tvdw0s3jn54khce6mua7l]+)$"
        },
        "crypto.ONG.address": {
          deprecatedKeyName: "ONG",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.ONT.address": {
          deprecatedKeyName: "ONT",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.SMART.address": {
          deprecatedKeyName: "SMART",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.TPAY.address": {
          deprecatedKeyName: "TPAY",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.GRS.address": {
          deprecatedKeyName: "GRS",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.BSV.address": {
          deprecatedKeyName: "BSV",
          deprecated: false,
          validationRegex: "^bitcoincash:[a-zA-Z0-9]{42}$"
        },
        "crypto.GAS.address": {
          deprecatedKeyName: "GAS",
          deprecated: false,
          validationRegex: null
        },
        "crypto.TRX.address": {
          deprecatedKeyName: "TRX",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.VTHO.address": {
          deprecatedKeyName: "VTHO",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{42}$"
        },
        "crypto.BCD.address": {
          deprecatedKeyName: "BCD",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.BTT.address": {
          deprecatedKeyName: "BTT",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.KIN.address": {
          deprecatedKeyName: "KIN",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{56}$"
        },
        "crypto.RVN.address": {
          deprecatedKeyName: "RVN",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.ARK.address": {
          deprecatedKeyName: "ARK",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.XVG.address": {
          deprecatedKeyName: "XVG",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.ALGO.address": {
          deprecatedKeyName: "ALGO",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{58}$"
        },
        "crypto.NEBL.address": {
          deprecatedKeyName: "NEBL",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.XPM.address": {
          deprecatedKeyName: "XPM",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.ONE.address": {
          deprecatedKeyName: "ONE",
          deprecated: false,
          validationRegex: "^one[a-zA-Z0-9]{39}$"
        },
        "crypto.BNTY.address": {
          deprecatedKeyName: "BNTY",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.CRO.address": {
          deprecatedKeyName: "CRO",
          deprecated: false,
          validationRegex: "^0x[a-fA-F0-9]{40}$"
        },
        "crypto.TWT.address": {
          deprecatedKeyName: "TWT",
          deprecated: false,
          validationRegex: "^bnb[0-9a-z]{39}$"
        },
        "crypto.SIERRA.address": {
          deprecatedKeyName: "SIERRA",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{34}$"
        },
        "crypto.VSYS.address": {
          deprecatedKeyName: "VSYS",
          deprecated: false,
          validationRegex: "^[a-zA-Z0-9]{35}$"
        },
        "crypto.HIVE.address": {
          deprecatedKeyName: "HIVE",
          validationRegex: "^(?!s*$).+",
          deprecated: false
        },
        "crypto.HT.address": {
          deprecatedKeyName: "HT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ENJ.address": {
          deprecatedKeyName: "ENJ",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.YFI.address": {
          deprecatedKeyName: "YFI",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MTA.address": {
          deprecatedKeyName: "MTA",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.COMP.address": {
          deprecatedKeyName: "COMP",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BAL.address": {
          deprecatedKeyName: "BAL",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AMPL.address": {
          deprecatedKeyName: "AMPL",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LEND.address": {
          deprecatedKeyName: "LEND",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TLOS.address": {
          deprecatedKeyName: "TLOS",
          validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$",
          deprecated: false
        },
        "crypto.XDC.address": {
          deprecatedKeyName: "XDC",
          validationRegex: "^xdc[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XST.address": {
          deprecatedKeyName: "XST",
          validationRegex: "(?:RwxQ3jUs2BjKhseNX1em4msn2GyV5XAec[PQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|RwxQ3jUs2BjKhseNX1em4msn2GyV5XAe[defghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|RwxQ3jUs2BjKhseNX1em4msn2GyV5XA[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{2}|RwxQ3jUs2BjKhseNX1em4msn2GyV5X[BCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{3}|RwxQ3jUs2BjKhseNX1em4msn2GyV5[YZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{4}|RwxQ3jUs2BjKhseNX1em4msn2GyV[6789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{5}|RwxQ3jUs2BjKhseNX1em4msn2Gy[WXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{6}|RwxQ3jUs2BjKhseNX1em4msn2G[z][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{7}|RwxQ3jUs2BjKhseNX1em4msn2[HJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{8}|RwxQ3jUs2BjKhseNX1em4msn[3456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{9}|RwxQ3jUs2BjKhseNX1em4ms[opqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{10}|RwxQ3jUs2BjKhseNX1em4m[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{11}|RwxQ3jUs2BjKhseNX1em4[nopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{12}|RwxQ3jUs2BjKhseNX1em[56789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{13}|RwxQ3jUs2BjKhseNX1e[nopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{14}|RwxQ3jUs2BjKhseNX1[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{15}|RwxQ3jUs2BjKhseNX[23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{16}|RwxQ3jUs2BjKhseN[YZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{17}|RwxQ3jUs2BjKhse[PQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{18}|RwxQ3jUs2BjKhs[fghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{19}|RwxQ3jUs2BjKh[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{20}|RwxQ3jUs2BjK[ijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}|RwxQ3jUs2Bj[LMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{22}|RwxQ3jUs2B[kmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{23}|RwxQ3jUs2[CDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{24}|RwxQ3jUs[3456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}|RwxQ3jU[tuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26}|RwxQ3j[VWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{27}|RwxQ3[kmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{28}|RwxQ[456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|Rwx[RSTUVWXYZabcdefghijkmnopqrstuvwxyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{30}|Rw[yz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{31}|R[xyz][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{32}|S[123456789ABCDEFGHJKL][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{32}|SM[123456789ABCDEFGH][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{31}|SMJ11[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|SMJ11[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{29}|SMJ12[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnop][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{28}|SMJ12q[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{27}|SMJ12qn[12345678][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{26}|SMJ12qn9[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghi][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{25}|SMJ12qn9j[123456789ABCDEFGHJKLM][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{24}|SMJ12qn9jN[123456789AB][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{23}|SMJ12qn9jNC[123456789AB][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{22}|SMJ12qn9jNCC[123456789ABCDEFGHJKLMNPQRSTUVW][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{21}|SMJ12qn9jNCCX[123456789ABCDEFGH][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{20}|SMJ12qn9jNCCXJ[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{19}|SMJ12qn9jNCCXJn[123456789ABCDEFGHJKLMNPQRS][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{18}|SMJ12qn9jNCCXJnT[123456789ABCDEFGHJKLMNPQRSTUVWX][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{17}|SMJ12qn9jNCCXJnTY[123456789ABCDEFGHJKLMNPQ][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{16}|SMJ12qn9jNCCXJnTYR[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxy][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{15}|SMJ12qn9jNCCXJnTYRz[1234][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{14}|SMJ12qn9jNCCXJnTYRz5[123456789ABCDEFGHJKLMNPQRSTUVWX][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{13}|SMJ12qn9jNCCXJnTYRz5Y[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrst][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{12}|SMJ12qn9jNCCXJnTYRz5Yu[12345678][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{11}|SMJ12qn9jNCCXJnTYRz5Yu9[123456789ABCDEFGHJKLMNPQRSTUVWXY][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{10}|SMJ12qn9jNCCXJnTYRz5Yu9Z[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcd][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{9}|SMJ12qn9jNCCXJnTYRz5Yu9Ze[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{8}|SMJ12qn9jNCCXJnTYRz5Yu9Zen[123456789ABCD][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{7}|SMJ12qn9jNCCXJnTYRz5Yu9ZenE[123456789ABCDEFGHJKLMNPQ][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{6}|SMJ12qn9jNCCXJnTYRz5Yu9ZenER[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkm][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{5}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERn[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghij][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{4}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnk[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghij][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{3}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkk[123456789ABCDEFGHJKLMNPQRST][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{2}|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkkU[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstu][123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]|SMJ12qn9jNCCXJnTYRz5Yu9ZenERnkkUv[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghi])",
          deprecated: false
        },
        "crypto.STRAX.address": {
          deprecatedKeyName: "STRAX",
          validationRegex: "^X[a-km-zA-HJ-NP-Z1-9]{33}$",
          deprecated: false
        },
        "crypto.SIGNA.address": {
          deprecatedKeyName: "SIGNA",
          validationRegex: "^S-((?=[A-Z2-9]{4})(?:[^IO]{4})-){3}(?=[A-Z2-9]{5})(?:[^IO]{5})$",
          deprecated: false
        },
        "crypto.NIM.address": {
          deprecatedKeyName: "NIM",
          validationRegex: "^NQ[0-9]{2} ([A-Z0-9]{4} ){7}[A-Z0-9]{4}$",
          deprecated: false
        },
        "crypto.GUAP.address": {
          deprecatedKeyName: "GUAP",
          validationRegex: "^(G|P)[a-zA-HJ-NP-Z0-9]{25,39}$",
          deprecated: false
        },
        "crypto.ELA.version.ELA.address": {
          deprecatedKeyName: "ELA_ELA",
          validationRegex: "E[a-zA-HJ-NP-Z0-9]{33}",
          deprecated: false
        },
        "crypto.ELA.version.ESC.address": {
          deprecatedKeyName: "ELA_ESC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.USDT.version.ERC20.address": {
          deprecatedKeyName: "USDT_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.USDT.version.TRON.address": {
          deprecatedKeyName: "USDT_TRON",
          validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
          deprecated: false
        },
        "crypto.USDT.version.EOS.address": {
          deprecatedKeyName: "USDT_EOS",
          validationRegex: "^[a-z][a-z1-5.]{10}[a-z1-5]$",
          deprecated: false
        },
        "crypto.USDT.version.OMNI.address": {
          deprecatedKeyName: "USDT_OMNI",
          validationRegex: "^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$",
          deprecated: false
        },
        "crypto.FTM.version.ERC20.address": {
          deprecatedKeyName: "FTM_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FTM.version.BEP2.address": {
          deprecatedKeyName: "FTM_BEP2",
          validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
          deprecated: false
        },
        "crypto.FTM.version.OPERA.address": {
          deprecatedKeyName: "FTM_OPERA",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FUSE.version.ERC20.address": {
          deprecatedKeyName: "FUSE_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FUSE.version.FUSE.address": {
          deprecatedKeyName: "FUSE_FUSE",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MATIC.version.MATIC.address": {
          deprecatedKeyName: "MATIC_MATIC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MATIC.version.BEP20.address": {
          deprecatedKeyName: "MATIC_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MATIC.version.ERC20.address": {
          deprecatedKeyName: "MATIC_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "social.payid.name": {
          deprecatedKeyName: "payid",
          validationRegex: "^[0-9a-zA-Z]+\\$[0-9a-zA-Z]+\\.[0-9a-zA-Z]+$",
          deprecated: false
        },
        "social.picture.value": {
          deprecatedKeyName: "picture",
          validationRegex: null,
          deprecated: false
        },
        "whois.email.value": {
          deprecatedKeyName: "email",
          validationRegex: "^[^@]+@[^\\.]+\\..+$",
          deprecated: false
        },
        "whois.for_sale.value": {
          deprecatedKeyName: "for_sale",
          validationRegex: "(true)|(false)",
          deprecated: false
        },
        "ipfs.html.value": {
          deprecatedKeyName: "html",
          validationRegex: ".{0,100}",
          deprecated: false
        },
        "ipfs.redirect_domain.value": {
          deprecatedKeyName: "redirect_domain",
          validationRegex: ".{0,253}",
          deprecated: false
        },
        "dweb.ipfs.hash": {
          deprecatedKeyName: "dweb_hash",
          validationRegex: ".{0,100}",
          deprecated: false
        },
        "browser.redirect_url": {
          deprecatedKeyName: "browser_redirect",
          validationRegex: ".{0,253}",
          deprecated: false
        },
        "browser.preferred_protocols": {
          deprecatedKeyName: "browser_preferred_protocols",
          validationRegex: null,
          deprecated: false
        },
        "gundb.username.value": {
          deprecatedKeyName: "gundb_username",
          validationRegex: null,
          deprecated: false
        },
        "gundb.public_key.value": {
          deprecatedKeyName: "gundb_public_key",
          validationRegex: null,
          deprecated: false
        },
        "social.image.value": {
          deprecatedKeyName: "image",
          validationRegex: null,
          deprecated: false
        },
        "social.twitter.username": {
          deprecatedKeyName: "twitter_username",
          validationRegex: null,
          deprecated: false
        },
        "validation.social.twitter.username": {
          deprecatedKeyName: "validation_twitter_username",
          validationRegex: null,
          deprecated: false
        },
        "forwarding.url": {
          deprecatedKeyName: "forwarding_url",
          validationRegex: "^(https?)://[^\\s/$.?#].[^\\s]*$",
          deprecated: false
        },
        "dns.ttl": {
          deprecatedKeyName: "dns_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.A": {
          deprecatedKeyName: "dns_A",
          validationRegex: null,
          deprecated: false
        },
        "dns.A.ttl": {
          deprecatedKeyName: "dns_A_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.AAAA": {
          deprecatedKeyName: "dns_AAAA",
          validationRegex: null,
          deprecated: false
        },
        "dns.AAAA.ttl": {
          deprecatedKeyName: "dns_AAAA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.AFSDB": {
          deprecatedKeyName: "dns_AFSDB",
          validationRegex: null,
          deprecated: false
        },
        "dns.AFSDB.ttl": {
          deprecatedKeyName: "dns_AFSDB_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.APL": {
          deprecatedKeyName: "dns_APL",
          validationRegex: null,
          deprecated: false
        },
        "dns.APL.ttl": {
          deprecatedKeyName: "dns_APL_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CAA": {
          deprecatedKeyName: "dns_CAA",
          validationRegex: null,
          deprecated: false
        },
        "dns.CAA.ttl": {
          deprecatedKeyName: "dns_CAA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CDNSKEY": {
          deprecatedKeyName: "dns_CDNSKEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.CDNSKEY.ttl": {
          deprecatedKeyName: "dns_CDNSKEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CDS": {
          deprecatedKeyName: "dns_CDS",
          validationRegex: null,
          deprecated: false
        },
        "dns.CDS.ttl": {
          deprecatedKeyName: "dns_CDS_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CERT": {
          deprecatedKeyName: "dns_CERT",
          validationRegex: null,
          deprecated: false
        },
        "dns.CERT.ttl": {
          deprecatedKeyName: "dns_CERT_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CNAME": {
          deprecatedKeyName: "dns_CNAME",
          validationRegex: null,
          deprecated: false
        },
        "dns.CNAME.ttl": {
          deprecatedKeyName: "dns_CNAME_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.CSYNC": {
          deprecatedKeyName: "dns_CSYNC",
          validationRegex: null,
          deprecated: false
        },
        "dns.CSYNC.ttl": {
          deprecatedKeyName: "dns_CSYNC_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.DHCID": {
          deprecatedKeyName: "dns_DHCID",
          validationRegex: null,
          deprecated: false
        },
        "dns.DHCID.ttl": {
          deprecatedKeyName: "dns_DHCID_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.DLV": {
          deprecatedKeyName: "dns_DLV",
          validationRegex: null,
          deprecated: false
        },
        "dns.DLV.ttl": {
          deprecatedKeyName: "dns_DLV_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.DNAME": {
          deprecatedKeyName: "dns_DNAME",
          validationRegex: null,
          deprecated: false
        },
        "dns.DNAME.ttl": {
          deprecatedKeyName: "dns_DNAME_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.DNSKEY": {
          deprecatedKeyName: "dns_DNSKEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.DNSKEY.ttl": {
          deprecatedKeyName: "dns_DNSKEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.DS": {
          deprecatedKeyName: "dns_DS",
          validationRegex: null,
          deprecated: false
        },
        "dns.DS.ttl": {
          deprecatedKeyName: "dns_DS_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.EUI48": {
          deprecatedKeyName: "dns_EUI48",
          validationRegex: null,
          deprecated: false
        },
        "dns.EUI48.ttl": {
          deprecatedKeyName: "dns_EUI48_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.EUI64": {
          deprecatedKeyName: "dns_EUI64",
          validationRegex: null,
          deprecated: false
        },
        "dns.EUI64.ttl": {
          deprecatedKeyName: "dns_EUI64_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.HINFO": {
          deprecatedKeyName: "dns_HINFO",
          validationRegex: null,
          deprecated: false
        },
        "dns.HINFO.ttl": {
          deprecatedKeyName: "dns_HINFO_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.HIP": {
          deprecatedKeyName: "dns_HIP",
          validationRegex: null,
          deprecated: false
        },
        "dns.HIP.ttl": {
          deprecatedKeyName: "dns_HIP_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.HTTPS": {
          deprecatedKeyName: "dns_HTTPS",
          validationRegex: null,
          deprecated: false
        },
        "dns.HTTPS.ttl": {
          deprecatedKeyName: "dns_HTTPS_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.IPSECKEY": {
          deprecatedKeyName: "dns_IPSECKEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.IPSECKEY.ttl": {
          deprecatedKeyName: "dns_IPSECKEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.KEY": {
          deprecatedKeyName: "dns_KEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.KEY.ttl": {
          deprecatedKeyName: "dns_KEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.KX": {
          deprecatedKeyName: "dns_KX",
          validationRegex: null,
          deprecated: false
        },
        "dns.KX.ttl": {
          deprecatedKeyName: "dns_KX_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.LOC": {
          deprecatedKeyName: "dns_LOC",
          validationRegex: null,
          deprecated: false
        },
        "dns.LOC.ttl": {
          deprecatedKeyName: "dns_LOC_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.MX": {
          deprecatedKeyName: "dns_MX",
          validationRegex: null,
          deprecated: false
        },
        "dns.MX.ttl": {
          deprecatedKeyName: "dns_MX_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.NAPTR": {
          deprecatedKeyName: "dns_NAPTR",
          validationRegex: null,
          deprecated: false
        },
        "dns.NAPTR.ttl": {
          deprecatedKeyName: "dns_NAPTR_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.NS": {
          deprecatedKeyName: "dns_NS",
          validationRegex: null,
          deprecated: false
        },
        "dns.NS.ttl": {
          deprecatedKeyName: "dns_NS_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC": {
          deprecatedKeyName: "dns_NSEC",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC.ttl": {
          deprecatedKeyName: "dns_NSEC_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC3": {
          deprecatedKeyName: "dns_NSEC3",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC3.ttl": {
          deprecatedKeyName: "dns_NSEC3_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC3PARAM": {
          deprecatedKeyName: "dns_NSEC3PARAM",
          validationRegex: null,
          deprecated: false
        },
        "dns.NSEC3PARAM.ttl": {
          deprecatedKeyName: "dns_NSEC3PARAM_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.OPENPGPKEY": {
          deprecatedKeyName: "dns_OPENPGPKEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.OPENPGPKEY.ttl": {
          deprecatedKeyName: "dns_OPENPGPKEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.PTR": {
          deprecatedKeyName: "dns_PTR",
          validationRegex: null,
          deprecated: false
        },
        "dns.PTR.ttl": {
          deprecatedKeyName: "dns_PTR_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.RP": {
          deprecatedKeyName: "dns_RP",
          validationRegex: null,
          deprecated: false
        },
        "dns.RP.ttl": {
          deprecatedKeyName: "dns_RP_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.RRSIG": {
          deprecatedKeyName: "dns_RRSIG",
          validationRegex: null,
          deprecated: false
        },
        "dns.RRSIG.ttl": {
          deprecatedKeyName: "dns_RRSIG_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SIG": {
          deprecatedKeyName: "dns_SIG",
          validationRegex: null,
          deprecated: false
        },
        "dns.SIG.ttl": {
          deprecatedKeyName: "dns_SIG_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SMIMEA": {
          deprecatedKeyName: "dns_SMIMEA",
          validationRegex: null,
          deprecated: false
        },
        "dns.SMIMEA.ttl": {
          deprecatedKeyName: "dns_SMIMEA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SOA": {
          deprecatedKeyName: "dns_SOA",
          validationRegex: null,
          deprecated: false
        },
        "dns.SOA.ttl": {
          deprecatedKeyName: "dns_SOA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SRV": {
          deprecatedKeyName: "dns_SRV",
          validationRegex: null,
          deprecated: false
        },
        "dns.SRV.ttl": {
          deprecatedKeyName: "dns_SRV_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SSHFP": {
          deprecatedKeyName: "dns_SSHFP",
          validationRegex: null,
          deprecated: false
        },
        "dns.SSHFP.ttl": {
          deprecatedKeyName: "dns_SSHFP_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.SVCB": {
          deprecatedKeyName: "dns_SVCB",
          validationRegex: null,
          deprecated: false
        },
        "dns.SVCB.ttl": {
          deprecatedKeyName: "dns_SVCB_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.TA": {
          deprecatedKeyName: "dns_TA",
          validationRegex: null,
          deprecated: false
        },
        "dns.TA.ttl": {
          deprecatedKeyName: "dns_TA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.TKEY": {
          deprecatedKeyName: "dns_TKEY",
          validationRegex: null,
          deprecated: false
        },
        "dns.TKEY.ttl": {
          deprecatedKeyName: "dns_TKEY_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.TLSA": {
          deprecatedKeyName: "dns_TLSA",
          validationRegex: null,
          deprecated: false
        },
        "dns.TLSA.ttl": {
          deprecatedKeyName: "dns_TLSA_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.TSIG": {
          deprecatedKeyName: "dns_TSIG",
          validationRegex: null,
          deprecated: false
        },
        "dns.TSIG.ttl": {
          deprecatedKeyName: "dns_TSIG_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.TXT": {
          deprecatedKeyName: "dns_TXT",
          validationRegex: null,
          deprecated: false
        },
        "dns.TXT.ttl": {
          deprecatedKeyName: "dns_TXT_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.URI": {
          deprecatedKeyName: "dns_URI",
          validationRegex: null,
          deprecated: false
        },
        "dns.URI.ttl": {
          deprecatedKeyName: "dns_URI_ttl",
          validationRegex: null,
          deprecated: false
        },
        "dns.ZONEMD": {
          deprecatedKeyName: "dns_ZONEMD",
          validationRegex: null,
          deprecated: false
        },
        "dns.ZONEMD.ttl": {
          deprecatedKeyName: "dns_ZONEMD_ttl",
          validationRegex: null,
          deprecated: false
        },
        "crypto.DOT.address": {
          deprecatedKeyName: "DOT",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UNI.version.ERC20.address": {
          deprecatedKeyName: "UNI_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.UNI.version.BEP20.address": {
          deprecatedKeyName: "UNI_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.UNI.version.MATIC.address": {
          deprecatedKeyName: "UNI_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UNI.version.HRC20.address": {
          deprecatedKeyName: "UNI_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.UNI.version.XDAI.address": {
          deprecatedKeyName: "UNI_XDAI",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SOL.address": {
          deprecatedKeyName: "SOL",
          validationRegex: null,
          deprecated: false
        },
        "crypto.BUSD.version.ERC20.address": {
          deprecatedKeyName: "BUSD_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BUSD.version.BEP20.address": {
          deprecatedKeyName: "BUSD_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BUSD.version.HRC20.address": {
          deprecatedKeyName: "BUSD_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ICP.address": {
          deprecatedKeyName: "ICP",
          validationRegex: null,
          deprecated: false
        },
        "crypto.THETA.address": {
          deprecatedKeyName: "THETA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.WBTC.version.ERC20.address": {
          deprecatedKeyName: "WBTC_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.WBTC.version.MATIC.address": {
          deprecatedKeyName: "WBTC_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.WBTC.version.FANTOM.address": {
          deprecatedKeyName: "WBTC_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.WBTC.version.HRC20.address": {
          deprecatedKeyName: "WBTC_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.WBTC.version.XDAI.address": {
          deprecatedKeyName: "WBTC_XDAI",
          validationRegex: null,
          deprecated: false
        },
        "crypto.FIL.address": {
          deprecatedKeyName: "FIL",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CDAI.address": {
          deprecatedKeyName: "CDAI",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KSM.address": {
          deprecatedKeyName: "KSM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.OKB.address": {
          deprecatedKeyName: "OKB",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AAVE.version.ERC20.address": {
          deprecatedKeyName: "AAVE_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AAVE.version.MATIC.address": {
          deprecatedKeyName: "AAVE_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.AAVE.version.FANTOM.address": {
          deprecatedKeyName: "AAVE_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.AAVE.version.HRC20.address": {
          deprecatedKeyName: "AAVE_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SHIB.version.ERC20.address": {
          deprecatedKeyName: "SHIB_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SHIB.version.MATIC.address": {
          deprecatedKeyName: "SHIB_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SHIB.version.FANTOM.address": {
          deprecatedKeyName: "SHIB_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CEL.version.ERC20.address": {
          deprecatedKeyName: "CEL_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CEL.version.MATIC.address": {
          deprecatedKeyName: "CEL_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CEL.version.FANTOM.address": {
          deprecatedKeyName: "CEL_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CEL.version.HRC20.address": {
          deprecatedKeyName: "CEL_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CUSDC.address": {
          deprecatedKeyName: "CUSDC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CETH.address": {
          deprecatedKeyName: "CETH",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AMP.address": {
          deprecatedKeyName: "AMP",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CAKE.version.BEP20.address": {
          deprecatedKeyName: "CAKE_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CAKE.version.HRC20.address": {
          deprecatedKeyName: "CAKE_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MIOTA.address": {
          deprecatedKeyName: "MIOTA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.FTT.address": {
          deprecatedKeyName: "FTT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MKR.address": {
          deprecatedKeyName: "MKR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TFUEL.address": {
          deprecatedKeyName: "TFUEL",
          validationRegex: null,
          deprecated: false
        },
        "crypto.KLAY.address": {
          deprecatedKeyName: "KLAY",
          validationRegex: null,
          deprecated: false
        },
        "crypto.LUNA.address": {
          deprecatedKeyName: "LUNA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.AVAX.address": {
          deprecatedKeyName: "AVAX",
          validationRegex: null,
          deprecated: false
        },
        "crypto.LEO.address": {
          deprecatedKeyName: "LEO",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SAFEMOON.version.BEP20.address": {
          deprecatedKeyName: "SAFEMOON_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SAFEMOON.version.HRC20.address": {
          deprecatedKeyName: "SAFEMOON_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.UST.address": {
          deprecatedKeyName: "UST",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RUNE.address": {
          deprecatedKeyName: "RUNE",
          validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
          deprecated: false
        },
        "crypto.HBAR.address": {
          deprecatedKeyName: "HBAR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.TEL.version.ERC20.address": {
          deprecatedKeyName: "TEL_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TEL.version.MATIC.address": {
          deprecatedKeyName: "TEL_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CHZ.address": {
          deprecatedKeyName: "CHZ",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SUSHI.version.ERC20.address": {
          deprecatedKeyName: "SUSHI_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SUSHI.version.BEP20.address": {
          deprecatedKeyName: "SUSHI_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SUSHI.version.MATIC.address": {
          deprecatedKeyName: "SUSHI_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SUSHI.version.FANTOM.address": {
          deprecatedKeyName: "SUSHI_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SUSHI.version.HRC20.address": {
          deprecatedKeyName: "SUSHI_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.EGLD.address": {
          deprecatedKeyName: "EGLD",
          validationRegex: null,
          deprecated: false
        },
        "crypto.TUSD.version.ERC20.address": {
          deprecatedKeyName: "TUSD_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TUSD.version.BEP20.address": {
          deprecatedKeyName: "TUSD_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TUSD.version.AVAX.address": {
          deprecatedKeyName: "TUSD_AVAX",
          validationRegex: null,
          deprecated: false
        },
        "crypto.TUSD.version.HRC20.address": {
          deprecatedKeyName: "TUSD_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TUSD.version.BEP2.address": {
          deprecatedKeyName: "TUSD_BEP2",
          validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
          deprecated: false
        },
        "crypto.TUSD.version.TRON.address": {
          deprecatedKeyName: "TUSD_TRON",
          validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
          deprecated: false
        },
        "crypto.HBTC.version.ERC20.address": {
          deprecatedKeyName: "HBTC_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HBTC.version.HRC20.address": {
          deprecatedKeyName: "HBTC_HRC20",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SNX.version.ERC20.address": {
          deprecatedKeyName: "SNX_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SNX.version.MATIC.address": {
          deprecatedKeyName: "SNX_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SNX.version.FANTOM.address": {
          deprecatedKeyName: "SNX_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SNX.version.HRC20.address": {
          deprecatedKeyName: "SNX_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HOT.version.ERC20.address": {
          deprecatedKeyName: "HOT_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HOT.version.HRC20.address": {
          deprecatedKeyName: "HOT_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NEAR.address": {
          deprecatedKeyName: "NEAR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.HNT.address": {
          deprecatedKeyName: "HNT",
          validationRegex: null,
          deprecated: false
        },
        "crypto.STETH.address": {
          deprecatedKeyName: "STETH",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NEXO.version.ERC20.address": {
          deprecatedKeyName: "NEXO_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NEXO.version.FANTOM.address": {
          deprecatedKeyName: "NEXO_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.PAX.address": {
          deprecatedKeyName: "PAX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.STX.address": {
          deprecatedKeyName: "STX",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MANA.version.ERC20.address": {
          deprecatedKeyName: "MANA_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MANA.version.MATIC.address": {
          deprecatedKeyName: "MANA_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MDX.version.HRC20.address": {
          deprecatedKeyName: "MDX_HRC20",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MDX.version.BEP20.address": {
          deprecatedKeyName: "MDX_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ZEN.address": {
          deprecatedKeyName: "ZEN",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ARRR.address": {
          deprecatedKeyName: "ARRR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.BNT.address": {
          deprecatedKeyName: "BNT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LUSD.version.ERC20.address": {
          deprecatedKeyName: "LUSD_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LUSD.version.MATIC.address": {
          deprecatedKeyName: "LUSD_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.GRT.version.ERC20.address": {
          deprecatedKeyName: "GRT_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GRT.version.MATIC.address": {
          deprecatedKeyName: "GRT_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.GRT.version.HRC20.address": {
          deprecatedKeyName: "GRT_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SC.address": {
          deprecatedKeyName: "SC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.HUSD.version.ERC20.address": {
          deprecatedKeyName: "HUSD_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HUSD.version.HRC20.address": {
          deprecatedKeyName: "HUSD_HRC20",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CRV.version.ERC20.address": {
          deprecatedKeyName: "CRV_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CRV.version.MATIC.address": {
          deprecatedKeyName: "CRV_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.CRV.version.FANTOM.address": {
          deprecatedKeyName: "CRV_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UMA.address": {
          deprecatedKeyName: "UMA",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.WRX.version.BEP2.address": {
          deprecatedKeyName: "WRX_BEP2",
          validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
          deprecated: false
        },
        "crypto.WRX.version.MATIC.address": {
          deprecatedKeyName: "WRX_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.AR.address": {
          deprecatedKeyName: "AR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.OMG.address": {
          deprecatedKeyName: "OMG",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GT.address": {
          deprecatedKeyName: "GT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.QNT.address": {
          deprecatedKeyName: "QNT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CHSB.address": {
          deprecatedKeyName: "CHSB",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.IOST.address": {
          deprecatedKeyName: "IOST",
          validationRegex: null,
          deprecated: false
        },
        "crypto.NXM.address": {
          deprecatedKeyName: "NXM",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KCS.address": {
          deprecatedKeyName: "KCS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LPT.version.ERC20.address": {
          deprecatedKeyName: "LPT_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LPT.version.HRC20.address": {
          deprecatedKeyName: "LPT_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XSUSHI.address": {
          deprecatedKeyName: "XSUSHI",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CUSDT.address": {
          deprecatedKeyName: "CUSDT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FLOW.address": {
          deprecatedKeyName: "FLOW",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ANKR.address": {
          deprecatedKeyName: "ANKR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HBC.address": {
          deprecatedKeyName: "HBC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.VGX.address": {
          deprecatedKeyName: "VGX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FEI.address": {
          deprecatedKeyName: "FEI",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BAKE.version.BEP20.address": {
          deprecatedKeyName: "BAKE_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BAKE.version.HRC20.address": {
          deprecatedKeyName: "BAKE_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.1INCH.version.ERC20.address": {
          deprecatedKeyName: "1INCH_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.1INCH.version.BEP20.address": {
          deprecatedKeyName: "1INCH_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.1INCH.version.MATIC.address": {
          deprecatedKeyName: "1INCH_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.1INCH.version.HRC20.address": {
          deprecatedKeyName: "1INCH_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CKB.address": {
          deprecatedKeyName: "CKB",
          validationRegex: null,
          deprecated: false
        },
        "crypto.WOO.version.ERC20.address": {
          deprecatedKeyName: "WOO_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.WOO.version.HRC20.address": {
          deprecatedKeyName: "WOO_HRC20",
          validationRegex: null,
          deprecated: false
        },
        "crypto.TITAN.address": {
          deprecatedKeyName: "TITAN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.OMI.address": {
          deprecatedKeyName: "OMI",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MINA.address": {
          deprecatedKeyName: "MINA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SETH.address": {
          deprecatedKeyName: "SETH",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RSR.address": {
          deprecatedKeyName: "RSR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.OXY.version.SOLANA.address": {
          deprecatedKeyName: "OXY_SOLANA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.OXY.version.ERC20.address": {
          deprecatedKeyName: "OXY_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.REN.version.ERC20.address": {
          deprecatedKeyName: "REN_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.REN.version.HRC20.address": {
          deprecatedKeyName: "REN_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XCH.address": {
          deprecatedKeyName: "XCH",
          validationRegex: null,
          deprecated: false
        },
        "crypto.RENBTC.version.ERC20.address": {
          deprecatedKeyName: "RENBTC_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RENBTC.version.BEP20.address": {
          deprecatedKeyName: "RENBTC_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RENBTC.version.HRC20.address": {
          deprecatedKeyName: "RENBTC_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.USDN.address": {
          deprecatedKeyName: "USDN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BCHA.address": {
          deprecatedKeyName: "BCHA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.LRC.address": {
          deprecatedKeyName: "LRC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.PUNDIX.address": {
          deprecatedKeyName: "PUNDIX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ERG.address": {
          deprecatedKeyName: "ERG",
          validationRegex: null,
          deprecated: false
        },
        "crypto.WIN.address": {
          deprecatedKeyName: "WIN",
          validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
          deprecated: false
        },
        "crypto.NPXS.address": {
          deprecatedKeyName: "NPXS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TRIBE.address": {
          deprecatedKeyName: "TRIBE",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MAID.address": {
          deprecatedKeyName: "MAID",
          validationRegex: "^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$",
          deprecated: false
        },
        "crypto.ASD.address": {
          deprecatedKeyName: "ASD",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CUNI.address": {
          deprecatedKeyName: "CUNI",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CELO.address": {
          deprecatedKeyName: "CELO",
          validationRegex: null,
          deprecated: false
        },
        "crypto.DENT.address": {
          deprecatedKeyName: "DENT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SNT.address": {
          deprecatedKeyName: "SNT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FEG.version.ERC20.address": {
          deprecatedKeyName: "FEG_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FEG.version.HRC20.address": {
          deprecatedKeyName: "FEG_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SKL.address": {
          deprecatedKeyName: "SKL",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ALUSD.address": {
          deprecatedKeyName: "ALUSD",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MIR.version.ERC20.address": {
          deprecatedKeyName: "MIR_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MIR.version.BEP20.address": {
          deprecatedKeyName: "MIR_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GLM.address": {
          deprecatedKeyName: "GLM",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.PAXG.version.ERC20.address": {
          deprecatedKeyName: "PAXG_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.PAXG.version.HRC20.address": {
          deprecatedKeyName: "PAXG_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CFX.address": {
          deprecatedKeyName: "CFX",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UOS.address": {
          deprecatedKeyName: "UOS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SVCS.address": {
          deprecatedKeyName: "SVCS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.REEF.version.ERC20.address": {
          deprecatedKeyName: "REEF_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.REEF.version.BEP20.address": {
          deprecatedKeyName: "REEF_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.REEF.version.HRC20.address": {
          deprecatedKeyName: "REEF_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GNO.address": {
          deprecatedKeyName: "GNO",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.USDP.address": {
          deprecatedKeyName: "USDP",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KAVA.address": {
          deprecatedKeyName: "KAVA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ALCX.address": {
          deprecatedKeyName: "ALCX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.EWT.address": {
          deprecatedKeyName: "EWT",
          validationRegex: null,
          deprecated: false
        },
        "crypto.TON.address": {
          deprecatedKeyName: "TON",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RLC.address": {
          deprecatedKeyName: "RLC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AXS.address": {
          deprecatedKeyName: "AXS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AUDIO.address": {
          deprecatedKeyName: "AUDIO",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XVS.address": {
          deprecatedKeyName: "XVS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BAND.version.ERC20.address": {
          deprecatedKeyName: "BAND_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.BAND.version.FANTOM.address": {
          deprecatedKeyName: "BAND_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.NMR.address": {
          deprecatedKeyName: "NMR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.INJ.version.ERC20.address": {
          deprecatedKeyName: "INJ_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.INJ.version.BEP20.address": {
          deprecatedKeyName: "INJ_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.WAXP.address": {
          deprecatedKeyName: "WAXP",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UQC.address": {
          deprecatedKeyName: "UQC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.IOTX.address": {
          deprecatedKeyName: "IOTX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FUN.address": {
          deprecatedKeyName: "FUN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.OCEAN.address": {
          deprecatedKeyName: "OCEAN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SAND.version.ERC20.address": {
          deprecatedKeyName: "SAND_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SAND.version.HRC20.address": {
          deprecatedKeyName: "SAND_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CTSI.version.ERC20.address": {
          deprecatedKeyName: "CTSI_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CTSI.version.BEP20.address": {
          deprecatedKeyName: "CTSI_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CTSI.version.MATIC.address": {
          deprecatedKeyName: "CTSI_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.RAY.address": {
          deprecatedKeyName: "RAY",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ANC.version.TERRA.address": {
          deprecatedKeyName: "ANC_TERRA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ANC.version.ERC20.address": {
          deprecatedKeyName: "ANC_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.IQ.version.ERC20.address": {
          deprecatedKeyName: "IQ_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.IQ.version.BEP20.address": {
          deprecatedKeyName: "IQ_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.IQ.version.MATIC.address": {
          deprecatedKeyName: "IQ_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SUSD.version.ERC20.address": {
          deprecatedKeyName: "SUSD_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SUSD.version.FANTOM.address": {
          deprecatedKeyName: "SUSD_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.KLV.address": {
          deprecatedKeyName: "KLV",
          validationRegex: "^[T][a-zA-HJ-NP-Z0-9]{33}$",
          deprecated: false
        },
        "crypto.BTCST.address": {
          deprecatedKeyName: "BTCST",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TLM.address": {
          deprecatedKeyName: "TLM",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AKT.address": {
          deprecatedKeyName: "AKT",
          validationRegex: null,
          deprecated: false
        },
        "crypto.STMX.address": {
          deprecatedKeyName: "STMX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.PROM.address": {
          deprecatedKeyName: "PROM",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XPRT.address": {
          deprecatedKeyName: "XPRT",
          validationRegex: null,
          deprecated: false
        },
        "crypto.SRM.version.ERC20.address": {
          deprecatedKeyName: "SRM_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SRM.version.SOLANA.address": {
          deprecatedKeyName: "SRM_SOLANA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.RPL.address": {
          deprecatedKeyName: "RPL",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AGIX.address": {
          deprecatedKeyName: "AGIX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CELR.address": {
          deprecatedKeyName: "CELR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.FET.address": {
          deprecatedKeyName: "FET",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.OXT.address": {
          deprecatedKeyName: "OXT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ARDR.address": {
          deprecatedKeyName: "ARDR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MATH.address": {
          deprecatedKeyName: "MATH",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.10SET.address": {
          deprecatedKeyName: "10SET",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.POLY.address": {
          deprecatedKeyName: "POLY",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GUSD.address": {
          deprecatedKeyName: "GUSD",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NKN.address": {
          deprecatedKeyName: "NKN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CVC.address": {
          deprecatedKeyName: "CVC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.GTC.address": {
          deprecatedKeyName: "GTC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.STEEM.address": {
          deprecatedKeyName: "STEEM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ORN.address": {
          deprecatedKeyName: "ORN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KEEP.version.ERC20.address": {
          deprecatedKeyName: "KEEP_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KEEP.version.HRC20.address": {
          deprecatedKeyName: "KEEP_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HXRO.address": {
          deprecatedKeyName: "HXRO",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ORBS.address": {
          deprecatedKeyName: "ORBS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ALPHA.version.ERC20.address": {
          deprecatedKeyName: "ALPHA_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ALPHA.version.BEP20.address": {
          deprecatedKeyName: "ALPHA_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.DODO.version.ERC20.address": {
          deprecatedKeyName: "DODO_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.DODO.version.BEP20.address": {
          deprecatedKeyName: "DODO_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.OGN.address": {
          deprecatedKeyName: "OGN",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KNCL.version.ERC20.address": {
          deprecatedKeyName: "KNCL_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KNCL.version.FANTOM.address": {
          deprecatedKeyName: "KNCL_FANTOM",
          validationRegex: null,
          deprecated: false
        },
        "crypto.KNCL.version.HRC20.address": {
          deprecatedKeyName: "KNCL_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MED.address": {
          deprecatedKeyName: "MED",
          validationRegex: null,
          deprecated: false
        },
        "crypto.XAUT.address": {
          deprecatedKeyName: "XAUT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.VLX.address": {
          deprecatedKeyName: "VLX",
          validationRegex: null,
          deprecated: false
        },
        "crypto.PHA.address": {
          deprecatedKeyName: "PHA",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.KOBE.address": {
          deprecatedKeyName: "KOBE",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.PERP.address": {
          deprecatedKeyName: "PERP",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.XHV.address": {
          deprecatedKeyName: "XHV",
          validationRegex: null,
          deprecated: false
        },
        "crypto.META.address": {
          deprecatedKeyName: "META",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SEUR.address": {
          deprecatedKeyName: "SEUR",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.MONA.address": {
          deprecatedKeyName: "MONA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ANT.address": {
          deprecatedKeyName: "ANT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.HYDRA.address": {
          deprecatedKeyName: "HYDRA",
          validationRegex: null,
          deprecated: false
        },
        "crypto.ZKS.address": {
          deprecatedKeyName: "ZKS",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SXP.version.ERC20.address": {
          deprecatedKeyName: "SXP_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SXP.version.BEP20.address": {
          deprecatedKeyName: "SXP_BEP20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.SXP.version.HRC20.address": {
          deprecatedKeyName: "SXP_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.CSPR.address": {
          deprecatedKeyName: "CSPR",
          validationRegex: null,
          deprecated: false
        },
        "crypto.MTL.address": {
          deprecatedKeyName: "MTL",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NU.address": {
          deprecatedKeyName: "NU",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ZMT.address": {
          deprecatedKeyName: "ZMT",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.LOC.address": {
          deprecatedKeyName: "LOC",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.TKO.address": {
          deprecatedKeyName: "TKO",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.ETN.address": {
          deprecatedKeyName: "ETN",
          validationRegex: null,
          deprecated: false
        },
        "crypto.UBT.version.ERC20.address": {
          deprecatedKeyName: "UBT_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.UBT.version.MATIC.address": {
          deprecatedKeyName: "UBT_MATIC",
          validationRegex: null,
          deprecated: false
        },
        "crypto.EXRD.address": {
          deprecatedKeyName: "EXRD",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.NMX.address": {
          deprecatedKeyName: "NMX",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.RIF.address": {
          deprecatedKeyName: "RIF",
          validationRegex: null,
          deprecated: false
        },
        "crypto.STORJ.version.ERC20.address": {
          deprecatedKeyName: "STORJ_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.STORJ.version.HRC20.address": {
          deprecatedKeyName: "STORJ_HRC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.AVA.address": {
          deprecatedKeyName: "AVA",
          validationRegex: "^(bnb|tbnb)[a-zA-HJ-NP-Z0-9]{39}$",
          deprecated: false
        },
        "crypto.DPI.version.ERC20.address": {
          deprecatedKeyName: "DPI_ERC20",
          validationRegex: "^0x[a-fA-F0-9]{40}$",
          deprecated: false
        },
        "crypto.DPI.version.MATIC.address": {
          deprecatedKeyName: "DPI_MATIC",
          validationRegex: null,
          deprecated: false
        }
      }
    };
  }
});

// node_modules/@unstoppabledomains/resolution/build/Uns.js
var require_Uns = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/Uns.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require_types();
    var resolutionError_1 = __importStar(require_resolutionError());
    var utils_1 = require_utils();
    var publicTypes_1 = require_publicTypes();
    var TwitterSignatureValidator_1 = require_TwitterSignatureValidator();
    var FetchProvider_1 = __importDefault(require_FetchProvider());
    var namehash_1 = require_namehash();
    var NamingService_1 = require_NamingService();
    var configurationError_1 = __importStar(require_configurationError());
    var UnsInternal_1 = __importDefault(require_UnsInternal());
    var Networking_1 = __importDefault(require_Networking());
    var resolver_keys_json_1 = __importDefault(require_resolver_keys());
    var Uns = (
      /** @class */
      function(_super) {
        __extends(Uns2, _super);
        function Uns2(source) {
          var _this = _super.call(this) || this;
          _this.name = publicTypes_1.NamingServiceName.UNS;
          if (source && source.locations && (!source.locations.Layer1 || !source.locations.Layer2)) {
            throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.NetworkConfigMissing, {
              method: publicTypes_1.NamingServiceName.UNS,
              config: !source.locations.Layer1 ? "Layer1" : "Layer2"
            });
          }
          if (!source) {
            source = {
              locations: {
                Layer1: {
                  url: UnsInternal_1.default.UrlMap["mainnet"],
                  network: "mainnet"
                },
                Layer2: {
                  url: UnsInternal_1.default.UrlMap["polygon-mainnet"],
                  network: "polygon-mainnet"
                }
              }
            };
          }
          _this.unsl1 = new UnsInternal_1.default(publicTypes_1.UnsLocation.Layer1, source.locations.Layer1, publicTypes_1.BlockchainType.ETH);
          _this.unsl2 = new UnsInternal_1.default(publicTypes_1.UnsLocation.Layer2, source.locations.Layer2, publicTypes_1.BlockchainType.MATIC);
          return _this;
        }
        Uns2.autoNetwork = function(config) {
          return __awaiter(this, void 0, void 0, function() {
            var providerLayer1, providerLayer2, networkIdLayer1, networkIdLayer2, networkNameLayer1, networkNameLayer2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if ((0, types_1.hasProvider)(config.locations.Layer1) && (0, types_1.hasProvider)(config.locations.Layer2)) {
                    providerLayer1 = config.locations.Layer1.provider;
                    providerLayer2 = config.locations.Layer2.provider;
                  } else {
                    if (!config.locations.Layer1["url"] || !config.locations.Layer2["url"]) {
                      throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnspecifiedUrl, {
                        method: publicTypes_1.NamingServiceName.UNS
                      });
                    }
                    providerLayer1 = FetchProvider_1.default.factory(publicTypes_1.NamingServiceName.UNS, config.locations.Layer1["url"]);
                    providerLayer2 = FetchProvider_1.default.factory(publicTypes_1.NamingServiceName.UNS, config.locations.Layer2["url"]);
                  }
                  return [4, providerLayer1.request({
                    method: "net_version"
                  })];
                case 1:
                  networkIdLayer1 = _a.sent();
                  return [4, providerLayer2.request({
                    method: "net_version"
                  })];
                case 2:
                  networkIdLayer2 = _a.sent();
                  networkNameLayer1 = utils_1.EthereumNetworksInverted[networkIdLayer1];
                  networkNameLayer2 = utils_1.EthereumNetworksInverted[networkIdLayer2];
                  if (!networkNameLayer1 || !types_1.UnsSupportedNetwork.guard(networkNameLayer1) || !networkNameLayer2 || !types_1.UnsSupportedNetwork.guard(networkNameLayer2)) {
                    throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.UnsupportedNetwork, {
                      method: publicTypes_1.NamingServiceName.UNS
                    });
                  }
                  return [2, new this({
                    locations: {
                      Layer1: { network: networkNameLayer1, provider: providerLayer1 },
                      Layer2: { network: networkNameLayer2, provider: providerLayer2 }
                    }
                  })];
              }
            });
          });
        };
        Uns2.prototype.namehash = function(domain) {
          if (!this.checkDomain(domain)) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
              domain
            });
          }
          return (0, namehash_1.eip137Namehash)(domain);
        };
        Uns2.prototype.childhash = function(parentHash, label) {
          return (0, namehash_1.eip137Childhash)(parentHash, label);
        };
        Uns2.prototype.isSupportedDomain = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var tld, _a, existsL1, existsL2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!this.checkDomain(domain)) {
                    return [2, false];
                  }
                  tld = domain.split(".").pop();
                  if (!tld) {
                    return [2, false];
                  }
                  return [4, Promise.all([
                    this.unsl1.exists(tld),
                    this.unsl2.exists(tld)
                  ])];
                case 1:
                  _a = _b.sent(), existsL1 = _a[0], existsL2 = _a[1];
                  return [2, existsL1 || existsL2];
              }
            });
          });
        };
        Uns2.prototype.owner = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId, data;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = this.namehash(domain);
                  return [4, this.get(tokenId, [])];
                case 1:
                  data = _a.sent();
                  if ((0, utils_1.isNullAddress)(data.owner)) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  return [2, data.owner];
              }
            });
          });
        };
        Uns2.prototype.resolver = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getVerifiedData(domain)];
                case 1:
                  return [2, _a.sent().resolver];
              }
            });
          });
        };
        Uns2.prototype.record = function(domain, key) {
          return __awaiter(this, void 0, void 0, function() {
            var returnee;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.records(domain, [key])];
                case 1:
                  returnee = _a.sent()[key];
                  if (!returnee) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      recordName: key,
                      domain
                    });
                  }
                  return [2, returnee];
              }
            });
          });
        };
        Uns2.prototype.records = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getVerifiedData(domain, keys)];
                case 1:
                  return [2, _a.sent().records];
              }
            });
          });
        };
        Uns2.prototype.allRecords = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.records(domain, __spreadArray([], Object.keys(resolver_keys_json_1.default.keys), true))];
            });
          });
        };
        Uns2.prototype.twitter = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId, keys, data, records, location, validationSignature, twitterHandle, owner;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = this.namehash(domain);
                  keys = [
                    "validation.social.twitter.username",
                    "social.twitter.username"
                  ];
                  return [4, this.getVerifiedData(domain, keys)];
                case 1:
                  data = _a.sent();
                  records = data.records, location = data.location;
                  validationSignature = records["validation.social.twitter.username"];
                  twitterHandle = records["social.twitter.username"];
                  if ((0, utils_1.isNullAddress)(validationSignature)) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      domain,
                      location,
                      recordName: "validation.social.twitter.username"
                    });
                  }
                  if (!twitterHandle) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      domain,
                      location,
                      recordName: "social.twitter.username"
                    });
                  }
                  owner = data.owner;
                  if (!(0, TwitterSignatureValidator_1.isValidTwitterSignature)({
                    tokenId,
                    owner,
                    twitterHandle,
                    validationSignature
                  })) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.InvalidTwitterVerification, {
                      domain
                    });
                  }
                  return [2, twitterHandle];
              }
            });
          });
        };
        Uns2.prototype.reverse = function(address, currencyTicker) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "reverse"
              });
            });
          });
        };
        Uns2.prototype.isRegistered = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId, data;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = this.namehash(domain);
                  return [4, this.get(tokenId, [])];
                case 1:
                  data = _a.sent();
                  return [2, !(0, utils_1.isNullAddress)(data.owner)];
              }
            });
          });
        };
        Uns2.prototype.getTokenUri = function(tokenId) {
          var e_1, _a;
          return __awaiter(this, void 0, void 0, function() {
            var _b, _c, result, tokenUri, e_1_1;
            var _this = this;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  _d.trys.push([0, 5, 6, 11]);
                  _b = __asyncValues([
                    (0, utils_1.wrapResult)(function() {
                      return _this.unsl2.getTokenUri(tokenId);
                    }),
                    (0, utils_1.wrapResult)(function() {
                      return _this.unsl1.getTokenUri(tokenId);
                    })
                  ]);
                  _d.label = 1;
                case 1:
                  return [4, _b.next()];
                case 2:
                  if (!(_c = _d.sent(), !_c.done)) return [3, 4];
                  result = _c.value;
                  tokenUri = (0, utils_1.unwrapResult)(result);
                  if (tokenUri) {
                    return [2, tokenUri];
                  }
                  _d.label = 3;
                case 3:
                  return [3, 1];
                case 4:
                  return [3, 11];
                case 5:
                  e_1_1 = _d.sent();
                  e_1 = { error: e_1_1 };
                  return [3, 11];
                case 6:
                  _d.trys.push([6, , 9, 10]);
                  if (!(_c && !_c.done && (_a = _b.return))) return [3, 8];
                  return [4, _a.call(_b)];
                case 7:
                  _d.sent();
                  _d.label = 8;
                case 8:
                  return [3, 10];
                case 9:
                  if (e_1) throw e_1.error;
                  return [
                    7
                    /*endfinally*/
                  ];
                case 10:
                  return [
                    7
                    /*endfinally*/
                  ];
                case 11:
                  throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                    domain: "with tokenId ".concat(tokenId)
                  });
              }
            });
          });
        };
        Uns2.prototype.isAvailable = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.isRegistered(domain)];
                case 1:
                  return [2, !_a.sent()];
              }
            });
          });
        };
        Uns2.prototype.registryAddress = function(domainOrNamehash) {
          return __awaiter(this, void 0, void 0, function() {
            var _a, resultOrErrorL1, resultOrErrorL2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, Promise.all([
                    this.unsl1.registryAddress(domainOrNamehash).catch(function(err) {
                      return err;
                    }),
                    this.unsl2.registryAddress(domainOrNamehash).catch(function(err) {
                      return err;
                    })
                  ])];
                case 1:
                  _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                  if (resultOrErrorL2 instanceof Error) {
                    validResolutionErrorOrThrow(resultOrErrorL2, resolutionError_1.ResolutionErrorCode.UnregisteredDomain);
                  } else if (!(0, utils_1.isNullAddress)(resultOrErrorL2)) {
                    return [2, resultOrErrorL2];
                  }
                  return [2, validResultOrThrow(resultOrErrorL1)];
              }
            });
          });
        };
        Uns2.prototype.locations = function(domains) {
          return __awaiter(this, void 0, void 0, function() {
            var _a, resultL1, resultL2, nonEmptyRecordsFromL2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, Promise.all([
                    this.unsl1.locations(domains),
                    this.unsl2.locations(domains)
                  ])];
                case 1:
                  _a = _b.sent(), resultL1 = _a[0], resultL2 = _a[1];
                  nonEmptyRecordsFromL2 = Object.keys(resultL2).filter(function(k) {
                    return resultL2[k] != null;
                  }).reduce(function(a, k) {
                    var _a2;
                    return __assign(__assign({}, a), (_a2 = {}, _a2[k] = resultL2[k], _a2));
                  }, {});
                  return [2, __assign(__assign({}, resultL1), nonEmptyRecordsFromL2)];
              }
            });
          });
        };
        Uns2.prototype.reverseOf = function(addr, location) {
          return __awaiter(this, void 0, void 0, function() {
            var _a, resultOrErrorL1, resultOrErrorL2, reverseL1, reverseL2, reversedL1, reversedL2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, Promise.all([
                    this.unsl1.reverseOf(addr).catch(function(err) {
                      return err;
                    }),
                    this.unsl2.reverseOf(addr).catch(function(err) {
                      return err;
                    })
                  ])];
                case 1:
                  _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                  reverseL1 = function() {
                    validResultOrThrow(resultOrErrorL1);
                    if (resultOrErrorL1._hex !== "0x00") {
                      return (0, namehash_1.fromHexStringToDecimals)(resultOrErrorL1._hex);
                    } else {
                      return null;
                    }
                  };
                  reverseL2 = function() {
                    validResultOrThrow(resultOrErrorL2);
                    if (resultOrErrorL2._hex !== "0x00") {
                      return (0, namehash_1.fromHexStringToDecimals)(resultOrErrorL2._hex);
                    } else {
                      return null;
                    }
                  };
                  if (location === publicTypes_1.UnsLocation.Layer1) {
                    return [2, reverseL1()];
                  }
                  if (location === publicTypes_1.UnsLocation.Layer2) {
                    return [2, reverseL2()];
                  }
                  reversedL1 = reverseL1();
                  if (reversedL1) {
                    return [2, reversedL1];
                  }
                  reversedL2 = reverseL2();
                  if (reversedL2) {
                    return [2, reversedL2];
                  }
                  return [2, null];
              }
            });
          });
        };
        Uns2.prototype.getDomainFromTokenId = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            var metadata;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getMetadata(tokenId)];
                case 1:
                  metadata = _a.sent();
                  if (this.namehash(metadata.name) !== tokenId) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                      methodName: "unhash",
                      domain: metadata.name,
                      providerMessage: "Service provider returned an invalid domain name"
                    });
                  }
                  return [2, metadata.name];
              }
            });
          });
        };
        Uns2.prototype.getMetadata = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenUri, resp, metadata;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getTokenUri(tokenId)];
                case 1:
                  tokenUri = _a.sent();
                  return [4, Networking_1.default.fetch(tokenUri, {}).catch(function(err) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.MetadataEndpointError, {
                      tokenUri: tokenUri || "undefined",
                      errorMessage: err.message
                    });
                  })];
                case 2:
                  resp = _a.sent();
                  if (!resp.ok) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.MetadataEndpointError, {
                      tokenUri: tokenUri || "undefined"
                    });
                  }
                  return [4, resp.json()];
                case 3:
                  metadata = _a.sent();
                  if (!metadata.name) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain: "with tokenId ".concat(tokenId)
                    });
                  }
                  if (this.namehash(metadata.name) !== tokenId) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                      methodName: "unhash",
                      domain: metadata.name,
                      providerMessage: "Service provider returned an invalid domain name"
                    });
                  }
                  return [2, metadata];
              }
            });
          });
        };
        Uns2.prototype.getVerifiedData = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId, data;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = this.namehash(domain);
                  return [4, this.get(tokenId, keys)];
                case 1:
                  data = _a.sent();
                  if ((0, utils_1.isNullAddress)(data.resolver)) {
                    if ((0, utils_1.isNullAddress)(data.owner)) {
                      throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                        domain
                      });
                    }
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                      location: data.location,
                      domain
                    });
                  }
                  return [2, data];
              }
            });
          });
        };
        Uns2.prototype.get = function(tokenId, keys) {
          if (keys === void 0) {
            keys = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a, resultOrErrorL1, resultOrErrorL2, resolverL2, ownerL2, recordsL2, resolverL1, ownerL1, recordsL1;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, Promise.all([
                    this.unsl1.get(tokenId, keys).catch(function(err) {
                      return err;
                    }),
                    this.unsl2.get(tokenId, keys).catch(function(err) {
                      return err;
                    })
                  ])];
                case 1:
                  _a = _b.sent(), resultOrErrorL1 = _a[0], resultOrErrorL2 = _a[1];
                  validResultOrThrow(resultOrErrorL2);
                  resolverL2 = resultOrErrorL2.resolver, ownerL2 = resultOrErrorL2.owner, recordsL2 = resultOrErrorL2.records;
                  if (!(0, utils_1.isNullAddress)(ownerL2)) {
                    return [2, {
                      resolver: resolverL2,
                      owner: ownerL2,
                      records: (0, utils_1.constructRecords)(keys, recordsL2),
                      location: publicTypes_1.UnsLocation.Layer2
                    }];
                  }
                  validResultOrThrow(resultOrErrorL1);
                  resolverL1 = resultOrErrorL1.resolver, ownerL1 = resultOrErrorL1.owner, recordsL1 = resultOrErrorL1.records;
                  return [2, {
                    resolver: resolverL1,
                    owner: ownerL1,
                    records: (0, utils_1.constructRecords)(keys, recordsL1),
                    location: publicTypes_1.UnsLocation.Layer1
                  }];
              }
            });
          });
        };
        Uns2.prototype.checkDomain = function(domain, passIfTokenID) {
          if (passIfTokenID === void 0) {
            passIfTokenID = false;
          }
          if (passIfTokenID) {
            return true;
          }
          var tokens = domain.split(".");
          return !!tokens.length && !(domain === "eth" || /^[^-]*[^-]*\.(eth|luxe|xyz|kred|addr\.reverse)$/.test(domain)) && tokens.every(function(v) {
            return !!v.length;
          });
        };
        return Uns2;
      }(NamingService_1.NamingService)
    );
    exports.default = Uns;
    function validResultOrThrow(resultOrError) {
      if (resultOrError instanceof Error) {
        throw resultOrError;
      }
      return resultOrError;
    }
    function validResolutionErrorOrThrow(error, validCode) {
      if (!(error instanceof resolutionError_1.default)) {
        throw error;
      }
      if (error.code === validCode) {
        return true;
      }
      throw error;
    }
  }
});

// node_modules/@unstoppabledomains/resolution/build/UdApi.js
var require_UdApi = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/UdApi.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var znsUtils_1 = require_znsUtils();
    var resolutionError_1 = require_resolutionError();
    var TwitterSignatureValidator_1 = require_TwitterSignatureValidator();
    var publicTypes_1 = require_publicTypes();
    var Networking_1 = __importDefault(require_Networking());
    var utils_1 = require_utils();
    var namehash_1 = require_namehash();
    var NamingService_1 = require_NamingService();
    var UdApi = (
      /** @class */
      function(_super) {
        __extends(UdApi2, _super);
        function UdApi2(api) {
          var _this = _super.call(this) || this;
          _this.url = (api === null || api === void 0 ? void 0 : api.url) || "https://unstoppabledomains.com/api/v1";
          var DefaultUserAgent = "cross-fetch/3.1.4 (+https://github.com/lquixada/cross-fetch)";
          var CustomUserAgent = "".concat(DefaultUserAgent, " Resolution");
          _this.headers = { "X-user-agent": CustomUserAgent };
          return _this;
        }
        UdApi2.prototype.isSupportedDomain = function(_domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "isSupportedDomain"
              });
            });
          });
        };
        UdApi2.prototype.namehash = function(_domain) {
          throw new Error("Unsupported method when using UD Resolution API");
        };
        UdApi2.prototype.childhash = function(_parentHash, _label) {
          throw new Error("Unsupported method when using UD Resolution API");
        };
        UdApi2.prototype.record = function(domain, key) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.records(domain, [key])];
                case 1:
                  return [2, _a.sent()[key]];
              }
            });
          });
        };
        UdApi2.prototype.records = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            var records;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.allRecords(domain)];
                case 1:
                  records = _a.sent();
                  return [2, (0, utils_1.constructRecords)(keys, records)];
              }
            });
          });
        };
        UdApi2.prototype.owner = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var response, _a, owner, blockchain;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.resolve(domain)];
                case 1:
                  response = _b.sent();
                  _a = response.meta, owner = _a.owner, blockchain = _a.blockchain;
                  if (!owner) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  if (blockchain === publicTypes_1.BlockchainType.ZIL && !owner.startsWith("zil1")) {
                    return [2, (0, znsUtils_1.toBech32Address)(owner)];
                  }
                  return [2, owner];
              }
            });
          });
        };
        UdApi2.prototype.twitter = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var serviceName, domainMetaData, owner, records, validationSignature, twitterHandle;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  serviceName = (0, utils_1.findNamingServiceName)(domain);
                  if (serviceName !== publicTypes_1.NamingServiceName.UNS) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                      domain,
                      methodName: "twitter"
                    });
                  }
                  return [4, this.resolve(domain)];
                case 1:
                  domainMetaData = _a.sent();
                  if (!domainMetaData.meta.owner) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain
                    });
                  }
                  owner = domainMetaData.meta.owner;
                  records = domainMetaData.records || {};
                  validationSignature = records["validation.social.twitter.username"];
                  twitterHandle = records["social.twitter.username"];
                  if (!validationSignature) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      recordName: "validation.social.twitter.username",
                      domain
                    });
                  }
                  if (!twitterHandle) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      recordName: "social.twitter.username",
                      domain
                    });
                  }
                  if (!(0, TwitterSignatureValidator_1.isValidTwitterSignature)({
                    tokenId: domainMetaData.meta.namehash,
                    owner,
                    twitterHandle,
                    validationSignature
                  })) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.InvalidTwitterVerification, {
                      domain
                    });
                  }
                  return [2, twitterHandle];
              }
            });
          });
        };
        UdApi2.prototype.allRecords = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.resolve(domain)];
                case 1:
                  return [2, _a.sent().records || {}];
              }
            });
          });
        };
        UdApi2.prototype.getDomainFromTokenId = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            var metadata;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenId = (0, namehash_1.fromDecStringToHex)(tokenId);
                  return [4, this.getMetadata(tokenId)];
                case 1:
                  metadata = _a.sent();
                  return [2, metadata.meta.domain];
              }
            });
          });
        };
        UdApi2.prototype.getMetadata = function(tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenUri, resp, metadata, namehash;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  tokenUri = "".concat(this.url, "/").concat(tokenId);
                  return [4, Networking_1.default.fetch(tokenUri, {}).catch(function(err) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.MetadataEndpointError, {
                      tokenUri: tokenUri || "undefined",
                      errorMessage: err.message
                    });
                  })];
                case 1:
                  resp = _a.sent();
                  return [4, resp.json()];
                case 2:
                  metadata = _a.sent();
                  if (!metadata.meta || !metadata.meta.domain) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                      domain: "with tokenId ".concat(tokenId)
                    });
                  }
                  namehash = metadata.meta.blockchain === publicTypes_1.BlockchainType.ZIL ? (0, namehash_1.znsNamehash)(metadata.meta.domain) : (0, namehash_1.eip137Namehash)(metadata.meta.domain);
                  if (namehash !== tokenId) {
                    throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                      methodName: "unhash",
                      domain: metadata.meta.domain,
                      providerMessage: "Service provider returned an invalid domain name"
                    });
                  }
                  return [2, metadata];
              }
            });
          });
        };
        UdApi2.prototype.resolve = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, Networking_1.default.fetch("".concat(this.url, "/").concat(domain), {
                    method: "GET",
                    headers: this.headers
                  })];
                case 1:
                  response = _a.sent();
                  return [2, response.json()];
              }
            });
          });
        };
        UdApi2.prototype.resolver = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var record;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.resolve(domain)];
                case 1:
                  record = _a.sent();
                  return [2, record.meta.resolver];
              }
            });
          });
        };
        UdApi2.prototype.reverse = function(_address, _currencyTicker) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "reverse"
              });
            });
          });
        };
        UdApi2.prototype.reverseOf = function(_address, _location) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "reverseOf"
              });
            });
          });
        };
        UdApi2.prototype.isRegistered = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var record;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.resolve(domain)];
                case 1:
                  record = _a.sent();
                  return [2, !(0, utils_1.isNullAddress)(record.meta.owner)];
              }
            });
          });
        };
        UdApi2.prototype.getTokenUri = function(_tokenId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "getTokenUri"
              });
            });
          });
        };
        UdApi2.prototype.isAvailable = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.isRegistered(domain)];
                case 1:
                  return [2, !_a.sent()];
              }
            });
          });
        };
        UdApi2.prototype.registryAddress = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                domain,
                methodName: "registryAddress"
              });
            });
          });
        };
        UdApi2.prototype.locations = function(_domains) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              throw new resolutionError_1.ResolutionError(resolutionError_1.ResolutionErrorCode.UnsupportedMethod, {
                methodName: "locations"
              });
            });
          });
        };
        return UdApi2;
      }(NamingService_1.NamingService)
    );
    exports.default = UdApi;
  }
});

// node_modules/@unstoppabledomains/resolution/build/errors/dnsRecordsError.js
var require_dnsRecordsError = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/errors/dnsRecordsError.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DnsRecordsError = exports.DnsRecordsErrorCode = void 0;
    var DnsRecordsErrorCode;
    (function(DnsRecordsErrorCode2) {
      DnsRecordsErrorCode2["InconsistentTtl"] = "InconsistentTtl";
      DnsRecordsErrorCode2["DnsRecordCorrupted"] = "DnsRecordCorrupted";
    })(DnsRecordsErrorCode = exports.DnsRecordsErrorCode || (exports.DnsRecordsErrorCode = {}));
    var HandlersByCode = (_a = {}, _a[DnsRecordsErrorCode.InconsistentTtl] = function(params) {
      return "ttl for record ".concat(params.recordType, " is different for other records of the same type");
    }, _a[DnsRecordsErrorCode.DnsRecordCorrupted] = function(params) {
      return "dns record ".concat(params.recordType, " is invalid json-string");
    }, _a);
    var DnsRecordsError = (
      /** @class */
      function(_super) {
        __extends(DnsRecordsError2, _super);
        function DnsRecordsError2(code, options) {
          if (options === void 0) {
            options = {};
          }
          var _this = this;
          var DnsRecordsErrorHandler = HandlersByCode[code];
          _this = _super.call(this, DnsRecordsErrorHandler(options)) || this;
          _this.code = code;
          _this.name = "DnsRecordsError";
          Object.setPrototypeOf(_this, DnsRecordsError2.prototype);
          return _this;
        }
        return DnsRecordsError2;
      }(Error)
    );
    exports.DnsRecordsError = DnsRecordsError;
    exports.default = DnsRecordsError;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/DnsUtils.js
var require_DnsUtils = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/DnsUtils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var dnsRecordsError_1 = __importStar(require_dnsRecordsError());
    var publicTypes_1 = require_publicTypes();
    var DnsUtils = (
      /** @class */
      function() {
        function DnsUtils2() {
        }
        DnsUtils2.prototype.toList = function(record) {
          var _a;
          var _this = this;
          var dnsTypes = this.getAllDnsTypes(record);
          return (_a = []).concat.apply(_a, dnsTypes.map(function(type) {
            return _this.constructDnsRecords(record, type);
          }));
        };
        DnsUtils2.prototype.toCrypto = function(records) {
          var cryptoRecords = {};
          for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
            var record = records_1[_i];
            var type = record.type, TTL = record.TTL, data = record.data;
            var ttlInRecord = this.getJsonNumber(cryptoRecords["dns.".concat(type, ".ttl")]);
            var dnsInRecord = this.getJsonArray(cryptoRecords, "dns.".concat(type));
            if (dnsInRecord) {
              dnsInRecord.push(data);
              cryptoRecords["dns.".concat(type)] = JSON.stringify(dnsInRecord);
            } else {
              cryptoRecords["dns.".concat(type)] = JSON.stringify([data]);
              cryptoRecords["dns.".concat(type, ".ttl")] = TTL.toString(10);
            }
            if (!!ttlInRecord && ttlInRecord !== TTL) {
              throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.InconsistentTtl, {
                recordType: type
              });
            }
          }
          return cryptoRecords;
        };
        DnsUtils2.prototype.protectFromCorruptRecord = function(rawRecord, type) {
          try {
            return rawRecord ? JSON.parse(rawRecord) : void 0;
          } catch (err) {
            if (err instanceof SyntaxError) {
              throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.DnsRecordCorrupted, {
                recordType: type
              });
            }
            throw err;
          }
        };
        DnsUtils2.prototype.getJsonArray = function(cryptoRecrods, key) {
          var rawRecord = cryptoRecrods[key];
          var type = key.split(".")[1];
          return this.protectFromCorruptRecord(rawRecord, type);
        };
        DnsUtils2.prototype.getJsonNumber = function(rawRecord) {
          return rawRecord ? parseInt(rawRecord, 10) : void 0;
        };
        DnsUtils2.prototype.getAllDnsTypes = function(records) {
          var keys = /* @__PURE__ */ new Set();
          Object.keys(records).forEach(function(key) {
            var chunks = key.split(".");
            var type = chunks[1] && chunks[1] !== "ttl";
            if (type) {
              keys.add(publicTypes_1.DnsRecordType[chunks[1]]);
            }
          });
          return Array.from(keys);
        };
        DnsUtils2.prototype.constructDnsRecords = function(cryptoData, type) {
          var TTL = this.parseTtl(cryptoData, type);
          var jsonValueString = cryptoData["dns.".concat(type)];
          if (!jsonValueString) {
            return [];
          }
          var typeData = this.protectFromCorruptRecord(jsonValueString, type);
          if (!this.isStringArray(typeData)) {
            return [];
          }
          return typeData.map(function(data) {
            return { TTL, data, type };
          });
        };
        DnsUtils2.prototype.parseTtl = function(data, type) {
          var defaultTtl = data["dns.ttl"];
          var recordTtl = data["dns.".concat(type, ".ttl")];
          if (recordTtl) {
            var parsedInt = this.parseIfNumber(recordTtl);
            if (parsedInt) {
              return parsedInt;
            }
          }
          if (defaultTtl) {
            var parsedInt = this.parseIfNumber(defaultTtl);
            if (parsedInt) {
              return parsedInt;
            }
          }
          return DnsUtils2.DefaultTtl;
        };
        DnsUtils2.prototype.parseIfNumber = function(str) {
          var parsedInt = parseInt(str, 10);
          if (!isNaN(parsedInt)) {
            return parsedInt;
          }
        };
        DnsUtils2.prototype.isStringArray = function(value) {
          if (value instanceof Array) {
            return value.every(function(item) {
              return typeof item === "string";
            });
          }
          return false;
        };
        DnsUtils2.DefaultTtl = 300;
        return DnsUtils2;
      }()
    );
    exports.default = DnsUtils;
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/Eip1993Factories.js
var require_Eip1993Factories = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/Eip1993Factories.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Eip1993Factories = void 0;
    var configurationError_1 = require_configurationError();
    var resolutionError_1 = __importStar(require_resolutionError());
    exports.Eip1993Factories = {
      fromWeb3Version0Provider,
      fromWeb3Version1Provider,
      fromEthersProvider,
      fromZilliqaProvider
    };
    function fromWeb3Version0Provider(provider) {
      if (provider.sendAsync === void 0) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
      }
      return {
        request: function(request) {
          return new Promise(function(resolve, reject) {
            provider.sendAsync({
              jsonrpc: "2.0",
              method: request.method,
              params: wrapArray(request.params),
              id: 1
            }, function(error, result) {
              if (error) {
                reject(error);
              }
              if (result.error) {
                reject(new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                  providerMessage: result.error
                }));
              }
              resolve(result.result);
            });
          });
        }
      };
    }
    function fromWeb3Version1Provider(provider) {
      if (provider.send === void 0) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
      }
      return {
        request: function(request) {
          return new Promise(function(resolve, reject) {
            provider.send({
              jsonrpc: "2.0",
              method: request.method,
              params: wrapArray(request.params),
              id: 1
            }, function(error, result) {
              if (error) {
                reject(error);
              }
              if (result.error) {
                reject(new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                  providerMessage: result.error
                }));
              }
              resolve(result.result);
            });
          });
        }
      };
    }
    function fromEthersProvider(provider) {
      var _this = this;
      if (provider.call === void 0) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
      }
      return {
        request: function(request) {
          return __awaiter(_this, void 0, void 0, function() {
            var _a, error_1;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _b.trys.push([0, 7, , 8]);
                  _a = request.method;
                  switch (_a) {
                    case "eth_call":
                      return [3, 1];
                    case "eth_getLogs":
                      return [3, 3];
                  }
                  return [3, 5];
                case 1:
                  return [4, provider.call(request.params[0])];
                case 2:
                  return [2, _b.sent()];
                case 3:
                  return [4, provider.getLogs(request.params[0])];
                case 4:
                  return [2, _b.sent()];
                case 5:
                  throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                    providerMessage: "Unsupported provider method ".concat(request.method)
                  });
                case 6:
                  return [3, 8];
                case 7:
                  error_1 = _b.sent();
                  throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                    providerMessage: error_1.message
                  });
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      };
    }
    function fromZilliqaProvider(provider) {
      var _this = this;
      if (provider.middleware === void 0 || provider.send === void 0) {
        throw new configurationError_1.ConfigurationError(configurationError_1.ConfigurationErrorCode.IncorrectProvider);
      }
      return {
        request: function(request) {
          return __awaiter(_this, void 0, void 0, function() {
            var resp, error_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 3]);
                  return [4, provider.send.apply(provider, __spreadArray([request.method], request.params || [], false))];
                case 1:
                  resp = _a.sent();
                  if (resp.error) {
                    throw new Error(resp.error.message);
                  }
                  return [2, resp.result];
                case 2:
                  error_2 = _a.sent();
                  throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                    providerMessage: error_2.message
                  });
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      };
    }
    function wrapArray(params) {
      if (params === void 0) {
        params = [];
      }
      return params instanceof Array ? params : [params];
    }
  }
});

// node_modules/@unstoppabledomains/resolution/build/utils/prepareAndValidate.js
var require_prepareAndValidate = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/utils/prepareAndValidate.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareAndValidateDomain = void 0;
    var resolutionError_1 = __importStar(require_resolutionError());
    var reg = RegExp("^[.a-z0-9-]+$");
    function prepareAndValidateDomain(domain) {
      var retVal = domain ? domain.trim().toLowerCase() : "";
      if (!reg.test(retVal)) {
        throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.InvalidDomainAddress, {
          domain
        });
      }
      return retVal;
    }
    exports.prepareAndValidateDomain = prepareAndValidateDomain;
  }
});

// node_modules/@unstoppabledomains/resolution/build/Resolution.js
var require_Resolution = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/Resolution.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Resolution = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var Zns_1 = __importDefault(require_Zns());
    var Uns_1 = __importDefault(require_Uns());
    var UdApi_1 = __importDefault(require_UdApi());
    var publicTypes_1 = require_publicTypes();
    var resolutionError_1 = __importStar(require_resolutionError());
    var DnsUtils_1 = __importDefault(require_DnsUtils());
    var utils_1 = require_utils();
    var Eip1993Factories_1 = require_Eip1993Factories();
    var Networking_1 = __importDefault(require_Networking());
    var prepareAndValidate_1 = require_prepareAndValidate();
    var namehash_1 = require_namehash();
    var Resolution = (
      /** @class */
      function() {
        function Resolution2(_a) {
          var _b;
          var _c = _a === void 0 ? {} : _a, _d = _c.sourceConfig, sourceConfig = _d === void 0 ? void 0 : _d;
          var uns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) : new Uns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns);
          var zns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) : new Zns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns);
          var equalUdApiProviders = uns instanceof UdApi_1.default && zns instanceof UdApi_1.default && uns.url === zns.url;
          this.serviceMap = (_b = {}, _b[publicTypes_1.NamingServiceName.UNS] = {
            usedServices: [uns],
            native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) ? new Uns_1.default() : uns
          }, _b[publicTypes_1.NamingServiceName.ZNS] = {
            usedServices: equalUdApiProviders ? [uns] : [uns, zns],
            native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new Zns_1.default() : zns
          }, _b);
        }
        Resolution2.autoNetwork = function(sourceConfig) {
          return __awaiter(this, void 0, void 0, function() {
            var resolution, uns;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  resolution = new this();
                  if (!sourceConfig.uns) return [3, 2];
                  return [4, Uns_1.default.autoNetwork(sourceConfig.uns)];
                case 1:
                  uns = _a.sent();
                  resolution.serviceMap[publicTypes_1.NamingServiceName.UNS] = {
                    usedServices: [uns],
                    native: uns
                  };
                  _a.label = 2;
                case 2:
                  return [2, resolution];
              }
            });
          });
        };
        Resolution2.infura = function(infura, networks) {
          var _a, _b, _c, _d;
          return new this({
            sourceConfig: {
              uns: {
                locations: {
                  Layer1: {
                    url: (0, utils_1.signedLink)(infura, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || "mainnet", "infura"),
                    network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || "mainnet"
                  },
                  Layer2: {
                    url: (0, utils_1.signedLink)(infura, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || "polygon-mainnet", "infura"),
                    network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || "polygon-mainnet"
                  }
                }
              }
            }
          });
        };
        Resolution2.alchemy = function(alchemy, networks) {
          var _a, _b, _c, _d;
          return new this({
            sourceConfig: {
              uns: {
                locations: {
                  Layer1: {
                    url: (0, utils_1.signedLink)(alchemy, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || "mainnet"),
                    network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || "mainnet"
                  },
                  Layer2: {
                    url: (0, utils_1.signedLink)(alchemy, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || "polygon-mainnet"),
                    network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || "polygon-mainnet"
                  }
                }
              }
            }
          });
        };
        Resolution2.fromResolutionProvider = function(networks) {
          if (networks.uns) {
            return this.fromEthereumEip1193Provider({
              uns: networks.uns
            });
          }
          if (networks.zns) {
            return this.fromZilliqaProvider(networks.zns.provider, networks);
          }
          throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
            providerMessage: "Must specify network for uns or zns"
          });
        };
        Resolution2.fromEthereumEip1193Provider = function(networks) {
          var sourceConfig = {};
          if (networks.uns) {
            sourceConfig.uns = {
              locations: {
                Layer1: {
                  provider: networks.uns.locations.Layer1.provider,
                  network: networks.uns.locations.Layer1.network || "mainnet"
                },
                Layer2: {
                  provider: networks.uns.locations.Layer2.provider,
                  network: networks.uns.locations.Layer2.network || "polygon-mainnet"
                }
              }
            };
          }
          return new this({
            sourceConfig
          });
        };
        Resolution2.fromZilliqaProvider = function(provider, networks) {
          var _a;
          return new this({
            sourceConfig: {
              zns: { provider, network: ((_a = networks === null || networks === void 0 ? void 0 : networks.zns) === null || _a === void 0 ? void 0 : _a.network) || "mainnet" }
            }
          });
        };
        Resolution2.fromWeb3Version0Provider = function(networks) {
          return this.fromEthereumEip1193Provider({
            uns: networks.uns ? {
              locations: {
                Layer1: {
                  network: networks.uns.locations.Layer1.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer1.provider)
                },
                Layer2: {
                  network: networks.uns.locations.Layer2.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer2.provider)
                }
              }
            } : void 0
          });
        };
        Resolution2.fromWeb3Version1Provider = function(networks) {
          return this.fromEthereumEip1193Provider({
            uns: networks.uns ? {
              locations: {
                Layer1: {
                  network: networks.uns.locations.Layer1.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer1.provider)
                },
                Layer2: {
                  network: networks.uns.locations.Layer2.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer2.provider)
                }
              }
            } : void 0
          });
        };
        Resolution2.fromEthersProvider = function(networks) {
          return this.fromEthereumEip1193Provider({
            uns: networks.uns ? {
              locations: {
                Layer1: {
                  network: networks.uns.locations.Layer1.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer1.provider)
                },
                Layer2: {
                  network: networks.uns.locations.Layer2.network,
                  provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer2.provider)
                }
              }
            } : void 0
          });
        };
        Resolution2.prototype.addr = function(domain, ticker) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.record(domain, "crypto.".concat(ticker.toUpperCase(), ".address"))];
            });
          });
        };
        Resolution2.prototype.multiChainAddr = function(domain, ticker, chain) {
          return __awaiter(this, void 0, void 0, function() {
            var recordKey;
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              recordKey = "crypto.".concat(ticker.toUpperCase(), ".version.").concat(chain.toUpperCase(), ".address");
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.record(domain, recordKey);
              })];
            });
          });
        };
        Resolution2.prototype.twitter = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.twitter(domain);
              })];
            });
          });
        };
        Resolution2.prototype.chatId = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.record(domain, "gundb.username.value")];
            });
          });
        };
        Resolution2.prototype.chatPk = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.record(domain, "gundb.public_key.value")];
            });
          });
        };
        Resolution2.prototype.ipfsHash = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.getPreferableNewRecord(domain, "dweb.ipfs.hash", "ipfs.html.value")];
            });
          });
        };
        Resolution2.prototype.httpUrl = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.getPreferableNewRecord(domain, "browser.redirect_url", "ipfs.redirect_domain.value")];
            });
          });
        };
        Resolution2.prototype.email = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.record(domain, "whois.email.value")];
            });
          });
        };
        Resolution2.prototype.resolver = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var resolver;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                  return [4, this.callServiceForDomain(domain, function(service) {
                    return service.resolver(domain);
                  })];
                case 1:
                  resolver = _a.sent();
                  if (!resolver) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                      domain
                    });
                  }
                  return [2, resolver];
              }
            });
          });
        };
        Resolution2.prototype.owner = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.owner(domain);
              })];
            });
          });
        };
        Resolution2.prototype.record = function(domain, recordKey) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.record(domain, recordKey);
              })];
            });
          });
        };
        Resolution2.prototype.records = function(domain, keys) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.records(domain, keys);
              })];
            });
          });
        };
        Resolution2.prototype.isRegistered = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomainBoolean(domain, function(service) {
                return service.isRegistered(domain);
              }, {
                throwIfUnsupportedDomain: true,
                expectedValue: true
              })];
            });
          });
        };
        Resolution2.prototype.isAvailable = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomainBoolean(domain, function(service) {
                return service.isAvailable(domain);
              }, {
                throwIfUnsupportedDomain: true,
                expectedValue: false
              })];
            });
          });
        };
        Resolution2.prototype.namehash = function(domain, namingService, options) {
          if (options === void 0) {
            options = publicTypes_1.NamehashOptionsDefault;
          }
          var service = this.serviceMap[namingService];
          if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
              namingService
            });
          }
          domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
          return this.formatNamehash(service.native.namehash(domain), options);
        };
        Resolution2.prototype.childhash = function(parent, label, namingService, options) {
          if (options === void 0) {
            options = publicTypes_1.NamehashOptionsDefault;
          }
          var service = this.serviceMap[namingService];
          if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
              namingService
            });
          }
          return this.formatNamehash(service.native.childhash(parent, label), options);
        };
        Resolution2.prototype.formatNamehash = function(hash, options) {
          hash = hash.replace("0x", "");
          if (options.format === "dec") {
            return new bn_js_1.default(hash, "hex").toString(10);
          } else {
            return options.prefix ? "0x" + hash : hash;
          }
        };
        Resolution2.prototype.isValidHash = function(domain, hash, namingService) {
          var service = this.serviceMap[namingService];
          if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
              namingService
            });
          }
          domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
          return service.native.namehash(domain) === hash;
        };
        Resolution2.prototype.isSupportedDomain = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomainBoolean(domain, function(service) {
                return service.isSupportedDomain(domain);
              }, {
                throwIfUnsupportedDomain: false,
                expectedValue: true
              })];
            });
          });
        };
        Resolution2.prototype.allRecords = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.allRecords(domain);
              })];
            });
          });
        };
        Resolution2.prototype.dns = function(domain, types) {
          return __awaiter(this, void 0, void 0, function() {
            var dnsUtils, dnsRecordKeys, blockchainData;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  dnsUtils = new DnsUtils_1.default();
                  domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);
                  dnsRecordKeys = this.getDnsRecordKeys(types);
                  return [4, this.callServiceForDomain(domain, function(service) {
                    return service.records(domain, dnsRecordKeys);
                  })];
                case 1:
                  blockchainData = _a.sent();
                  return [2, dnsUtils.toList(blockchainData)];
              }
            });
          });
        };
        Resolution2.prototype.tokenURI = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var namehash;
            return __generator(this, function(_a) {
              namehash = this.namehash(domain, publicTypes_1.NamingServiceName.UNS);
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.getTokenUri(namehash);
              })];
            });
          });
        };
        Resolution2.prototype.tokenURIMetadata = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenUri;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.tokenURI(domain)];
                case 1:
                  tokenUri = _a.sent();
                  return [2, this.getMetadataFromTokenURI(tokenUri)];
              }
            });
          });
        };
        Resolution2.prototype.registryAddress = function(domain) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.callServiceForDomain(domain, function(service) {
                return service.registryAddress(domain);
              })];
            });
          });
        };
        Resolution2.prototype.unhash = function(hash, service) {
          return __awaiter(this, void 0, void 0, function() {
            var services, method;
            return __generator(this, function(_a) {
              hash = (0, namehash_1.fromDecStringToHex)(hash);
              services = this.serviceMap[service].usedServices;
              method = services[services.length - 1];
              return [2, method.getDomainFromTokenId(hash)];
            });
          });
        };
        Resolution2.prototype.locations = function(domains) {
          return __awaiter(this, void 0, void 0, function() {
            var zilDomains, unsPromise, znsServices, znsService, znsPromise, unsLocations, emptyZilEntries, znsLocations, _i, emptyZilEntries_1, domain;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  zilDomains = domains.filter(function(domain2) {
                    return domain2.endsWith(".zil");
                  });
                  unsPromise = this.serviceMap.UNS.usedServices[0].locations(domains);
                  if (!zilDomains.length) {
                    return [2, unsPromise];
                  }
                  znsServices = this.serviceMap.ZNS.usedServices;
                  znsService = znsServices[znsServices.length - 1];
                  znsPromise = (0, utils_1.wrapResult)(function() {
                    return znsService.locations(zilDomains);
                  });
                  return [4, unsPromise];
                case 1:
                  unsLocations = _a.sent();
                  emptyZilEntries = Object.entries(unsLocations).filter(function(_a2) {
                    var domain2 = _a2[0], location = _a2[1];
                    return domain2.endsWith(".zil") && !location;
                  });
                  if (!emptyZilEntries.length) {
                    return [2, unsLocations];
                  }
                  return [4, znsPromise.then(utils_1.unwrapResult)];
                case 2:
                  znsLocations = _a.sent();
                  for (_i = 0, emptyZilEntries_1 = emptyZilEntries; _i < emptyZilEntries_1.length; _i++) {
                    domain = emptyZilEntries_1[_i][0];
                    unsLocations[domain] = znsLocations[domain];
                  }
                  return [2, unsLocations];
              }
            });
          });
        };
        Resolution2.prototype.reverseTokenId = function(address, options) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId;
            return __generator(this, function(_a) {
              tokenId = this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location);
              return [2, tokenId];
            });
          });
        };
        Resolution2.prototype.reverse = function(address, options) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenId;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location)];
                case 1:
                  tokenId = _a.sent();
                  if (tokenId) {
                    return [2, this.unhash(tokenId, publicTypes_1.NamingServiceName.UNS)];
                  }
                  return [2, null];
              }
            });
          });
        };
        Resolution2.prototype.getMetadataFromTokenURI = function(tokenUri) {
          return __awaiter(this, void 0, void 0, function() {
            var resp, _a, _b;
            var _c;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, Networking_1.default.fetch(tokenUri, {})];
                case 1:
                  resp = _d.sent();
                  if (resp.ok) {
                    return [2, resp.json()];
                  }
                  _a = resolutionError_1.default.bind;
                  _b = [void 0, resolutionError_1.ResolutionErrorCode.ServiceProviderError];
                  _c = {};
                  return [4, resp.text()];
                case 2:
                  throw new (_a.apply(resolutionError_1.default, _b.concat([(_c.providerMessage = _d.sent(), _c.method = "UDAPI", _c.methodName = "tokenURIMetadata", _c)])))();
              }
            });
          });
        };
        Resolution2.prototype.getDnsRecordKeys = function(types) {
          var records = ["dns.ttl"];
          types.forEach(function(type) {
            records.push("dns.".concat(type));
            records.push("dns.".concat(type, ".ttl"));
          });
          return records;
        };
        Resolution2.prototype.getPreferableNewRecord = function(domain, newRecord, oldRecord) {
          return __awaiter(this, void 0, void 0, function() {
            var records;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.records(domain, [newRecord, oldRecord])];
                case 1:
                  records = _a.sent();
                  if (!records[newRecord] && !records[oldRecord]) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                      recordName: newRecord,
                      domain
                    });
                  }
                  return [2, records[newRecord] || records[oldRecord]];
              }
            });
          });
        };
        Resolution2.prototype.callServiceForDomain = function(domain, func) {
          return __awaiter(this, void 0, void 0, function() {
            var serviceName, servicePromises, _i, servicePromises_1, servicePromise, serviceCallResult;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  serviceName = (0, utils_1.findNamingServiceName)(domain);
                  if (!serviceName) {
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                      domain
                    });
                  }
                  servicePromises = this.serviceMap[serviceName].usedServices.map(function(service) {
                    return (0, utils_1.wrapResult)(function() {
                      return func(service);
                    });
                  });
                  _i = 0, servicePromises_1 = servicePromises;
                  _a.label = 1;
                case 1:
                  if (!(_i < servicePromises_1.length)) return [3, 4];
                  servicePromise = servicePromises_1[_i];
                  return [4, servicePromise];
                case 2:
                  serviceCallResult = _a.sent();
                  if (serviceCallResult.error !== null) {
                    if (!(serviceCallResult.error instanceof resolutionError_1.default && serviceCallResult.error.code === resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {
                      throw serviceCallResult.error;
                    }
                  } else {
                    return [2, serviceCallResult.result];
                  }
                  _a.label = 3;
                case 3:
                  _i++;
                  return [3, 1];
                case 4:
                  throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {
                    domain
                  });
              }
            });
          });
        };
        Resolution2.prototype.callServiceForDomainBoolean = function(domain, func, options) {
          return __awaiter(this, void 0, void 0, function() {
            var serviceName, servicePromises, _i, servicePromises_2, servicePromise, _a, result, error;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  serviceName = (0, utils_1.findNamingServiceName)(domain);
                  if (!serviceName) {
                    if (!options.throwIfUnsupportedDomain) {
                      return [2, !options.expectedValue];
                    }
                    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                      domain
                    });
                  }
                  servicePromises = this.serviceMap[serviceName].usedServices.map(function(service) {
                    return (0, utils_1.wrapResult)(function() {
                      return func(service);
                    });
                  });
                  _i = 0, servicePromises_2 = servicePromises;
                  _b.label = 1;
                case 1:
                  if (!(_i < servicePromises_2.length)) return [3, 4];
                  servicePromise = servicePromises_2[_i];
                  return [4, servicePromise];
                case 2:
                  _a = _b.sent(), result = _a.result, error = _a.error;
                  if (error) {
                    if (!(error instanceof resolutionError_1.default && error.code === resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {
                      throw error;
                    }
                  } else if (result === options.expectedValue) {
                    return [2, result];
                  }
                  _b.label = 3;
                case 3:
                  _i++;
                  return [3, 1];
                case 4:
                  return [2, !options.expectedValue];
              }
            });
          });
        };
        Resolution2.prototype.reverseGetTokenId = function(address, location) {
          return __awaiter(this, void 0, void 0, function() {
            var service, tokenId;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  service = this.serviceMap["UNS"].native;
                  return [4, service.reverseOf(address, location)];
                case 1:
                  tokenId = _a.sent();
                  return [2, tokenId];
              }
            });
          });
        };
        return Resolution2;
      }()
    );
    exports.Resolution = Resolution;
    exports.default = Resolution;
    function isApi(obj) {
      return obj && obj.api;
    }
  }
});

// node_modules/@unstoppabledomains/resolution/build/index.js
var require_build = __commonJS({
  "node_modules/@unstoppabledomains/resolution/build/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderFactories = exports.Eip1193Factories = exports.Eip1993Factories = exports.DnsRecordsErrorCode = exports.DnsRecordsError = exports.ConfigurationErrorCode = exports.ConfigurationError = exports.ResolutionErrorCode = exports.ResolutionError = exports.DnsUtils = exports.default = exports.Resolution = void 0;
    var Resolution_1 = require_Resolution();
    Object.defineProperty(exports, "Resolution", { enumerable: true, get: function() {
      return Resolution_1.Resolution;
    } });
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return Resolution_1.Resolution;
    } });
    __exportStar(require_publicTypes(), exports);
    var DnsUtils_1 = require_DnsUtils();
    Object.defineProperty(exports, "DnsUtils", { enumerable: true, get: function() {
      return __importDefault(DnsUtils_1).default;
    } });
    var resolutionError_1 = require_resolutionError();
    Object.defineProperty(exports, "ResolutionError", { enumerable: true, get: function() {
      return resolutionError_1.ResolutionError;
    } });
    Object.defineProperty(exports, "ResolutionErrorCode", { enumerable: true, get: function() {
      return resolutionError_1.ResolutionErrorCode;
    } });
    var configurationError_1 = require_configurationError();
    Object.defineProperty(exports, "ConfigurationError", { enumerable: true, get: function() {
      return configurationError_1.ConfigurationError;
    } });
    Object.defineProperty(exports, "ConfigurationErrorCode", { enumerable: true, get: function() {
      return configurationError_1.ConfigurationErrorCode;
    } });
    var dnsRecordsError_1 = require_dnsRecordsError();
    Object.defineProperty(exports, "DnsRecordsError", { enumerable: true, get: function() {
      return dnsRecordsError_1.DnsRecordsError;
    } });
    Object.defineProperty(exports, "DnsRecordsErrorCode", { enumerable: true, get: function() {
      return dnsRecordsError_1.DnsRecordsErrorCode;
    } });
    var Eip1993Factories_1 = require_Eip1993Factories();
    Object.defineProperty(exports, "Eip1993Factories", { enumerable: true, get: function() {
      return Eip1993Factories_1.Eip1993Factories;
    } });
    var Eip1993Factories_2 = require_Eip1993Factories();
    Object.defineProperty(exports, "Eip1193Factories", { enumerable: true, get: function() {
      return Eip1993Factories_2.Eip1993Factories;
    } });
    var Eip1993Factories_3 = require_Eip1993Factories();
    Object.defineProperty(exports, "ProviderFactories", { enumerable: true, get: function() {
      return Eip1993Factories_3.Eip1993Factories;
    } });
  }
});

export {
  require_build
};
//# sourceMappingURL=chunk-STAUNXPQ.js.map

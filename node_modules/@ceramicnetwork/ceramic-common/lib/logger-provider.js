"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootLogger = exports.LoggerProvider = void 0;
const loglevel_1 = __importDefault(require("loglevel"));
exports.RootLogger = loglevel_1.default;
const loglevel_plugin_prefix_1 = __importDefault(require("loglevel-plugin-prefix"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const defaultOpts = {
    level: 'info',
    format: 'text',
    stacktrace: {
        levels: ['trace', 'warn', 'error'],
        depth: 3,
        excess: 0,
    },
};
class LoggerProvider {
    static init(opts = defaultOpts) {
        this.options = Object.assign(defaultOpts, opts);
        if (this.options.level) {
            loglevel_1.default.setLevel(this.options.level);
        }
        else {
            loglevel_1.default.enableAll();
        }
        LoggerProvider._applyPrefix();
        LoggerProvider._includeJsonPlugin();
        return lodash_clonedeep_1.default(this.options);
    }
    static addPlugin(plugin, loggerOptions, pluginOptions) {
        plugin(loglevel_1.default, loggerOptions, pluginOptions);
    }
    static _applyPrefix() {
        loglevel_plugin_prefix_1.default.reg(loglevel_1.default);
        loglevel_plugin_prefix_1.default.apply(loglevel_1.default, {
            format(level, name, timestamp) {
                return LoggerProvider._toText(timestamp, level, name);
            },
            timestampFormatter(date) {
                return date.toISOString();
            }
        });
    }
    static _includeJsonPlugin() {
        const originalFactory = loglevel_1.default.methodFactory;
        loglevel_1.default.methodFactory = (methodName, logLevel, loggerName) => {
            const rawMethod = originalFactory(methodName, logLevel, loggerName);
            return (...args) => {
                if (this.options.format !== 'json') {
                    rawMethod(...args);
                    return;
                }
                const timestamp = new Date().toISOString();
                const hasStacktrace = !!LoggerProvider._stacktrace();
                const needStack = hasStacktrace && this.options.stacktrace.levels.some(level => level === methodName);
                let stacktrace = needStack ? LoggerProvider._stacktrace() : '';
                if (stacktrace) {
                    const lines = stacktrace.split('\n');
                    lines.splice(0, this.options.stacktrace.excess + 3);
                    const { depth } = this.options.stacktrace;
                    if (depth && lines.length !== depth + 1) {
                        const shrink = lines.splice(0, depth);
                        stacktrace = shrink.join('\n');
                        if (lines.length) {
                            stacktrace += `\n    and ${lines.length} more`;
                        }
                    }
                    else {
                        stacktrace = lines.join('\n');
                    }
                }
                rawMethod(JSON.stringify({
                    message: LoggerProvider._interpolate(args),
                    level: {
                        label: methodName, value: logLevel,
                    },
                    logger: loggerName || '',
                    timestamp,
                    stacktrace,
                    component: this.options.component || undefined
                }));
            };
        };
        loglevel_1.default.setLevel(loglevel_1.default.getLevel());
    }
    static _toText(timestamp, level, name) {
        if (this.options.format === 'json') {
            return "";
        }
        return `[${timestamp}] ${level} ${this.options.component ? this.options.component : ""} ${name}:`;
    }
    static _stacktrace() {
        try {
            throw new Error();
        }
        catch (trace) {
            return trace.stack;
        }
    }
    static _interpolate(array) {
        let result = '';
        let index = 0;
        if (array.length > 1 && typeof array[0] === 'string') {
            result = array[0].replace(/(%?)(%([sdjo]))/g, (match, escaped, ptn, flag) => {
                if (!escaped) {
                    index += 1;
                    const arg = array[index];
                    let a = '';
                    switch (flag) {
                        case 's':
                            a += arg;
                            break;
                        case 'd':
                            a += +arg;
                            break;
                        case 'j':
                            a = LoggerProvider._safeStringify(arg);
                            break;
                        case 'o': {
                            let obj = LoggerProvider._safeStringify(arg);
                            if (obj[0] !== '{' && obj[0] !== '[') {
                                obj = `<${obj}>`;
                            }
                            a = LoggerProvider._constructorName(arg) + obj;
                            break;
                        }
                    }
                    return a;
                }
                return match;
            });
            result = result.replace(/%{2,2}/g, '%');
            index += 1;
        }
        if (array.length > index) {
            if (result)
                result += ' ';
            result += array.slice(index).join(' ');
        }
        return result;
    }
    static _constructorName(obj) {
        if (!Object.getOwnPropertyDescriptor || !Object.getPrototypeOf) {
            return Object.prototype.toString.call(obj).slice(8, -1);
        }
        while (obj) {
            const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
            if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
                return descriptor.value.name;
            }
            obj = Object.getPrototypeOf(obj);
        }
        return '';
    }
    static _safeStringify(obj, indent = 0) {
        let cache = [];
        const retVal = JSON.stringify(obj, (key, value) => typeof value === "object" && value !== null
            ? cache.includes(value)
                ? undefined
                : cache.push(value) && value
            : value, indent);
        cache = null;
        return retVal;
    }
}
exports.LoggerProvider = LoggerProvider;
//# sourceMappingURL=logger-provider.js.map
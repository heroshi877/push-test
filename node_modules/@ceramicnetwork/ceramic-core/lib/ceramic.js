"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dispatcher_1 = __importDefault(require("./dispatcher"));
const document_1 = __importDefault(require("./document"));
const _3id_did_resolver_1 = __importDefault(require("@ceramicnetwork/3id-did-resolver"));
const key_did_resolver_1 = __importDefault(require("@ceramicnetwork/key-did-resolver"));
const docid_1 = __importDefault(require("@ceramicnetwork/docid"));
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const did_resolver_1 = require("did-resolver");
const dids_1 = require("dids");
const ceramic_doctype_tile_1 = require("@ceramicnetwork/ceramic-doctype-tile");
const ceramic_doctype_account_link_1 = require("@ceramicnetwork/ceramic-doctype-account-link");
const pin_store_factory_1 = require("./store/pin-store-factory");
const ethereum_anchor_service_1 = __importDefault(require("./anchor/ethereum/ethereum-anchor-service"));
const in_memory_anchor_service_1 = __importDefault(require("./anchor/memory/in-memory-anchor-service"));
const normalizeDocID = (docId) => {
    return (typeof docId === 'string') ? docid_1.default.fromString(docId) : docId;
};
class Ceramic {
    constructor(dispatcher, pinStore, context, _validateDocs = true) {
        this.dispatcher = dispatcher;
        this.pinStore = pinStore;
        this._validateDocs = _validateDocs;
        this._docmap = {};
        this._doctypeHandlers = {
            'tile': new ceramic_doctype_tile_1.TileDoctypeHandler(),
            'account-link': new ceramic_doctype_account_link_1.AccountLinkDoctypeHandler()
        };
        this.pin = this._initPinApi();
        this.context = context;
        this.context.api = this;
    }
    get ipfs() {
        return this.context.ipfs;
    }
    get did() {
        return this.context.did;
    }
    _initPinApi() {
        return {
            add: async (docId) => {
                const document = await this._loadDoc(docId);
                await this.pinStore.add(document.doctype);
            },
            rm: async (docId) => {
                await this.pinStore.rm(docId);
            },
            ls: async (docId) => {
                const docIds = await this.pinStore.ls(docId ? docId.baseID : null);
                return {
                    [Symbol.asyncIterator]() {
                        let index = 0;
                        return {
                            next() {
                                if (index === docIds.length) {
                                    return Promise.resolve({ value: null, done: true });
                                }
                                return Promise.resolve({ value: docIds[index++], done: false });
                            }
                        };
                    }
                };
            }
        };
    }
    static async create(ipfs, config = {}) {
        const loggerOptions = ceramic_common_1.LoggerProvider.init({
            level: config.logLevel ? config.logLevel : 'silent',
            component: config.gateway ? 'GATEWAY' : 'NODE',
        });
        if (config.logToFiles) {
            ceramic_common_1.LoggerProvider.addPlugin(config.logToFilesPlugin.plugin, loggerOptions, config.logToFilesPlugin.options);
        }
        const dispatcher = new dispatcher_1.default(ipfs, config.topic);
        await dispatcher.init();
        const anchorService = config.anchorServiceUrl ? new ethereum_anchor_service_1.default(config) : new in_memory_anchor_service_1.default(config);
        const context = {
            ipfs,
            anchorService,
        };
        const pinStoreFactory = new pin_store_factory_1.PinStoreFactory(context, config.stateStorePath, config.pinning);
        const pinStore = await pinStoreFactory.open();
        const ceramic = new Ceramic(dispatcher, pinStore, context, config.validateDocs);
        anchorService.ceramic = ceramic;
        if (config.didProvider) {
            await ceramic.setDIDProvider(config.didProvider);
        }
        const keyDidResolver = key_did_resolver_1.default.getResolver();
        const threeIdResolver = _3id_did_resolver_1.default.getResolver(ceramic);
        ceramic.context.resolver = new did_resolver_1.Resolver({
            ...config.didResolver, ...threeIdResolver, ...keyDidResolver,
        });
        return ceramic;
    }
    findHandler(genesisRecord) {
        if (genesisRecord.doctype in this._doctypeHandlers) {
            return this._doctypeHandlers[genesisRecord.doctype];
        }
        else if (genesisRecord['@context'] === "https://w3id.org/did/v1") {
            return this._doctypeHandlers['3id'];
        }
        throw new Error("Couldn't determine doctype handler");
    }
    async setDIDProvider(provider) {
        this.context.provider = provider;
        this.context.did = new dids_1.DID({ provider });
        if (!this.context.did.authenticated) {
            await this.context.did.authenticate();
        }
    }
    addDoctypeHandler(doctypeHandler) {
        this._doctypeHandlers[doctypeHandler.name] = doctypeHandler;
    }
    findDoctypeHandler(doctype) {
        const doctypeHandler = this._doctypeHandlers[doctype];
        if (doctypeHandler == null) {
            throw new Error(`Failed to find doctype handler for doctype ${doctype}`);
        }
        return doctypeHandler;
    }
    async applyRecord(docId, record, opts) {
        docId = normalizeDocID(docId);
        if (docId.version != null) {
            throw new Error('The version of the document is readonly. Checkout the latest HEAD in order to update.');
        }
        const doc = await this._loadDoc(docId, opts);
        await doc.applyRecord(record, opts, this._validateDocs);
        return doc.doctype;
    }
    getDocFromMap(docId) {
        return this._docmap[docId.toString()];
    }
    async createDocument(doctype, params, opts) {
        const doc = await this._createDoc(doctype, params, opts);
        return doc.doctype;
    }
    async _createDoc(doctype, params, opts = {}) {
        const doctypeHandler = this._doctypeHandlers[doctype];
        const genesis = await doctypeHandler.doctype.makeGenesis(params, this.context, opts);
        const genesisCid = await this.dispatcher.storeRecord(genesis);
        const docId = new docid_1.default(doctype, genesisCid);
        let doc = this.getDocFromMap(docId);
        if (doc) {
            return doc;
        }
        doc = await document_1.default.create(docId, doctypeHandler, this.dispatcher, this.pinStore, this.context, opts, this._validateDocs);
        this._docmap[doc.id.toString()] = doc;
        return doc;
    }
    async createDocumentFromGenesis(genesis, opts = {}) {
        const doc = await this._createDocFromGenesis(genesis, opts);
        return doc.doctype;
    }
    async _createDocFromGenesis(genesis, opts = {}) {
        const genesisCid = await this.dispatcher.storeRecord(genesis);
        let doctypeHandler, doctype;
        genesis = await this.dispatcher.retrieveRecord(genesisCid);
        if (ceramic_common_1.DoctypeUtils.isSignedRecord(genesis)) {
            const payload = await this.dispatcher.retrieveRecord(genesis.link);
            doctypeHandler = this.findHandler(payload);
            doctype = payload.doctype;
        }
        else {
            doctypeHandler = this.findHandler(genesis);
            doctype = genesis.doctype;
        }
        const docId = new docid_1.default(doctype, genesisCid);
        let doc = this.getDocFromMap(docId);
        if (doc) {
            return doc;
        }
        doc = await document_1.default.create(docId, doctypeHandler, this.dispatcher, this.pinStore, this.context, opts, this._validateDocs);
        this._docmap[doc.id.toString()] = doc;
        return doc;
    }
    async loadDocument(docId, opts = {}) {
        docId = normalizeDocID(docId);
        const doc = await this._loadDoc(docId.baseID, opts);
        return (docId.version ? await doc.getVersion(docId.version) : doc.doctype);
    }
    async loadDocumentRecords(docId) {
        docId = normalizeDocID(docId);
        const doc = await this.loadDocument(docId);
        const { state } = doc;
        return Promise.all(state.log.map(async (cid) => {
            const record = (await this.ipfs.dag.get(cid)).value;
            return {
                cid: cid.toString(),
                value: await ceramic_common_1.DoctypeUtils.convertRecordToDTO(record, this.ipfs)
            };
        }));
    }
    async _loadDoc(docId, opts = {}) {
        docId = normalizeDocID(docId);
        const docIdStr = docId.toString();
        if (!this._docmap[docIdStr]) {
            this._docmap[docIdStr] = await document_1.default.load(docId, this.findHandler.bind(this), this.dispatcher, this.pinStore, this.context, opts);
        }
        return this._docmap[docIdStr];
    }
    async listVersions(docId) {
        docId = normalizeDocID(docId);
        const doc = await this._loadDoc(docId, {
            applyOnly: true
        });
        return (await doc.listVersions()).map((e) => e.toString());
    }
    async close() {
        await this.pinStore.close();
        await this.dispatcher.close();
    }
}
exports.default = Ceramic;
//# sourceMappingURL=ceramic.js.map
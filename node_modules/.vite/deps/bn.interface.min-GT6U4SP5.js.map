{
  "version": 3,
  "sources": ["../../openpgp/src/biginteger/bn.interface.js"],
  "sourcesContent": ["import BN from 'bn.js';\n\n/**\n * @fileoverview\n * BigInteger implementation of basic operations\n * Wrapper of bn.js library (wwww.github.com/indutny/bn.js)\n * @module biginteger/bn\n * @private\n */\n\n/**\n * @private\n */\nexport default class BigInteger {\n  /**\n   * Get a BigInteger (input must be big endian for strings and arrays)\n   * @param {Number|String|Uint8Array} n - Value to convert\n   * @throws {Error} on undefined input\n   */\n  constructor(n) {\n    if (n === undefined) {\n      throw new Error('Invalid BigInteger input');\n    }\n\n    this.value = new BN(n);\n  }\n\n  clone() {\n    const clone = new BigInteger(null);\n    this.value.copy(clone.value);\n    return clone;\n  }\n\n  /**\n   * BigInteger increment in place\n   */\n  iinc() {\n    this.value.iadd(new BN(1));\n    return this;\n  }\n\n  /**\n   * BigInteger increment\n   * @returns {BigInteger} this + 1.\n   */\n  inc() {\n    return this.clone().iinc();\n  }\n\n  /**\n   * BigInteger decrement in place\n   */\n  idec() {\n    this.value.isub(new BN(1));\n    return this;\n  }\n\n  /**\n   * BigInteger decrement\n   * @returns {BigInteger} this - 1.\n   */\n  dec() {\n    return this.clone().idec();\n  }\n\n\n  /**\n   * BigInteger addition in place\n   * @param {BigInteger} x - Value to add\n   */\n  iadd(x) {\n    this.value.iadd(x.value);\n    return this;\n  }\n\n  /**\n   * BigInteger addition\n   * @param {BigInteger} x - Value to add\n   * @returns {BigInteger} this + x.\n   */\n  add(x) {\n    return this.clone().iadd(x);\n  }\n\n  /**\n   * BigInteger subtraction in place\n   * @param {BigInteger} x - Value to subtract\n   */\n  isub(x) {\n    this.value.isub(x.value);\n    return this;\n  }\n\n  /**\n   * BigInteger subtraction\n   * @param {BigInteger} x - Value to subtract\n   * @returns {BigInteger} this - x.\n   */\n  sub(x) {\n    return this.clone().isub(x);\n  }\n\n  /**\n   * BigInteger multiplication in place\n   * @param {BigInteger} x - Value to multiply\n   */\n  imul(x) {\n    this.value.imul(x.value);\n    return this;\n  }\n\n  /**\n   * BigInteger multiplication\n   * @param {BigInteger} x - Value to multiply\n   * @returns {BigInteger} this * x.\n   */\n  mul(x) {\n    return this.clone().imul(x);\n  }\n\n  /**\n   * Compute value modulo m, in place\n   * @param {BigInteger} m - Modulo\n   */\n  imod(m) {\n    this.value = this.value.umod(m.value);\n    return this;\n  }\n\n  /**\n   * Compute value modulo m\n   * @param {BigInteger} m - Modulo\n   * @returns {BigInteger} this mod m.\n   */\n  mod(m) {\n    return this.clone().imod(m);\n  }\n\n  /**\n   * Compute modular exponentiation\n   * Much faster than this.exp(e).mod(n)\n   * @param {BigInteger} e - Exponent\n   * @param {BigInteger} n - Modulo\n   * @returns {BigInteger} this ** e mod n.\n   */\n  modExp(e, n) {\n    // We use either Montgomery or normal reduction context\n    // Montgomery requires coprime n and R (montogmery multiplier)\n    //  bn.js picks R as power of 2, so n must be odd\n    const nred = n.isEven() ? BN.red(n.value) : BN.mont(n.value);\n    const x = this.clone();\n    x.value = x.value.toRed(nred).redPow(e.value).fromRed();\n    return x;\n  }\n\n  /**\n   * Compute the inverse of this value modulo n\n   * Note: this and and n must be relatively prime\n   * @param {BigInteger} n - Modulo\n   * @returns {BigInteger} x such that this*x = 1 mod n\n   * @throws {Error} if the inverse does not exist\n   */\n  modInv(n) {\n    // invm returns a wrong result if the inverse does not exist\n    if (!this.gcd(n).isOne()) {\n      throw new Error('Inverse does not exist');\n    }\n    return new BigInteger(this.value.invm(n.value));\n  }\n\n  /**\n   * Compute greatest common divisor between this and n\n   * @param {BigInteger} n - Operand\n   * @returns {BigInteger} gcd\n   */\n  gcd(n) {\n    return new BigInteger(this.value.gcd(n.value));\n  }\n\n  /**\n   * Shift this to the left by x, in place\n   * @param {BigInteger} x - Shift value\n   */\n  ileftShift(x) {\n    this.value.ishln(x.value.toNumber());\n    return this;\n  }\n\n  /**\n   * Shift this to the left by x\n   * @param {BigInteger} x - Shift value\n   * @returns {BigInteger} this << x.\n   */\n  leftShift(x) {\n    return this.clone().ileftShift(x);\n  }\n\n  /**\n   * Shift this to the right by x, in place\n   * @param {BigInteger} x - Shift value\n   */\n  irightShift(x) {\n    this.value.ishrn(x.value.toNumber());\n    return this;\n  }\n\n  /**\n   * Shift this to the right by x\n   * @param {BigInteger} x - Shift value\n   * @returns {BigInteger} this >> x.\n   */\n  rightShift(x) {\n    return this.clone().irightShift(x);\n  }\n\n  /**\n   * Whether this value is equal to x\n   * @param {BigInteger} x\n   * @returns {Boolean}\n   */\n  equal(x) {\n    return this.value.eq(x.value);\n  }\n\n  /**\n   * Whether this value is less than x\n   * @param {BigInteger} x\n   * @returns {Boolean}\n   */\n  lt(x) {\n    return this.value.lt(x.value);\n  }\n\n  /**\n   * Whether this value is less than or equal to x\n   * @param {BigInteger} x\n   * @returns {Boolean}\n   */\n  lte(x) {\n    return this.value.lte(x.value);\n  }\n\n  /**\n   * Whether this value is greater than x\n   * @param {BigInteger} x\n   * @returns {Boolean}\n   */\n  gt(x) {\n    return this.value.gt(x.value);\n  }\n\n  /**\n   * Whether this value is greater than or equal to x\n   * @param {BigInteger} x\n   * @returns {Boolean}\n   */\n  gte(x) {\n    return this.value.gte(x.value);\n  }\n\n  isZero() {\n    return this.value.isZero();\n  }\n\n  isOne() {\n    return this.value.eq(new BN(1));\n  }\n\n  isNegative() {\n    return this.value.isNeg();\n  }\n\n  isEven() {\n    return this.value.isEven();\n  }\n\n  abs() {\n    const res = this.clone();\n    res.value = res.value.abs();\n    return res;\n  }\n\n  /**\n   * Get this value as a string\n   * @returns {String} this value.\n   */\n  toString() {\n    return this.value.toString();\n  }\n\n  /**\n   * Get this value as an exact Number (max 53 bits)\n   * Fails if this value is too large\n   * @returns {Number}\n   */\n  toNumber() {\n    return this.value.toNumber();\n  }\n\n  /**\n   * Get value of i-th bit\n   * @param {Number} i - Bit index\n   * @returns {Number} Bit value.\n   */\n  getBit(i) {\n    return this.value.testn(i) ? 1 : 0;\n  }\n\n  /**\n   * Compute bit length\n   * @returns {Number} Bit length.\n   */\n  bitLength() {\n    return this.value.bitLength();\n  }\n\n  /**\n   * Compute byte length\n   * @returns {Number} Byte length.\n   */\n  byteLength() {\n    return this.value.byteLength();\n  }\n\n  /**\n   * Get Uint8Array representation of this number\n   * @param {String} endian - Endianess of output array (defaults to 'be')\n   * @param {Number} length - Of output array\n   * @returns {Uint8Array}\n   */\n  toUint8Array(endian = 'be', length) {\n    return this.value.toArrayLike(Uint8Array, endian, length);\n  }\n}\n"],
  "mappings": "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",
  "names": ["BigInteger", "constructor", "n", "Error", "this", "value", "BN", "clone", "copy", "iinc", "iadd", "inc", "idec", "isub", "dec", "x", "add", "sub", "imul", "mul", "imod", "m", "umod", "mod", "modExp", "e", "nred", "isEven", "red", "mont", "toRed", "redPow", "fromRed", "modInv", "gcd", "isOne", "invm", "ileftShift", "ishln", "toNumber", "leftShift", "irightShift", "ishrn", "rightShift", "equal", "eq", "lt", "lte", "gt", "gte", "isZero", "isNegative", "isNeg", "abs", "res", "toString", "getBit", "i", "testn", "bitLength", "byteLength", "toUint8Array", "endian", "length", "toArrayLike", "Uint8Array"]
}

"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _pow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PowergatePinning = exports.JobStatus = exports.EmptyTokenError = void 0;
const powergate_client_1 = require("@textile/powergate-client");
class EmptyTokenError extends Error {
    constructor(address) {
        super(`No token provided for Powergate at ${address}`);
    }
}
exports.EmptyTokenError = EmptyTokenError;
var JobStatus;
(function (JobStatus) {
    JobStatus[JobStatus["JOB_STATUS_UNSPECIFIED"] = 0] = "JOB_STATUS_UNSPECIFIED";
    JobStatus[JobStatus["JOB_STATUS_QUEUED"] = 1] = "JOB_STATUS_QUEUED";
    JobStatus[JobStatus["JOB_STATUS_EXECUTING"] = 2] = "JOB_STATUS_EXECUTING";
    JobStatus[JobStatus["JOB_STATUS_FAILED"] = 3] = "JOB_STATUS_FAILED";
    JobStatus[JobStatus["JOB_STATUS_CANCELED"] = 4] = "JOB_STATUS_CANCELED";
    JobStatus[JobStatus["JOB_STATUS_SUCCESS"] = 5] = "JOB_STATUS_SUCCESS";
})(JobStatus = exports.JobStatus || (exports.JobStatus = {}));
class PowergatePinning {
    constructor(connectionString, context) {
        _pow.set(this, void 0);
        const url = new URL(connectionString);
        const hostname = url.hostname;
        const port = parseInt(url.port, 10) || 5002;
        const token = url.searchParams.get('token');
        const protocol = url.protocol
            .replace('powergate:', 'http')
            .replace('powergate+http:', 'http')
            .replace('powergate+https:', 'https');
        this.endpoint = `${protocol}://${hostname}:${port}`;
        if (!token) {
            throw new EmptyTokenError(this.endpoint);
        }
        this.token = token;
    }
    get pow() {
        return __classPrivateFieldGet(this, _pow);
    }
    async open() {
        __classPrivateFieldSet(this, _pow, powergate_client_1.createPow({ host: this.endpoint }));
        __classPrivateFieldGet(this, _pow).setToken(this.token);
    }
    async close() {
    }
    async pin(cid) {
        try {
            const defaultConfig = await __classPrivateFieldGet(this, _pow).ffs.defaultStorageConfig();
            await __classPrivateFieldGet(this, _pow).ffs.pushStorageConfig(cid.toString(), powergate_client_1.ffsOptions.withStorageConfig(defaultConfig));
        }
        catch (e) {
            if (e.message.includes('cid already pinned, consider using override flag')) {
            }
            else {
                throw e;
            }
        }
    }
    async unpin(cid) {
        const { config } = await __classPrivateFieldGet(this, _pow).ffs.getStorageConfig(cid.toString());
        const next = Object.assign({}, config, {
            config: {
                ...config,
                repairable: false,
                hot: {
                    ...config.hot,
                    allowUnfreeze: false,
                    enabled: false
                },
                cold: {
                    ...config.cold,
                    enabled: false
                }
            }
        });
        const opts = [powergate_client_1.ffsOptions.withOverride(true), powergate_client_1.ffsOptions.withStorageConfig(next)];
        const { jobId } = await __classPrivateFieldGet(this, _pow).ffs.pushStorageConfig(cid.toString(), ...opts);
        await this.waitForJobStatus(jobId, JobStatus.JOB_STATUS_SUCCESS);
        await __classPrivateFieldGet(this, _pow).ffs.remove(cid.toString());
    }
    waitForJobStatus(jobId, status) {
        return new Promise((resolve, reject) => {
            const cancel = __classPrivateFieldGet(this, _pow).ffs.watchJobs((job) => {
                if (job.errCause && job.errCause.length > 0) {
                    reject(new Error(job.errCause));
                }
                if (job.status === JobStatus.JOB_STATUS_CANCELED) {
                    reject(new Error("job canceled"));
                }
                if (job.status === JobStatus.JOB_STATUS_FAILED) {
                    reject(new Error("job failed"));
                }
                if (job.status === status) {
                    cancel();
                    resolve();
                }
            }, jobId);
        });
    }
}
exports.PowergatePinning = PowergatePinning;
_pow = new WeakMap();
PowergatePinning.designator = 'powergate';
//# sourceMappingURL=powergate-pinning.js.map
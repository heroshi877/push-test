import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/refractor/lang/javadoclike.js
var require_javadoclike = __commonJS({
  "node_modules/refractor/lang/javadoclike.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = javadoclike;
    javadoclike.displayName = "javadoclike";
    javadoclike.aliases = [];
    function javadoclike(Prism) {
      ;
      (function(Prism2) {
        var javaDocLike = Prism2.languages.javadoclike = {
          parameter: {
            pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
            lookbehind: true
          },
          keyword: {
            // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
            // @word, {@word}
            pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
            lookbehind: true
          },
          punctuation: /[{}]/
        };
        function docCommentSupport(lang, callback) {
          var tokenName = "doc-comment";
          var grammar = Prism2.languages[lang];
          if (!grammar) {
            return;
          }
          var token = grammar[tokenName];
          if (!token) {
            var definition = {};
            definition[tokenName] = {
              pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
              lookbehind: true,
              alias: "comment"
            };
            grammar = Prism2.languages.insertBefore(lang, "comment", definition);
            token = grammar[tokenName];
          }
          if (token instanceof RegExp) {
            token = grammar[tokenName] = {
              pattern: token
            };
          }
          if (Array.isArray(token)) {
            for (var i = 0, l = token.length; i < l; i++) {
              if (token[i] instanceof RegExp) {
                token[i] = {
                  pattern: token[i]
                };
              }
              callback(token[i]);
            }
          } else {
            callback(token);
          }
        }
        function addSupport(languages, docLanguage) {
          if (typeof languages === "string") {
            languages = [languages];
          }
          languages.forEach(function(lang) {
            docCommentSupport(lang, function(pattern) {
              if (!pattern.inside) {
                pattern.inside = {};
              }
              pattern.inside.rest = docLanguage;
            });
          });
        }
        Object.defineProperty(javaDocLike, "addSupport", {
          value: addSupport
        });
        javaDocLike.addSupport(["java", "javascript", "php"], javaDocLike);
      })(Prism);
    }
  }
});

export {
  require_javadoclike
};
//# sourceMappingURL=chunk-5C7LKVAR.js.map

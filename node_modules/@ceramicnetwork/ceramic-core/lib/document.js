"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const p_queue_1 = __importDefault(require("p-queue"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const utils_1 = __importDefault(require("./utils"));
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const docid_1 = __importDefault(require("@ceramicnetwork/docid"));
class Document extends events_1.EventEmitter {
    constructor(id, dispatcher, pinStore) {
        super();
        this.dispatcher = dispatcher;
        this.pinStore = pinStore;
        this.id = id;
        this.version = id.version;
        this.logger = ceramic_common_1.RootLogger.getLogger(Document.name);
        this._applyQueue = new p_queue_1.default({ concurrency: 1 });
        this._genesisCid = id.cid;
    }
    static async create(docId, doctypeHandler, dispatcher, pinStore, context, opts = {}, validate = true) {
        const genesis = await dispatcher.retrieveRecord(docId.cid);
        const doc = new Document(docId, dispatcher, pinStore);
        doc._context = context;
        doc._doctypeHandler = doctypeHandler;
        doc._doctype = new doctypeHandler.doctype(null, context);
        doc._doctype.state = await doc._doctypeHandler.applyRecord(genesis, doc._genesisCid, context);
        if (validate) {
            const schema = await Document.loadSchema(context.api, doc._doctype);
            if (schema) {
                utils_1.default.validate(doc._doctype.content, schema);
            }
        }
        await doc._updateStateIfPinned();
        if (typeof opts.applyOnly === 'undefined') {
            opts.applyOnly = false;
        }
        await doc._register(opts);
        return doc;
    }
    static async load(id, findHandler, dispatcher, pinStore, context, opts = {}) {
        const doc = new Document(id, dispatcher, pinStore);
        doc._context = context;
        if (typeof opts.applyOnly === 'undefined') {
            opts.applyOnly = true;
        }
        const record = await dispatcher.retrieveRecord(doc._genesisCid);
        let payload;
        if (ceramic_common_1.DoctypeUtils.isSignedRecord(record)) {
            payload = await dispatcher.retrieveRecord(record.link);
        }
        else {
            payload = record;
        }
        doc._doctypeHandler = findHandler(payload);
        doc._doctype = new doc._doctypeHandler.doctype(null, context);
        if (doc._doctype.state == null) {
            doc._doctype.state = await doc._doctypeHandler.applyRecord(record, doc._genesisCid, context);
        }
        const isPresent = await pinStore.stateStore.exists(id);
        if (isPresent) {
            doc._doctype.state = await pinStore.stateStore.load(id);
        }
        await doc._register(opts);
        return doc;
    }
    async validate() {
        var _a, _b;
        const schemaDocId = (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.schema;
        if (schemaDocId) {
            const schemaDoc = await this._context.api.loadDocument(schemaDocId);
            if (!schemaDoc) {
                throw new Error(`Schema not found for ${schemaDocId}`);
            }
            utils_1.default.validate(this.content, schemaDoc.content);
        }
    }
    async listVersions() {
        if (this._doctype.state == null) {
            return [];
        }
        const checkPromises = this._doctype.state.log.map(async (cid) => {
            const record = await this.dispatcher.retrieveRecord(cid);
            return record.proof != null ? [cid] : [];
        });
        return (await Promise.all(checkPromises)).reduce((acc, recs) => acc.concat(...recs), []);
    }
    async getVersion(version) {
        const doc = await Document.getVersion(this, version);
        return doc.doctype;
    }
    static async getVersion(doc, version) {
        const { _context: context, dispatcher, pinStore, _doctypeHandler: doctypeHandler } = doc;
        const isGenesis = version.equals(doc._genesisCid);
        if (!isGenesis) {
            const versionRecord = await dispatcher.retrieveRecord(version);
            if (versionRecord == null) {
                throw new Error(`No record found for version ${version.toString()}`);
            }
            if (versionRecord.proof == null) {
                throw new Error(`No anchor record for version ${version.toString()}`);
            }
        }
        const docid = docid_1.default.fromBytes(doc.id.bytes, version);
        const document = new Document(docid, dispatcher, pinStore);
        document._context = context;
        document._doctypeHandler = doctypeHandler;
        document._doctype = new doc._doctypeHandler.doctype(null, context);
        const genesisRecord = await document.dispatcher.retrieveRecord(doc._genesisCid);
        document._doctype.state = await doc._doctypeHandler.applyRecord(genesisRecord, doc._genesisCid, context);
        if (!isGenesis) {
            await document._handleHead(version);
            document._doctype = ceramic_common_1.DoctypeUtils.makeReadOnly(document.doctype);
        }
        return document;
    }
    async applyRecord(record, opts = {}, validate = true) {
        const cid = await this.dispatcher.storeRecord(record);
        const retrievedRec = await this.dispatcher.retrieveRecord(cid);
        const state = await this._doctypeHandler.applyRecord(retrievedRec, cid, this._context, this.state);
        if (ceramic_common_1.DoctypeUtils.isAnchorRecord(retrievedRec)) {
            state.anchorStatus = ceramic_common_1.AnchorStatus.ANCHORED;
        }
        let payload;
        if (retrievedRec.payload && retrievedRec.signatures) {
            payload = (await this._context.ipfs.dag.get(retrievedRec.link)).value;
        }
        else {
            payload = retrievedRec;
        }
        if (payload.header) {
            Object.assign(state.metadata, payload.header);
        }
        if (validate) {
            const schema = await Document.loadSchemaById(this._context.api, state.metadata.schema);
            if (schema) {
                utils_1.default.validate(state.next.content, schema);
            }
        }
        this._doctype.state = state;
        await this._updateStateIfPinned();
        await this._applyOpts(opts);
    }
    async _register(opts) {
        this.on('update', this._handleHead.bind(this));
        this.on('headreq', this._publishHead.bind(this));
        await this.dispatcher.register(this);
        await this._applyOpts(opts);
    }
    async _applyOpts(opts) {
        if (!opts.applyOnly) {
            await this.anchor();
            this._publishHead();
        }
        else if (!opts.skipWait) {
            await Document.wait(this);
        }
    }
    async _updateStateIfPinned() {
        const isPinned = await this.pinStore.stateStore.exists(this.id);
        if (isPinned) {
            await this.pinStore.add(this._doctype);
        }
    }
    async _handleHead(cid) {
        try {
            this.isProcessing = true;
            await this._applyQueue.add(async () => {
                const log = await this._fetchLog(cid);
                if (log.length) {
                    const updated = await this._applyLog(log);
                    if (updated) {
                        this._doctype.emit('change');
                    }
                }
            });
        }
        catch (e) {
            this.logger.error(e);
        }
        finally {
            this.isProcessing = false;
        }
    }
    async _fetchLog(cid, log = []) {
        if (await this._isCidIncluded(cid, this._doctype.state.log)) {
            return [];
        }
        const record = await this.dispatcher.retrieveRecord(cid);
        let payload = record;
        if (ceramic_common_1.DoctypeUtils.isSignedRecord(record)) {
            payload = await this.dispatcher.retrieveRecord(record.link);
        }
        const prevCid = payload.prev;
        if (!prevCid) {
            return [];
        }
        log.unshift(cid);
        if (await this._isCidIncluded(prevCid, this._doctype.state.log)) {
            return log;
        }
        return this._fetchLog(prevCid, log);
    }
    async _findIndex(cid, log) {
        for (let index = 0; index < log.length; index++) {
            const c = log[index];
            if (c.equals(cid)) {
                return index;
            }
            const record = await this.dispatcher.retrieveRecord(c);
            if (ceramic_common_1.DoctypeUtils.isSignedRecord(record) && record.link.equals(cid)) {
                return index;
            }
        }
        return -1;
    }
    async _isCidIncluded(cid, log) {
        return (await this._findIndex(cid, log)) !== -1;
    }
    async _applyLog(log) {
        let modified = false;
        if (log[log.length - 1].equals(this.head)) {
            return;
        }
        const cid = log[0];
        const record = await this.dispatcher.retrieveRecord(cid);
        let payload = record;
        if (ceramic_common_1.DoctypeUtils.isSignedRecord(record)) {
            payload = await this.dispatcher.retrieveRecord(record.link);
        }
        if (payload.prev.equals(this.head)) {
            this._doctype.state = await this._applyLogToState(log, lodash_clonedeep_1.default(this._doctype.state));
            modified = true;
        }
        else {
            const conflictIdx = await this._findIndex(payload.prev, this._doctype.state.log) + 1;
            const canonicalLog = this._doctype.state.log.slice();
            const localLog = canonicalLog.splice(conflictIdx);
            let state = await this._applyLogToState(canonicalLog);
            const localState = await this._applyLogToState(localLog, lodash_clonedeep_1.default(state), true);
            const remoteState = await this._applyLogToState(log, lodash_clonedeep_1.default(state), true);
            const isLocalAnchored = localState.anchorStatus === ceramic_common_1.AnchorStatus.ANCHORED;
            const isRemoteAnchored = remoteState.anchorStatus === ceramic_common_1.AnchorStatus.ANCHORED;
            if (!isLocalAnchored && isRemoteAnchored) {
                state = await this._applyLogToState(log, lodash_clonedeep_1.default(state));
                this._doctype.state = state;
                modified = true;
            }
            if (isLocalAnchored && isRemoteAnchored) {
                const { anchorProof: localProof } = localState;
                const { anchorProof: remoteProof } = remoteState;
                if (remoteProof.blockTimestamp < localProof.blockTimestamp) {
                    state = await this._applyLogToState(log, lodash_clonedeep_1.default(state));
                    this._doctype.state = state;
                    modified = true;
                }
            }
        }
        return modified;
    }
    async _applyLogToState(log, state, breakOnAnchor) {
        const itr = log.entries();
        let entry = itr.next();
        while (!entry.done) {
            const cid = entry.value[1];
            const record = await this.dispatcher.retrieveRecord(cid);
            let payload = record;
            if (ceramic_common_1.DoctypeUtils.isSignedRecord(record)) {
                payload = await this.dispatcher.retrieveRecord(record.link);
            }
            if (!payload.prev) {
                state = await this._doctypeHandler.applyRecord(record, cid, this._context);
            }
            else if (payload.proof) {
                await this._verifyAnchorRecord(record);
                state = await this._doctypeHandler.applyRecord(record, cid, this._context, state);
            }
            else {
                state = await this._doctypeHandler.applyRecord(record, cid, this._context, state);
            }
            if (breakOnAnchor && ceramic_common_1.AnchorStatus.ANCHORED === state.anchorStatus) {
                return state;
            }
            entry = itr.next();
        }
        return state;
    }
    async _verifyAnchorRecord(record) {
        const proofRecord = await this.dispatcher.retrieveRecord(record.proof);
        let prevRootPathRecord;
        try {
            if (record.path.length === 0) {
                prevRootPathRecord = proofRecord.root;
            }
            else {
                const subPath = '/root/' + record.path.substr(0, record.path.lastIndexOf('/'));
                const last = record.path.substr(record.path.lastIndexOf('/') + 1);
                prevRootPathRecord = await this.dispatcher.retrieveRecord(record.proof.toString() + subPath);
                prevRootPathRecord = prevRootPathRecord[last];
            }
        }
        catch (e) {
            throw new Error(`The anchor record couldn't be verified. Reason ${e.message}`);
        }
        if (record.prev.toString() !== prevRootPathRecord.toString()) {
            throw new Error(`The anchor record proof ${record.proof.toString()} with path ${record.path} points to invalid 'prev' record`);
        }
        const proof = await this.dispatcher.retrieveRecord(record.proof);
        await this._context.anchorService.validateChainInclusion(proof);
        return proof;
    }
    async _publishHead() {
        await this.dispatcher.publishHead(this.id.toString(), this.head, this.doctype.doctype);
    }
    async anchor() {
        this._context.anchorService.on(this.id.toString(), async (asr) => {
            switch (asr.status) {
                case 'PENDING': {
                    const state = this._doctype.state;
                    state.anchorScheduledFor = asr.anchorScheduledFor;
                    this._doctype.state = state;
                    await this._updateStateIfPinned();
                    return;
                }
                case 'PROCESSING': {
                    const state = this._doctype.state;
                    state.anchorStatus = ceramic_common_1.AnchorStatus.PROCESSING;
                    this._doctype.state = state;
                    await this._updateStateIfPinned();
                    return;
                }
                case 'COMPLETED': {
                    const state = this._doctype.state;
                    state.anchorStatus = ceramic_common_1.AnchorStatus.ANCHORED;
                    this._doctype.state = state;
                    await this._handleHead(asr.anchorRecord);
                    await this._updateStateIfPinned();
                    this._publishHead();
                    this._context.anchorService.removeAllListeners(this.id.toString());
                    return;
                }
                case 'FAILED': {
                    const state = this._doctype.state;
                    state.anchorStatus = ceramic_common_1.AnchorStatus.FAILED;
                    this._doctype.state = state;
                    this._context.anchorService.removeAllListeners(this.id.toString());
                    return;
                }
            }
        });
        await this._context.anchorService.requestAnchor(this.id.toString(), this.head);
        const state = this._doctype.state;
        state.anchorStatus = ceramic_common_1.AnchorStatus.PENDING;
        this._doctype.state = state;
    }
    static async loadSchema(ceramicApi, doctype) {
        var _a, _b;
        return ((_b = (_a = doctype.state) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.schema) ? Document.loadSchemaById(ceramicApi, doctype.state.metadata.schema) : null;
    }
    static async loadSchemaById(ceramicApi, schemaDocId) {
        if (schemaDocId) {
            const schemaDoc = await ceramicApi.loadDocument(schemaDocId);
            return schemaDoc.content;
        }
        return null;
    }
    get content() {
        var _a;
        const { next, content } = this._doctype.state;
        return (_a = next === null || next === void 0 ? void 0 : next.content) !== null && _a !== void 0 ? _a : content;
    }
    get state() {
        return this._doctype.state;
    }
    get doctype() {
        return this._doctype;
    }
    get head() {
        return this._doctype.head;
    }
    get controllers() {
        return this._doctype.controllers;
    }
    get metadata() {
        return this._doctype.metadata;
    }
    static async wait(doc) {
        return new Promise(resolve => {
            let tid;
            const clear = () => {
                clearTimeout(tid);
                doc._doctype.off('change', clear);
                resolve();
            };
            tid = setTimeout(clear, 3000);
            doc._doctype.on('change', clear);
        });
    }
    async close() {
        this.off('update', this._handleHead.bind(this));
        this.off('headreq', this._publishHead.bind(this));
        this.dispatcher.unregister(this.id.toString());
        await this._applyQueue.onEmpty();
        this._context.anchorService.removeAllListeners(this.id.toString());
        await utils_1.default.awaitCondition(() => this.isProcessing, () => false, 500);
    }
    toString() {
        return JSON.stringify(this._doctype.state.content);
    }
}
exports.default = Document;
//# sourceMappingURL=document.js.map
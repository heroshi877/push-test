/// <reference types="node" />
import Dispatcher from './dispatcher';
import CID from 'cids';
import { EventEmitter } from 'events';
import { AnchorProof, AnchorRecord, DocState, Doctype, DoctypeHandler, DocOpts, Context, CeramicApi, DocMetadata } from '@ceramicnetwork/ceramic-common';
import DocID from '@ceramicnetwork/docid';
import { PinStore } from './store/pin-store';
declare class Document extends EventEmitter {
    dispatcher: Dispatcher;
    pinStore: PinStore;
    private _genesisCid;
    private _applyQueue;
    private _doctype;
    private _doctypeHandler;
    _context: Context;
    readonly id: DocID;
    readonly version: CID;
    private logger;
    private isProcessing;
    constructor(id: DocID, dispatcher: Dispatcher, pinStore: PinStore);
    static create<T extends Doctype>(docId: DocID, doctypeHandler: DoctypeHandler<Doctype>, dispatcher: Dispatcher, pinStore: PinStore, context: Context, opts?: DocOpts, validate?: boolean): Promise<Document>;
    static load<T extends Doctype>(id: DocID, findHandler: (genesisRecord: any) => DoctypeHandler<Doctype>, dispatcher: Dispatcher, pinStore: PinStore, context: Context, opts?: DocOpts): Promise<Document>;
    validate(): Promise<void>;
    listVersions(): Promise<CID[]>;
    getVersion<T extends Doctype>(version: CID): Promise<T>;
    static getVersion<T extends Doctype>(doc: Document, version: CID): Promise<Document>;
    applyRecord(record: any, opts?: DocOpts, validate?: boolean): Promise<void>;
    _register(opts: DocOpts): Promise<void>;
    _applyOpts(opts: DocOpts): Promise<void>;
    _updateStateIfPinned(): Promise<void>;
    _handleHead(cid: CID): Promise<void>;
    _fetchLog(cid: CID, log?: Array<CID>): Promise<Array<CID>>;
    _findIndex(cid: CID, log: Array<CID>): Promise<number>;
    _isCidIncluded(cid: CID, log: Array<CID>): Promise<boolean>;
    _applyLog(log: Array<CID>): Promise<boolean>;
    _applyLogToState(log: Array<CID>, state?: DocState, breakOnAnchor?: boolean): Promise<DocState>;
    _verifyAnchorRecord(record: AnchorRecord): Promise<AnchorProof>;
    _publishHead(): Promise<void>;
    anchor(): Promise<void>;
    static loadSchema<T extends Doctype>(ceramicApi: CeramicApi, doctype: Doctype): Promise<T>;
    static loadSchemaById<T extends Doctype>(ceramicApi: CeramicApi, schemaDocId: string): Promise<T>;
    get content(): any;
    get state(): DocState;
    get doctype(): Doctype;
    get head(): CID;
    get controllers(): string[];
    get metadata(): DocMetadata;
    static wait(doc: Document): Promise<void>;
    close(): Promise<void>;
    toString(): string;
}
export default Document;
//# sourceMappingURL=document.d.ts.map
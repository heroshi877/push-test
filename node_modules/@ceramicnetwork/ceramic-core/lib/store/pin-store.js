"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinStore = void 0;
class PinStore {
    constructor(stateStore, pinning, retrieve, resolve) {
        this.stateStore = stateStore;
        this.pinning = pinning;
        this.retrieve = retrieve;
        this.resolve = resolve;
    }
    async open() {
        await this.stateStore.open();
        await this.pinning.open();
    }
    async close() {
        await this.stateStore.close();
        await this.pinning.close();
    }
    async add(document) {
        await this.stateStore.save(document);
        const points = await this.pointsOfInterest(document.state);
        await Promise.all(points.map(point => this.pinning.pin(point)));
    }
    async rm(docId) {
        const state = await this.stateStore.load(docId);
        if (state) {
            const points = await this.pointsOfInterest(state);
            Promise.all(points.map(point => this.pinning.unpin(point))).catch(() => {
            });
            await this.stateStore.remove(docId);
        }
    }
    async ls(docId) {
        return this.stateStore.list(docId);
    }
    async pointsOfInterest(state) {
        const log = state.log;
        const points = [];
        for (const cid of log) {
            points.push(cid);
            const record = await this.retrieve(cid);
            if (record && record.proof) {
                points.push(record.proof);
                const path = record.path ? "root/" + record.path : "root";
                const subPaths = path.split('/').filter(p => !!p);
                let currentPath = "";
                for (const subPath of subPaths) {
                    currentPath += "/" + subPath;
                    const subPathResolved = await this.resolve(record.proof.toString() + currentPath);
                    points.push(subPathResolved);
                }
            }
        }
        return points;
    }
}
exports.PinStore = PinStore;
//# sourceMappingURL=pin-store.js.map
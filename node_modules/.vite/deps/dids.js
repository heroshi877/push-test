import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  init_index_browser,
  nanoid
} from "./chunk-E4AQTZSY.js";
import {
  require_bignumber,
  require_src,
  require_src2,
  require_src3,
  require_src4
} from "./chunk-HUPQMMQ4.js";
import {
  require_binary,
  require_chacha,
  require_chacha20poly1305,
  require_ed25519,
  require_random,
  require_sha256,
  require_wipe,
  require_x25519
} from "./chunk-7ZFPSPPS.js";
import {
  equals_exports,
  init_equals,
  require_varint
} from "./chunk-6AAHU4TF.js";
import {
  basics_exports,
  from_string_exports,
  init_basics,
  init_from_string
} from "./chunk-4RQHP5TB.js";
import "./chunk-55VHLUOO.js";
import {
  require_err_code
} from "./chunk-YAFUTRBD.js";
import {
  require_sha3
} from "./chunk-BLRZAMSF.js";
import {
  require_elliptic
} from "./chunk-7LYDIDA4.js";
import {
  require_util
} from "./chunk-D2UFQSSP.js";
import "./chunk-LPS2SYRB.js";
import "./chunk-KLW5T4S3.js";
import {
  dist_exports,
  init_dist
} from "./chunk-644CRGRM.js";
import "./chunk-FI2GMLQC.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/did-resolver/lib/resolver.esm.js
var resolver_esm_exports = {};
__export(resolver_esm_exports, {
  Resolver: () => i,
  inMemoryCache: () => e,
  noCache: () => t,
  parse: () => o
});
function r(r2, e2) {
  (null == e2 || e2 > r2.length) && (e2 = r2.length);
  for (var t2 = 0, n2 = new Array(e2); t2 < e2; t2++) n2[t2] = r2[t2];
  return n2;
}
function e() {
  var r2 = /* @__PURE__ */ new Map();
  return function(e2, t2) {
    try {
      var n2, o2 = function(o3) {
        if (n2) return o3;
        var i3 = r2.get(e2.did);
        return void 0 !== i3 ? i3 : Promise.resolve(t2()).then(function(t3) {
          return null !== t3 && r2.set(e2.did, t3), t3;
        });
      }, i2 = function() {
        if (e2.params && "true" === e2.params["no-cache"]) return n2 = 1, Promise.resolve(t2());
      }();
      return Promise.resolve(i2 && i2.then ? i2.then(o2) : o2(i2));
    } catch (r3) {
      return Promise.reject(r3);
    }
  };
}
function t(r2, e2) {
  return e2();
}
function o(e2) {
  if ("" === e2 || !e2) throw new Error("Missing DID");
  var t2 = e2.match(n);
  if (t2) {
    var o2 = { did: "did:" + t2[1] + ":" + t2[2], method: t2[1], id: t2[2], didUrl: e2 };
    if (t2[4]) {
      var i2 = t2[4].slice(1).split(";");
      o2.params = {};
      for (var a, u = function(e3, t3) {
        var n2;
        if ("undefined" == typeof Symbol || null == e3[Symbol.iterator]) {
          if (Array.isArray(e3) || (n2 = function(e4, t4) {
            if (e4) {
              if ("string" == typeof e4) return r(e4, t4);
              var n3 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n3 && e4.constructor && (n3 = e4.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e4) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? r(e4, t4) : void 0;
            }
          }(e3))) {
            n2 && (e3 = n2);
            var o3 = 0;
            return function() {
              return o3 >= e3.length ? { done: true } : { done: false, value: e3[o3++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (n2 = e3[Symbol.iterator]()).next.bind(n2);
      }(i2); !(a = u()).done; ) {
        var c = a.value.split("=");
        o2.params[c[0]] = c[1];
      }
    }
    return t2[6] && (o2.path = t2[6]), t2[7] && (o2.query = t2[7].slice(1)), t2[8] && (o2.fragment = t2[8].slice(1)), o2;
  }
  throw new Error("Invalid DID " + e2);
}
var import_dist, import_dist2, import_dist3, n, i;
var init_resolver_esm = __esm({
  "node_modules/did-resolver/lib/resolver.esm.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    n = new RegExp("^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$");
    i = function() {
      function r2(r3, n2) {
        void 0 === r3 && (r3 = {}), this.registry = r3, this.cache = true === n2 ? e() : n2 || t;
      }
      return r2.prototype.resolve = function(r3) {
        try {
          var e2, t2 = this, n2 = function(r4) {
            if (e2) return r4;
            throw new Error("Unsupported DID method: '" + i2.method + "'");
          }, i2 = o(r3), a = t2.registry[i2.method], u = function() {
            if (a) return Promise.resolve(t2.cache(i2, function() {
              return a(i2.did, i2, t2);
            })).then(function(r4) {
              if (null == r4) throw new Error("resolver returned null for " + i2.did);
              return e2 = 1, r4;
            });
          }();
          return Promise.resolve(u && u.then ? u.then(n2) : n2(u));
        } catch (r4) {
          return Promise.reject(r4);
        }
      }, r2;
    }();
  }
});

// node_modules/dids/node_modules/rpc-utils/dist/rpc-utils.esm.js
var rpc_utils_esm_exports = {};
__export(rpc_utils_esm_exports, {
  ERROR_CODE: () => ERROR_CODE,
  ERROR_MESSAGE: () => ERROR_MESSAGE,
  RPCClient: () => RPCClient,
  RPCError: () => RPCError,
  createErrorResponse: () => createErrorResponse,
  createHandler: () => createHandler,
  createInternalError: () => createInternalError,
  createInvalidParams: () => createInvalidParams,
  createInvalidRequest: () => createInvalidRequest,
  createMethodNotFound: () => createMethodNotFound,
  createParseError: () => createParseError,
  getErrorMessage: () => getErrorMessage,
  isServerError: () => isServerError,
  parseJSON: () => parseJSON
});
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2) _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isServerError(code) {
  return -32e3 >= code && code >= -32099;
}
function getErrorMessage(code) {
  var _ERROR_MESSAGE$code$t;
  return (_ERROR_MESSAGE$code$t = ERROR_MESSAGE[code.toString()]) !== null && _ERROR_MESSAGE$code$t !== void 0 ? _ERROR_MESSAGE$code$t : isServerError(code) ? "Server error" : "Application error";
}
function createErrorFactory(code) {
  var message = ERROR_MESSAGE[code];
  return function createError(data) {
    return new RPCError(code, message, data);
  };
}
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e2) {
    return recover(e2);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function parseJSON(input) {
  try {
    return JSON.parse(input);
  } catch (err) {
    throw createParseError();
  }
}
function createErrorResponse(id, code) {
  return {
    jsonrpc: "2.0",
    id,
    error: {
      code,
      message: getErrorMessage(code)
    }
  };
}
function fallbackOnHandlerError(_ctx, msg, error) {
  console.warn("Unhandled handler error", msg, error);
}
function fallbackOnInvalidMessage(_ctx, msg) {
  console.warn("Unhandled invalid message", msg);
}
function fallbackOnNotification(_ctx, msg) {
  console.warn("Unhandled notification", msg);
}
function createHandler(methods, options) {
  var _options$onHandlerErr, _options$onInvalidMes, _options$onNotificati;
  if (options === void 0) {
    options = {};
  }
  var onHandlerError = (_options$onHandlerErr = options.onHandlerError) !== null && _options$onHandlerErr !== void 0 ? _options$onHandlerErr : fallbackOnHandlerError;
  var onInvalidMessage = (_options$onInvalidMes = options.onInvalidMessage) !== null && _options$onInvalidMes !== void 0 ? _options$onInvalidMes : fallbackOnInvalidMessage;
  var onNotification = (_options$onNotificati = options.onNotification) !== null && _options$onNotificati !== void 0 ? _options$onNotificati : fallbackOnNotification;
  return function handleRequest(ctx, msg) {
    try {
      var id = msg.id;
      if (msg.jsonrpc !== "2.0" || msg.method == null) {
        if (id == null) {
          onInvalidMessage(ctx, msg);
          return Promise.resolve(null);
        }
        return Promise.resolve(createErrorResponse(id, ERROR_CODE.INVALID_REQUEST));
      }
      if (id == null) {
        onNotification(ctx, msg);
        return Promise.resolve(null);
      }
      var handler = methods[msg.method];
      if (handler == null) {
        return Promise.resolve(createErrorResponse(id, ERROR_CODE.METHOD_NOT_FOUND));
      }
      return Promise.resolve(_catch(function() {
        var _msg$params;
        function _temp2(result) {
          return {
            jsonrpc: "2.0",
            id,
            result
          };
        }
        var handled = handler(ctx, (_msg$params = msg.params) !== null && _msg$params !== void 0 ? _msg$params : {});
        var _temp = typeof handled.then === "function";
        return _temp ? Promise.resolve(handled).then(_temp2) : _temp2(handled);
      }, function(err) {
        var error;
        if (err instanceof RPCError) {
          error = err.toObject();
        } else {
          var _err$code;
          onHandlerError(ctx, msg, err);
          var code = (_err$code = err.code) !== null && _err$code !== void 0 ? _err$code : -32e3;
          error = {
            code,
            message: err.message || getErrorMessage(code)
          };
        }
        return {
          jsonrpc: "2.0",
          id,
          error
        };
      }));
    } catch (e2) {
      return Promise.reject(e2);
    }
  };
}
var import_dist4, import_dist5, import_dist6, _ERROR_MESSAGE, ERROR_CODE, ERROR_MESSAGE, RPCError, createParseError, createInvalidRequest, createMethodNotFound, createInvalidParams, createInternalError, RPCClient, _iteratorSymbol, _asyncIteratorSymbol;
var init_rpc_utils_esm = __esm({
  "node_modules/dids/node_modules/rpc-utils/dist/rpc-utils.esm.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
    init_index_browser();
    (function(ERROR_CODE2) {
      ERROR_CODE2[ERROR_CODE2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
      ERROR_CODE2[ERROR_CODE2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
      ERROR_CODE2[ERROR_CODE2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
      ERROR_CODE2[ERROR_CODE2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
      ERROR_CODE2[ERROR_CODE2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
    })(ERROR_CODE || (ERROR_CODE = {}));
    ERROR_MESSAGE = (_ERROR_MESSAGE = {}, _ERROR_MESSAGE[ERROR_CODE.PARSE_ERROR] = "Parse error", _ERROR_MESSAGE[ERROR_CODE.INVALID_REQUEST] = "Invalid request", _ERROR_MESSAGE[ERROR_CODE.METHOD_NOT_FOUND] = "Method not found", _ERROR_MESSAGE[ERROR_CODE.INVALID_PARAMS] = "Invalid params", _ERROR_MESSAGE[ERROR_CODE.INTERNAL_ERROR] = "Internal error", _ERROR_MESSAGE);
    RPCError = function(_Error) {
      _inheritsLoose(RPCError2, _Error);
      function RPCError2(code, message, data) {
        var _this;
        _this = _Error.call(this) || this;
        Object.setPrototypeOf(_assertThisInitialized(_this), RPCError2.prototype);
        _this.code = code;
        _this.data = data;
        _this.message = message !== null && message !== void 0 ? message : getErrorMessage(code);
        return _this;
      }
      RPCError2.fromObject = function fromObject(err) {
        return new RPCError2(err.code, err.message, err.data);
      };
      var _proto = RPCError2.prototype;
      _proto.toObject = function toObject() {
        return {
          code: this.code,
          data: this.data,
          message: this.message
        };
      };
      return RPCError2;
    }(_wrapNativeSuper(Error));
    createParseError = createErrorFactory(ERROR_CODE.PARSE_ERROR);
    createInvalidRequest = createErrorFactory(ERROR_CODE.INVALID_REQUEST);
    createMethodNotFound = createErrorFactory(ERROR_CODE.METHOD_NOT_FOUND);
    createInvalidParams = createErrorFactory(ERROR_CODE.INVALID_PARAMS);
    createInternalError = createErrorFactory(ERROR_CODE.INTERNAL_ERROR);
    RPCClient = function() {
      function RPCClient2(connection) {
        this.connection = connection;
      }
      var _proto = RPCClient2.prototype;
      _proto.createID = function createID() {
        return nanoid();
      };
      _proto.request = function request(method, params) {
        try {
          var _this2 = this;
          return Promise.resolve(_this2.connection.send({
            jsonrpc: "2.0",
            id: _this2.createID(),
            method,
            params
          })).then(function(res) {
            if (res == null) {
              throw new Error("Missing response");
            }
            if (res.error != null) {
              throw RPCError.fromObject(res.error);
            }
            return res.result;
          });
        } catch (e2) {
          return Promise.reject(e2);
        }
      };
      return RPCClient2;
    }();
    _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/compare.js
var require_compare = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/compare.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function compare(a, b) {
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] < b[i2]) {
          return -1;
        }
        if (a[i2] > b[i2]) {
          return 1;
        }
      }
      if (a.byteLength > b.byteLength) {
        return 1;
      }
      if (a.byteLength < b.byteLength) {
        return -1;
      }
      return 0;
    }
    module.exports = compare;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/concat.js
var require_concat = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/concat.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function concat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = concat;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/equals.js
var require_equals = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/equals.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function equals(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    module.exports = equals;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/util/bases.js
var require_bases = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/util/bases.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { bases } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec(name, prefix, encode, decode) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode
        },
        decoder: {
          decode
        }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i2 = 0; i2 < buf.length; i2++) {
        string2 += String.fromCharCode(buf[i2]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    });
    var BASES = {
      "utf8": string,
      "utf-8": string,
      "hex": bases.base16,
      "latin1": ascii,
      "ascii": ascii,
      "binary": ascii,
      ...bases
    };
    module.exports = BASES;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/from-string.js
var require_from_string = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/from-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bases = require_bases();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    module.exports = fromString;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/to-string.js
var require_to_string = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/to-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bases = require_bases();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.encoder.encode(array).substring(1);
    }
    module.exports = toString;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/xor.js
var require_xor = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/xor.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function xor(a, b) {
      if (a.length !== b.length) {
        throw new Error("Inputs should have the same length");
      }
      const result = new Uint8Array(a.length);
      for (let i2 = 0; i2 < a.length; i2++) {
        result[i2] = a[i2] ^ b[i2];
      }
      return result;
    }
    module.exports = xor;
  }
});

// node_modules/did-jwt/node_modules/uint8arrays/index.js
var require_uint8arrays = __commonJS({
  "node_modules/did-jwt/node_modules/uint8arrays/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare();
    var concat = require_concat();
    var equals = require_equals();
    var fromString = require_from_string();
    var toString = require_to_string();
    var xor = require_xor();
    module.exports = {
      compare,
      concat,
      equals,
      fromString,
      toString,
      xor
    };
  }
});

// node_modules/@stablelib/xchacha20/lib/xchacha20.js
var require_xchacha20 = __commonJS({
  "node_modules/@stablelib/xchacha20/lib/xchacha20.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var chacha_1 = require_chacha();
    var ROUNDS = 20;
    function streamXOR(key, nonce, src, dst) {
      if (nonce.length !== 24) {
        throw new Error("XChaCha20 nonce must be 24 bytes");
      }
      var subkey = hchacha(key, nonce.subarray(0, 16), new Uint8Array(32));
      var modifiedNonce = new Uint8Array(12);
      modifiedNonce.set(nonce.subarray(16), 4);
      var result = chacha_1.streamXOR(subkey, modifiedNonce, src, dst);
      wipe_1.wipe(subkey);
      return result;
    }
    exports.streamXOR = streamXOR;
    function stream(key, nonce, dst) {
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst);
    }
    exports.stream = stream;
    function hchacha(key, src, dst) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = src[3] << 24 | src[2] << 16 | src[1] << 8 | src[0];
      var j13 = src[7] << 24 | src[6] << 16 | src[5] << 8 | src[4];
      var j14 = src[11] << 24 | src[10] << 16 | src[9] << 8 | src[8];
      var j15 = src[15] << 24 | src[14] << 16 | src[13] << 8 | src[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i2 = 0; i2 < ROUNDS; i2 += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0, dst, 0);
      binary_1.writeUint32LE(x1, dst, 4);
      binary_1.writeUint32LE(x2, dst, 8);
      binary_1.writeUint32LE(x3, dst, 12);
      binary_1.writeUint32LE(x12, dst, 16);
      binary_1.writeUint32LE(x13, dst, 20);
      binary_1.writeUint32LE(x14, dst, 24);
      binary_1.writeUint32LE(x15, dst, 28);
      return dst;
    }
    exports.hchacha = hchacha;
  }
});

// node_modules/@stablelib/xchacha20poly1305/lib/xchacha20poly1305.js
var require_xchacha20poly1305 = __commonJS({
  "node_modules/@stablelib/xchacha20poly1305/lib/xchacha20poly1305.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var xchacha20_1 = require_xchacha20();
    var chacha20poly1305_1 = require_chacha20poly1305();
    var wipe_1 = require_wipe();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 24;
    exports.TAG_LENGTH = 16;
    var XChaCha20Poly1305 = (
      /** @class */
      function() {
        function XChaCha20Poly13052(key) {
          this.nonceLength = exports.NONCE_LENGTH;
          this.tagLength = exports.TAG_LENGTH;
          if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        XChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length !== 24) {
            throw new Error("XChaCha20Poly1305: incorrect nonce length");
          }
          var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
          var modifiedNonce = new Uint8Array(12);
          modifiedNonce.set(nonce.subarray(16), 4);
          var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
          var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);
          wipe_1.wipe(subKey);
          wipe_1.wipe(modifiedNonce);
          chaChaPoly.clean();
          return result;
        };
        XChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length !== 24) {
            throw new Error("XChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));
          var modifiedNonce = new Uint8Array(12);
          modifiedNonce.set(nonce.subarray(16), 4);
          var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);
          var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);
          wipe_1.wipe(subKey);
          wipe_1.wipe(modifiedNonce);
          chaChaPoly.clean();
          return result;
        };
        XChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        return XChaCha20Poly13052;
      }()
    );
    exports.XChaCha20Poly1305 = XChaCha20Poly1305;
  }
});

// node_modules/did-jwt/lib/index.js
var require_lib = __commonJS({
  "node_modules/did-jwt/lib/index.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var r2 = require_uint8arrays();
    var e2 = require_sha256();
    var t2 = require_sha3();
    var n2 = require_elliptic();
    var i2 = require_ed25519();
    var o2 = require_xchacha20poly1305();
    var a = require_x25519();
    var u = require_random();
    function c(e3) {
      return r2.toString(e3, "base64url");
    }
    function f(e3) {
      var t3 = e3.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      return r2.fromString(t3, "base64url");
    }
    function s(e3) {
      return r2.fromString(e3, "base58btc");
    }
    function l(e3) {
      var t3 = e3.startsWith("0x") ? e3.substring(2) : e3;
      return r2.fromString(t3.toLowerCase(), "base16");
    }
    function h(e3) {
      return c(r2.fromString(e3));
    }
    function v(e3) {
      return r2.toString(f(e3));
    }
    function d(e3) {
      return r2.toString(e3, "base16");
    }
    function p(e3) {
      return r2.fromString(e3);
    }
    function y(e3, t3) {
      var n3 = e3.r, i3 = e3.s, o3 = e3.recoveryParam, a2 = new Uint8Array(t3 ? 65 : 64);
      if (a2.set(r2.fromString(n3, "base16"), 0), a2.set(r2.fromString(i3, "base16"), 32), t3) {
        if (void 0 === o3) throw new Error("Signer did not return a recoveryParam");
        a2[64] = o3;
      }
      return c(a2);
    }
    function g(r3) {
      var e3 = f(r3);
      if (e3.length < 64 || e3.length > 65) throw new TypeError("Wrong size for signature. Expected 64 or 65 bytes, but got " + e3.length);
      return { r: d(e3.slice(0, 32)), s: d(e3.slice(32, 64)), recoveryParam: 65 === e3.length ? e3[64] : void 0 };
    }
    function w(e3, t3) {
      return r2.concat([f(e3), f(t3)]);
    }
    var m = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/;
    var b = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/;
    var E = /^([0-9a-zA-Z=\-_\+\/]{43}|[0-9a-zA-Z=\-_\+\/]{86})(={0,2})$/;
    function P(r3) {
      if ("string" == typeof r3) {
        if (m.test(r3)) return l(r3);
        if (b.test(r3)) return s(r3);
        if (E.test(r3)) return f(r3);
        throw TypeError("Invalid private key format");
      }
      if (r3 instanceof Uint8Array) return r3;
      throw TypeError("Invalid private key format");
    }
    function S(r3, e3) {
      return void 0 === e3 && (e3 = 64), r3.length === e3 ? r3 : "0".repeat(e3 - r3.length) + r3;
    }
    function x(t3) {
      var n3 = "string" == typeof t3 ? r2.fromString(t3) : t3;
      return e2.hash(n3);
    }
    function k(e3) {
      var n3, i3 = r2.fromString(e3.slice(2), "base16");
      return "0x" + r2.toString((n3 = i3, new Uint8Array(t2.keccak_256.arrayBuffer(n3))).slice(-20), "base16");
    }
    function K(e3, t3) {
      void 0 === t3 && (t3 = new Uint8Array(4));
      var n3 = r2.fromString(e3.toString(), "base10");
      return t3.set(n3, 4 - n3.length), t3;
    }
    var A = function(e3) {
      return r2.concat([K(e3.length), e3]);
    };
    function j(t3, n3, i3) {
      if (256 !== n3) throw new Error("Unsupported key length: " + n3);
      var o3 = r2.concat([A(r2.fromString(i3)), A(new Uint8Array(0)), A(new Uint8Array(0)), K(n3)]);
      return e2.hash(r2.concat([K(1), t3, o3]));
    }
    var J = new n2.ec("secp256k1");
    function W(r3, e3) {
      void 0 === e3 && (e3 = false);
      var t3 = P(r3);
      if (32 !== t3.length) throw new Error("Invalid private key format. Expecting 32 bytes, but got " + t3.length);
      var n3 = J.keyFromPrivate(t3);
      return function(r4) {
        try {
          var t4 = n3.sign(x(r4)), i3 = t4.s, o3 = t4.recoveryParam;
          return Promise.resolve(y({ r: S(t4.r.toString("hex")), s: S(i3.toString("hex")), recoveryParam: o3 }, e3));
        } catch (r5) {
          return Promise.reject(r5);
        }
      };
    }
    function D(r3) {
      var e3 = P(r3);
      if (64 !== e3.length) throw new Error("Invalid private key format. Expecting 64 bytes, but got " + e3.length);
      return function(r4) {
        try {
          var t3 = "string" == typeof r4 ? p(r4) : r4, n3 = i2.sign(e3, t3);
          return Promise.resolve(c(n3));
        } catch (r5) {
          return Promise.reject(r5);
        }
      };
    }
    function T() {
      return (T = Object.assign || function(r3) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var t3 = arguments[e3];
          for (var n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && (r3[n3] = t3[n3]);
        }
        return r3;
      }).apply(this, arguments);
    }
    var I = new n2.ec("secp256k1");
    function C(r3, e3) {
      void 0 === e3 && (e3 = false);
      var t3 = f(r3);
      if (t3.length !== (e3 ? 65 : 64)) throw new Error("wrong signature length");
      var n3 = { r: d(t3.slice(0, 32)), s: d(t3.slice(32, 64)) };
      return e3 && (n3.recoveryParam = t3[64]), n3;
    }
    function U(r3) {
      return r3.publicKeyBase58 ? s(r3.publicKeyBase58) : r3.publicKeyBase64 ? f(r3.publicKeyBase64) : r3.publicKeyHex ? l(r3.publicKeyHex) : new Uint8Array();
    }
    function O(r3, e3, t3) {
      var n3;
      if (e3.length > 86) n3 = [C(e3, true)];
      else {
        var i3 = C(e3, false);
        n3 = [T({}, i3, { recoveryParam: 0 }), T({}, i3, { recoveryParam: 1 })];
      }
      var o3 = n3.map(function(e4) {
        var n4 = x(r3), i4 = I.recoverPubKey(n4, e4, e4.recoveryParam), o4 = i4.encode("hex"), a2 = i4.encode("hex", true), u2 = k(o4);
        return t3.find(function(r4) {
          var e5 = r4.publicKeyHex;
          return e5 === o4 || e5 === a2 || r4.ethereumAddress === u2;
        });
      }).filter(function(r4) {
        return null != r4;
      });
      if (0 === o3.length) throw new Error("Signature invalid for JWT");
      return o3[0];
    }
    function B(r3, e3, t3) {
      var n3 = p(r3), o3 = f(e3), a2 = t3.find(function(r4) {
        return i2.verify(U(r4), n3, o3);
      });
      if (!a2) throw new Error("Signature invalid for JWT");
      return a2;
    }
    var N = { ES256K: function(r3, e3, t3) {
      var n3 = x(r3), i3 = C(e3), o3 = t3.filter(function(r4) {
        return void 0 === r4.ethereumAddress;
      }), a2 = t3.filter(function(r4) {
        return void 0 !== r4.ethereumAddress;
      }), u2 = o3.find(function(r4) {
        try {
          var e4 = U(r4);
          return I.keyFromPublic(e4).verify(n3, i3);
        } catch (r5) {
          return false;
        }
      });
      if (!u2 && a2.length > 0 && (u2 = O(r3, e3, a2)), !u2) throw new Error("Signature invalid for JWT");
      return u2;
    }, "ES256K-R": O, Ed25519: B, EdDSA: B };
    function X(r3) {
      var e3 = N[r3];
      if (!e3) throw new Error("Unsupported algorithm " + r3);
      return e3;
    }
    function V(r3) {
      return "object" == typeof r3 && "r" in r3 && "s" in r3;
    }
    function _(r3) {
      return function(e3, t3) {
        try {
          return Promise.resolve(t3(e3)).then(function(e4) {
            if (V(e4)) return y(e4, r3);
            if (r3 && void 0 === g(e4).recoveryParam) throw new Error("ES256K-R not supported when signer doesn't provide a recovery param");
            return e4;
          });
        } catch (r4) {
          return Promise.reject(r4);
        }
      };
    }
    function q() {
      return function(r3, e3) {
        try {
          return Promise.resolve(e3(r3)).then(function(r4) {
            if (V(r4)) throw new Error("expected a signer function that returns a string instead of signature object");
            return r4;
          });
        } catch (r4) {
          return Promise.reject(r4);
        }
      };
    }
    X.toSignatureObject = C;
    var H = { ES256K: _(), "ES256K-R": _(true), Ed25519: q(), EdDSA: q() };
    var z = function(r3, e3, t3) {
      void 0 === t3 && (t3 = {});
      try {
        t3.alg || (t3.alg = F);
        var n3 = "string" == typeof r3 ? r3 : L(r3), i3 = [L(t3), n3].join("."), o3 = function(r4) {
          var e4 = H[r4];
          if (!e4) throw new Error("Unsupported algorithm " + r4);
          return e4;
        }(t3.alg);
        return Promise.resolve(o3(i3, e3)).then(function(r4) {
          return [i3, r4].join(".");
        });
      } catch (r4) {
        return Promise.reject(r4);
      }
    };
    var Z = { ES256K: ["Secp256k1VerificationKey2018", "Secp256k1SignatureVerificationKey2018", "EcdsaPublicKeySecp256k1", "EcdsaSecp256k1VerificationKey2019"], "ES256K-R": ["Secp256k1VerificationKey2018", "Secp256k1SignatureVerificationKey2018", "EcdsaPublicKeySecp256k1", "EcdsaSecp256k1VerificationKey2019"], Ed25519: ["ED25519SignatureVerification", "Ed25519VerificationKey2018"], EdDSA: ["ED25519SignatureVerification", "Ed25519VerificationKey2018"] };
    var F = "ES256K";
    function L(r3) {
      return h(JSON.stringify(r3));
    }
    function R(r3) {
      var e3 = r3.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
      if (e3) return { header: JSON.parse(v(e3[1])), payload: e3[2], signature: e3[3], data: e3[1] + "." + e3[2] };
      throw new Error("Incorrect format JWS");
    }
    function $(r3) {
      if (!r3) throw new Error("no JWT passed into decodeJWT");
      try {
        var e3 = R(r3);
        return Object.assign(e3, { payload: JSON.parse(v(e3.payload)) });
      } catch (r4) {
        throw new Error("Incorrect format JWT");
      }
    }
    function M(r3, e3) {
      var t3 = r3.header, n3 = r3.data, i3 = r3.signature;
      return Array.isArray(e3) || (e3 = [e3]), X(t3.alg)(n3, i3, e3);
    }
    var G = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
    function Q(r3, e3, t3) {
      if (!r3.s) {
        if (t3 instanceof Y) {
          if (!t3.s) return void (t3.o = Q.bind(null, r3, e3));
          1 & e3 && (e3 = t3.s), t3 = t3.v;
        }
        if (t3 && t3.then) return void t3.then(Q.bind(null, r3, e3), Q.bind(null, r3, 2));
        r3.s = e3, r3.v = t3;
        var n3 = r3.o;
        n3 && n3(r3);
      }
    }
    var Y = function() {
      function r3() {
      }
      return r3.prototype.then = function(e3, t3) {
        var n3 = new r3(), i3 = this.s;
        if (i3) {
          var o3 = 1 & i3 ? e3 : t3;
          if (o3) {
            try {
              Q(n3, 1, o3(this.v));
            } catch (r4) {
              Q(n3, 2, r4);
            }
            return n3;
          }
          return this;
        }
        return this.o = function(r4) {
          try {
            var i4 = r4.v;
            1 & r4.s ? Q(n3, 1, e3 ? e3(i4) : i4) : t3 ? Q(n3, 1, t3(i4)) : Q(n3, 2, i4);
          } catch (r5) {
            Q(n3, 2, r5);
          }
        }, n3;
      }, r3;
    }();
    function rr(r3) {
      return r3 instanceof Y && 1 & r3.s;
    }
    function er(r3, e3) {
      var t3 = r3.ciphertext, n3 = r3.tag, i3 = r3.recipient, o3 = { protected: r3.protectedHeader, iv: c(r3.iv), ciphertext: c(t3), tag: c(n3) };
      return e3 && (o3.aad = c(e3)), i3 && (o3.recipients = [i3]), o3;
    }
    function tr(r3) {
      var e3 = new o2.XChaCha20Poly1305(r3);
      return function(r4, t3) {
        var n3 = u.randomBytes(e3.nonceLength), i3 = e3.seal(n3, r4, t3);
        return { ciphertext: i3.subarray(0, i3.length - e3.tagLength), tag: i3.subarray(i3.length - e3.tagLength), iv: n3 };
      };
    }
    function nr(r3) {
      var e3 = tr(r3), t3 = "XC20P";
      return { alg: "dir", enc: t3, encrypt: function(r4, n3, i3) {
        void 0 === n3 && (n3 = {});
        try {
          var o3 = h(JSON.stringify(Object.assign({ alg: "dir" }, n3, { enc: t3 }))), a2 = new Uint8Array(Buffer.from(i3 ? o3 + "." + c(i3) : o3));
          return Promise.resolve(T({}, e3(r4, a2), { protectedHeader: o3 }));
        } catch (r5) {
          return Promise.reject(r5);
        }
      } };
    }
    function ir(r3) {
      var e3 = new o2.XChaCha20Poly1305(r3);
      return { alg: "dir", enc: "XC20P", decrypt: function(r4, t3, n3) {
        try {
          return Promise.resolve(e3.open(t3, r4, n3));
        } catch (r5) {
          return Promise.reject(r5);
        }
      } };
    }
    function or(r3, e3) {
      var t3 = function(t4) {
        try {
          var u2 = a.generateKeyPair(), f2 = tr(j(a.sharedKey(u2.secretKey, r3), i3, n3))(t4), s2 = { encrypted_key: c(f2.ciphertext), header: { alg: n3, iv: c(f2.iv), tag: c(f2.tag), epk: { kty: "OKP", crv: o3, x: c(u2.publicKey) } } };
          return e3 && (s2.header.kid = e3), Promise.resolve(s2);
        } catch (r4) {
          return Promise.reject(r4);
        }
      }, n3 = "ECDH-ES+XC20PKW", i3 = 256, o3 = "X25519";
      return { alg: n3, enc: "XC20P", encrypt: function(r4, e4, n4) {
        void 0 === e4 && (e4 = {});
        try {
          Object.assign(e4, { alg: void 0 });
          var i4 = u.randomBytes(32);
          return Promise.resolve(nr(i4).encrypt(r4, e4, n4)).then(function(r5) {
            return Promise.resolve(t3(i4)).then(function(e5) {
              return T({}, r5, { recipient: e5, cek: i4 });
            });
          });
        } catch (r5) {
          return Promise.reject(r5);
        }
      }, encryptCek: t3 };
    }
    exports.ES256KSigner = W, exports.EdDSASigner = D, exports.EllipticSigner = function(r3) {
      return W(r3);
    }, exports.NaclSigner = function(r3) {
      return D(r3);
    }, exports.SimpleSigner = function(r3) {
      var e3 = W(r3, true);
      return function(r4) {
        try {
          return Promise.resolve(e3(r4)).then(g);
        } catch (r5) {
          return Promise.reject(r5);
        }
      };
    }, exports.createJWE = function(r3, e3, t3, n3) {
      void 0 === t3 && (t3 = {});
      try {
        if ("dir" === e3[0].alg) {
          if (e3.length > 1) throw new Error('Can only do "dir" encryption to one key.');
          return Promise.resolve(e3[0].encrypt(r3, t3, n3)).then(function(r4) {
            return er(r4, n3);
          });
        }
        var i3, o3, a2 = e3[0].enc;
        if (!e3.reduce(function(r4, e4) {
          return r4 && e4.enc === a2;
        }, true)) throw new Error("Incompatible encrypters passed");
        var u2 = function(r4, e4, t4) {
          if ("function" == typeof r4[G]) {
            var n4, i4, o4, a3 = r4[G]();
            if (function r5(t5) {
              try {
                for (; !(n4 = a3.next()).done; ) if ((t5 = e4(n4.value)) && t5.then) {
                  if (!rr(t5)) return void t5.then(r5, o4 || (o4 = Q.bind(null, i4 = new Y(), 2)));
                  t5 = t5.v;
                }
                i4 ? Q(i4, 1, t5) : i4 = t5;
              } catch (r6) {
                Q(i4 || (i4 = new Y()), 2, r6);
              }
            }(), a3.return) {
              var u3 = function(r5) {
                try {
                  n4.done || a3.return();
                } catch (r6) {
                }
                return r5;
              };
              if (i4 && i4.then) return i4.then(u3, function(r5) {
                throw u3(r5);
              });
              u3();
            }
            return i4;
          }
          if (!("length" in r4)) throw new TypeError("Object is not iterable");
          for (var c2 = [], f2 = 0; f2 < r4.length; f2++) c2.push(r4[f2]);
          return function(r5, e5, t5) {
            var n5, i5, o5 = -1;
            return function t6(a4) {
              try {
                for (; ++o5 < r5.length; ) if ((a4 = e5(o5)) && a4.then) {
                  if (!rr(a4)) return void a4.then(t6, i5 || (i5 = Q.bind(null, n5 = new Y(), 2)));
                  a4 = a4.v;
                }
                n5 ? Q(n5, 1, a4) : n5 = a4;
              } catch (r6) {
                Q(n5 || (n5 = new Y()), 2, r6);
              }
            }(), n5;
          }(c2, function(r5) {
            return e4(c2[r5]);
          });
        }(e3, function(e4) {
          var a3 = function() {
            if (i3) {
              var a4 = o3.recipients, u3 = a4.push;
              return Promise.resolve(e4.encryptCek(i3)).then(function(r4) {
                u3.call(a4, r4);
              });
            }
            return Promise.resolve(e4.encrypt(r3, t3, n3)).then(function(r4) {
              i3 = r4.cek, o3 = er(r4, n3);
            });
          }();
          if (a3 && a3.then) return a3.then(function() {
          });
        });
        return Promise.resolve(u2 && u2.then ? u2.then(function() {
          return o3;
        }) : o3);
      } catch (r4) {
        return Promise.reject(r4);
      }
    }, exports.createJWS = z, exports.createJWT = function(r3, e3, t3) {
      var n3 = e3.issuer, i3 = e3.signer, o3 = e3.alg, a2 = e3.expiresIn;
      void 0 === t3 && (t3 = {});
      try {
        if (!i3) throw new Error("No Signer functionality has been configured");
        if (!n3) throw new Error("No issuing DID has been configured");
        t3.typ || (t3.typ = "JWT"), t3.alg || (t3.alg = o3);
        var u2 = { iat: Math.floor(Date.now() / 1e3), exp: void 0 };
        if (a2) {
          if ("number" != typeof a2) throw new Error("JWT expiresIn is not a number");
          u2.exp = (r3.nbf || u2.iat) + Math.floor(a2);
        }
        var c2 = T({}, u2, r3, { iss: n3 });
        return z(c2, i3, t3);
      } catch (r4) {
        return Promise.reject(r4);
      }
    }, exports.decodeJWT = $, exports.decryptJWE = function(r3, e3) {
      try {
        var t3 = function(r4) {
          if (null === a2) throw new Error("Failed to decrypt");
          return a2;
        };
        !function(r4) {
          if (!(r4.protected && r4.iv && r4.ciphertext && r4.tag)) throw new Error("Invalid JWE");
          r4.recipients && r4.recipients.map(function(r5) {
            if (!r5.header || !r5.encrypted_key) throw new Error("Invalid JWE");
          });
        }(r3);
        var n3 = JSON.parse(v(r3.protected));
        if (n3.enc !== e3.enc) throw new Error("Decrypter does not support: '" + n3.enc + "'");
        var i3 = w(r3.ciphertext, r3.tag), o3 = new Uint8Array(Buffer.from(r3.aad ? r3.protected + "." + r3.aad : r3.protected)), a2 = null, u2 = "dir" === n3.alg && "dir" === e3.alg ? Promise.resolve(e3.decrypt(i3, f(r3.iv), o3)).then(function(r4) {
          a2 = r4;
        }) : function() {
          if (r3.recipients && 0 !== r3.recipients.length) {
            var t4 = 0;
            return function(r4, e4, t5) {
              for (var n4; ; ) {
                var i4 = r4();
                if (rr(i4) && (i4 = i4.v), !i4) return o4;
                if (i4.then) {
                  n4 = 0;
                  break;
                }
                var o4 = t5();
                if (o4 && o4.then) {
                  if (!rr(o4)) {
                    n4 = 1;
                    break;
                  }
                  o4 = o4.s;
                }
                if (e4) {
                  var a3 = e4();
                  if (a3 && a3.then && !rr(a3)) {
                    n4 = 2;
                    break;
                  }
                }
              }
              var u3 = new Y(), c2 = Q.bind(null, u3, 2);
              return (0 === n4 ? i4.then(s2) : 1 === n4 ? o4.then(f2) : a3.then(l2)).then(void 0, c2), u3;
              function f2(n5) {
                o4 = n5;
                do {
                  if (e4 && (a3 = e4()) && a3.then && !rr(a3)) return void a3.then(l2).then(void 0, c2);
                  if (!(i4 = r4()) || rr(i4) && !i4.v) return void Q(u3, 1, o4);
                  if (i4.then) return void i4.then(s2).then(void 0, c2);
                  rr(o4 = t5()) && (o4 = o4.v);
                } while (!o4 || !o4.then);
                o4.then(f2).then(void 0, c2);
              }
              function s2(r5) {
                r5 ? (o4 = t5()) && o4.then ? o4.then(f2).then(void 0, c2) : f2(o4) : Q(u3, 1, o4);
              }
              function l2() {
                (i4 = r4()) ? i4.then ? i4.then(s2).then(void 0, c2) : s2(i4) : Q(u3, 1, o4);
              }
            }(function() {
              return !a2 && t4 < r3.recipients.length;
            }, function() {
              return t4++;
            }, function() {
              var u3 = r3.recipients[t4];
              Object.assign(u3.header, n3);
              var c2 = function() {
                if (u3.header.alg === e3.alg) return Promise.resolve(e3.decrypt(i3, f(r3.iv), o3, u3)).then(function(r4) {
                  a2 = r4;
                });
              }();
              if (c2 && c2.then) return c2.then(function() {
              });
            });
          }
          throw new Error("Invalid JWE");
        }();
        return Promise.resolve(u2 && u2.then ? u2.then(t3) : t3());
      } catch (r4) {
        return Promise.reject(r4);
      }
    }, exports.resolveX25519Encrypters = function(r3, e3) {
      try {
        return Promise.all(r3.map(function(r4) {
          try {
            return Promise.resolve(e3.resolve(r4)).then(function(e4) {
              var t3;
              if (!e4.keyAgreement) throw new Error("Could not find x25519 key for " + r4);
              var n3 = (null == (t3 = e4.keyAgreement) ? void 0 : t3.map(function(r5) {
                return "string" == typeof r5 ? e4.publicKey.find(function(e5) {
                  return e5.id === r5;
                }) : r5;
              })).find(function(r5) {
                return "X25519KeyAgreementKey2019" === r5.type && Boolean(r5.publicKeyBase58);
              });
              if (!n3) throw new Error("Could not find x25519 key for " + r4);
              return or(s(n3.publicKeyBase58), n3.id);
            });
          } catch (r5) {
            return Promise.reject(r5);
          }
        }));
      } catch (r4) {
        return Promise.reject(r4);
      }
    }, exports.toEthereumAddress = k, exports.verifyJWS = function(r3, e3) {
      return M(R(r3), e3);
    }, exports.verifyJWT = function(r3, e3) {
      void 0 === e3 && (e3 = { resolver: null, auth: null, audience: null, callbackUrl: null, skewTime: null });
      try {
        if (!e3.resolver) throw new Error("No DID resolver has been configured");
        var t3 = $(r3), n3 = t3.payload, i3 = t3.header, o3 = t3.signature, a2 = t3.data;
        return Promise.resolve(function(r4, e4, t4, n4) {
          try {
            var i4 = Z[e4];
            if (!i4 || 0 === i4.length) throw new Error("No supported signature types for algorithm " + e4);
            return Promise.resolve(r4.resolve(t4)).then(function(r5) {
              if (!r5) throw new Error("Unable to resolve DID document for " + t4);
              var o4 = function(r6, e5) {
                var t5 = r6.publicKey.filter(function(r7) {
                  return e5 === r7.id;
                });
                return t5.length > 0 ? t5[0] : null;
              }, a3 = r5.publicKey || [];
              n4 && (a3 = (r5.authentication || []).map(function(e5) {
                return "string" == typeof e5 ? o4(r5, e5) : "string" == typeof e5.publicKey ? o4(r5, e5.publicKey) : e5;
              }).filter(function(r6) {
                return null != r6;
              }));
              var u2 = a3.filter(function(r6) {
                var e5 = r6.type;
                return i4.find(function(r7) {
                  return r7 === e5;
                });
              });
              if (n4 && (!u2 || 0 === u2.length)) throw new Error("DID document for " + t4 + " does not have public keys suitable for authenticating user");
              if (!u2 || 0 === u2.length) throw new Error("DID document for " + t4 + " does not have public keys for " + e4);
              return { authenticators: u2, issuer: t4, doc: r5 };
            });
          } catch (r5) {
            return Promise.reject(r5);
          }
        }(e3.resolver, i3.alg, n3.iss, e3.auth)).then(function(t4) {
          var u2 = t4.doc, c2 = t4.issuer;
          return Promise.resolve(M({ header: i3, data: a2, signature: o3 }, t4.authenticators)).then(function(t5) {
            var i4 = Math.floor(Date.now() / 1e3), o4 = e3.skewTime >= 0 ? e3.skewTime : 300;
            if (t5) {
              var a3 = i4 + o4;
              if (n3.nbf) {
                if (n3.nbf > a3) throw new Error("JWT not valid before nbf: " + n3.nbf);
              } else if (n3.iat && n3.iat > a3) throw new Error("JWT not valid yet (issued in the future) iat: " + n3.iat);
              if (n3.exp && n3.exp <= i4 - o4) throw new Error("JWT has expired: exp: " + n3.exp + " < now: " + i4);
              if (n3.aud) {
                if (!e3.audience && !e3.callbackUrl) throw new Error("JWT audience is required but your app address has not been configured");
                if (void 0 === (Array.isArray(n3.aud) ? n3.aud : [n3.aud]).find(function(r4) {
                  return e3.audience === r4 || e3.callbackUrl === r4;
                })) throw new Error("JWT audience does not match your DID or callback url");
              }
              return { payload: n3, doc: u2, issuer: c2, signer: t5, jwt: r3 };
            }
          });
        });
      } catch (r4) {
        return Promise.reject(r4);
      }
    }, exports.x25519Decrypter = function(r3) {
      var e3 = "ECDH-ES+XC20PKW";
      return { alg: e3, enc: "XC20P", decrypt: function(t3, n3, i3, o3) {
        try {
          if (function(r4) {
            if (!(r4.epk && r4.iv && r4.tag)) throw new Error("Invalid JWE");
          }(o3.header), "X25519" !== o3.header.epk.crv) return Promise.resolve(null);
          var u2 = f(o3.header.epk.x), c2 = j(a.sharedKey(r3, u2), 256, e3), s2 = w(o3.encrypted_key, o3.header.tag);
          return Promise.resolve(ir(c2).decrypt(s2, f(o3.header.iv))).then(function(r4) {
            return null === r4 ? null : ir(r4).decrypt(t3, n3, i3);
          });
        } catch (r4) {
          return Promise.reject(r4);
        }
      } };
    }, exports.x25519Encrypter = or, exports.xc20pDirDecrypter = ir, exports.xc20pDirEncrypter = nr;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i2];
      i2 += d;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e2)) < 1) {
          e2--;
          c *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e2++;
          c /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d] |= s * 128;
    };
  }
});

// node_modules/borc/src/decoder.asm.js
var require_decoder_asm = __commonJS({
  "node_modules/borc/src/decoder.asm.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = function decodeAsm(stdlib, foreign, buffer) {
      ;
      var heap = new stdlib.Uint8Array(buffer);
      var pushInt = foreign.pushInt;
      var pushInt32 = foreign.pushInt32;
      var pushInt32Neg = foreign.pushInt32Neg;
      var pushInt64 = foreign.pushInt64;
      var pushInt64Neg = foreign.pushInt64Neg;
      var pushFloat = foreign.pushFloat;
      var pushFloatSingle = foreign.pushFloatSingle;
      var pushFloatDouble = foreign.pushFloatDouble;
      var pushTrue = foreign.pushTrue;
      var pushFalse = foreign.pushFalse;
      var pushUndefined = foreign.pushUndefined;
      var pushNull = foreign.pushNull;
      var pushInfinity = foreign.pushInfinity;
      var pushInfinityNeg = foreign.pushInfinityNeg;
      var pushNaN = foreign.pushNaN;
      var pushNaNNeg = foreign.pushNaNNeg;
      var pushArrayStart = foreign.pushArrayStart;
      var pushArrayStartFixed = foreign.pushArrayStartFixed;
      var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
      var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
      var pushObjectStart = foreign.pushObjectStart;
      var pushObjectStartFixed = foreign.pushObjectStartFixed;
      var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
      var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
      var pushByteString = foreign.pushByteString;
      var pushByteStringStart = foreign.pushByteStringStart;
      var pushUtf8String = foreign.pushUtf8String;
      var pushUtf8StringStart = foreign.pushUtf8StringStart;
      var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
      var pushTagStart = foreign.pushTagStart;
      var pushTagStart4 = foreign.pushTagStart4;
      var pushTagStart8 = foreign.pushTagStart8;
      var pushTagUnassigned = foreign.pushTagUnassigned;
      var pushBreak = foreign.pushBreak;
      var pow = stdlib.Math.pow;
      var offset = 0;
      var inputLength = 0;
      var code = 0;
      function parse(input) {
        input = input | 0;
        offset = 0;
        inputLength = input;
        while ((offset | 0) < (inputLength | 0)) {
          code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
          if ((code | 0) > 0) {
            break;
          }
        }
        return code | 0;
      }
      function checkOffset(n2) {
        n2 = n2 | 0;
        if (((offset | 0) + (n2 | 0) | 0) < (inputLength | 0)) {
          return 0;
        }
        return 1;
      }
      function readUInt16(n2) {
        n2 = n2 | 0;
        return heap[n2 | 0] << 8 | heap[n2 + 1 | 0] | 0;
      }
      function readUInt32(n2) {
        n2 = n2 | 0;
        return heap[n2 | 0] << 24 | heap[n2 + 1 | 0] << 16 | heap[n2 + 2 | 0] << 8 | heap[n2 + 3 | 0] | 0;
      }
      function INT_P(octet) {
        octet = octet | 0;
        pushInt(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function UINT_P_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushInt(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function UINT_P_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushInt(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function UINT_P_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushInt32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function UINT_P_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushInt64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function INT_N(octet) {
        octet = octet | 0;
        pushInt(-1 - (octet - 32 | 0) | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function UINT_N_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushInt(
          -1 - (heap[offset + 1 | 0] | 0) | 0
        );
        offset = offset + 2 | 0;
        return 0;
      }
      function UINT_N_16(octet) {
        octet = octet | 0;
        var val = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        val = readUInt16(offset + 1 | 0) | 0;
        pushInt(-1 - (val | 0) | 0);
        offset = offset + 3 | 0;
        return 0;
      }
      function UINT_N_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushInt32Neg(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function UINT_N_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushInt64Neg(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function BYTE_STRING(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var step = 0;
        step = octet - 64 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        start = offset + 1 | 0;
        end = (offset + 1 | 0) + (step | 0) | 0;
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_8(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        length = heap[offset + 1 | 0] | 0;
        start = offset + 2 | 0;
        end = (offset + 2 | 0) + (length | 0) | 0;
        if (checkOffset(length + 1 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_16(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        length = readUInt16(offset + 1 | 0) | 0;
        start = offset + 3 | 0;
        end = (offset + 3 | 0) + (length | 0) | 0;
        if (checkOffset(length + 2 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_32(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        length = readUInt32(offset + 1 | 0) | 0;
        start = offset + 5 | 0;
        end = (offset + 5 | 0) + (length | 0) | 0;
        if (checkOffset(length + 4 | 0) | 0) {
          return 1;
        }
        pushByteString(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function BYTE_STRING_64(octet) {
        octet = octet | 0;
        return 1;
      }
      function BYTE_STRING_BREAK(octet) {
        octet = octet | 0;
        pushByteStringStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function UTF8_STRING(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var step = 0;
        step = octet - 96 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        start = offset + 1 | 0;
        end = (offset + 1 | 0) + (step | 0) | 0;
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_8(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        length = heap[offset + 1 | 0] | 0;
        start = offset + 2 | 0;
        end = (offset + 2 | 0) + (length | 0) | 0;
        if (checkOffset(length + 1 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_16(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        length = readUInt16(offset + 1 | 0) | 0;
        start = offset + 3 | 0;
        end = (offset + 3 | 0) + (length | 0) | 0;
        if (checkOffset(length + 2 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_32(octet) {
        octet = octet | 0;
        var start = 0;
        var end = 0;
        var length = 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        length = readUInt32(offset + 1 | 0) | 0;
        start = offset + 5 | 0;
        end = (offset + 5 | 0) + (length | 0) | 0;
        if (checkOffset(length + 4 | 0) | 0) {
          return 1;
        }
        pushUtf8String(start | 0, end | 0);
        offset = end | 0;
        return 0;
      }
      function UTF8_STRING_64(octet) {
        octet = octet | 0;
        return 1;
      }
      function UTF8_STRING_BREAK(octet) {
        octet = octet | 0;
        pushUtf8StringStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function ARRAY(octet) {
        octet = octet | 0;
        pushArrayStartFixed(octet - 128 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function ARRAY_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushArrayStartFixed(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function ARRAY_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushArrayStartFixed(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function ARRAY_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushArrayStartFixed32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function ARRAY_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushArrayStartFixed64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function ARRAY_BREAK(octet) {
        octet = octet | 0;
        pushArrayStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function MAP(octet) {
        octet = octet | 0;
        var step = 0;
        step = octet - 160 | 0;
        if (checkOffset(step | 0) | 0) {
          return 1;
        }
        pushObjectStartFixed(step | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function MAP_8(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushObjectStartFixed(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function MAP_16(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushObjectStartFixed(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function MAP_32(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushObjectStartFixed32(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function MAP_64(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushObjectStartFixed64(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function MAP_BREAK(octet) {
        octet = octet | 0;
        pushObjectStart();
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_KNOWN(octet) {
        octet = octet | 0;
        pushTagStart(octet - 192 | 0 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_POS(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_NEG(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_FRAC(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BIGNUM_FLOAT(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_UNASSIGNED(octet) {
        octet = octet | 0;
        pushTagStart(octet - 192 | 0 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE64_URL(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE64(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_BASE16(octet) {
        octet = octet | 0;
        pushTagStart(octet | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function TAG_MORE_1(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushTagStart(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function TAG_MORE_2(octet) {
        octet = octet | 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        pushTagStart(
          readUInt16(offset + 1 | 0) | 0
        );
        offset = offset + 3 | 0;
        return 0;
      }
      function TAG_MORE_4(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushTagStart4(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function TAG_MORE_8(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushTagStart8(
          readUInt16(offset + 1 | 0) | 0,
          readUInt16(offset + 3 | 0) | 0,
          readUInt16(offset + 5 | 0) | 0,
          readUInt16(offset + 7 | 0) | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function SIMPLE_UNASSIGNED(octet) {
        octet = octet | 0;
        pushSimpleUnassigned((octet | 0) - 224 | 0);
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_FALSE(octet) {
        octet = octet | 0;
        pushFalse();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_TRUE(octet) {
        octet = octet | 0;
        pushTrue();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_NULL(octet) {
        octet = octet | 0;
        pushNull();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_UNDEFINED(octet) {
        octet = octet | 0;
        pushUndefined();
        offset = offset + 1 | 0;
        return 0;
      }
      function SIMPLE_BYTE(octet) {
        octet = octet | 0;
        if (checkOffset(1) | 0) {
          return 1;
        }
        pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
        offset = offset + 2 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_HALF(octet) {
        octet = octet | 0;
        var f = 0;
        var g = 0;
        var sign = 1;
        var exp = 0;
        var mant = 0;
        var r2 = 0;
        if (checkOffset(2) | 0) {
          return 1;
        }
        f = heap[offset + 1 | 0] | 0;
        g = heap[offset + 2 | 0] | 0;
        if ((f | 0) & 128) {
          sign = -1;
        }
        exp = +(((f | 0) & 124) >> 2);
        mant = +(((f | 0) & 3) << 8 | g);
        if (+exp == 0) {
          pushFloat(+(+sign * 5960464477539063e-23 * +mant));
        } else if (+exp == 31) {
          if (+sign == 1) {
            if (+mant > 0) {
              pushNaN();
            } else {
              pushInfinity();
            }
          } else {
            if (+mant > 0) {
              pushNaNNeg();
            } else {
              pushInfinityNeg();
            }
          }
        } else {
          pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
        }
        offset = offset + 3 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_SINGLE(octet) {
        octet = octet | 0;
        if (checkOffset(4) | 0) {
          return 1;
        }
        pushFloatSingle(
          heap[offset + 1 | 0] | 0,
          heap[offset + 2 | 0] | 0,
          heap[offset + 3 | 0] | 0,
          heap[offset + 4 | 0] | 0
        );
        offset = offset + 5 | 0;
        return 0;
      }
      function SIMPLE_FLOAT_DOUBLE(octet) {
        octet = octet | 0;
        if (checkOffset(8) | 0) {
          return 1;
        }
        pushFloatDouble(
          heap[offset + 1 | 0] | 0,
          heap[offset + 2 | 0] | 0,
          heap[offset + 3 | 0] | 0,
          heap[offset + 4 | 0] | 0,
          heap[offset + 5 | 0] | 0,
          heap[offset + 6 | 0] | 0,
          heap[offset + 7 | 0] | 0,
          heap[offset + 8 | 0] | 0
        );
        offset = offset + 9 | 0;
        return 0;
      }
      function ERROR(octet) {
        octet = octet | 0;
        return 1;
      }
      function BREAK(octet) {
        octet = octet | 0;
        pushBreak();
        offset = offset + 1 | 0;
        return 0;
      }
      var jumpTable = [
        // Integer 0x00..0x17 (0..23)
        INT_P,
        // 0x00
        INT_P,
        // 0x01
        INT_P,
        // 0x02
        INT_P,
        // 0x03
        INT_P,
        // 0x04
        INT_P,
        // 0x05
        INT_P,
        // 0x06
        INT_P,
        // 0x07
        INT_P,
        // 0x08
        INT_P,
        // 0x09
        INT_P,
        // 0x0A
        INT_P,
        // 0x0B
        INT_P,
        // 0x0C
        INT_P,
        // 0x0D
        INT_P,
        // 0x0E
        INT_P,
        // 0x0F
        INT_P,
        // 0x10
        INT_P,
        // 0x11
        INT_P,
        // 0x12
        INT_P,
        // 0x13
        INT_P,
        // 0x14
        INT_P,
        // 0x15
        INT_P,
        // 0x16
        INT_P,
        // 0x17
        // Unsigned integer (one-byte uint8_t follows)
        UINT_P_8,
        // 0x18
        // Unsigned integer (two-byte uint16_t follows)
        UINT_P_16,
        // 0x19
        // Unsigned integer (four-byte uint32_t follows)
        UINT_P_32,
        // 0x1a
        // Unsigned integer (eight-byte uint64_t follows)
        UINT_P_64,
        // 0x1b
        ERROR,
        // 0x1c
        ERROR,
        // 0x1d
        ERROR,
        // 0x1e
        ERROR,
        // 0x1f
        // Negative integer -1-0x00..-1-0x17 (-1..-24)
        INT_N,
        // 0x20
        INT_N,
        // 0x21
        INT_N,
        // 0x22
        INT_N,
        // 0x23
        INT_N,
        // 0x24
        INT_N,
        // 0x25
        INT_N,
        // 0x26
        INT_N,
        // 0x27
        INT_N,
        // 0x28
        INT_N,
        // 0x29
        INT_N,
        // 0x2A
        INT_N,
        // 0x2B
        INT_N,
        // 0x2C
        INT_N,
        // 0x2D
        INT_N,
        // 0x2E
        INT_N,
        // 0x2F
        INT_N,
        // 0x30
        INT_N,
        // 0x31
        INT_N,
        // 0x32
        INT_N,
        // 0x33
        INT_N,
        // 0x34
        INT_N,
        // 0x35
        INT_N,
        // 0x36
        INT_N,
        // 0x37
        // Negative integer -1-n (one-byte uint8_t for n follows)
        UINT_N_8,
        // 0x38
        // Negative integer -1-n (two-byte uint16_t for n follows)
        UINT_N_16,
        // 0x39
        // Negative integer -1-n (four-byte uint32_t for nfollows)
        UINT_N_32,
        // 0x3a
        // Negative integer -1-n (eight-byte uint64_t for n follows)
        UINT_N_64,
        // 0x3b
        ERROR,
        // 0x3c
        ERROR,
        // 0x3d
        ERROR,
        // 0x3e
        ERROR,
        // 0x3f
        // byte string (0x00..0x17 bytes follow)
        BYTE_STRING,
        // 0x40
        BYTE_STRING,
        // 0x41
        BYTE_STRING,
        // 0x42
        BYTE_STRING,
        // 0x43
        BYTE_STRING,
        // 0x44
        BYTE_STRING,
        // 0x45
        BYTE_STRING,
        // 0x46
        BYTE_STRING,
        // 0x47
        BYTE_STRING,
        // 0x48
        BYTE_STRING,
        // 0x49
        BYTE_STRING,
        // 0x4A
        BYTE_STRING,
        // 0x4B
        BYTE_STRING,
        // 0x4C
        BYTE_STRING,
        // 0x4D
        BYTE_STRING,
        // 0x4E
        BYTE_STRING,
        // 0x4F
        BYTE_STRING,
        // 0x50
        BYTE_STRING,
        // 0x51
        BYTE_STRING,
        // 0x52
        BYTE_STRING,
        // 0x53
        BYTE_STRING,
        // 0x54
        BYTE_STRING,
        // 0x55
        BYTE_STRING,
        // 0x56
        BYTE_STRING,
        // 0x57
        // byte string (one-byte uint8_t for n, and then n bytes follow)
        BYTE_STRING_8,
        // 0x58
        // byte string (two-byte uint16_t for n, and then n bytes follow)
        BYTE_STRING_16,
        // 0x59
        // byte string (four-byte uint32_t for n, and then n bytes follow)
        BYTE_STRING_32,
        // 0x5a
        // byte string (eight-byte uint64_t for n, and then n bytes follow)
        BYTE_STRING_64,
        // 0x5b
        ERROR,
        // 0x5c
        ERROR,
        // 0x5d
        ERROR,
        // 0x5e
        // byte string, byte strings follow, terminated by "break"
        BYTE_STRING_BREAK,
        // 0x5f
        // UTF-8 string (0x00..0x17 bytes follow)
        UTF8_STRING,
        // 0x60
        UTF8_STRING,
        // 0x61
        UTF8_STRING,
        // 0x62
        UTF8_STRING,
        // 0x63
        UTF8_STRING,
        // 0x64
        UTF8_STRING,
        // 0x65
        UTF8_STRING,
        // 0x66
        UTF8_STRING,
        // 0x67
        UTF8_STRING,
        // 0x68
        UTF8_STRING,
        // 0x69
        UTF8_STRING,
        // 0x6A
        UTF8_STRING,
        // 0x6B
        UTF8_STRING,
        // 0x6C
        UTF8_STRING,
        // 0x6D
        UTF8_STRING,
        // 0x6E
        UTF8_STRING,
        // 0x6F
        UTF8_STRING,
        // 0x70
        UTF8_STRING,
        // 0x71
        UTF8_STRING,
        // 0x72
        UTF8_STRING,
        // 0x73
        UTF8_STRING,
        // 0x74
        UTF8_STRING,
        // 0x75
        UTF8_STRING,
        // 0x76
        UTF8_STRING,
        // 0x77
        // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)
        UTF8_STRING_8,
        // 0x78
        // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)
        UTF8_STRING_16,
        // 0x79
        // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)
        UTF8_STRING_32,
        // 0x7a
        // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)
        UTF8_STRING_64,
        // 0x7b
        // UTF-8 string, UTF-8 strings follow, terminated by "break"
        ERROR,
        // 0x7c
        ERROR,
        // 0x7d
        ERROR,
        // 0x7e
        UTF8_STRING_BREAK,
        // 0x7f
        // array (0x00..0x17 data items follow)
        ARRAY,
        // 0x80
        ARRAY,
        // 0x81
        ARRAY,
        // 0x82
        ARRAY,
        // 0x83
        ARRAY,
        // 0x84
        ARRAY,
        // 0x85
        ARRAY,
        // 0x86
        ARRAY,
        // 0x87
        ARRAY,
        // 0x88
        ARRAY,
        // 0x89
        ARRAY,
        // 0x8A
        ARRAY,
        // 0x8B
        ARRAY,
        // 0x8C
        ARRAY,
        // 0x8D
        ARRAY,
        // 0x8E
        ARRAY,
        // 0x8F
        ARRAY,
        // 0x90
        ARRAY,
        // 0x91
        ARRAY,
        // 0x92
        ARRAY,
        // 0x93
        ARRAY,
        // 0x94
        ARRAY,
        // 0x95
        ARRAY,
        // 0x96
        ARRAY,
        // 0x97
        // array (one-byte uint8_t fo, and then n data items follow)
        ARRAY_8,
        // 0x98
        // array (two-byte uint16_t for n, and then n data items follow)
        ARRAY_16,
        // 0x99
        // array (four-byte uint32_t for n, and then n data items follow)
        ARRAY_32,
        // 0x9a
        // array (eight-byte uint64_t for n, and then n data items follow)
        ARRAY_64,
        // 0x9b
        // array, data items follow, terminated by "break"
        ERROR,
        // 0x9c
        ERROR,
        // 0x9d
        ERROR,
        // 0x9e
        ARRAY_BREAK,
        // 0x9f
        // map (0x00..0x17 pairs of data items follow)
        MAP,
        // 0xa0
        MAP,
        // 0xa1
        MAP,
        // 0xa2
        MAP,
        // 0xa3
        MAP,
        // 0xa4
        MAP,
        // 0xa5
        MAP,
        // 0xa6
        MAP,
        // 0xa7
        MAP,
        // 0xa8
        MAP,
        // 0xa9
        MAP,
        // 0xaA
        MAP,
        // 0xaB
        MAP,
        // 0xaC
        MAP,
        // 0xaD
        MAP,
        // 0xaE
        MAP,
        // 0xaF
        MAP,
        // 0xb0
        MAP,
        // 0xb1
        MAP,
        // 0xb2
        MAP,
        // 0xb3
        MAP,
        // 0xb4
        MAP,
        // 0xb5
        MAP,
        // 0xb6
        MAP,
        // 0xb7
        // map (one-byte uint8_t for n, and then n pairs of data items follow)
        MAP_8,
        // 0xb8
        // map (two-byte uint16_t for n, and then n pairs of data items follow)
        MAP_16,
        // 0xb9
        // map (four-byte uint32_t for n, and then n pairs of data items follow)
        MAP_32,
        // 0xba
        // map (eight-byte uint64_t for n, and then n pairs of data items follow)
        MAP_64,
        // 0xbb
        ERROR,
        // 0xbc
        ERROR,
        // 0xbd
        ERROR,
        // 0xbe
        // map, pairs of data items follow, terminated by "break"
        MAP_BREAK,
        // 0xbf
        // Text-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN,
        // 0xc0
        // Epoch-based date/time (data item follows; see Section 2.4.1)
        TAG_KNOWN,
        // 0xc1
        // Positive bignum (data item "byte string" follows)
        TAG_KNOWN,
        // 0xc2
        // Negative bignum (data item "byte string" follows)
        TAG_KNOWN,
        // 0xc3
        // Decimal Fraction (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN,
        // 0xc4
        // Bigfloat (data item "array" follows; see Section 2.4.3)
        TAG_KNOWN,
        // 0xc5
        // (tagged item)
        TAG_UNASSIGNED,
        // 0xc6
        TAG_UNASSIGNED,
        // 0xc7
        TAG_UNASSIGNED,
        // 0xc8
        TAG_UNASSIGNED,
        // 0xc9
        TAG_UNASSIGNED,
        // 0xca
        TAG_UNASSIGNED,
        // 0xcb
        TAG_UNASSIGNED,
        // 0xcc
        TAG_UNASSIGNED,
        // 0xcd
        TAG_UNASSIGNED,
        // 0xce
        TAG_UNASSIGNED,
        // 0xcf
        TAG_UNASSIGNED,
        // 0xd0
        TAG_UNASSIGNED,
        // 0xd1
        TAG_UNASSIGNED,
        // 0xd2
        TAG_UNASSIGNED,
        // 0xd3
        TAG_UNASSIGNED,
        // 0xd4
        // Expected Conversion (data item follows; see Section 2.4.4.2)
        TAG_UNASSIGNED,
        // 0xd5
        TAG_UNASSIGNED,
        // 0xd6
        TAG_UNASSIGNED,
        // 0xd7
        // (more tagged items, 1/2/4/8 bytes and then a data item follow)
        TAG_MORE_1,
        // 0xd8
        TAG_MORE_2,
        // 0xd9
        TAG_MORE_4,
        // 0xda
        TAG_MORE_8,
        // 0xdb
        ERROR,
        // 0xdc
        ERROR,
        // 0xdd
        ERROR,
        // 0xde
        ERROR,
        // 0xdf
        // (simple value)
        SIMPLE_UNASSIGNED,
        // 0xe0
        SIMPLE_UNASSIGNED,
        // 0xe1
        SIMPLE_UNASSIGNED,
        // 0xe2
        SIMPLE_UNASSIGNED,
        // 0xe3
        SIMPLE_UNASSIGNED,
        // 0xe4
        SIMPLE_UNASSIGNED,
        // 0xe5
        SIMPLE_UNASSIGNED,
        // 0xe6
        SIMPLE_UNASSIGNED,
        // 0xe7
        SIMPLE_UNASSIGNED,
        // 0xe8
        SIMPLE_UNASSIGNED,
        // 0xe9
        SIMPLE_UNASSIGNED,
        // 0xea
        SIMPLE_UNASSIGNED,
        // 0xeb
        SIMPLE_UNASSIGNED,
        // 0xec
        SIMPLE_UNASSIGNED,
        // 0xed
        SIMPLE_UNASSIGNED,
        // 0xee
        SIMPLE_UNASSIGNED,
        // 0xef
        SIMPLE_UNASSIGNED,
        // 0xf0
        SIMPLE_UNASSIGNED,
        // 0xf1
        SIMPLE_UNASSIGNED,
        // 0xf2
        SIMPLE_UNASSIGNED,
        // 0xf3
        // False
        SIMPLE_FALSE,
        // 0xf4
        // True
        SIMPLE_TRUE,
        // 0xf5
        // Null
        SIMPLE_NULL,
        // 0xf6
        // Undefined
        SIMPLE_UNDEFINED,
        // 0xf7
        // (simple value, one byte follows)
        SIMPLE_BYTE,
        // 0xf8
        // Half-Precision Float (two-byte IEEE 754)
        SIMPLE_FLOAT_HALF,
        // 0xf9
        // Single-Precision Float (four-byte IEEE 754)
        SIMPLE_FLOAT_SINGLE,
        // 0xfa
        // Double-Precision Float (eight-byte IEEE 754)
        SIMPLE_FLOAT_DOUBLE,
        // 0xfb
        ERROR,
        // 0xfc
        ERROR,
        // 0xfd
        ERROR,
        // 0xfe
        // "break" stop code
        BREAK
        // 0xff
      ];
      return {
        parse
      };
    };
  }
});

// node_modules/borc/src/constants.js
var require_constants = __commonJS({
  "node_modules/borc/src/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Bignumber = require_bignumber().BigNumber;
    exports.MT = {
      POS_INT: 0,
      NEG_INT: 1,
      BYTE_STRING: 2,
      UTF8_STRING: 3,
      ARRAY: 4,
      MAP: 5,
      TAG: 6,
      SIMPLE_FLOAT: 7
    };
    exports.TAG = {
      DATE_STRING: 0,
      DATE_EPOCH: 1,
      POS_BIGINT: 2,
      NEG_BIGINT: 3,
      DECIMAL_FRAC: 4,
      BIGFLOAT: 5,
      BASE64URL_EXPECTED: 21,
      BASE64_EXPECTED: 22,
      BASE16_EXPECTED: 23,
      CBOR: 24,
      URI: 32,
      BASE64URL: 33,
      BASE64: 34,
      REGEXP: 35,
      MIME: 36
    };
    exports.NUMBYTES = {
      ZERO: 0,
      ONE: 24,
      TWO: 25,
      FOUR: 26,
      EIGHT: 27,
      INDEFINITE: 31
    };
    exports.SIMPLE = {
      FALSE: 20,
      TRUE: 21,
      NULL: 22,
      UNDEFINED: 23
    };
    exports.SYMS = {
      NULL: Symbol("null"),
      UNDEFINED: Symbol("undef"),
      PARENT: Symbol("parent"),
      BREAK: Symbol("break"),
      STREAM: Symbol("stream")
    };
    exports.SHIFT32 = Math.pow(2, 32);
    exports.SHIFT16 = Math.pow(2, 16);
    exports.MAX_SAFE_HIGH = 2097151;
    exports.NEG_ONE = new Bignumber(-1);
    exports.TEN = new Bignumber(10);
    exports.TWO = new Bignumber(2);
    exports.PARENT = {
      ARRAY: 0,
      OBJECT: 1,
      MAP: 2,
      TAG: 3,
      BYTE_STRING: 4,
      UTF8_STRING: 5
    };
  }
});

// node_modules/borc/src/utils.js
var require_utils = __commonJS({
  "node_modules/borc/src/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { Buffer: Buffer2 } = (init_dist(), __toCommonJS(dist_exports));
    var Bignumber = require_bignumber().BigNumber;
    var constants = require_constants();
    var SHIFT32 = constants.SHIFT32;
    var SHIFT16 = constants.SHIFT16;
    var MAX_SAFE_HIGH = 2097151;
    exports.parseHalf = function parseHalf(buf) {
      var exp, mant, sign;
      sign = buf[0] & 128 ? -1 : 1;
      exp = (buf[0] & 124) >> 2;
      mant = (buf[0] & 3) << 8 | buf[1];
      if (!exp) {
        return sign * 5960464477539063e-23 * mant;
      } else if (exp === 31) {
        return sign * (mant ? 0 / 0 : Infinity);
      } else {
        return sign * Math.pow(2, exp - 25) * (1024 + mant);
      }
    };
    function toHex(n2) {
      if (n2 < 16) {
        return "0" + n2.toString(16);
      }
      return n2.toString(16);
    }
    exports.arrayBufferToBignumber = function(buf) {
      const len = buf.byteLength;
      let res = "";
      for (let i2 = 0; i2 < len; i2++) {
        res += toHex(buf[i2]);
      }
      return new Bignumber(res, 16);
    };
    exports.buildMap = (obj) => {
      const res = /* @__PURE__ */ new Map();
      const keys = Object.keys(obj);
      const length = keys.length;
      for (let i2 = 0; i2 < length; i2++) {
        res.set(keys[i2], obj[keys[i2]]);
      }
      return res;
    };
    exports.buildInt32 = (f, g) => {
      return f * SHIFT16 + g;
    };
    exports.buildInt64 = (f1, f2, g1, g2) => {
      const f = exports.buildInt32(f1, f2);
      const g = exports.buildInt32(g1, g2);
      if (f > MAX_SAFE_HIGH) {
        return new Bignumber(f).times(SHIFT32).plus(g);
      } else {
        return f * SHIFT32 + g;
      }
    };
    exports.writeHalf = function writeHalf(buf, half) {
      const u32 = Buffer2.allocUnsafe(4);
      u32.writeFloatBE(half, 0);
      const u = u32.readUInt32BE(0);
      if ((u & 8191) !== 0) {
        return false;
      }
      var s16 = u >> 16 & 32768;
      const exp = u >> 23 & 255;
      const mant = u & 8388607;
      if (exp >= 113 && exp <= 142) {
        s16 += (exp - 112 << 10) + (mant >> 13);
      } else if (exp >= 103 && exp < 113) {
        if (mant & (1 << 126 - exp) - 1) {
          return false;
        }
        s16 += mant + 8388608 >> 126 - exp;
      } else {
        return false;
      }
      buf.writeUInt16BE(s16, 0);
      return true;
    };
    exports.keySorter = function(a, b) {
      var lenA = a[0].byteLength;
      var lenB = b[0].byteLength;
      if (lenA > lenB) {
        return 1;
      }
      if (lenB > lenA) {
        return -1;
      }
      return a[0].compare(b[0]);
    };
    exports.isNegativeZero = (x) => {
      return x === 0 && 1 / x < 0;
    };
    exports.nextPowerOf2 = (n2) => {
      let count = 0;
      if (n2 && !(n2 & n2 - 1)) {
        return n2;
      }
      while (n2 !== 0) {
        n2 >>= 1;
        count += 1;
      }
      return 1 << count;
    };
  }
});

// node_modules/borc/src/simple.js
var require_simple = __commonJS({
  "node_modules/borc/src/simple.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var constants = require_constants();
    var MT = constants.MT;
    var SIMPLE = constants.SIMPLE;
    var SYMS = constants.SYMS;
    var Simple = class _Simple {
      /**
       * Creates an instance of Simple.
       *
       * @param {integer} value - the simple value's integer value
       */
      constructor(value) {
        if (typeof value !== "number") {
          throw new Error("Invalid Simple type: " + typeof value);
        }
        if (value < 0 || value > 255 || (value | 0) !== value) {
          throw new Error("value must be a small positive integer: " + value);
        }
        this.value = value;
      }
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      toString() {
        return "simple(" + this.value + ")";
      }
      /**
       * Debug string for simple value
       *
       * @returns {string} simple(value)
       */
      inspect() {
        return "simple(" + this.value + ")";
      }
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen The generator to push onto
       * @returns {number}
       */
      encodeCBOR(gen) {
        return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
      }
      /**
       * Is the given object a Simple?
       *
       * @param {any} obj - object to test
       * @returns {bool} - is it Simple?
       */
      static isSimple(obj) {
        return obj instanceof _Simple;
      }
      /**
       * Decode from the CBOR additional information into a JavaScript value.
       * If the CBOR item has no parent, return a "safe" symbol instead of
       * `null` or `undefined`, so that the value can be passed through a
       * stream in object mode.
       *
       * @param {Number} val - the CBOR additional info to convert
       * @param {bool} hasParent - Does the CBOR item have a parent?
       * @returns {(null|undefined|Boolean|Symbol)} - the decoded value
       */
      static decode(val, hasParent) {
        if (hasParent == null) {
          hasParent = true;
        }
        switch (val) {
          case SIMPLE.FALSE:
            return false;
          case SIMPLE.TRUE:
            return true;
          case SIMPLE.NULL:
            if (hasParent) {
              return null;
            } else {
              return SYMS.NULL;
            }
          case SIMPLE.UNDEFINED:
            if (hasParent) {
              return void 0;
            } else {
              return SYMS.UNDEFINED;
            }
          case -1:
            if (!hasParent) {
              throw new Error("Invalid BREAK");
            }
            return SYMS.BREAK;
          default:
            return new _Simple(val);
        }
      }
    };
    module.exports = Simple;
  }
});

// node_modules/borc/src/tagged.js
var require_tagged = __commonJS({
  "node_modules/borc/src/tagged.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Tagged = class _Tagged {
      /**
       * Creates an instance of Tagged.
       *
       * @param {Number} tag - the number of the tag
       * @param {any} value - the value inside the tag
       * @param {Error} err - the error that was thrown parsing the tag, or null
       */
      constructor(tag, value, err) {
        this.tag = tag;
        this.value = value;
        this.err = err;
        if (typeof this.tag !== "number") {
          throw new Error("Invalid tag type (" + typeof this.tag + ")");
        }
        if (this.tag < 0 || (this.tag | 0) !== this.tag) {
          throw new Error("Tag must be a positive integer: " + this.tag);
        }
      }
      /**
       * Convert to a String
       *
       * @returns {String} string of the form '1(2)'
       */
      toString() {
        return `${this.tag}(${JSON.stringify(this.value)})`;
      }
      /**
       * Push the simple value onto the CBOR stream
       *
       * @param {cbor.Encoder} gen The generator to push onto
       * @returns {number}
       */
      encodeCBOR(gen) {
        gen._pushTag(this.tag);
        return gen.pushAny(this.value);
      }
      /**
       * If we have a converter for this type, do the conversion.  Some converters
       * are built-in.  Additional ones can be passed in.  If you want to remove
       * a built-in converter, pass a converter in whose value is 'null' instead
       * of a function.
       *
       * @param {Object} converters - keys in the object are a tag number, the value
       *   is a function that takes the decoded CBOR and returns a JavaScript value
       *   of the appropriate type.  Throw an exception in the function on errors.
       * @returns {any} - the converted item
       */
      convert(converters) {
        var er, f;
        f = converters != null ? converters[this.tag] : void 0;
        if (typeof f !== "function") {
          f = _Tagged["_tag" + this.tag];
          if (typeof f !== "function") {
            return this;
          }
        }
        try {
          return f.call(_Tagged, this.value);
        } catch (error) {
          er = error;
          this.err = er;
          return this;
        }
      }
    };
    module.exports = Tagged;
  }
});

// node_modules/borc/node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/borc/node_modules/iso-url/src/url-browser.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var defaultBase = self.location ? self.location.protocol + "//" + self.location.host : "";
    var URL = self.URL;
    var URLWithLegacySupport = class {
      constructor(url = "", base = defaultBase) {
        this.super = new URL(url, base);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash) {
        this.super.hash = hash;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set origin(origin) {
        this.super.origin = origin;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set searchParams(searchParams) {
        this.super.searchParams = searchParams;
      }
      set username(username) {
        this.super.username = username;
      }
      createObjectURL(o2) {
        return this.super.createObjectURL(o2);
      }
      revokeObjectURL(o2) {
        this.super.revokeObjectURL(o2);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format(obj) {
      if (typeof obj === "string") {
        const url = new URL(obj);
        return url.toString();
      }
      if (!(obj instanceof URL)) {
        const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
      }
    }
    module.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format
    };
  }
});

// node_modules/borc/node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/borc/node_modules/iso-url/src/relative.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { URLWithLegacySupport, format } = require_url_browser();
    module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base = Object.assign({}, location, {
        protocol: protocol || urlParsed.protocol,
        host: location.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format(base)).toString();
    };
  }
});

// node_modules/borc/node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/borc/node_modules/iso-url/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var {
      URLWithLegacySupport,
      format,
      URLSearchParams,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams,
      format,
      relative,
      defaultBase
    };
  }
});

// node_modules/borc/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/borc/src/decoder.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { Buffer: Buffer2 } = (init_dist(), __toCommonJS(dist_exports));
    var ieee754 = require_ieee754();
    var Bignumber = require_bignumber().BigNumber;
    var parser = require_decoder_asm();
    var utils = require_utils();
    var c = require_constants();
    var Simple = require_simple();
    var Tagged = require_tagged();
    var { URL } = require_iso_url();
    var Decoder = class _Decoder {
      /**
       * @param {Object} [opts={}]
       * @param {number} [opts.size=65536] - Size of the allocated heap.
       */
      constructor(opts) {
        opts = opts || {};
        if (!opts.size || opts.size < 65536) {
          opts.size = 65536;
        } else {
          opts.size = utils.nextPowerOf2(opts.size);
        }
        this._heap = new ArrayBuffer(opts.size);
        this._heap8 = new Uint8Array(this._heap);
        this._buffer = Buffer2.from(this._heap);
        this._reset();
        this._knownTags = Object.assign({
          0: (val) => new Date(val),
          1: (val) => new Date(val * 1e3),
          2: (val) => utils.arrayBufferToBignumber(val),
          3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
          4: (v) => {
            return c.TEN.pow(v[0]).times(v[1]);
          },
          5: (v) => {
            return c.TWO.pow(v[0]).times(v[1]);
          },
          32: (val) => new URL(val),
          35: (val) => new RegExp(val)
        }, opts.tags);
        this.parser = parser(global, {
          // eslint-disable-next-line no-console
          log: console.log.bind(console),
          pushInt: this.pushInt.bind(this),
          pushInt32: this.pushInt32.bind(this),
          pushInt32Neg: this.pushInt32Neg.bind(this),
          pushInt64: this.pushInt64.bind(this),
          pushInt64Neg: this.pushInt64Neg.bind(this),
          pushFloat: this.pushFloat.bind(this),
          pushFloatSingle: this.pushFloatSingle.bind(this),
          pushFloatDouble: this.pushFloatDouble.bind(this),
          pushTrue: this.pushTrue.bind(this),
          pushFalse: this.pushFalse.bind(this),
          pushUndefined: this.pushUndefined.bind(this),
          pushNull: this.pushNull.bind(this),
          pushInfinity: this.pushInfinity.bind(this),
          pushInfinityNeg: this.pushInfinityNeg.bind(this),
          pushNaN: this.pushNaN.bind(this),
          pushNaNNeg: this.pushNaNNeg.bind(this),
          pushArrayStart: this.pushArrayStart.bind(this),
          pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
          pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
          pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
          pushObjectStart: this.pushObjectStart.bind(this),
          pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
          pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
          pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
          pushByteString: this.pushByteString.bind(this),
          pushByteStringStart: this.pushByteStringStart.bind(this),
          pushUtf8String: this.pushUtf8String.bind(this),
          pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
          pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
          pushTagUnassigned: this.pushTagUnassigned.bind(this),
          pushTagStart: this.pushTagStart.bind(this),
          pushTagStart4: this.pushTagStart4.bind(this),
          pushTagStart8: this.pushTagStart8.bind(this),
          pushBreak: this.pushBreak.bind(this)
        }, this._heap);
      }
      get _depth() {
        return this._parents.length;
      }
      get _currentParent() {
        return this._parents[this._depth - 1];
      }
      get _ref() {
        return this._currentParent.ref;
      }
      // Finish the current parent
      _closeParent() {
        var p = this._parents.pop();
        if (p.length > 0) {
          throw new Error(`Missing ${p.length} elements`);
        }
        switch (p.type) {
          case c.PARENT.TAG:
            this._push(
              this.createTag(p.ref[0], p.ref[1])
            );
            break;
          case c.PARENT.BYTE_STRING:
            this._push(this.createByteString(p.ref, p.length));
            break;
          case c.PARENT.UTF8_STRING:
            this._push(this.createUtf8String(p.ref, p.length));
            break;
          case c.PARENT.MAP:
            if (p.values % 2 > 0) {
              throw new Error("Odd number of elements in the map");
            }
            this._push(this.createMap(p.ref, p.length));
            break;
          case c.PARENT.OBJECT:
            if (p.values % 2 > 0) {
              throw new Error("Odd number of elements in the map");
            }
            this._push(this.createObject(p.ref, p.length));
            break;
          case c.PARENT.ARRAY:
            this._push(this.createArray(p.ref, p.length));
            break;
          default:
            break;
        }
        if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
          this._dec();
        }
      }
      // Reduce the expected length of the current parent by one
      _dec() {
        const p = this._currentParent;
        if (p.length < 0) {
          return;
        }
        p.length--;
        if (p.length === 0) {
          this._closeParent();
        }
      }
      // Push any value to the current parent
      _push(val, hasChildren) {
        const p = this._currentParent;
        p.values++;
        switch (p.type) {
          case c.PARENT.ARRAY:
          case c.PARENT.BYTE_STRING:
          case c.PARENT.UTF8_STRING:
            if (p.length > -1) {
              this._ref[this._ref.length - p.length] = val;
            } else {
              this._ref.push(val);
            }
            this._dec();
            break;
          case c.PARENT.OBJECT:
            if (p.tmpKey != null) {
              this._ref[p.tmpKey] = val;
              p.tmpKey = null;
              this._dec();
            } else {
              p.tmpKey = val;
              if (typeof p.tmpKey !== "string") {
                p.type = c.PARENT.MAP;
                p.ref = utils.buildMap(p.ref);
              }
            }
            break;
          case c.PARENT.MAP:
            if (p.tmpKey != null) {
              this._ref.set(p.tmpKey, val);
              p.tmpKey = null;
              this._dec();
            } else {
              p.tmpKey = val;
            }
            break;
          case c.PARENT.TAG:
            this._ref.push(val);
            if (!hasChildren) {
              this._dec();
            }
            break;
          default:
            throw new Error("Unknown parent type");
        }
      }
      // Create a new parent in the parents list
      _createParent(obj, type, len) {
        this._parents[this._depth] = {
          type,
          length: len,
          ref: obj,
          values: 0,
          tmpKey: null
        };
      }
      // Reset all state back to the beginning, also used for initiatlization
      _reset() {
        this._res = [];
        this._parents = [{
          type: c.PARENT.ARRAY,
          length: -1,
          ref: this._res,
          values: 0,
          tmpKey: null
        }];
      }
      // -- Interface to customize deoding behaviour
      createTag(tagNumber, value) {
        const typ = this._knownTags[tagNumber];
        if (!typ) {
          return new Tagged(tagNumber, value);
        }
        return typ(value);
      }
      createMap(obj, len) {
        return obj;
      }
      createObject(obj, len) {
        return obj;
      }
      createArray(arr, len) {
        return arr;
      }
      createByteString(raw, len) {
        return Buffer2.concat(raw);
      }
      createByteStringFromHeap(start, end) {
        if (start === end) {
          return Buffer2.alloc(0);
        }
        return Buffer2.from(this._heap.slice(start, end));
      }
      createInt(val) {
        return val;
      }
      createInt32(f, g) {
        return utils.buildInt32(f, g);
      }
      createInt64(f1, f2, g1, g2) {
        return utils.buildInt64(f1, f2, g1, g2);
      }
      createFloat(val) {
        return val;
      }
      createFloatSingle(a, b, c2, d) {
        return ieee754.read([a, b, c2, d], 0, false, 23, 4);
      }
      createFloatDouble(a, b, c2, d, e2, f, g, h) {
        return ieee754.read([a, b, c2, d, e2, f, g, h], 0, false, 52, 8);
      }
      createInt32Neg(f, g) {
        return -1 - utils.buildInt32(f, g);
      }
      createInt64Neg(f1, f2, g1, g2) {
        const f = utils.buildInt32(f1, f2);
        const g = utils.buildInt32(g1, g2);
        if (f > c.MAX_SAFE_HIGH) {
          return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
        }
        return -1 - (f * c.SHIFT32 + g);
      }
      createTrue() {
        return true;
      }
      createFalse() {
        return false;
      }
      createNull() {
        return null;
      }
      createUndefined() {
        return void 0;
      }
      createInfinity() {
        return Infinity;
      }
      createInfinityNeg() {
        return -Infinity;
      }
      createNaN() {
        return NaN;
      }
      createNaNNeg() {
        return NaN;
      }
      createUtf8String(raw, len) {
        return raw.join("");
      }
      createUtf8StringFromHeap(start, end) {
        if (start === end) {
          return "";
        }
        return this._buffer.toString("utf8", start, end);
      }
      createSimpleUnassigned(val) {
        return new Simple(val);
      }
      // -- Interface for decoder.asm.js
      pushInt(val) {
        this._push(this.createInt(val));
      }
      pushInt32(f, g) {
        this._push(this.createInt32(f, g));
      }
      pushInt64(f1, f2, g1, g2) {
        this._push(this.createInt64(f1, f2, g1, g2));
      }
      pushFloat(val) {
        this._push(this.createFloat(val));
      }
      pushFloatSingle(a, b, c2, d) {
        this._push(this.createFloatSingle(a, b, c2, d));
      }
      pushFloatDouble(a, b, c2, d, e2, f, g, h) {
        this._push(this.createFloatDouble(a, b, c2, d, e2, f, g, h));
      }
      pushInt32Neg(f, g) {
        this._push(this.createInt32Neg(f, g));
      }
      pushInt64Neg(f1, f2, g1, g2) {
        this._push(this.createInt64Neg(f1, f2, g1, g2));
      }
      pushTrue() {
        this._push(this.createTrue());
      }
      pushFalse() {
        this._push(this.createFalse());
      }
      pushNull() {
        this._push(this.createNull());
      }
      pushUndefined() {
        this._push(this.createUndefined());
      }
      pushInfinity() {
        this._push(this.createInfinity());
      }
      pushInfinityNeg() {
        this._push(this.createInfinityNeg());
      }
      pushNaN() {
        this._push(this.createNaN());
      }
      pushNaNNeg() {
        this._push(this.createNaNNeg());
      }
      pushArrayStart() {
        this._createParent([], c.PARENT.ARRAY, -1);
      }
      pushArrayStartFixed(len) {
        this._createArrayStartFixed(len);
      }
      pushArrayStartFixed32(len1, len2) {
        const len = utils.buildInt32(len1, len2);
        this._createArrayStartFixed(len);
      }
      pushArrayStartFixed64(len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4);
        this._createArrayStartFixed(len);
      }
      pushObjectStart() {
        this._createObjectStartFixed(-1);
      }
      pushObjectStartFixed(len) {
        this._createObjectStartFixed(len);
      }
      pushObjectStartFixed32(len1, len2) {
        const len = utils.buildInt32(len1, len2);
        this._createObjectStartFixed(len);
      }
      pushObjectStartFixed64(len1, len2, len3, len4) {
        const len = utils.buildInt64(len1, len2, len3, len4);
        this._createObjectStartFixed(len);
      }
      pushByteStringStart() {
        this._parents[this._depth] = {
          type: c.PARENT.BYTE_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        };
      }
      pushByteString(start, end) {
        this._push(this.createByteStringFromHeap(start, end));
      }
      pushUtf8StringStart() {
        this._parents[this._depth] = {
          type: c.PARENT.UTF8_STRING,
          length: -1,
          ref: [],
          values: 0,
          tmpKey: null
        };
      }
      pushUtf8String(start, end) {
        this._push(this.createUtf8StringFromHeap(start, end));
      }
      pushSimpleUnassigned(val) {
        this._push(this.createSimpleUnassigned(val));
      }
      pushTagStart(tag) {
        this._parents[this._depth] = {
          type: c.PARENT.TAG,
          length: 1,
          ref: [tag]
        };
      }
      pushTagStart4(f, g) {
        this.pushTagStart(utils.buildInt32(f, g));
      }
      pushTagStart8(f1, f2, g1, g2) {
        this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
      }
      pushTagUnassigned(tagNumber) {
        this._push(this.createTag(tagNumber));
      }
      pushBreak() {
        if (this._currentParent.length > -1) {
          throw new Error("Unexpected break");
        }
        this._closeParent();
      }
      _createObjectStartFixed(len) {
        if (len === 0) {
          this._push(this.createObject({}));
          return;
        }
        this._createParent({}, c.PARENT.OBJECT, len);
      }
      _createArrayStartFixed(len) {
        if (len === 0) {
          this._push(this.createArray([]));
          return;
        }
        this._createParent(new Array(len), c.PARENT.ARRAY, len);
      }
      _decode(input) {
        if (input.byteLength === 0) {
          throw new Error("Input too short");
        }
        this._reset();
        this._heap8.set(input);
        const code = this.parser.parse(input.byteLength);
        if (this._depth > 1) {
          while (this._currentParent.length === 0) {
            this._closeParent();
          }
          if (this._depth > 1) {
            throw new Error("Undeterminated nesting");
          }
        }
        if (code > 0) {
          throw new Error("Failed to parse");
        }
        if (this._res.length === 0) {
          throw new Error("No valid result");
        }
      }
      // -- Public Interface
      decodeFirst(input) {
        this._decode(input);
        return this._res[0];
      }
      decodeAll(input) {
        this._decode(input);
        return this._res;
      }
      /**
       * Decode the first cbor object.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {*}
       */
      static decode(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new _Decoder({ size: input.length });
        return dec.decodeFirst(input);
      }
      /**
       * Decode all cbor objects.
       *
       * @param {Buffer|string} input
       * @param {string} [enc='hex'] - Encoding used if a string is passed.
       * @returns {Array<*>}
       */
      static decodeAll(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new _Decoder({ size: input.length });
        return dec.decodeAll(input);
      }
    };
    Decoder.decodeFirst = Decoder.decode;
    module.exports = Decoder;
  }
});

// node_modules/borc/src/diagnose.js
var require_diagnose = __commonJS({
  "node_modules/borc/src/diagnose.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { Buffer: Buffer2 } = (init_dist(), __toCommonJS(dist_exports));
    var Decoder = require_decoder();
    var utils = require_utils();
    var Diagnose = class _Diagnose extends Decoder {
      createTag(tagNumber, value) {
        return `${tagNumber}(${value})`;
      }
      createInt(val) {
        return super.createInt(val).toString();
      }
      createInt32(f, g) {
        return super.createInt32(f, g).toString();
      }
      createInt64(f1, f2, g1, g2) {
        return super.createInt64(f1, f2, g1, g2).toString();
      }
      createInt32Neg(f, g) {
        return super.createInt32Neg(f, g).toString();
      }
      createInt64Neg(f1, f2, g1, g2) {
        return super.createInt64Neg(f1, f2, g1, g2).toString();
      }
      createTrue() {
        return "true";
      }
      createFalse() {
        return "false";
      }
      createFloat(val) {
        const fl = super.createFloat(val);
        if (utils.isNegativeZero(val)) {
          return "-0_1";
        }
        return `${fl}_1`;
      }
      createFloatSingle(a, b, c, d) {
        const fl = super.createFloatSingle(a, b, c, d);
        return `${fl}_2`;
      }
      createFloatDouble(a, b, c, d, e2, f, g, h) {
        const fl = super.createFloatDouble(a, b, c, d, e2, f, g, h);
        return `${fl}_3`;
      }
      createByteString(raw, len) {
        const val = raw.join(", ");
        if (len === -1) {
          return `(_ ${val})`;
        }
        return `h'${val}`;
      }
      createByteStringFromHeap(start, end) {
        const val = Buffer2.from(
          super.createByteStringFromHeap(start, end)
        ).toString("hex");
        return `h'${val}'`;
      }
      createInfinity() {
        return "Infinity_1";
      }
      createInfinityNeg() {
        return "-Infinity_1";
      }
      createNaN() {
        return "NaN_1";
      }
      createNaNNeg() {
        return "-NaN_1";
      }
      createNull() {
        return "null";
      }
      createUndefined() {
        return "undefined";
      }
      createSimpleUnassigned(val) {
        return `simple(${val})`;
      }
      createArray(arr, len) {
        const val = super.createArray(arr, len);
        if (len === -1) {
          return `[_ ${val.join(", ")}]`;
        }
        return `[${val.join(", ")}]`;
      }
      createMap(map, len) {
        const val = super.createMap(map);
        const list = Array.from(val.keys()).reduce(collectObject(val), "");
        if (len === -1) {
          return `{_ ${list}}`;
        }
        return `{${list}}`;
      }
      createObject(obj, len) {
        const val = super.createObject(obj);
        const map = Object.keys(val).reduce(collectObject(val), "");
        if (len === -1) {
          return `{_ ${map}}`;
        }
        return `{${map}}`;
      }
      createUtf8String(raw, len) {
        const val = raw.join(", ");
        if (len === -1) {
          return `(_ ${val})`;
        }
        return `"${val}"`;
      }
      createUtf8StringFromHeap(start, end) {
        const val = Buffer2.from(
          super.createUtf8StringFromHeap(start, end)
        ).toString("utf8");
        return `"${val}"`;
      }
      static diagnose(input, enc) {
        if (typeof input === "string") {
          input = Buffer2.from(input, enc || "hex");
        }
        const dec = new _Diagnose();
        return dec.decodeFirst(input);
      }
    };
    module.exports = Diagnose;
    function collectObject(val) {
      return (acc, key) => {
        if (acc) {
          return `${acc}, ${key}: ${val[key]}`;
        }
        return `${key}: ${val[key]}`;
      };
    }
  }
});

// node_modules/borc/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/borc/src/encoder.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { Buffer: Buffer2 } = (init_dist(), __toCommonJS(dist_exports));
    var { URL } = require_iso_url();
    var Bignumber = require_bignumber().BigNumber;
    var utils = require_utils();
    var constants = require_constants();
    var MT = constants.MT;
    var NUMBYTES = constants.NUMBYTES;
    var SHIFT32 = constants.SHIFT32;
    var SYMS = constants.SYMS;
    var TAG = constants.TAG;
    var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
    var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
    var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
    var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
    var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
    var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
    var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
    var MAXINT_BN = new Bignumber("0x20000000000000");
    var BUF_NAN = Buffer2.from("f97e00", "hex");
    var BUF_INF_NEG = Buffer2.from("f9fc00", "hex");
    var BUF_INF_POS = Buffer2.from("f97c00", "hex");
    function toType(obj) {
      return {}.toString.call(obj).slice(8, -1);
    }
    var Encoder = class _Encoder {
      /**
       * @param {Object} [options={}]
       * @param {function(Buffer)} options.stream
       */
      constructor(options) {
        options = options || {};
        this.streaming = typeof options.stream === "function";
        this.onData = options.stream;
        this.semanticTypes = [
          [URL, this._pushUrl],
          [Bignumber, this._pushBigNumber]
        ];
        const addTypes = options.genTypes || [];
        const len = addTypes.length;
        for (let i2 = 0; i2 < len; i2++) {
          this.addSemanticType(
            addTypes[i2][0],
            addTypes[i2][1]
          );
        }
        this._reset();
      }
      addSemanticType(type, fun) {
        const len = this.semanticTypes.length;
        for (let i2 = 0; i2 < len; i2++) {
          const typ = this.semanticTypes[i2][0];
          if (typ === type) {
            const old = this.semanticTypes[i2][1];
            this.semanticTypes[i2][1] = fun;
            return old;
          }
        }
        this.semanticTypes.push([type, fun]);
        return null;
      }
      push(val) {
        if (!val) {
          return true;
        }
        this.result[this.offset] = val;
        this.resultMethod[this.offset] = 0;
        this.resultLength[this.offset] = val.length;
        this.offset++;
        if (this.streaming) {
          this.onData(this.finalize());
        }
        return true;
      }
      pushWrite(val, method, len) {
        this.result[this.offset] = val;
        this.resultMethod[this.offset] = method;
        this.resultLength[this.offset] = len;
        this.offset++;
        if (this.streaming) {
          this.onData(this.finalize());
        }
        return true;
      }
      _pushUInt8(val) {
        return this.pushWrite(val, 1, 1);
      }
      _pushUInt16BE(val) {
        return this.pushWrite(val, 2, 2);
      }
      _pushUInt32BE(val) {
        return this.pushWrite(val, 3, 4);
      }
      _pushDoubleBE(val) {
        return this.pushWrite(val, 4, 8);
      }
      _pushNaN() {
        return this.push(BUF_NAN);
      }
      _pushInfinity(obj) {
        const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
        return this.push(half);
      }
      _pushFloat(obj) {
        const b2 = Buffer2.allocUnsafe(2);
        if (utils.writeHalf(b2, obj)) {
          if (utils.parseHalf(b2) === obj) {
            return this._pushUInt8(HALF) && this.push(b2);
          }
        }
        const b4 = Buffer2.allocUnsafe(4);
        b4.writeFloatBE(obj, 0);
        if (b4.readFloatBE(0) === obj) {
          return this._pushUInt8(FLOAT) && this.push(b4);
        }
        return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
      }
      _pushInt(obj, mt, orig) {
        const m = mt << 5;
        if (obj < 24) {
          return this._pushUInt8(m | obj);
        }
        if (obj <= 255) {
          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
        }
        if (obj <= 65535) {
          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
        }
        if (obj <= 4294967295) {
          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
        }
        if (obj <= Number.MAX_SAFE_INTEGER) {
          return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
        }
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig);
        }
        return this._pushFloat(obj);
      }
      _pushIntNum(obj) {
        if (obj < 0) {
          return this._pushInt(-obj - 1, MT.NEG_INT, obj);
        } else {
          return this._pushInt(obj, MT.POS_INT);
        }
      }
      _pushNumber(obj) {
        switch (false) {
          case obj === obj:
            return this._pushNaN(obj);
          case isFinite(obj):
            return this._pushInfinity(obj);
          case obj % 1 !== 0:
            return this._pushIntNum(obj);
          default:
            return this._pushFloat(obj);
        }
      }
      _pushString(obj) {
        const len = Buffer2.byteLength(obj, "utf8");
        return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
      }
      _pushBoolean(obj) {
        return this._pushUInt8(obj ? TRUE : FALSE);
      }
      _pushUndefined(obj) {
        return this._pushUInt8(UNDEFINED);
      }
      _pushArray(gen, obj) {
        const len = obj.length;
        if (!gen._pushInt(len, MT.ARRAY)) {
          return false;
        }
        for (let j = 0; j < len; j++) {
          if (!gen.pushAny(obj[j])) {
            return false;
          }
        }
        return true;
      }
      _pushTag(tag) {
        return this._pushInt(tag, MT.TAG);
      }
      _pushDate(gen, obj) {
        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
      }
      _pushBuffer(gen, obj) {
        return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
      }
      _pushNoFilter(gen, obj) {
        return gen._pushBuffer(gen, obj.slice());
      }
      _pushRegexp(gen, obj) {
        return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
      }
      _pushSet(gen, obj) {
        if (!gen._pushInt(obj.size, MT.ARRAY)) {
          return false;
        }
        for (const x of obj) {
          if (!gen.pushAny(x)) {
            return false;
          }
        }
        return true;
      }
      _pushUrl(gen, obj) {
        return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
      }
      _pushBigint(obj) {
        let tag = TAG.POS_BIGINT;
        if (obj.isNegative()) {
          obj = obj.negated().minus(1);
          tag = TAG.NEG_BIGINT;
        }
        let str = obj.toString(16);
        if (str.length % 2) {
          str = "0" + str;
        }
        const buf = Buffer2.from(str, "hex");
        return this._pushTag(tag) && this._pushBuffer(this, buf);
      }
      _pushBigNumber(gen, obj) {
        if (obj.isNaN()) {
          return gen._pushNaN();
        }
        if (!obj.isFinite()) {
          return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
        }
        if (obj.isInteger()) {
          return gen._pushBigint(obj);
        }
        if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
          return false;
        }
        const dec = obj.decimalPlaces();
        const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
        if (!gen._pushIntNum(-dec)) {
          return false;
        }
        if (slide.abs().isLessThan(MAXINT_BN)) {
          return gen._pushIntNum(slide.toNumber());
        } else {
          return gen._pushBigint(slide);
        }
      }
      _pushMap(gen, obj) {
        if (!gen._pushInt(obj.size, MT.MAP)) {
          return false;
        }
        return this._pushRawMap(
          obj.size,
          Array.from(obj)
        );
      }
      _pushObject(obj) {
        if (!obj) {
          return this._pushUInt8(NULL);
        }
        var len = this.semanticTypes.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (obj instanceof this.semanticTypes[i2][0]) {
            return this.semanticTypes[i2][1].call(obj, this, obj);
          }
        }
        var f = obj.encodeCBOR;
        if (typeof f === "function") {
          return f.call(obj, this);
        }
        var keys = Object.keys(obj);
        var keyLength = keys.length;
        if (!this._pushInt(keyLength, MT.MAP)) {
          return false;
        }
        return this._pushRawMap(
          keyLength,
          keys.map((k) => [k, obj[k]])
        );
      }
      _pushRawMap(len, map) {
        map = map.map(function(a) {
          a[0] = _Encoder.encode(a[0]);
          return a;
        }).sort(utils.keySorter);
        for (var j = 0; j < len; j++) {
          if (!this.push(map[j][0])) {
            return false;
          }
          if (!this.pushAny(map[j][1])) {
            return false;
          }
        }
        return true;
      }
      /**
       * Alias for `.pushAny`
       *
       * @param {*} obj
       * @returns {boolean} true on success
       */
      write(obj) {
        return this.pushAny(obj);
      }
      /**
       * Push any supported type onto the encoded stream
       *
       * @param {any} obj
       * @returns {boolean} true on success
       */
      pushAny(obj) {
        var typ = toType(obj);
        switch (typ) {
          case "Number":
            return this._pushNumber(obj);
          case "String":
            return this._pushString(obj);
          case "Boolean":
            return this._pushBoolean(obj);
          case "Object":
            return this._pushObject(obj);
          case "Array":
            return this._pushArray(this, obj);
          case "Uint8Array":
            return this._pushBuffer(this, Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj));
          case "Null":
            return this._pushUInt8(NULL);
          case "Undefined":
            return this._pushUndefined(obj);
          case "Map":
            return this._pushMap(this, obj);
          case "Set":
            return this._pushSet(this, obj);
          case "URL":
            return this._pushUrl(this, obj);
          case "BigNumber":
            return this._pushBigNumber(this, obj);
          case "Date":
            return this._pushDate(this, obj);
          case "RegExp":
            return this._pushRegexp(this, obj);
          case "Symbol":
            switch (obj) {
              case SYMS.NULL:
                return this._pushObject(null);
              case SYMS.UNDEFINED:
                return this._pushUndefined(void 0);
              default:
                throw new Error("Unknown symbol: " + obj.toString());
            }
          default:
            throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
        }
      }
      finalize() {
        if (this.offset === 0) {
          return null;
        }
        var result = this.result;
        var resultLength = this.resultLength;
        var resultMethod = this.resultMethod;
        var offset = this.offset;
        var size = 0;
        var i2 = 0;
        for (; i2 < offset; i2++) {
          size += resultLength[i2];
        }
        var res = Buffer2.allocUnsafe(size);
        var index = 0;
        var length = 0;
        for (i2 = 0; i2 < offset; i2++) {
          length = resultLength[i2];
          switch (resultMethod[i2]) {
            case 0:
              result[i2].copy(res, index);
              break;
            case 1:
              res.writeUInt8(result[i2], index, true);
              break;
            case 2:
              res.writeUInt16BE(result[i2], index, true);
              break;
            case 3:
              res.writeUInt32BE(result[i2], index, true);
              break;
            case 4:
              res.writeDoubleBE(result[i2], index, true);
              break;
            case 5:
              res.write(result[i2], index, length, "utf8");
              break;
            default:
              throw new Error("unkown method");
          }
          index += length;
        }
        var tmp = res;
        this._reset();
        return tmp;
      }
      _reset() {
        this.result = [];
        this.resultMethod = [];
        this.resultLength = [];
        this.offset = 0;
      }
      /**
       * Encode the given value
       * @param {*} o
       * @returns {Buffer}
       */
      static encode(o2) {
        const enc = new _Encoder();
        const ret = enc.pushAny(o2);
        if (!ret) {
          throw new Error("Failed to encode input");
        }
        return enc.finalize();
      }
    };
    module.exports = Encoder;
  }
});

// node_modules/borc/src/index.js
var require_src5 = __commonJS({
  "node_modules/borc/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    exports.Diagnose = require_diagnose();
    exports.Decoder = require_decoder();
    exports.Encoder = require_encoder();
    exports.Simple = require_simple();
    exports.Tagged = require_tagged();
    exports.decodeAll = exports.Decoder.decodeAll;
    exports.decodeFirst = exports.Decoder.decodeFirst;
    exports.diagnose = exports.Diagnose.diagnose;
    exports.encode = exports.Encoder.encode;
    exports.decode = exports.Decoder.decode;
    exports.leveldb = {
      decode: exports.Decoder.decodeAll,
      encode: exports.Encoder.encode,
      buffer: true,
      name: "cbor"
    };
  }
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes) {
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
          return false;
        }
        for (var i2 = 0; i2 < bytes.length; i2++) {
          if (!Number.isInteger(bytes[i2]) || bytes[i2] < 0 || bytes[i2] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n2) {
        return (m & 65535) * n2 + (((m >>> 16) * n2 & 65535) << 16);
      }
      function _x86Rotl(m, n2) {
        return m << n2 | m >>> 32 - n2;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n2) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
        var o2 = [0, 0, 0, 0];
        o2[3] += m[3] + n2[3];
        o2[2] += o2[3] >>> 16;
        o2[3] &= 65535;
        o2[2] += m[2] + n2[2];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[1] += m[1] + n2[1];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[0] += m[0] + n2[0];
        o2[0] &= 65535;
        return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
      }
      function _x64Multiply(m, n2) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n2 = [n2[0] >>> 16, n2[0] & 65535, n2[1] >>> 16, n2[1] & 65535];
        var o2 = [0, 0, 0, 0];
        o2[3] += m[3] * n2[3];
        o2[2] += o2[3] >>> 16;
        o2[3] &= 65535;
        o2[2] += m[2] * n2[3];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[2] += m[3] * n2[2];
        o2[1] += o2[2] >>> 16;
        o2[2] &= 65535;
        o2[1] += m[1] * n2[3];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[1] += m[2] * n2[2];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[1] += m[3] * n2[1];
        o2[0] += o2[1] >>> 16;
        o2[1] &= 65535;
        o2[0] += m[0] * n2[3] + m[1] * n2[2] + m[2] * n2[1] + m[3] * n2[0];
        o2[0] &= 65535;
        return [o2[0] << 16 | o2[1], o2[2] << 16 | o2[3]];
      }
      function _x64Rotl(m, n2) {
        n2 %= 64;
        if (n2 === 32) {
          return [m[1], m[0]];
        } else if (n2 < 32) {
          return [m[0] << n2 | m[1] >>> 32 - n2, m[1] << n2 | m[0] >>> 32 - n2];
        } else {
          n2 -= 32;
          return [m[1] << n2 | m[0] >>> 32 - n2, m[0] << n2 | m[1] >>> 32 - n2];
        }
      }
      function _x64LeftShift(m, n2) {
        n2 %= 64;
        if (n2 === 0) {
          return m;
        } else if (n2 < 32) {
          return [m[0] << n2 | m[1] >>> 32 - n2, m[1] << n2];
        } else {
          return [m[1] << n2 - 32, 0];
        }
      }
      function _x64Xor(m, n2) {
        return [m[0] ^ n2[0], m[1] ^ n2[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 4) {
          k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes[i2 + 2] << 16;
          case 2:
            k1 ^= bytes[i2 + 1] << 8;
          case 1:
            k1 ^= bytes[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24;
          k2 = bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24;
          k3 = bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24;
          k4 = bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes[i2 + 14] << 16;
          case 14:
            k4 ^= bytes[i2 + 13] << 8;
          case 13:
            k4 ^= bytes[i2 + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes[i2 + 11] << 24;
          case 11:
            k3 ^= bytes[i2 + 10] << 16;
          case 10:
            k3 ^= bytes[i2 + 9] << 8;
          case 9:
            k3 ^= bytes[i2 + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes[i2 + 7] << 24;
          case 7:
            k2 ^= bytes[i2 + 6] << 16;
          case 6:
            k2 ^= bytes[i2 + 5] << 8;
          case 5:
            k2 ^= bytes[i2 + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes[i2 + 3] << 24;
          case 3:
            k1 ^= bytes[i2 + 2] << 16;
          case 2:
            k1 ^= bytes[i2 + 1] << 8;
          case 1:
            k1 ^= bytes[i2];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes, seed) {
        if (library.inputValidation && !_validBytes(bytes)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i2 = 0; i2 < blocks; i2 = i2 + 16) {
          k1 = [bytes[i2 + 4] | bytes[i2 + 5] << 8 | bytes[i2 + 6] << 16 | bytes[i2 + 7] << 24, bytes[i2] | bytes[i2 + 1] << 8 | bytes[i2 + 2] << 16 | bytes[i2 + 3] << 24];
          k2 = [bytes[i2 + 12] | bytes[i2 + 13] << 8 | bytes[i2 + 14] << 16 | bytes[i2 + 15] << 24, bytes[i2 + 8] | bytes[i2 + 9] << 8 | bytes[i2 + 10] << 16 | bytes[i2 + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i2 + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes[i2 + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i2 + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes[i2]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes.length]);
        h2 = _x64Xor(h2, [0, bytes.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library;
        }
        exports.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports);
  }
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = require_murmurHash3js();
  }
});

// node_modules/multihashing-async/src/sha.browser.js
var require_sha_browser = __commonJS({
  "node_modules/multihashing-async/src/sha.browser.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var multihash = require_src2();
    var crypto = self.crypto || /** @type {typeof window.crypto} */
    // @ts-ignore - unknown property
    self.msCrypto;
    var digest = async (data, alg) => {
      if (typeof self === "undefined" || !crypto) {
        throw new Error(
          "Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context"
        );
      }
      switch (alg) {
        case "sha1":
          return new Uint8Array(await crypto.subtle.digest({ name: "SHA-1" }, data));
        case "sha2-256":
          return new Uint8Array(await crypto.subtle.digest({ name: "SHA-256" }, data));
        case "sha2-512":
          return new Uint8Array(await crypto.subtle.digest({ name: "SHA-512" }, data));
        case "dbl-sha2-256": {
          const d = await crypto.subtle.digest({ name: "SHA-256" }, data);
          return new Uint8Array(await crypto.subtle.digest({ name: "SHA-256" }, d));
        }
        default:
          throw new Error(`${alg} is not a supported algorithm`);
      }
    };
    module.exports = {
      /**
       * @param {HashName} alg
       * @returns {Digest}
       */
      factory: (alg) => async (data) => {
        return digest(data, alg);
      },
      digest,
      /**
       * @param {Uint8Array} buf
       * @param {HashName} alg
       * @param {number} [length]
       */
      multihashing: async (buf, alg, length) => {
        const h = await digest(buf, alg);
        return multihash.encode(h, alg, length);
      }
    };
  }
});

// node_modules/multihashing-async/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/multihashing-async/src/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var fromNumberTo32BitBuf = (number) => {
      const bytes = new Uint8Array(4);
      for (let i2 = 0; i2 < 4; i2++) {
        bytes[i2] = number & 255;
        number = number >> 8;
      }
      return bytes;
    };
    module.exports = {
      fromNumberTo32BitBuf
    };
  }
});

// node_modules/blakejs/util.js
var require_util2 = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex(bytes) {
      return Array.prototype.map.call(bytes, function(n2) {
        return (n2 < 16 ? "0" : "") + n2.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i2 = 0; i2 < arr.length; i2 += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i2]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i2 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i2]).toUpperCase();
        } else throw new Error("Invalid size " + size);
        if (i2 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i2 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N, M) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N);
      for (let i2 = 0; i2 < N; i2++) {
        input[i2] = i2 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i2 = 0; i2 < M; i2++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var util = require_util2();
    function ADD64AA(v2, a, b) {
      const o0 = v2[a] + v2[b];
      let o1 = v2[a + 1] + v2[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function ADD64AC(v2, a, b0, b1) {
      let o0 = v2[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v2[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function B2B_GET32(arr, i2) {
      return arr[i2] ^ arr[i2 + 1] << 8 ^ arr[i2 + 2] << 16 ^ arr[i2 + 3] << 24;
    }
    function B2B_G(a, b, c, d, ix, iy) {
      const x0 = m[ix];
      const x1 = m[ix + 1];
      const y0 = m[iy];
      const y1 = m[iy + 1];
      ADD64AA(v, a, b);
      ADD64AC(v, a, x0, x1);
      let xor0 = v[d] ^ v[a];
      let xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor1;
      v[d + 1] = xor0;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor0 >>> 24 ^ xor1 << 8;
      v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      xor0 = v[d] ^ v[a];
      xor1 = v[d + 1] ^ v[a + 1];
      v[d] = xor0 >>> 16 ^ xor1 << 16;
      v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c, d);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor1 >>> 31 ^ xor0 << 1;
      v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x) {
        return x * 2;
      })
    );
    var v = new Uint32Array(32);
    var m = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 16; i2++) {
        v[i2] = ctx.h[i2];
        v[i2 + 16] = BLAKE2B_IV32[i2];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i2 = 0; i2 < 32; i2++) {
        m[i2] = B2B_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 12; i2++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i2 * 16 + 0], SIGMA82[i2 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i2 * 16 + 2], SIGMA82[i2 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i2 * 16 + 4], SIGMA82[i2 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i2 * 16 + 6], SIGMA82[i2 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i2 * 16 + 8], SIGMA82[i2 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i2 * 16 + 10], SIGMA82[i2 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i2 * 16 + 12], SIGMA82[i2 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i2 * 16 + 14], SIGMA82[i2 * 16 + 15]);
      }
      for (i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = ctx.h[i2] ^ v[i2] ^ v[i2 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i2 = 0; i2 < 16; i2++) {
        ctx.h[i2] = BLAKE2B_IV32[i2] ^ B2B_GET32(parameterBlock, i2 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var util = require_util2();
    function B2S_GET32(v2, i2) {
      return v2[i2] ^ v2[i2 + 1] << 8 ^ v2[i2 + 2] << 16 ^ v2[i2 + 3] << 24;
    }
    function B2S_G(a, b, c, d, x, y) {
      v[a] = v[a] + v[b] + x;
      v[d] = ROTR32(v[d] ^ v[a], 16);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 12);
      v[a] = v[a] + v[b] + y;
      v[d] = ROTR32(v[d] ^ v[a], 8);
      v[c] = v[c] + v[d];
      v[b] = ROTR32(v[b] ^ v[c], 7);
    }
    function ROTR32(x, y) {
      return x >>> y ^ x << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v = new Uint32Array(16);
    var m = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i2 = 0;
      for (i2 = 0; i2 < 8; i2++) {
        v[i2] = ctx.h[i2];
        v[i2 + 8] = BLAKE2S_IV[i2];
      }
      v[12] ^= ctx.t;
      v[13] ^= ctx.t / 4294967296;
      if (last) {
        v[14] = ~v[14];
      }
      for (i2 = 0; i2 < 16; i2++) {
        m[i2] = B2S_GET32(ctx.b, 4 * i2);
      }
      for (i2 = 0; i2 < 10; i2++) {
        B2S_G(0, 4, 8, 12, m[SIGMA[i2 * 16 + 0]], m[SIGMA[i2 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i2 * 16 + 2]], m[SIGMA[i2 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i2 * 16 + 4]], m[SIGMA[i2 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i2 * 16 + 6]], m[SIGMA[i2 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i2 * 16 + 8]], m[SIGMA[i2 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i2 * 16 + 10]], m[SIGMA[i2 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i2 * 16 + 12]], m[SIGMA[i2 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i2 * 16 + 14]], m[SIGMA[i2 * 16 + 15]]);
      }
      for (i2 = 0; i2 < 8; i2++) {
        ctx.h[i2] ^= v[i2] ^ v[i2 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i2 = 0; i2 < input.length; i2++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i2];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i2 = 0; i2 < ctx.outlen; i2++) {
        out[i2] = ctx.h[i2 >> 2] >> 8 * (i2 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/multihashing-async/src/blake.js
var require_blake = __commonJS({
  "node_modules/multihashing-async/src/blake.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var blake = require_blakejs();
    var minB = 45569;
    var minS = 45633;
    var blake2b = {
      init: blake.blake2bInit,
      update: blake.blake2bUpdate,
      digest: blake.blake2bFinal
    };
    var blake2s = {
      init: blake.blake2sInit,
      update: blake.blake2sUpdate,
      digest: blake.blake2sFinal
    };
    var makeB2Hash = (size, hf) => async (data) => {
      const ctx = hf.init(size, null);
      hf.update(ctx, data);
      return hf.digest(ctx);
    };
    module.exports = (table) => {
      for (let i2 = 0; i2 < 64; i2++) {
        table[minB + i2] = makeB2Hash(i2 + 1, blake2b);
      }
      for (let i2 = 0; i2 < 32; i2++) {
        table[minS + i2] = makeB2Hash(i2 + 1, blake2s);
      }
    };
  }
});

// node_modules/multihashing-async/src/crypto.js
var require_crypto = __commonJS({
  "node_modules/multihashing-async/src/crypto.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var sha3 = require_sha3();
    var mur = require_murmurhash3js_revisited();
    var { factory: sha } = require_sha_browser();
    var { fromNumberTo32BitBuf } = require_utils2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var hash = (algorithm) => async (data) => {
      switch (algorithm) {
        case "sha3-224":
          return new Uint8Array(sha3.sha3_224.arrayBuffer(data));
        case "sha3-256":
          return new Uint8Array(sha3.sha3_256.arrayBuffer(data));
        case "sha3-384":
          return new Uint8Array(sha3.sha3_384.arrayBuffer(data));
        case "sha3-512":
          return new Uint8Array(sha3.sha3_512.arrayBuffer(data));
        case "shake-128":
          return new Uint8Array(sha3.shake128.create(128).update(data).arrayBuffer());
        case "shake-256":
          return new Uint8Array(sha3.shake256.create(256).update(data).arrayBuffer());
        case "keccak-224":
          return new Uint8Array(sha3.keccak224.arrayBuffer(data));
        case "keccak-256":
          return new Uint8Array(sha3.keccak256.arrayBuffer(data));
        case "keccak-384":
          return new Uint8Array(sha3.keccak384.arrayBuffer(data));
        case "keccak-512":
          return new Uint8Array(sha3.keccak512.arrayBuffer(data));
        case "murmur3-128":
          return uint8ArrayFromString(mur.x64.hash128(data), "base16");
        case "murmur3-32":
          return fromNumberTo32BitBuf(mur.x86.hash32(data));
        default:
          throw new TypeError(`${algorithm} is not a supported algorithm`);
      }
    };
    var identity = (data) => data;
    module.exports = {
      identity,
      sha1: sha("sha1"),
      sha2256: sha("sha2-256"),
      sha2512: sha("sha2-512"),
      dblSha2256: sha("dbl-sha2-256"),
      sha3224: hash("sha3-224"),
      sha3256: hash("sha3-256"),
      sha3384: hash("sha3-384"),
      sha3512: hash("sha3-512"),
      shake128: hash("shake-128"),
      shake256: hash("shake-256"),
      keccak224: hash("keccak-224"),
      keccak256: hash("keccak-256"),
      keccak384: hash("keccak-384"),
      keccak512: hash("keccak-512"),
      murmur3128: hash("murmur3-128"),
      murmur332: hash("murmur3-32"),
      addBlake: require_blake()
    };
  }
});

// node_modules/multihashing-async/src/index.js
var require_src6 = __commonJS({
  "node_modules/multihashing-async/src/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var errcode = require_err_code();
    var multihash = require_src2();
    var crypto = require_crypto();
    var { equals } = (init_equals(), __toCommonJS(equals_exports));
    async function Multihashing(bytes, alg, length) {
      const digest = await Multihashing.digest(bytes, alg, length);
      return multihash.encode(digest, alg, length);
    }
    Multihashing.multihash = multihash;
    Multihashing.digest = async (bytes, alg, length) => {
      const hash = Multihashing.createHash(alg);
      const digest = await hash(bytes);
      return length ? digest.slice(0, length) : digest;
    };
    Multihashing.createHash = function(alg) {
      if (!alg) {
        const e2 = errcode(new Error("hash algorithm must be specified"), "ERR_HASH_ALGORITHM_NOT_SPECIFIED");
        throw e2;
      }
      const code = multihash.coerceCode(alg);
      if (!Multihashing.functions[code]) {
        throw errcode(new Error(`multihash function '${alg}' not yet supported`), "ERR_HASH_ALGORITHM_NOT_SUPPORTED");
      }
      return Multihashing.functions[code];
    };
    Multihashing.functions = {
      // identity
      0: crypto.identity,
      // sha1
      17: crypto.sha1,
      // sha2-256
      18: crypto.sha2256,
      // sha2-512
      19: crypto.sha2512,
      // sha3-512
      20: crypto.sha3512,
      // sha3-384
      21: crypto.sha3384,
      // sha3-256
      22: crypto.sha3256,
      // sha3-224
      23: crypto.sha3224,
      // shake-128
      24: crypto.shake128,
      // shake-256
      25: crypto.shake256,
      // keccak-224
      26: crypto.keccak224,
      // keccak-256
      27: crypto.keccak256,
      // keccak-384
      28: crypto.keccak384,
      // keccak-512
      29: crypto.keccak512,
      // murmur3-128
      34: crypto.murmur3128,
      // murmur3-32
      35: crypto.murmur332,
      // dbl-sha2-256
      86: crypto.dblSha2256
    };
    crypto.addBlake(Multihashing.functions);
    Multihashing.validate = async (bytes, hash) => {
      const newHash = await Multihashing(bytes, multihash.decode(hash).name);
      return equals(hash, newHash);
    };
    module.exports = Multihashing;
  }
});

// node_modules/is-circular/lib/node.js
var require_node = __commonJS({
  "node_modules/is-circular/lib/node.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = Node;
    function Node(value, next) {
      this.value = value;
      this.next = next;
    }
    Node.prototype.contains = function(value) {
      var cursor = this;
      while (cursor) {
        if (cursor.value === value) return true;
        cursor = cursor.next;
      }
      return false;
    };
  }
});

// node_modules/is-circular/index.js
var require_is_circular = __commonJS({
  "node_modules/is-circular/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Node = require_node();
    module.exports = isCircular;
    function isCircular(obj) {
      if (!(obj instanceof Object)) {
        throw new TypeError('"obj" must be an object (or inherit from it)');
      }
      return _isCircular(obj);
    }
    function _isCircular(obj, parentList) {
      parentList = new Node(obj, parentList);
      for (var key in obj) {
        var val = obj[key];
        if (val instanceof Object) {
          if (parentList.contains(val) || _isCircular(val, parentList)) {
            return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/ipld-dag-cbor/node_modules/uint8arrays/concat.js
var require_concat2 = __commonJS({
  "node_modules/ipld-dag-cbor/node_modules/uint8arrays/concat.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function concat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = concat;
  }
});

// node_modules/ipld-dag-cbor/node_modules/uint8arrays/util/bases.js
var require_bases2 = __commonJS({
  "node_modules/ipld-dag-cbor/node_modules/uint8arrays/util/bases.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { bases } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec(name, prefix, encode, decode) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode
        },
        decoder: {
          decode
        }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i2 = 0; i2 < buf.length; i2++) {
        string2 += String.fromCharCode(buf[i2]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    });
    var BASES = {
      "utf8": string,
      "utf-8": string,
      "hex": bases.base16,
      "latin1": ascii,
      "ascii": ascii,
      "binary": ascii,
      ...bases
    };
    module.exports = BASES;
  }
});

// node_modules/ipld-dag-cbor/node_modules/uint8arrays/from-string.js
var require_from_string2 = __commonJS({
  "node_modules/ipld-dag-cbor/node_modules/uint8arrays/from-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bases = require_bases2();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    module.exports = fromString;
  }
});

// node_modules/ipld-dag-cbor/src/util.js
var require_util3 = __commonJS({
  "node_modules/ipld-dag-cbor/src/util.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var cbor = require_src5();
    var multicodec = require_src3();
    var multihashing = require_src6();
    var CID = require_src4();
    var isCircular = require_is_circular();
    var uint8ArrayConcat = require_concat2();
    var uint8ArrayFromString = require_from_string2();
    var CID_CBOR_TAG = 42;
    function tagCID(cid2) {
      if (typeof cid2 === "string") {
        cid2 = new CID(cid2).bytes;
      } else if (CID.isCID(cid2)) {
        cid2 = cid2.bytes;
      }
      return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([
        uint8ArrayFromString("00", "base16"),
        // thanks jdag
        cid2
      ], 1 + cid2.length));
    }
    function replaceCIDbyTAG(dagNode) {
      let circular;
      try {
        circular = isCircular(dagNode);
      } catch (e2) {
        circular = false;
      }
      if (circular) {
        throw new Error("The object passed has circular references");
      }
      function transform(obj) {
        if (!obj || obj instanceof Uint8Array || typeof obj === "string") {
          return obj;
        }
        if (Array.isArray(obj)) {
          return obj.map(transform);
        }
        if (CID.isCID(obj)) {
          return tagCID(obj);
        }
        const keys = Object.keys(obj);
        if (keys.length > 0) {
          const out = {};
          keys.forEach((key) => {
            if (typeof obj[key] === "object") {
              out[key] = transform(obj[key]);
            } else {
              out[key] = obj[key];
            }
          });
          return out;
        } else {
          return obj;
        }
      }
      return transform(dagNode);
    }
    var codec = multicodec.DAG_CBOR;
    var defaultHashAlg = multicodec.SHA2_256;
    var defaultTags = {
      [CID_CBOR_TAG]: (val) => {
        val = val.slice(1);
        return new CID(val);
      }
    };
    var defaultSize = 64 * 1024;
    var currentSize = defaultSize;
    var defaultMaxSize = 64 * 1024 * 1024;
    var maxSize = defaultMaxSize;
    var decoder = null;
    function configureDecoder(options) {
      let tags = defaultTags;
      if (options) {
        if (typeof options.size === "number") {
          currentSize = options.size;
        }
        if (typeof options.maxSize === "number") {
          maxSize = options.maxSize;
        }
        if (options.tags) {
          tags = Object.assign({}, defaultTags, options && options.tags);
        }
      } else {
        currentSize = defaultSize;
        maxSize = defaultMaxSize;
      }
      const decoderOptions = {
        tags,
        size: currentSize
      };
      decoder = new cbor.Decoder(decoderOptions);
      currentSize = decoderOptions.size;
    }
    configureDecoder();
    function serialize(node) {
      const nodeTagged = replaceCIDbyTAG(node);
      const serialized = cbor.encode(nodeTagged);
      return serialized;
    }
    function deserialize(data) {
      if (data.length > currentSize && data.length <= maxSize) {
        configureDecoder({ size: data.length });
      }
      if (data.length > currentSize) {
        throw new Error("Data is too large to deserialize with current decoder");
      }
      const all = decoder.decodeAll(data);
      if (all.length !== 1) {
        throw new Error("Extraneous CBOR data found beyond initial top-level object");
      }
      return all[0];
    }
    async function cid(binaryBlob, userOptions) {
      const defaultOptions = { cidVersion: 1, hashAlg: defaultHashAlg };
      const options = Object.assign(defaultOptions, userOptions);
      const multihash = await multihashing(binaryBlob, options.hashAlg);
      const codecName = multicodec.getNameFromCode(codec);
      const cid2 = new CID(options.cidVersion, codecName, multihash);
      return cid2;
    }
    module.exports = {
      codec,
      defaultHashAlg,
      configureDecoder,
      serialize,
      deserialize,
      cid
    };
  }
});

// node_modules/ipld-dag-cbor/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/ipld-dag-cbor/src/resolver.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var CID = require_src4();
    var util = require_util3();
    exports.resolve = (binaryBlob, path) => {
      let node = util.deserialize(binaryBlob);
      const parts = path.split("/").filter(Boolean);
      while (parts.length) {
        const key = parts.shift();
        if (node[key] === void 0) {
          throw new Error(`Object has no property '${key}'`);
        }
        node = node[key];
        if (CID.isCID(node)) {
          return {
            value: node,
            remainderPath: parts.join("/")
          };
        }
      }
      return {
        value: node,
        remainderPath: ""
      };
    };
    var traverse = function* (node, path) {
      if (node instanceof Uint8Array || CID.isCID(node) || typeof node === "string" || node === null) {
        return;
      }
      for (const item of Object.keys(node)) {
        const nextpath = path === void 0 ? item : path + "/" + item;
        yield nextpath;
        yield* traverse(node[item], nextpath);
      }
    };
    exports.tree = function* (binaryBlob) {
      const node = util.deserialize(binaryBlob);
      yield* traverse(node);
    };
  }
});

// node_modules/ipld-dag-cbor/src/index.js
var require_src7 = __commonJS({
  "node_modules/ipld-dag-cbor/src/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    exports.util = require_util3();
    exports.resolver = require_resolver();
    exports.codec = exports.util.codec;
    exports.defaultHashAlg = exports.util.defaultHashAlg;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/compare.js
var require_compare2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/compare.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function compare(a, b) {
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] < b[i2]) {
          return -1;
        }
        if (a[i2] > b[i2]) {
          return 1;
        }
      }
      if (a.byteLength > b.byteLength) {
        return 1;
      }
      if (a.byteLength < b.byteLength) {
        return -1;
      }
      return 0;
    }
    module.exports = compare;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/concat.js
var require_concat3 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/concat.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function concat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = concat;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/equals.js
var require_equals2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/equals.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function equals(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    module.exports = equals;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/util/bases.js
var require_bases3 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/util/bases.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { bases } = (init_basics(), __toCommonJS(basics_exports));
    function createCodec(name, prefix, encode, decode) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode
        },
        decoder: {
          decode
        }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i2 = 0; i2 < buf.length; i2++) {
        string2 += String.fromCharCode(buf[i2]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = new Uint8Array(str.length);
      for (let i2 = 0; i2 < str.length; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    });
    var BASES = {
      "utf8": string,
      "utf-8": string,
      "hex": bases.base16,
      "latin1": ascii,
      "ascii": ascii,
      "binary": ascii,
      ...bases
    };
    module.exports = BASES;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/from-string.js
var require_from_string3 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/from-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bases = require_bases3();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    module.exports = fromString;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/to-string.js
var require_to_string2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/to-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var bases = require_bases3();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base.encoder.encode(array).substring(1);
    }
    module.exports = toString;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/xor.js
var require_xor2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/xor.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function xor(a, b) {
      if (a.length !== b.length) {
        throw new Error("Inputs should have the same length");
      }
      const result = new Uint8Array(a.length);
      for (let i2 = 0; i2 < a.length; i2++) {
        result[i2] = a[i2] ^ b[i2];
      }
      return result;
    }
    module.exports = xor;
  }
});

// node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/index.js
var require_uint8arrays2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/node_modules/uint8arrays/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var compare = require_compare2();
    var concat = require_concat3();
    var equals = require_equals2();
    var fromString = require_from_string3();
    var toString = require_to_string2();
    var xor = require_xor2();
    module.exports = {
      compare,
      concat,
      equals,
      fromString,
      toString,
      xor
    };
  }
});

// node_modules/dids/node_modules/dag-jose-utils/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/dids/node_modules/dag-jose-utils/lib/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeCleartext = exports.prepareCleartext = exports.decodeIdentityCID = exports.encodeIdentityCID = exports.encodePayload = void 0;
    var ipld_dag_cbor_1 = __importDefault(require_src7());
    var cids_1 = __importDefault(require_src4());
    var multihashes_1 = __importDefault(require_src2());
    var u8a = __importStar(require_uint8arrays2());
    var varint_1 = __importDefault(require_varint());
    var DAG_CBOR_CODE = 113;
    var ID_MULTIHASH = 0;
    var ENC_BLOCK_SIZE = 24;
    function encodePayload(payload) {
      return __awaiter(this, void 0, void 0, function* () {
        const block = new Uint8Array(ipld_dag_cbor_1.default.util.serialize(payload));
        return {
          cid: yield ipld_dag_cbor_1.default.util.cid(block),
          linkedBlock: block
        };
      });
    }
    exports.encodePayload = encodePayload;
    function pad(b, blockSize = ENC_BLOCK_SIZE) {
      const padLen = (blockSize - b.length % blockSize) % blockSize;
      return u8a.concat([b, new Uint8Array(padLen)]);
    }
    function unpadCIDBytes(b) {
      let offset = 0;
      let mhLen;
      for (let i2 = 0; i2 < 4; i2++) {
        mhLen = varint_1.default.decode(b, offset);
        offset += varint_1.default.decode.bytes;
      }
      return new cids_1.default(b.slice(0, offset + mhLen));
    }
    function encodeIdentityCID(obj) {
      const block = ipld_dag_cbor_1.default.util.serialize(obj);
      const idMultiHash = multihashes_1.default.encode(block, ID_MULTIHASH);
      return new cids_1.default(1, DAG_CBOR_CODE, idMultiHash);
    }
    exports.encodeIdentityCID = encodeIdentityCID;
    function decodeIdentityCID(cid) {
      cids_1.default.validateCID(cid);
      if (cid.code !== DAG_CBOR_CODE)
        throw new Error("CID codec must be dag-cbor");
      const { code, digest } = multihashes_1.default.decode(cid.multihash);
      if (code !== ID_MULTIHASH)
        throw new Error("CID must use identity multihash");
      return ipld_dag_cbor_1.default.util.deserialize(digest);
    }
    exports.decodeIdentityCID = decodeIdentityCID;
    function prepareCleartext(cleartext, blockSize) {
      return pad(encodeIdentityCID(cleartext).bytes, blockSize);
    }
    exports.prepareCleartext = prepareCleartext;
    function decodeCleartext(b) {
      return decodeIdentityCID(unpadCIDBytes(b));
    }
    exports.decodeCleartext = decodeCleartext;
  }
});

// node_modules/dids/node_modules/uint8arrays/compare.js
var require_compare3 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/compare.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function compare(a, b) {
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] < b[i2]) {
          return -1;
        }
        if (a[i2] > b[i2]) {
          return 1;
        }
      }
      if (a.byteLength > b.byteLength) {
        return 1;
      }
      if (a.byteLength < b.byteLength) {
        return -1;
      }
      return 0;
    }
    module.exports = compare;
  }
});

// node_modules/dids/node_modules/uint8arrays/concat.js
var require_concat4 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/concat.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function concat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = concat;
  }
});

// node_modules/dids/node_modules/uint8arrays/equals.js
var require_equals3 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/equals.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function equals(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a.byteLength; i2++) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    module.exports = equals;
  }
});

// node_modules/web-encoding/src/lib.js
var require_lib3 = __commonJS({
  "node_modules/web-encoding/src/lib.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    exports.TextEncoder = typeof TextEncoder !== "undefined" ? TextEncoder : require_util().TextEncoder;
    exports.TextDecoder = typeof TextDecoder !== "undefined" ? TextDecoder : require_util().TextDecoder;
  }
});

// node_modules/multibase/src/util.js
var require_util4 = __commonJS({
  "node_modules/multibase/src/util.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = require_lib3();
    var textDecoder = new TextDecoder2();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder2();
    var encodeText = (text) => textEncoder.encode(text);
    function concat(arrs, length) {
      const output = new Uint8Array(length);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module.exports = { decodeText, encodeText, concat };
  }
});

// node_modules/multibase/src/base.js
var require_base = __commonJS({
  "node_modules/multibase/src/base.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { encodeText } = require_util4();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module.exports = Base;
  }
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "node_modules/multibase/src/rfc4648.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var decode = (string, alphabet, bitsPerChar) => {
      const codes = {};
      for (let i2 = 0; i2 < alphabet.length; ++i2) {
        codes[alphabet[i2]] = i2;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i2 = 0; i2 < end; ++i2) {
        const value = codes[string[i2]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i2]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i2 = 0; i2 < data.length; ++i2) {
        buffer = buffer << 8 | data[i2];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc4648 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode(input, alphabet, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode(input, alphabet, bitsPerChar);
        }
      };
    };
    module.exports = { rfc4648 };
  }
});

// node_modules/multibase/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/multibase/src/constants.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var baseX = require_src();
    var Base = require_base();
    var { rfc4648 } = require_rfc4648();
    var { decodeText, encodeText } = require_util4();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc4648(1), "01"],
      ["base8", "7", rfc4648(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc4648(4), "0123456789abcdef"],
      ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module.exports = {
      names,
      codes
    };
  }
});

// node_modules/dids/node_modules/uint8arrays/from-string.js
var require_from_string4 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/from-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { names } = require_constants2();
    var { TextEncoder: TextEncoder2 } = require_lib3();
    var utf8Encoder = new TextEncoder2();
    function asciiStringToUint8Array(string) {
      const array = new Uint8Array(string.length);
      for (let i2 = 0; i2 < string.length; i2++) {
        array[i2] = string.charCodeAt(i2);
      }
      return array;
    }
    function fromString(string, encoding = "utf8") {
      if (encoding === "utf8" || encoding === "utf-8") {
        return utf8Encoder.encode(string);
      }
      if (encoding === "ascii") {
        return asciiStringToUint8Array(string);
      }
      const codec = names[encoding];
      if (!codec) {
        throw new Error("Unknown base");
      }
      return codec.decode(string);
    }
    module.exports = fromString;
  }
});

// node_modules/dids/node_modules/uint8arrays/to-string.js
var require_to_string3 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/to-string.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var { names } = require_constants2();
    var { TextDecoder: TextDecoder2 } = require_lib3();
    var utf8Decoder = new TextDecoder2("utf8");
    function uint8ArrayToAsciiString(array) {
      let string = "";
      for (let i2 = 0; i2 < array.length; i2++) {
        string += String.fromCharCode(array[i2]);
      }
      return string;
    }
    function toString(array, encoding = "utf8") {
      if (encoding === "utf8" || encoding === "utf-8") {
        return utf8Decoder.decode(array);
      }
      if (encoding === "ascii") {
        return uint8ArrayToAsciiString(array);
      }
      const codec = names[encoding];
      if (!codec) {
        throw new Error("Unknown base");
      }
      return codec.encode(array);
    }
    module.exports = toString;
  }
});

// node_modules/dids/node_modules/uint8arrays/index.js
var require_uint8arrays3 = __commonJS({
  "node_modules/dids/node_modules/uint8arrays/index.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      compare: require_compare3(),
      concat: require_concat4(),
      equals: require_equals3(),
      fromString: require_from_string4(),
      toString: require_to_string3()
    };
  }
});

// node_modules/dids/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/dids/lib/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o2, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o2, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromDagJWS = exports.toDagJWS = exports.base64urlToJSON = exports.decodeBase64 = exports.encodeBase64Url = exports.encodeBase64 = void 0;
    var u8a = __importStar(require_uint8arrays3());
    var B64 = "base64pad";
    var B64_URL = "base64url";
    function encodeBase64(bytes) {
      return u8a.toString(bytes, B64);
    }
    exports.encodeBase64 = encodeBase64;
    function encodeBase64Url(bytes) {
      return u8a.toString(bytes, B64_URL);
    }
    exports.encodeBase64Url = encodeBase64Url;
    function decodeBase64(s) {
      return u8a.fromString(s, B64);
    }
    exports.decodeBase64 = decodeBase64;
    function base64urlToJSON(s) {
      return JSON.parse(u8a.toString(u8a.fromString(s, B64_URL)));
    }
    exports.base64urlToJSON = base64urlToJSON;
    function toDagJWS(jws, cid) {
      const [protectedHeader, payload, signature] = jws.split(".");
      return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
        link: cid
      };
    }
    exports.toDagJWS = toDagJWS;
    function fromDagJWS(jws) {
      if (jws.signatures.length > 1)
        throw new Error("Cant convert to compact jws");
      return `${jws.signatures[0].protected}.${jws.payload}.${jws.signatures[0].signature}`;
    }
    exports.fromDagJWS = fromDagJWS;
  }
});

// node_modules/dids/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dids/lib/index.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DID = void 0;
    var did_resolver_1 = (init_resolver_esm(), __toCommonJS(resolver_esm_exports));
    var rpc_utils_1 = (init_rpc_utils_esm(), __toCommonJS(rpc_utils_esm_exports));
    var did_jwt_1 = require_lib();
    var dag_jose_utils_1 = require_lib2();
    var utils_1 = require_utils3();
    var DID = class {
      constructor({ provider, resolver = {} } = {}) {
        if (provider != null) {
          this._client = new rpc_utils_1.RPCClient(provider);
        }
        this.setResolver(resolver);
      }
      get authenticated() {
        return this._id != null;
      }
      get id() {
        if (this._id == null) {
          throw new Error("DID is not authenticated");
        }
        return this._id;
      }
      setProvider(provider) {
        if (this._client == null) {
          this._client = new rpc_utils_1.RPCClient(provider);
        } else if (this._client.connection !== provider) {
          throw new Error("A different provider is already set, create a new DID instance to use another provider");
        }
      }
      setResolver(resolver) {
        this._resolver = resolver instanceof did_resolver_1.Resolver ? resolver : new did_resolver_1.Resolver(resolver.registry, resolver.cache);
      }
      authenticate({ provider } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (provider != null) {
            this.setProvider(provider);
          }
          if (this._client == null) {
            throw new Error("No provider available");
          }
          const { did } = yield this._client.request("did_authenticate");
          this._id = did;
          return did;
        });
      }
      createJWS(payload, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._client == null)
            throw new Error("No provider available");
          if (this._id == null)
            throw new Error("DID is not authenticated");
          if (!options.did)
            options.did = this._id;
          const { jws } = yield this._client.request("did_createJWS", Object.assign(Object.assign({}, options), { payload }));
          return jws;
        });
      }
      createDagJWS(payload, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const { cid, linkedBlock } = yield dag_jose_utils_1.encodePayload(payload);
          const payloadCid = utils_1.encodeBase64Url(cid.bytes);
          Object.assign(options, { linkedBlock: utils_1.encodeBase64(linkedBlock) });
          const compactJws = yield this.createJWS(payloadCid, options);
          const jws = utils_1.toDagJWS(compactJws, cid);
          return { jws, linkedBlock };
        });
      }
      verifyJWS(jws) {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof jws !== "string")
            jws = utils_1.fromDagJWS(jws);
          const kid = utils_1.base64urlToJSON(jws.split(".")[0]).kid;
          if (!kid)
            throw new Error('No "kid" found in jws');
          const { publicKey } = yield this.resolve(kid);
          did_jwt_1.verifyJWS(jws, publicKey);
          return kid;
        });
      }
      createJWE(cleartext, recipients, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const encrypters = yield did_jwt_1.resolveX25519Encrypters(recipients, this._resolver);
          return did_jwt_1.createJWE(cleartext, encrypters, options.protectedHeader, options.aad);
        });
      }
      createDagJWE(cleartext, recipients, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.createJWE(dag_jose_utils_1.prepareCleartext(cleartext), recipients, options);
        });
      }
      decryptJWE(jwe, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._client == null)
            throw new Error("No provider available");
          if (this._id == null)
            throw new Error("DID is not authenticated");
          if (!options.did)
            options.did = this._id;
          const { cleartext } = yield this._client.request("did_decryptJWE", Object.assign(Object.assign({}, options), { jwe }));
          return utils_1.decodeBase64(cleartext);
        });
      }
      decryptDagJWE(jwe) {
        return __awaiter(this, void 0, void 0, function* () {
          const bytes = yield this.decryptJWE(jwe);
          return dag_jose_utils_1.decodeCleartext(bytes);
        });
      }
      resolve(didUrl) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this._resolver.resolve(didUrl);
        });
      }
    };
    exports.DID = DID;
  }
});
export default require_lib4();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=dids.js.map

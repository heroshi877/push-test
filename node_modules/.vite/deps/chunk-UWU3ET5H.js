import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  require_pushStreamTypes
} from "./chunk-4NZRJO6A.js";
import {
  require_Video,
  require_cjs as require_cjs2,
  require_getIncomingIndexFromAddress,
  require_getPlainAddress,
  require_mediaToggle,
  require_messageTypes,
  require_types,
  require_video
} from "./chunk-7QGEYBWR.js";
import {
  require_aes,
  require_axiosUtil,
  require_cache,
  require_cjs,
  require_commonjs_browser,
  require_config,
  require_constants,
  require_crypto,
  require_crypto_js,
  require_getGroup,
  require_getGroupMemberCount,
  require_getGroupMembers,
  require_helpers,
  require_helpers2,
  require_parseSettings,
  require_payloadHelper,
  require_payloads,
  require_progressHook,
  require_pushAPITypes,
  require_user,
  require_utils,
  require_validationError
} from "./chunk-NYB2LBDY.js";
import {
  require_axios
} from "./chunk-P4BO54TR.js";
import {
  require_constants as require_constants2
} from "./chunk-R52GSNMP.js";
import {
  require_cjs as require_cjs3
} from "./chunk-5DEZFOZQ.js";
import {
  init_lib17 as init_lib,
  lib_exports17 as lib_exports
} from "./chunk-53TYC67H.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-FOVVVYF4.js";
import {
  require_events
} from "./chunk-LPS2SYRB.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/@pushprotocol/restapi/src/lib/alias/getAliasInfo.js
var require_getAliasInfo = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/alias/getAliasInfo.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAliasInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var config_1 = require_config();
    var axiosUtil_1 = require_axiosUtil();
    var getAliasInfo = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { alias, aliasChain, env = constants_1.default.ENV.PROD } = options || {};
      const aliasChainId = config_1.ALIAS_CHAIN_ID[aliasChain][env];
      const _alias = (0, helpers_1.getCAIPWithChainId)(alias, aliasChainId, "Alias");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/alias`;
      const requestUrl = `${apiEndpoint}/${_alias}/channel`;
      return yield (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => response.data).catch((err) => {
        console.error(`[EPNS-SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getAliasInfo = getAliasInfo;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/alias/index.js
var require_alias = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/alias/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_getAliasInfo(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/_getSubscribers.js
var require_getSubscribers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/_getSubscribers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getSubscribers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var deprecationWarning = `
 [Push SDK]: _getSubscribers() Deprecation Warning!
 This method has been deprecated, please use the below alternatives
 if you need to,
  * to check if user is subscribed or not: user.getSubscriptions()
  * get channels count: channels.getChannels()
`;
    var _getSubscribers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      console.warn(deprecationWarning);
      const { channel, env = constants_1.default.ENV.PROD } = options || {};
      const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channel, "Channel");
      const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
      if (!channelCAIPDetails)
        throw Error("Invalid Channel CAIP!");
      const chainId = channelCAIPDetails.networkId;
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/channels/_get_subscribers`;
      const requestUrl = `${apiEndpoint}`;
      const body = {
        channel: channelCAIPDetails.address,
        blockchain: chainId,
        op: "read"
      };
      const response = yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
      return response.data.subscribers;
    });
    exports._getSubscribers = _getSubscribers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/getChannel.js
var require_getChannel = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/getChannel.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChannel = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var parseSettings_1 = require_parseSettings();
    var getChannel = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { channel, env = constants_1.default.ENV.PROD, raw = true } = options || {};
      const _channel = yield (0, helpers_1.getCAIPAddress)(env, channel, "Channel");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/channels`;
      const requestUrl = `${apiEndpoint}/${_channel}`;
      return yield (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        if (raw)
          return response.data;
        else {
          response.data.channel_settings = response.data.channel_settings ? (0, parseSettings_1.parseSettings)(response.data.channel_settings) : null;
          return response.data;
        }
      });
    });
    exports.getChannel = getChannel;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/getChannelNotifications.js
var require_getChannelNotifications = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/getChannelNotifications.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChannelNotifications = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var getChannelNotifications = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { channel, env = constants_1.default.ENV.PROD, page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, filter = null, raw = true } = options || {};
      const _channel = yield (0, helpers_1.getCAIPAddress)(env, channel, "Channel");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v2/channels`;
      const query = (0, helpers_1.getQueryParams)(filter ? {
        page,
        limit,
        notificationType: filter,
        raw
      } : {
        page,
        limit,
        raw
      });
      const requestUrl = `${apiEndpoint}/${_channel}/notifications?${query}`;
      return yield (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        return response.data;
      });
    });
    exports.getChannelNotifications = getChannelNotifications;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/PushNotificationTypes.js
var require_PushNotificationTypes = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/PushNotificationTypes.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChannelListOrderType = exports.ChannelListSortType = exports.ChannelListType = exports.FeedType = void 0;
    var FeedType;
    (function(FeedType2) {
      FeedType2["INBOX"] = "INBOX";
      FeedType2["SPAM"] = "SPAM";
    })(FeedType = exports.FeedType || (exports.FeedType = {}));
    var ChannelListType;
    (function(ChannelListType2) {
      ChannelListType2["ALL"] = "all";
      ChannelListType2["VERIFIED"] = "verified";
      ChannelListType2["UNVERIFIED"] = "unverified";
    })(ChannelListType = exports.ChannelListType || (exports.ChannelListType = {}));
    var ChannelListSortType;
    (function(ChannelListSortType2) {
      ChannelListSortType2["SUBSCRIBER"] = "subscribers";
    })(ChannelListSortType = exports.ChannelListSortType || (exports.ChannelListSortType = {}));
    var ChannelListOrderType;
    (function(ChannelListOrderType2) {
      ChannelListOrderType2["ASCENDING"] = "asc";
      ChannelListOrderType2["DESCENDING"] = "desc";
    })(ChannelListOrderType = exports.ChannelListOrderType || (exports.ChannelListOrderType = {}));
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/spaces.js
var require_spaces = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/spaces.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spaces = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var axiosUtil_1 = require_axiosUtil();
    var spaces = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, page = 1, limit = 10 } = options || {};
      if (!(0, helpers_1.isValidPushCAIP)(account)) {
        throw new Error(`Invalid address!`);
      }
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/spaces/users/${user}/spaces?page=${page}&limit=${limit}`;
      const requestUrl = `${apiEndpoint}`;
      try {
        const toDecrypt = false;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        const spaces2 = response.data.spaces;
        const feeds = yield (0, helpers_2.getSpaceInboxLists)({
          lists: spaces2,
          user,
          toDecrypt,
          pgpPrivateKey,
          env
        });
        return feeds;
      } catch (err) {
        console.error(`[Push SDK] - API ${exports.spaces.name}: `, err);
        throw Error(`[Push SDK] - API ${exports.spaces.name}: ${err}`);
      }
    });
    exports.spaces = spaces;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/trending.js
var require_trending = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/trending.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trending = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var axiosUtil_1 = require_axiosUtil();
    var trending = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { env = constants_1.default.ENV.PROD, page = 1, limit = 10 } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/spaces/trending?page=${page}&limit=${limit}`;
      try {
        const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
        const spaces = response.data.spaces;
        const Feeds = yield (0, helpers_2.getTrendingSpaceInboxLists)({
          lists: spaces,
          env
        });
        return Feeds;
      } catch (err) {
        console.error(`[Push SDK] - API ${exports.trending.name}: `, err);
        throw Error(`[Push SDK] - API ${exports.trending.name}: ${err}`);
      }
    });
    exports.trending = trending;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/get.js
var require_get = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/get.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var getGroup_1 = require_getGroup();
    var get = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (spaceId == null || spaceId.length == 0) {
          throw new Error(`spaceId cannot be null or empty`);
        }
        const group = yield (0, getGroup_1.getGroup)({
          chatId: spaceId,
          env
        });
        return (0, helpers_1.groupDtoToSpaceDto)(group);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.get.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.get.name} -: ${err}`);
      }
    });
    exports.get = get;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/info.js
var require_info = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/info.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.info = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers();
    var getGroup_1 = require_getGroup();
    var constants_1 = require_constants();
    var info = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (spaceId == null || spaceId.length == 0) {
          throw new Error(`spaceId cannot be null or empty`);
        }
        const group = yield (0, getGroup_1.getGroup)({
          chatId: spaceId,
          env
        });
        return (0, helpers_1.groupDtoToSpaceDto)(group);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.info.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.info.name} -: ${err}`);
      }
    });
    exports.info = info;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/createGroup.js
var require_createGroup = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/createGroup.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupCore = exports.createGroup = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var createGroup = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.createGroupCore)(options, helpers_2.PGPHelper);
    });
    exports.createGroup = createGroup;
    var createGroupCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account = null, signer = null, groupName, groupDescription, members, groupImage, admins, isPublic, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, meta, groupType, scheduleAt, scheduleEnd, rules } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        (0, helpers_2.validateScheduleDates)(scheduleAt, scheduleEnd);
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        (0, helpers_2.createGroupRequestValidator)(groupName, members, admins, groupDescription, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20);
        const convertedMembersPromise = members.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedAdminsPromise = admins.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedMembers = yield Promise.all(convertedMembersPromise);
        const convertedAdmins = yield Promise.all(convertedAdminsPromise);
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        const bodyToBeHashed = {
          groupName,
          groupDescription: groupDescription == void 0 ? null : groupDescription,
          members: convertedMembers,
          groupImage: groupImage == void 0 ? null : groupImage,
          admins: convertedAdmins,
          isPublic,
          contractAddressNFT: contractAddressNFT == void 0 ? null : contractAddressNFT,
          numberOfNFTs: numberOfNFTs == void 0 ? 0 : numberOfNFTs,
          contractAddressERC20: contractAddressERC20 == void 0 ? null : contractAddressERC20,
          numberOfERC20: numberOfERC20 == void 0 ? 0 : numberOfERC20,
          groupCreator: connectedUser.did
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = yield pgpHelper.sign({
          message: hash,
          signingKey: connectedUser.privateKey
        });
        const sigType = "pgp";
        const verificationProof = sigType + ":" + signature;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups`;
        const body = (0, helpers_2.createGroupPayload)(groupName, convertedMembers, convertedAdmins, isPublic, connectedUser.did, verificationProof, groupDescription, groupImage, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20, meta, groupType, scheduleAt, scheduleEnd, rules);
        const response = yield (0, axiosUtil_1.axiosPost)(apiEndpoint, body);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.createGroup.name);
      }
    });
    exports.createGroupCore = createGroupCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/create.js
var require_create = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/create.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var createGroup_1 = require_createGroup();
    function create(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signer, spaceName, spaceDescription, listeners, spaceImage, speakers, isPublic, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, scheduleAt, scheduleEnd, rules } = options || {};
        const groupRules = rules ? (0, helpers_1.convertSpaceRulesToRules)(rules) : null;
        try {
          const group = yield (0, createGroup_1.createGroup)({
            signer,
            groupName: spaceName,
            groupDescription: spaceDescription,
            members: listeners,
            groupImage: spaceImage,
            admins: speakers,
            isPublic,
            contractAddressNFT,
            numberOfNFTs,
            contractAddressERC20,
            numberOfERC20,
            env,
            pgpPrivateKey,
            groupType: "spaces",
            scheduleAt,
            scheduleEnd,
            rules: groupRules
          });
          return (0, helpers_1.groupDtoToSpaceDto)(group);
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${create.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${create.name} -: ${err}`);
        }
      });
    }
    exports.create = create;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMemberStatus.js
var require_getGroupMemberStatus = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMemberStatus.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupMemberStatus = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var getGroupMemberStatus = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, did, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (chatId == null || chatId.length === 0) {
          throw new Error(`chatId cannot be null or empty`);
        }
        if (did == null || did.length === 0) {
          throw new Error(`did cannot be null or empty`);
        }
        const user = yield (0, helpers_1.convertToValidDID)(did, env);
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}/members/${user}/status`;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getGroupMemberStatus.name);
      }
    });
    exports.getGroupMemberStatus = getGroupMemberStatus;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/updateGroup.js
var require_updateGroup = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/updateGroup.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGroupCore = exports.updateGroup = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var getGroup_1 = require_getGroup();
    var AES = require_aes();
    var getGroupMemberStatus_1 = require_getGroupMemberStatus();
    var validationError_1 = require_validationError();
    var updateGroup = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.updateGroupCore)(options, helpers_2.PGPHelper);
    });
    exports.updateGroup = updateGroup;
    var updateGroupCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, groupName, groupImage, groupDescription, members, admins, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, scheduleAt, scheduleEnd, status, meta, rules } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const address = yield (0, helpers_2.getAccountAddress)(wallet);
        (0, helpers_2.updateGroupRequestValidator)(chatId, groupName, members, admins, address, groupDescription);
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        const convertedMembersPromise = members.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedAdminsPromise = admins.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedMembers = yield Promise.all(convertedMembersPromise);
        const convertedAdmins = yield Promise.all(convertedAdminsPromise);
        const groupChat = yield (0, getGroup_1.getGroup)({ chatId, env });
        const updatedParticipants = new Set(convertedMembers.map((participant) => participant.toLowerCase()));
        const participantStatus = yield (0, getGroupMemberStatus_1.getGroupMemberStatus)({
          chatId,
          did: connectedUser.did,
          env
        });
        let sameMembers = true;
        groupChat.members.map((element) => {
          if (!updatedParticipants.has(element.wallet.toLowerCase())) {
            sameMembers = false;
          }
        });
        let encryptedSecret = null;
        if ((!sameMembers || !participantStatus.isMember) && !groupChat.isPublic) {
          const secretKey = AES.generateRandomSecret(15);
          const publicKeys = [];
          groupChat.members.map((element) => {
            if (updatedParticipants.has(element.wallet.toLowerCase())) {
              publicKeys.push(element.publicKey);
            }
          });
          if (!participantStatus.isMember) {
            publicKeys.push(connectedUser.publicKey);
          }
          encryptedSecret = yield pgpHelper.pgpEncrypt({
            plainText: secretKey,
            keys: publicKeys
          });
        }
        const bodyToBeHashed = {
          groupName,
          groupDescription: groupDescription == void 0 ? null : groupDescription,
          groupImage: groupImage == void 0 ? null : groupImage,
          members: convertedMembers,
          admins: convertedAdmins,
          chatId
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = yield pgpHelper.sign({
          message: hash,
          signingKey: connectedUser.privateKey
        });
        const sigType = "pgp";
        const verificationProof = sigType + ":" + signature + ":" + account;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups/${chatId}`;
        const body = (0, helpers_2.updateGroupPayload)(groupName, convertedMembers, convertedAdmins, connectedUser.did, verificationProof, encryptedSecret, groupDescription, groupImage, scheduleAt, scheduleEnd, status, meta, rules);
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.updateGroup.name);
      }
    });
    exports.updateGroupCore = updateGroupCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/update_out.js
var require_update_out = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/update_out.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.update = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var types_1 = require_types();
    var helpers_1 = require_helpers();
    var updateGroup_1 = require_updateGroup();
    var get_1 = require_get();
    var update = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, spaceName, spaceImage, spaceDescription, listeners, speakers, signer, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, scheduleAt, scheduleEnd, status } = options || {};
      try {
        const space = yield (0, get_1.get)({
          spaceId,
          env
        });
        if (space.status === types_1.ChatStatus.ACTIVE && scheduleAt) {
          throw new Error("Unable change the start date/time of an active space");
        }
        if (space.status === types_1.ChatStatus.ENDED && scheduleEnd) {
          throw new Error("Unable change the end date/time of an ended space");
        }
        const group = yield (0, updateGroup_1.updateGroup)({
          chatId: spaceId,
          groupName: spaceName,
          groupImage: spaceImage,
          groupDescription: spaceDescription,
          members: listeners,
          admins: speakers,
          signer,
          env,
          pgpPrivateKey,
          scheduleAt,
          scheduleEnd,
          status
        });
        return (0, helpers_1.groupDtoToSpaceDto)(group);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.update.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.update.name} -: ${err}`);
      }
    });
    exports.update = update;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupInfo.js
var require_getGroupInfo = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupInfo.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var getGroupInfo = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (chatId == null || chatId.length == 0) {
          throw new Error(`chatId cannot be null or empty`);
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v2/chat/groups/${chatId}`;
        return axios_1.default.get(requestUrl).then((response) => {
          return response.data;
        }).catch((err) => {
          var _a, _b;
          if ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data)
            throw new Error((_b = err === null || err === void 0 ? void 0 : err.response) === null || _b === void 0 ? void 0 : _b.data);
          throw new Error(err);
        });
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getGroupInfo.name);
      }
    });
    exports.getGroupInfo = getGroupInfo;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMembersPublicKeys.js
var require_getGroupMembersPublicKeys = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMembersPublicKeys.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupMembersPublicKeys = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var getGroupMembersPublicKeys = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, page = 1, limit = 20, env = constants_1.default.ENV.PROD } = options;
      try {
        if (!chatId) {
          throw new Error("Chat ID is required.");
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}/members/publicKeys?pageNumber=${page}&pageSize=${limit}`;
        const response = yield axios_1.default.get(requestUrl);
        return response.data;
      } catch (error) {
        throw (0, validationError_1.handleError)(error, exports.getGroupMembersPublicKeys.name);
      }
    });
    exports.getGroupMembersPublicKeys = getGroupMembersPublicKeys;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getAllGroupMembersPublicKeys.js
var require_getAllGroupMembersPublicKeys = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getAllGroupMembersPublicKeys.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllGroupMembersPublicKeys = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var getGroupMemberCount_1 = require_getGroupMemberCount();
    var getGroupMembersPublicKeys_1 = require_getGroupMembersPublicKeys();
    var getAllGroupMembersPublicKeys = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, env } = options;
      const count = yield (0, getGroupMemberCount_1.getGroupMemberCount)({ chatId, env });
      const overallCount = count.approvedCount;
      const limit = 5e3;
      const totalPages = Math.ceil(overallCount / limit);
      const pageNumbers = Array.from({ length: totalPages }, (_, i) => i + 1);
      const groupMembers = [];
      const memberFetchPromises = pageNumbers.map((page) => (0, getGroupMembersPublicKeys_1.getGroupMembersPublicKeys)({ chatId, env, page, limit }));
      const membersResults = yield Promise.all(memberFetchPromises);
      membersResults.forEach((result) => {
        if (result.members.length > 0) {
          groupMembers.push(...result.members);
        }
      });
      return groupMembers;
    });
    exports.getAllGroupMembersPublicKeys = getAllGroupMembersPublicKeys;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupMembers.js
var require_updateGroupMembers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupMembers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGroupMembers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var getGroupInfo_1 = require_getGroupInfo();
    var getGroupMemberStatus_1 = require_getGroupMemberStatus();
    var AES = require_aes();
    var getAllGroupMembersPublicKeys_1 = require_getAllGroupMembersPublicKeys();
    var config_1 = require_config();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var updateGroupMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, upsert, remove, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options;
      try {
        (0, helpers_2.validateGroupMemberUpdateOptions)(options);
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, helpers_2.PGPHelper);
        const convertedUpsertPromise = Object.entries(upsert).map(([role, userDIDs]) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          const userIDs = yield Promise.all(userDIDs.map((userDID) => (0, helpers_1.convertToValidDID)(userDID, env)));
          return [role, userIDs];
        }));
        const convertedUpsert = Object.fromEntries(yield Promise.all(convertedUpsertPromise));
        const convertedRemove = yield Promise.all(remove.map((userDID) => (0, helpers_1.convertToValidDID)(userDID, env)));
        let encryptedSecret = null;
        const group = yield (0, getGroupInfo_1.getGroupInfo)({ chatId, env });
        if (!group) {
          throw new Error(`Group not found`);
        }
        if (!group.isPublic) {
          if (group.encryptedSecret || !overrideSecretKeyGeneration) {
            const { isMember } = yield (0, getGroupMemberStatus_1.getGroupMemberStatus)({
              chatId,
              did: connectedUser.did,
              env
            });
            const groupMembers = yield (0, getAllGroupMembersPublicKeys_1.getAllGroupMembersPublicKeys)({
              chatId,
              env
            });
            const removeParticipantSet = new Set(convertedRemove.map((participant) => participant.toLowerCase()));
            let sameMembers = true;
            groupMembers.map((element) => {
              if (removeParticipantSet.has(element.did.toLowerCase())) {
                sameMembers = false;
              }
            });
            if (!sameMembers || !isMember) {
              const secretKey = AES.generateRandomSecret(15);
              const publicKeys = [];
              groupMembers.map((element) => {
                if (!removeParticipantSet.has(element.did.toLowerCase())) {
                  publicKeys.push(element.publicKey);
                }
              });
              if (!isMember) {
                publicKeys.push(connectedUser.publicKey);
              }
              encryptedSecret = yield (0, helpers_2.pgpEncrypt)({
                plainText: secretKey,
                keys: publicKeys
              });
            }
          }
        }
        const bodyToBeHashed = {
          upsert: convertedUpsert,
          remove: convertedRemove,
          encryptedSecret
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = yield helpers_2.PGPHelper.sign({
          message: hash,
          signingKey: connectedUser.privateKey
        });
        const sigType = "pgpv2";
        const deltaVerificationProof = `${sigType}:${signature}:${connectedUser.did}`;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups/${chatId}/members`;
        const body = {
          upsert: convertedUpsert,
          remove: convertedRemove,
          encryptedSecret,
          deltaVerificationProof
        };
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        return response.data;
      } catch (error) {
        throw (0, validationError_1.handleError)(error, exports.updateGroupMembers.name);
      }
    });
    exports.updateGroupMembers = updateGroupMembers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/addAdmins.js
var require_addAdmins = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/addAdmins.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addAdmins = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var updateGroupMembers_1 = require_updateGroupMembers();
    var addAdmins = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, admins, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!admins || admins.length === 0) {
          throw new Error("Admin address array cannot be empty!");
        }
        const upsertPayload = {
          members: [],
          admins
        };
        const groupMemberUpdateOptions = {
          chatId,
          upsert: upsertPayload,
          remove: [],
          account,
          signer,
          pgpPrivateKey,
          env,
          overrideSecretKeyGeneration
        };
        return yield (0, updateGroupMembers_1.updateGroupMembers)(groupMemberUpdateOptions);
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.addAdmins.name);
      }
    });
    exports.addAdmins = addAdmins;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/addSpeakers.js
var require_addSpeakers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/addSpeakers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addSpeakers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var addAdmins_1 = require_addAdmins();
    var addSpeakers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b;
      const { spaceId, speakers, signer = null, env = (_a = options === null || options === void 0 ? void 0 : options.env) !== null && _a !== void 0 ? _a : constants_1.default.ENV.PROD, pgpPrivateKey = (_b = options === null || options === void 0 ? void 0 : options.pgpPrivateKey) !== null && _b !== void 0 ? _b : null } = options;
      const group = yield (0, addAdmins_1.addAdmins)({
        chatId: spaceId,
        admins: speakers,
        signer,
        env,
        pgpPrivateKey
      });
      return (0, helpers_1.groupDtoToSpaceDtoV2)(group, env);
    });
    exports.addSpeakers = addSpeakers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/removeAdmins.js
var require_removeAdmins = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/removeAdmins.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeAdmins = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var updateGroupMembers_1 = require_updateGroupMembers();
    var removeAdmins = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, admins, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!admins || admins.length === 0) {
          throw new Error("Admin address array cannot be empty!");
        }
        const groupMemberUpdateOptions = {
          chatId,
          upsert: {
            members: [],
            admins: []
          },
          remove: admins,
          account,
          signer,
          pgpPrivateKey,
          env,
          overrideSecretKeyGeneration
        };
        return yield (0, updateGroupMembers_1.updateGroupMembers)(groupMemberUpdateOptions);
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.removeAdmins.name);
      }
    });
    exports.removeAdmins = removeAdmins;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/removeSpeakers.js
var require_removeSpeakers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/removeSpeakers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeSpeakers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var removeAdmins_1 = require_removeAdmins();
    var removeSpeakers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, speakers, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      try {
        const group = yield (0, removeAdmins_1.removeAdmins)({
          chatId: spaceId,
          admins: speakers,
          signer,
          env,
          pgpPrivateKey
        });
        return (0, helpers_1.groupDtoToSpaceDtoV2)(group, env);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.removeSpeakers.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.removeSpeakers.name} -: ${err}`);
      }
    });
    exports.removeSpeakers = removeSpeakers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/addMembers.js
var require_addMembers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/addMembers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addMembers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var updateGroupMembers_1 = require_updateGroupMembers();
    var addMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, members, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!members || members.length === 0) {
          throw new Error("Member address array cannot be empty!");
        }
        const upsertPayload = {
          members,
          admins: []
        };
        const groupMemberUpdateOptions = {
          chatId,
          upsert: upsertPayload,
          remove: [],
          account,
          signer,
          pgpPrivateKey,
          env,
          overrideSecretKeyGeneration
        };
        return yield (0, updateGroupMembers_1.updateGroupMembers)(groupMemberUpdateOptions);
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.addMembers.name);
      }
    });
    exports.addMembers = addMembers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/addListeners.js
var require_addListeners = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/addListeners.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addListeners = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var addMembers_1 = require_addMembers();
    var addListeners = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, listeners, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      try {
        const group = yield (0, addMembers_1.addMembers)({
          chatId: spaceId,
          members: listeners,
          account,
          signer,
          env,
          pgpPrivateKey
        });
        return (0, helpers_1.groupDtoToSpaceDtoV2)(group, env);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.addListeners.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.addListeners.name} -: ${err}`);
      }
    });
    exports.addListeners = addListeners;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/removeMembers.js
var require_removeMembers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/removeMembers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeMembers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var updateGroupMembers_1 = require_updateGroupMembers();
    var removeMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, members, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!members || members.length === 0) {
          throw new Error("Member address array cannot be empty!");
        }
        const groupMemberUpdateOptions = {
          chatId,
          upsert: {
            members: [],
            admins: []
          },
          remove: members,
          account,
          signer,
          pgpPrivateKey,
          env,
          overrideSecretKeyGeneration
        };
        return yield (0, updateGroupMembers_1.updateGroupMembers)(groupMemberUpdateOptions);
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.removeMembers.name);
      }
    });
    exports.removeMembers = removeMembers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/removeListeners.js
var require_removeListeners = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/removeListeners.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeListeners = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var removeMembers_1 = require_removeMembers();
    var removeListeners = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, listeners, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      try {
        const group = yield (0, removeMembers_1.removeMembers)({
          chatId: spaceId,
          members: listeners,
          account,
          signer,
          env,
          pgpPrivateKey
        });
        return (0, helpers_1.groupDtoToSpaceDtoV2)(group, env);
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.removeListeners.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.removeListeners.name} -: ${err}`);
      }
    });
    exports.removeListeners = removeListeners;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/approveRequest.js
var require_approveRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/approveRequest.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.approveCore = exports.approve = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var AES = require_aes();
    var getGroupInfo_1 = require_getGroupInfo();
    var getAllGroupMembersPublicKeys_1 = require_getAllGroupMembersPublicKeys();
    var config_1 = require_config();
    var validationError_1 = require_validationError();
    var approve = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.approveCore)(options, helpers_2.PGPHelper);
    });
    exports.approve = approve;
    var approveCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { status = "Approved", account = null, signer = null, senderAddress, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      if (account == null && signer == null) {
        throw new Error(`At least one from account or signer is necessary!`);
      }
      const wallet = (0, helpers_2.getWallet)({ account, signer });
      const address = yield (0, helpers_2.getAccountAddress)(wallet);
      const isGroup = !(0, helpers_1.isValidPushCAIP)(senderAddress);
      const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
      const fromDID = isGroup ? yield (0, helpers_1.convertToValidDID)(address, env) : yield (0, helpers_1.convertToValidDID)(senderAddress, env);
      const toDID = isGroup ? yield (0, helpers_1.convertToValidDID)(senderAddress, env) : yield (0, helpers_1.convertToValidDID)(address, env);
      let encryptedSecret = null;
      let sigType = "pgp";
      if (isGroup) {
        const group = yield (0, getGroupInfo_1.getGroupInfo)({ chatId: senderAddress, env });
        if (group && !group.isPublic) {
          if (group.encryptedSecret || !overrideSecretKeyGeneration) {
            sigType = "pgpv2";
            const secretKey = AES.generateRandomSecret(15);
            const groupMembers = yield (0, getAllGroupMembersPublicKeys_1.getAllGroupMembersPublicKeys)({
              chatId: group.chatId,
              env
            });
            const publicKeys = groupMembers.map((member) => member.publicKey);
            publicKeys.push(connectedUser.publicKey);
            encryptedSecret = yield pgpHelper.pgpEncrypt({
              plainText: secretKey,
              keys: publicKeys
            });
          }
        }
      }
      let bodyToBeHashed;
      switch (sigType) {
        case "pgp": {
          bodyToBeHashed = {
            fromDID,
            toDID,
            status
          };
          break;
        }
        case "pgpv2": {
          bodyToBeHashed = {
            fromDID,
            toDID,
            status,
            encryptedSecret
          };
          break;
        }
      }
      const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
      const signature = yield pgpHelper.sign({
        message: hash,
        signingKey: connectedUser.privateKey
      });
      const verificationProof = `${sigType}:${signature}`;
      const body = {
        fromDID,
        toDID,
        signature,
        status,
        sigType,
        verificationProof,
        encryptedSecret
      };
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/request/accept`;
      return (0, axiosUtil_1.axiosPut)(apiEndpoint, body).then((response) => {
        return response.data;
      }).catch((err) => {
        throw (0, validationError_1.handleError)(err, exports.approve.name);
      });
    });
    exports.approveCore = approveCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/approve.js
var require_approve = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/approve.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.approve = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var approveRequest_1 = require_approveRequest();
    var approve = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const {
        status = "Approved",
        account = null,
        signer = null,
        senderAddress,
        // space id
        env = constants_1.default.ENV.PROD,
        pgpPrivateKey = null
      } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!(0, helpers_1.isValidPushCAIP)(senderAddress) && !senderAddress.startsWith("spaces:")) {
          throw new Error("Not a valid spaceId or ETH address");
        }
        return yield (0, approveRequest_1.approve)({
          status,
          account,
          signer,
          senderAddress,
          env,
          pgpPrivateKey
        });
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.approve.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.approve.name} -: ${err}`);
      }
    });
    exports.approve = approve;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/requests.js
var require_requests = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/requests.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requests = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var axiosUtil_1 = require_axiosUtil();
    var requests = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, toDecrypt = false, page = 1, limit = 10 } = options || {};
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/spaces/users/${user}/requests?page=${page}&limit=${limit}`;
      try {
        if (!(0, helpers_1.isValidPushCAIP)(user)) {
          throw new Error(`Invalid address!`);
        }
        const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
        const requests2 = response.data.requests;
        const Feeds = yield (0, helpers_2.getSpaceInboxLists)({
          lists: requests2,
          user,
          toDecrypt,
          pgpPrivateKey,
          env
        });
        return Feeds;
      } catch (err) {
        console.error(`[Push SDK] - API ${exports.requests.name}: `, err);
        throw Error(`[Push SDK] - API ${exports.requests.name}: ${err}`);
      }
    });
    exports.requests = requests;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/chats.js
var require_chats = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/chats.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chatsCore = exports.chats = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var chats = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.chatsCore)(options, helpers_2.PGPHelper);
    });
    exports.chats = chats;
    var chatsCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, toDecrypt = false, page = 1, limit = 10 } = options || {};
      if (!(0, helpers_1.isValidPushCAIP)(account)) {
        throw new Error(`Invalid address!`);
      }
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/users/${user}/chats?page=${page}&limit=${limit}`;
      const requestUrl = `${apiEndpoint}`;
      try {
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        const chats2 = response.data.chats;
        const updatedChats = (0, helpers_2.addDeprecatedInfo)(chats2);
        const feeds = yield (0, helpers_2.getInboxLists)({
          lists: updatedChats,
          user,
          toDecrypt,
          pgpPrivateKey,
          env
        }, pgpHelper);
        return feeds;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.chats.name);
      }
    });
    exports.chatsCore = chatsCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/chat.js
var require_chat = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/chat.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var helpers_2 = require_helpers();
    var validationError_1 = require_validationError();
    var chat = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, toDecrypt = false, recipient } = options || {};
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const recipientWallet = yield (0, helpers_1.convertToValidDID)(recipient, env);
      if (!(0, helpers_1.isValidPushCAIP)(user))
        throw new Error(`Invalid address ${user}`);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/users/${user}/chat/${recipientWallet}`;
      try {
        const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
        const chat2 = response.data;
        if (Object.keys(chat2).length !== 0) {
          const updatedChat = (0, helpers_2.addDeprecatedInfo)([chat2]);
          const [feed] = yield (0, helpers_2.getInboxLists)({
            lists: updatedChat,
            user,
            toDecrypt,
            pgpPrivateKey,
            env
          }, helpers_2.PGPHelper);
          return feed;
        } else {
          return chat2;
        }
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.chat.name);
      }
    });
    exports.chat = chat;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/requests.js
var require_requests2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/requests.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestsCore = exports.requests = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var helpers_2 = require_helpers();
    var validationError_1 = require_validationError();
    var requests = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.requestsCore)(options, helpers_2.PGPHelper);
    });
    exports.requests = requests;
    var requestsCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, toDecrypt = false, page = 1, limit = 10 } = options || {};
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/users/${user}/requests?page=${page}&limit=${limit}`;
      try {
        if (!(0, helpers_1.isValidPushCAIP)(user)) {
          throw new Error(`Invalid address!`);
        }
        const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
        const requests2 = response.data.requests;
        const updatedRequests = (0, helpers_2.addDeprecatedInfo)(requests2);
        const Feeds = yield (0, helpers_2.getInboxLists)({
          lists: updatedRequests,
          user,
          toDecrypt,
          pgpPrivateKey,
          env
        }, pgpHelper);
        return Feeds;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.requests.name);
      }
    });
    exports.requestsCore = requestsCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/conversationHash.js
var require_conversationHash = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/conversationHash.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.conversationHash = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var helpers_1 = require_helpers2();
    var helpers_2 = require_helpers();
    var conversationHash = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { conversationId, account, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (!(0, helpers_1.isValidPushCAIP)(account)) {
          throw new Error(`Invalid address!`);
        }
        const updatedConversationId = yield (0, helpers_1.convertToValidDID)(conversationId, env);
        const accountDID = yield (0, helpers_1.convertToValidDID)(account, env);
        const response = yield (0, helpers_2.getConversationHashService)({
          conversationId: updatedConversationId,
          account: accountDID,
          env
        });
        return response;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.conversationHash.name);
      }
    });
    exports.conversationHash = conversationHash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/joi/dist/joi-browser.min.js
var require_joi_browser_min = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/joi/dist/joi-browser.min.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.joi = t() : e.joi = t();
    }(self, () => {
      return e = { 7629: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(9474), i = r(1687), o = r(8652), l = r(8160), c = r(3292), u = r(6354), f = r(8901), m = r(9708), h = r(6914), d = r(2294), p = r(6133), g = r(1152), y = r(8863), b = r(2036), v = { Base: class {
          constructor(e3) {
            this.type = e3, this.$_root = null, this._definition = {}, this._reset();
          }
          _reset() {
            this._ids = new d.Ids(), this._preferences = null, this._refs = new p.Manager(), this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = /* @__PURE__ */ new Map(), this.$_terms = {}, this.$_temp = { ruleset: null, whens: {} };
          }
          describe() {
            return s("function" == typeof m.describe, "Manifest functionality disabled"), m.describe(this);
          }
          allow(...e3) {
            return l.verifyFlat(e3, "allow"), this._values(e3, "_valids");
          }
          alter(e3) {
            s(e3 && "object" == typeof e3 && !Array.isArray(e3), "Invalid targets argument"), s(!this._inRuleset(), "Cannot set alterations inside a ruleset");
            const t3 = this.clone();
            t3.$_terms.alterations = t3.$_terms.alterations || [];
            for (const r2 in e3) {
              const n2 = e3[r2];
              s("function" == typeof n2, "Alteration adjuster for", r2, "must be a function"), t3.$_terms.alterations.push({ target: r2, adjuster: n2 });
            }
            return t3.$_temp.ruleset = false, t3;
          }
          artifact(e3) {
            return s(void 0 !== e3, "Artifact cannot be undefined"), s(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", e3);
          }
          cast(e3) {
            return s(false === e3 || "string" == typeof e3, "Invalid to value"), s(false === e3 || this._definition.cast[e3], "Type", this.type, "does not support casting to", e3), this.$_setFlag("cast", false === e3 ? void 0 : e3);
          }
          default(e3, t3) {
            return this._default("default", e3, t3);
          }
          description(e3) {
            return s(e3 && "string" == typeof e3, "Description must be a non-empty string"), this.$_setFlag("description", e3);
          }
          empty(e3) {
            const t3 = this.clone();
            return void 0 !== e3 && (e3 = t3.$_compile(e3, { override: false })), t3.$_setFlag("empty", e3, { clone: false });
          }
          error(e3) {
            return s(e3, "Missing error"), s(e3 instanceof Error || "function" == typeof e3, "Must provide a valid Error object or a function"), this.$_setFlag("error", e3);
          }
          example(e3, t3 = {}) {
            return s(void 0 !== e3, "Missing example"), l.assertOptions(t3, ["override"]), this._inner("examples", e3, { single: true, override: t3.override });
          }
          external(e3, t3) {
            return "object" == typeof e3 && (s(!t3, "Cannot combine options with description"), t3 = e3.description, e3 = e3.method), s("function" == typeof e3, "Method must be a function"), s(void 0 === t3 || t3 && "string" == typeof t3, "Description must be a non-empty string"), this._inner("externals", { method: e3, description: t3 }, { single: true });
          }
          failover(e3, t3) {
            return this._default("failover", e3, t3);
          }
          forbidden() {
            return this.presence("forbidden");
          }
          id(e3) {
            return e3 ? (s("string" == typeof e3, "id must be a non-empty string"), s(/^[^\.]+$/.test(e3), "id cannot contain period character"), this.$_setFlag("id", e3)) : this.$_setFlag("id", void 0);
          }
          invalid(...e3) {
            return this._values(e3, "_invalids");
          }
          label(e3) {
            return s(e3 && "string" == typeof e3, "Label name must be a non-empty string"), this.$_setFlag("label", e3);
          }
          meta(e3) {
            return s(void 0 !== e3, "Meta cannot be undefined"), this._inner("metas", e3, { single: true });
          }
          note(...e3) {
            s(e3.length, "Missing notes");
            for (const t3 of e3) s(t3 && "string" == typeof t3, "Notes must be non-empty strings");
            return this._inner("notes", e3);
          }
          only(e3 = true) {
            return s("boolean" == typeof e3, "Invalid mode:", e3), this.$_setFlag("only", e3);
          }
          optional() {
            return this.presence("optional");
          }
          prefs(e3) {
            s(e3, "Missing preferences"), s(void 0 === e3.context, "Cannot override context"), s(void 0 === e3.externals, "Cannot override externals"), s(void 0 === e3.warnings, "Cannot override warnings"), s(void 0 === e3.debug, "Cannot override debug"), l.checkPreferences(e3);
            const t3 = this.clone();
            return t3._preferences = l.preferences(t3._preferences, e3), t3;
          }
          presence(e3) {
            return s(["optional", "required", "forbidden"].includes(e3), "Unknown presence mode", e3), this.$_setFlag("presence", e3);
          }
          raw(e3 = true) {
            return this.$_setFlag("result", e3 ? "raw" : void 0);
          }
          result(e3) {
            return s(["raw", "strip"].includes(e3), "Unknown result mode", e3), this.$_setFlag("result", e3);
          }
          required() {
            return this.presence("required");
          }
          strict(e3) {
            const t3 = this.clone(), r2 = void 0 !== e3 && !e3;
            return t3._preferences = l.preferences(t3._preferences, { convert: r2 }), t3;
          }
          strip(e3 = true) {
            return this.$_setFlag("result", e3 ? "strip" : void 0);
          }
          tag(...e3) {
            s(e3.length, "Missing tags");
            for (const t3 of e3) s(t3 && "string" == typeof t3, "Tags must be non-empty strings");
            return this._inner("tags", e3);
          }
          unit(e3) {
            return s(e3 && "string" == typeof e3, "Unit name must be a non-empty string"), this.$_setFlag("unit", e3);
          }
          valid(...e3) {
            l.verifyFlat(e3, "valid");
            const t3 = this.allow(...e3);
            return t3.$_setFlag("only", !!t3._valids, { clone: false }), t3;
          }
          when(e3, t3) {
            const r2 = this.clone();
            r2.$_terms.whens || (r2.$_terms.whens = []);
            const n2 = c.when(r2, e3, t3);
            if (!["any", "link"].includes(r2.type)) {
              const e4 = n2.is ? [n2] : n2.switch;
              for (const t4 of e4) s(!t4.then || "any" === t4.then.type || t4.then.type === r2.type, "Cannot combine", r2.type, "with", t4.then && t4.then.type), s(!t4.otherwise || "any" === t4.otherwise.type || t4.otherwise.type === r2.type, "Cannot combine", r2.type, "with", t4.otherwise && t4.otherwise.type);
            }
            return r2.$_terms.whens.push(n2), r2.$_mutateRebuild();
          }
          cache(e3) {
            s(!this._inRuleset(), "Cannot set caching inside a ruleset"), s(!this._cache, "Cannot override schema cache"), s(void 0 === this._flags.artifact, "Cannot cache a rule with an artifact");
            const t3 = this.clone();
            return t3._cache = e3 || o.provider.provision(), t3.$_temp.ruleset = false, t3;
          }
          clone() {
            const e3 = Object.create(Object.getPrototypeOf(this));
            return this._assign(e3);
          }
          concat(e3) {
            s(l.isSchema(e3), "Invalid schema object"), s("any" === this.type || "any" === e3.type || e3.type === this.type, "Cannot merge type", this.type, "with another type:", e3.type), s(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), s(!e3._inRuleset(), "Cannot concatenate a schema with open ruleset");
            let t3 = this.clone();
            if ("any" === this.type && "any" !== e3.type) {
              const r2 = e3.clone();
              for (const e4 of Object.keys(t3)) "type" !== e4 && (r2[e4] = t3[e4]);
              t3 = r2;
            }
            t3._ids.concat(e3._ids), t3._refs.register(e3, p.toSibling), t3._preferences = t3._preferences ? l.preferences(t3._preferences, e3._preferences) : e3._preferences, t3._valids = b.merge(t3._valids, e3._valids, e3._invalids), t3._invalids = b.merge(t3._invalids, e3._invalids, e3._valids);
            for (const r2 of e3._singleRules.keys()) t3._singleRules.has(r2) && (t3._rules = t3._rules.filter((e4) => e4.keep || e4.name !== r2), t3._singleRules.delete(r2));
            for (const r2 of e3._rules) e3._definition.rules[r2.method].multi || t3._singleRules.set(r2.name, r2), t3._rules.push(r2);
            if (t3._flags.empty && e3._flags.empty) {
              t3._flags.empty = t3._flags.empty.concat(e3._flags.empty);
              const r2 = Object.assign({}, e3._flags);
              delete r2.empty, i(t3._flags, r2);
            } else if (e3._flags.empty) {
              t3._flags.empty = e3._flags.empty;
              const r2 = Object.assign({}, e3._flags);
              delete r2.empty, i(t3._flags, r2);
            } else i(t3._flags, e3._flags);
            for (const r2 in e3.$_terms) {
              const s2 = e3.$_terms[r2];
              s2 ? t3.$_terms[r2] ? t3.$_terms[r2] = t3.$_terms[r2].concat(s2) : t3.$_terms[r2] = s2.slice() : t3.$_terms[r2] || (t3.$_terms[r2] = s2);
            }
            return this.$_root._tracer && this.$_root._tracer._combine(t3, [this, e3]), t3.$_mutateRebuild();
          }
          extend(e3) {
            return s(!e3.base, "Cannot extend type with another base"), f.type(this, e3);
          }
          extract(e3) {
            return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.reach(e3);
          }
          fork(e3, t3) {
            s(!this._inRuleset(), "Cannot fork inside a ruleset");
            let r2 = this;
            for (let s2 of [].concat(e3)) s2 = Array.isArray(s2) ? s2 : s2.split("."), r2 = r2._ids.fork(s2, t3, r2);
            return r2.$_temp.ruleset = false, r2;
          }
          rule(e3) {
            const t3 = this._definition;
            l.assertOptions(e3, Object.keys(t3.modifiers)), s(false !== this.$_temp.ruleset, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
            const r2 = null === this.$_temp.ruleset ? this._rules.length - 1 : this.$_temp.ruleset;
            s(r2 >= 0 && r2 < this._rules.length, "Cannot apply rules to empty ruleset");
            const a2 = this.clone();
            for (let i2 = r2; i2 < a2._rules.length; ++i2) {
              const r3 = a2._rules[i2], o2 = n(r3);
              for (const n2 in e3) t3.modifiers[n2](o2, e3[n2]), s(o2.name === r3.name, "Cannot change rule name");
              a2._rules[i2] = o2, a2._singleRules.get(o2.name) === r3 && a2._singleRules.set(o2.name, o2);
            }
            return a2.$_temp.ruleset = false, a2.$_mutateRebuild();
          }
          get ruleset() {
            s(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
            const e3 = this.clone();
            return e3.$_temp.ruleset = e3._rules.length, e3;
          }
          get $() {
            return this.ruleset;
          }
          tailor(e3) {
            e3 = [].concat(e3), s(!this._inRuleset(), "Cannot tailor inside a ruleset");
            let t3 = this;
            if (this.$_terms.alterations) for (const { target: r2, adjuster: n2 } of this.$_terms.alterations) e3.includes(r2) && (t3 = n2(t3), s(l.isSchema(t3), "Alteration adjuster for", r2, "failed to return a schema object"));
            return t3 = t3.$_modify({ each: (t4) => t4.tailor(e3), ref: false }), t3.$_temp.ruleset = false, t3.$_mutateRebuild();
          }
          tracer() {
            return g.location ? g.location(this) : this;
          }
          validate(e3, t3) {
            return y.entry(e3, this, t3);
          }
          validateAsync(e3, t3) {
            return y.entryAsync(e3, this, t3);
          }
          $_addRule(e3) {
            "string" == typeof e3 && (e3 = { name: e3 }), s(e3 && "object" == typeof e3, "Invalid options"), s(e3.name && "string" == typeof e3.name, "Invalid rule name");
            for (const t4 in e3) s("_" !== t4[0], "Cannot set private rule properties");
            const t3 = Object.assign({}, e3);
            t3._resolve = [], t3.method = t3.method || t3.name;
            const r2 = this._definition.rules[t3.method], n2 = t3.args;
            s(r2, "Unknown rule", t3.method);
            const a2 = this.clone();
            if (n2) {
              s(1 === Object.keys(n2).length || Object.keys(n2).length === this._definition.rules[t3.name].args.length, "Invalid rule definition for", this.type, t3.name);
              for (const e4 in n2) {
                let i2 = n2[e4];
                if (r2.argsByName) {
                  const o2 = r2.argsByName.get(e4);
                  if (o2.ref && l.isResolvable(i2)) t3._resolve.push(e4), a2.$_mutateRegister(i2);
                  else if (o2.normalize && (i2 = o2.normalize(i2), n2[e4] = i2), o2.assert) {
                    const t4 = l.validateArg(i2, e4, o2);
                    s(!t4, t4, "or reference");
                  }
                }
                void 0 !== i2 ? n2[e4] = i2 : delete n2[e4];
              }
            }
            return r2.multi || (a2._ruleRemove(t3.name, { clone: false }), a2._singleRules.set(t3.name, t3)), false === a2.$_temp.ruleset && (a2.$_temp.ruleset = null), r2.priority ? a2._rules.unshift(t3) : a2._rules.push(t3), a2;
          }
          $_compile(e3, t3) {
            return c.schema(this.$_root, e3, t3);
          }
          $_createError(e3, t3, r2, s2, n2, a2 = {}) {
            const i2 = false !== a2.flags ? this._flags : {}, o2 = a2.messages ? h.merge(this._definition.messages, a2.messages) : this._definition.messages;
            return new u.Report(e3, t3, r2, i2, o2, s2, n2);
          }
          $_getFlag(e3) {
            return this._flags[e3];
          }
          $_getRule(e3) {
            return this._singleRules.get(e3);
          }
          $_mapLabels(e3) {
            return e3 = Array.isArray(e3) ? e3 : e3.split("."), this._ids.labels(e3);
          }
          $_match(e3, t3, r2, s2) {
            (r2 = Object.assign({}, r2)).abortEarly = true, r2._externals = false, t3.snapshot();
            const n2 = !y.validate(e3, this, t3, r2, s2).errors;
            return t3.restore(), n2;
          }
          $_modify(e3) {
            return l.assertOptions(e3, ["each", "once", "ref", "schema"]), d.schema(this, e3) || this;
          }
          $_mutateRebuild() {
            return s(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({ each: (e3, { source: t3, name: r2, path: s2, key: n2 }) => {
              const a2 = this._definition[t3][r2] && this._definition[t3][r2].register;
              false !== a2 && this.$_mutateRegister(e3, { family: a2, key: n2 });
            } }), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = false, this;
          }
          $_mutateRegister(e3, { family: t3, key: r2 } = {}) {
            this._refs.register(e3, t3), this._ids.register(e3, { key: r2 });
          }
          $_property(e3) {
            return this._definition.properties[e3];
          }
          $_reach(e3) {
            return this._ids.reach(e3);
          }
          $_rootReferences() {
            return this._refs.roots();
          }
          $_setFlag(e3, t3, r2 = {}) {
            s("_" === e3[0] || !this._inRuleset(), "Cannot set flag inside a ruleset");
            const n2 = this._definition.flags[e3] || {};
            if (a(t3, n2.default) && (t3 = void 0), a(t3, this._flags[e3])) return this;
            const i2 = false !== r2.clone ? this.clone() : this;
            return void 0 !== t3 ? (i2._flags[e3] = t3, i2.$_mutateRegister(t3)) : delete i2._flags[e3], "_" !== e3[0] && (i2.$_temp.ruleset = false), i2;
          }
          $_parent(e3, ...t3) {
            return this[e3][l.symbols.parent].call(this, ...t3);
          }
          $_validate(e3, t3, r2) {
            return y.validate(e3, this, t3, r2);
          }
          _assign(e3) {
            e3.type = this.type, e3.$_root = this.$_root, e3.$_temp = Object.assign({}, this.$_temp), e3.$_temp.whens = {}, e3._ids = this._ids.clone(), e3._preferences = this._preferences, e3._valids = this._valids && this._valids.clone(), e3._invalids = this._invalids && this._invalids.clone(), e3._rules = this._rules.slice(), e3._singleRules = n(this._singleRules, { shallow: true }), e3._refs = this._refs.clone(), e3._flags = Object.assign({}, this._flags), e3._cache = null, e3.$_terms = {};
            for (const t3 in this.$_terms) e3.$_terms[t3] = this.$_terms[t3] ? this.$_terms[t3].slice() : null;
            e3.$_super = {};
            for (const t3 in this.$_super) e3.$_super[t3] = this._super[t3].bind(e3);
            return e3;
          }
          _bare() {
            const e3 = this.clone();
            e3._reset();
            const t3 = e3._definition.terms;
            for (const r2 in t3) {
              const s2 = t3[r2];
              e3.$_terms[r2] = s2.init;
            }
            return e3.$_mutateRebuild();
          }
          _default(e3, t3, r2 = {}) {
            return l.assertOptions(r2, "literal"), s(void 0 !== t3, "Missing", e3, "value"), s("function" == typeof t3 || !r2.literal, "Only function value supports literal option"), "function" == typeof t3 && r2.literal && (t3 = { [l.symbols.literal]: true, literal: t3 }), this.$_setFlag(e3, t3);
          }
          _generate(e3, t3, r2) {
            if (!this.$_terms.whens) return { schema: this };
            const s2 = [], n2 = [];
            for (let a3 = 0; a3 < this.$_terms.whens.length; ++a3) {
              const i3 = this.$_terms.whens[a3];
              if (i3.concat) {
                s2.push(i3.concat), n2.push(`${a3}.concat`);
                continue;
              }
              const o2 = i3.ref ? i3.ref.resolve(e3, t3, r2) : e3, l2 = i3.is ? [i3] : i3.switch, c2 = n2.length;
              for (let c3 = 0; c3 < l2.length; ++c3) {
                const { is: u2, then: f2, otherwise: m2 } = l2[c3], h2 = `${a3}${i3.switch ? "." + c3 : ""}`;
                if (u2.$_match(o2, t3.nest(u2, `${h2}.is`), r2)) {
                  if (f2) {
                    const a4 = t3.localize([...t3.path, `${h2}.then`], t3.ancestors, t3.schemas), { schema: i4, id: o3 } = f2._generate(e3, a4, r2);
                    s2.push(i4), n2.push(`${h2}.then${o3 ? `(${o3})` : ""}`);
                    break;
                  }
                } else if (m2) {
                  const a4 = t3.localize([...t3.path, `${h2}.otherwise`], t3.ancestors, t3.schemas), { schema: i4, id: o3 } = m2._generate(e3, a4, r2);
                  s2.push(i4), n2.push(`${h2}.otherwise${o3 ? `(${o3})` : ""}`);
                  break;
                }
              }
              if (i3.break && n2.length > c2) break;
            }
            const a2 = n2.join(", ");
            if (t3.mainstay.tracer.debug(t3, "rule", "when", a2), !a2) return { schema: this };
            if (!t3.mainstay.tracer.active && this.$_temp.whens[a2]) return { schema: this.$_temp.whens[a2], id: a2 };
            let i2 = this;
            this._definition.generate && (i2 = this._definition.generate(this, e3, t3, r2));
            for (const e4 of s2) i2 = i2.concat(e4);
            return this.$_root._tracer && this.$_root._tracer._combine(i2, [this, ...s2]), this.$_temp.whens[a2] = i2, { schema: i2, id: a2 };
          }
          _inner(e3, t3, r2 = {}) {
            s(!this._inRuleset(), `Cannot set ${e3} inside a ruleset`);
            const n2 = this.clone();
            return n2.$_terms[e3] && !r2.override || (n2.$_terms[e3] = []), r2.single ? n2.$_terms[e3].push(t3) : n2.$_terms[e3].push(...t3), n2.$_temp.ruleset = false, n2;
          }
          _inRuleset() {
            return null !== this.$_temp.ruleset && false !== this.$_temp.ruleset;
          }
          _ruleRemove(e3, t3 = {}) {
            if (!this._singleRules.has(e3)) return this;
            const r2 = false !== t3.clone ? this.clone() : this;
            r2._singleRules.delete(e3);
            const s2 = [];
            for (let t4 = 0; t4 < r2._rules.length; ++t4) {
              const n2 = r2._rules[t4];
              n2.name !== e3 || n2.keep ? s2.push(n2) : r2._inRuleset() && t4 < r2.$_temp.ruleset && --r2.$_temp.ruleset;
            }
            return r2._rules = s2, r2;
          }
          _values(e3, t3) {
            l.verifyFlat(e3, t3.slice(1, -1));
            const r2 = this.clone(), n2 = e3[0] === l.symbols.override;
            if (n2 && (e3 = e3.slice(1)), !r2[t3] && e3.length ? r2[t3] = new b() : n2 && (r2[t3] = e3.length ? new b() : null, r2.$_mutateRebuild()), !r2[t3]) return r2;
            n2 && r2[t3].override();
            for (const n3 of e3) {
              s(void 0 !== n3, "Cannot call allow/valid/invalid with undefined"), s(n3 !== l.symbols.override, "Override must be the first value");
              const e4 = "_invalids" === t3 ? "_valids" : "_invalids";
              r2[e4] && (r2[e4].remove(n3), r2[e4].length || (s("_valids" === t3 || !r2._flags.only, "Setting invalid value", n3, "leaves schema rejecting all values due to previous valid rule"), r2[e4] = null)), r2[t3].add(n3, r2._refs);
            }
            return r2;
          }
        } };
        v.Base.prototype[l.symbols.any] = { version: l.version, compile: c.compile, root: "$_root" }, v.Base.prototype.isImmutable = true, v.Base.prototype.deny = v.Base.prototype.invalid, v.Base.prototype.disallow = v.Base.prototype.invalid, v.Base.prototype.equal = v.Base.prototype.valid, v.Base.prototype.exist = v.Base.prototype.required, v.Base.prototype.not = v.Base.prototype.invalid, v.Base.prototype.options = v.Base.prototype.prefs, v.Base.prototype.preferences = v.Base.prototype.prefs, e2.exports = new v.Base();
      }, 8652: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(8160), i = { max: 1e3, supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"]) };
        t2.provider = { provision: (e3) => new i.Cache(e3) }, i.Cache = class {
          constructor(e3 = {}) {
            a.assertOptions(e3, ["max"]), s(void 0 === e3.max || e3.max && e3.max > 0 && isFinite(e3.max), "Invalid max cache size"), this._max = e3.max || i.max, this._map = /* @__PURE__ */ new Map(), this._list = new i.List();
          }
          get length() {
            return this._map.size;
          }
          set(e3, t3) {
            if (null !== e3 && !i.supported.has(typeof e3)) return;
            let r2 = this._map.get(e3);
            if (r2) return r2.value = t3, void this._list.first(r2);
            r2 = this._list.unshift({ key: e3, value: t3 }), this._map.set(e3, r2), this._compact();
          }
          get(e3) {
            const t3 = this._map.get(e3);
            if (t3) return this._list.first(t3), n(t3.value);
          }
          _compact() {
            if (this._map.size > this._max) {
              const e3 = this._list.pop();
              this._map.delete(e3.key);
            }
          }
        }, i.List = class {
          constructor() {
            this.tail = null, this.head = null;
          }
          unshift(e3) {
            return e3.next = null, e3.prev = this.head, this.head && (this.head.next = e3), this.head = e3, this.tail || (this.tail = e3), e3;
          }
          first(e3) {
            e3 !== this.head && (this._remove(e3), this.unshift(e3));
          }
          pop() {
            return this._remove(this.tail);
          }
          _remove(e3) {
            const { next: t3, prev: r2 } = e3;
            return t3.prev = r2, r2 && (r2.next = t3), e3 === this.tail && (this.tail = t3), e3.prev = null, e3.next = null, e3;
          }
        };
      }, 8160: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(7916), a = r(5934);
        let i, o;
        const l = { isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/ };
        t2.version = a.version, t2.defaults = { abortEarly: true, allowUnknown: false, artifacts: false, cache: true, context: null, convert: true, dateFormat: "iso", errors: { escapeHtml: false, label: "path", language: null, render: true, stack: false, wrap: { label: '"', array: "[]" } }, externals: true, messages: {}, nonEnumerables: false, noDefaults: false, presence: "optional", skipFunctions: false, stripUnknown: false, warnings: false }, t2.symbols = { any: Symbol.for("@hapi/joi/schema"), arraySingle: Symbol("arraySingle"), deepDefault: Symbol("deepDefault"), errors: Symbol("errors"), literal: Symbol("literal"), override: Symbol("override"), parent: Symbol("parent"), prefs: Symbol("prefs"), ref: Symbol("ref"), template: Symbol("template"), values: Symbol("values") }, t2.assertOptions = function(e3, t3, r2 = "Options") {
          s(e3 && "object" == typeof e3 && !Array.isArray(e3), "Options must be of type object");
          const n2 = Object.keys(e3).filter((e4) => !t3.includes(e4));
          s(0 === n2.length, `${r2} contain unknown keys: ${n2}`);
        }, t2.checkPreferences = function(e3) {
          o = o || r(3378);
          const t3 = o.preferences.validate(e3);
          if (t3.error) throw new n([t3.error.details[0].message]);
        }, t2.compare = function(e3, t3, r2) {
          switch (r2) {
            case "=":
              return e3 === t3;
            case ">":
              return e3 > t3;
            case "<":
              return e3 < t3;
            case ">=":
              return e3 >= t3;
            case "<=":
              return e3 <= t3;
          }
        }, t2.default = function(e3, t3) {
          return void 0 === e3 ? t3 : e3;
        }, t2.isIsoDate = function(e3) {
          return l.isoDate.test(e3);
        }, t2.isNumber = function(e3) {
          return "number" == typeof e3 && !isNaN(e3);
        }, t2.isResolvable = function(e3) {
          return !!e3 && (e3[t2.symbols.ref] || e3[t2.symbols.template]);
        }, t2.isSchema = function(e3, r2 = {}) {
          const n2 = e3 && e3[t2.symbols.any];
          return !!n2 && (s(r2.legacy || n2.version === t2.version, "Cannot mix different versions of joi schemas"), true);
        }, t2.isValues = function(e3) {
          return e3[t2.symbols.values];
        }, t2.limit = function(e3) {
          return Number.isSafeInteger(e3) && e3 >= 0;
        }, t2.preferences = function(e3, s2) {
          i = i || r(6914), e3 = e3 || {}, s2 = s2 || {};
          const n2 = Object.assign({}, e3, s2);
          return s2.errors && e3.errors && (n2.errors = Object.assign({}, e3.errors, s2.errors), n2.errors.wrap = Object.assign({}, e3.errors.wrap, s2.errors.wrap)), s2.messages && (n2.messages = i.compile(s2.messages, e3.messages)), delete n2[t2.symbols.prefs], n2;
        }, t2.tryWithPath = function(e3, t3, r2 = {}) {
          try {
            return e3();
          } catch (e4) {
            throw void 0 !== e4.path ? e4.path = t3 + "." + e4.path : e4.path = t3, r2.append && (e4.message = `${e4.message} (${e4.path})`), e4;
          }
        }, t2.validateArg = function(e3, r2, { assert: s2, message: n2 }) {
          if (t2.isSchema(s2)) {
            const t3 = s2.validate(e3);
            if (!t3.error) return;
            return t3.error.message;
          }
          if (!s2(e3)) return r2 ? `${r2} ${n2}` : n2;
        }, t2.verifyFlat = function(e3, t3) {
          for (const r2 of e3) s(!Array.isArray(r2), "Method no longer accepts array arguments:", t3);
        };
      }, 3292: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8160), a = r(6133), i = {};
        t2.schema = function(e3, t3, r2 = {}) {
          n.assertOptions(r2, ["appendPath", "override"]);
          try {
            return i.schema(e3, t3, r2);
          } catch (e4) {
            throw r2.appendPath && void 0 !== e4.path && (e4.message = `${e4.message} (${e4.path})`), e4;
          }
        }, i.schema = function(e3, t3, r2) {
          s(void 0 !== t3, "Invalid undefined schema"), Array.isArray(t3) && (s(t3.length, "Invalid empty array schema"), 1 === t3.length && (t3 = t3[0]));
          const a2 = (t4, ...s2) => false !== r2.override ? t4.valid(e3.override, ...s2) : t4.valid(...s2);
          if (i.simple(t3)) return a2(e3, t3);
          if ("function" == typeof t3) return e3.custom(t3);
          if (s("object" == typeof t3, "Invalid schema content:", typeof t3), n.isResolvable(t3)) return a2(e3, t3);
          if (n.isSchema(t3)) return t3;
          if (Array.isArray(t3)) {
            for (const r3 of t3) if (!i.simple(r3)) return e3.alternatives().try(...t3);
            return a2(e3, ...t3);
          }
          return t3 instanceof RegExp ? e3.string().regex(t3) : t3 instanceof Date ? a2(e3.date(), t3) : (s(Object.getPrototypeOf(t3) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), e3.object().keys(t3));
        }, t2.ref = function(e3, t3) {
          return a.isRef(e3) ? e3 : a.create(e3, t3);
        }, t2.compile = function(e3, r2, a2 = {}) {
          n.assertOptions(a2, ["legacy"]);
          const o = r2 && r2[n.symbols.any];
          if (o) return s(a2.legacy || o.version === n.version, "Cannot mix different versions of joi schemas:", o.version, n.version), r2;
          if ("object" != typeof r2 || !a2.legacy) return t2.schema(e3, r2, { appendPath: true });
          const l = i.walk(r2);
          return l ? l.compile(l.root, r2) : t2.schema(e3, r2, { appendPath: true });
        }, i.walk = function(e3) {
          if ("object" != typeof e3) return null;
          if (Array.isArray(e3)) {
            for (const t4 of e3) {
              const e4 = i.walk(t4);
              if (e4) return e4;
            }
            return null;
          }
          const t3 = e3[n.symbols.any];
          if (t3) return { root: e3[t3.root], compile: t3.compile };
          s(Object.getPrototypeOf(e3) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
          for (const t4 in e3) {
            const r2 = i.walk(e3[t4]);
            if (r2) return r2;
          }
          return null;
        }, i.simple = function(e3) {
          return null === e3 || ["boolean", "string", "number"].includes(typeof e3);
        }, t2.when = function(e3, r2, o) {
          if (void 0 === o && (s(r2 && "object" == typeof r2, "Missing options"), o = r2, r2 = a.create(".")), Array.isArray(o) && (o = { switch: o }), n.assertOptions(o, ["is", "not", "then", "otherwise", "switch", "break"]), n.isSchema(r2)) return s(void 0 === o.is, '"is" can not be used with a schema condition'), s(void 0 === o.not, '"not" can not be used with a schema condition'), s(void 0 === o.switch, '"switch" can not be used with a schema condition'), i.condition(e3, { is: r2, then: o.then, otherwise: o.otherwise, break: o.break });
          if (s(a.isRef(r2) || "string" == typeof r2, "Invalid condition:", r2), s(void 0 === o.not || void 0 === o.is, 'Cannot combine "is" with "not"'), void 0 === o.switch) {
            let l2 = o;
            void 0 !== o.not && (l2 = { is: o.not, then: o.otherwise, otherwise: o.then, break: o.break });
            let c = void 0 !== l2.is ? e3.$_compile(l2.is) : e3.$_root.invalid(null, false, 0, "").required();
            return s(void 0 !== l2.then || void 0 !== l2.otherwise, 'options must have at least one of "then", "otherwise", or "switch"'), s(void 0 === l2.break || void 0 === l2.then || void 0 === l2.otherwise, "Cannot specify then, otherwise, and break all together"), void 0 === o.is || a.isRef(o.is) || n.isSchema(o.is) || (c = c.required()), i.condition(e3, { ref: t2.ref(r2), is: c, then: l2.then, otherwise: l2.otherwise, break: l2.break });
          }
          s(Array.isArray(o.switch), '"switch" must be an array'), s(void 0 === o.is, 'Cannot combine "switch" with "is"'), s(void 0 === o.not, 'Cannot combine "switch" with "not"'), s(void 0 === o.then, 'Cannot combine "switch" with "then"');
          const l = { ref: t2.ref(r2), switch: [], break: o.break };
          for (let t3 = 0; t3 < o.switch.length; ++t3) {
            const r3 = o.switch[t3], i2 = t3 === o.switch.length - 1;
            n.assertOptions(r3, i2 ? ["is", "then", "otherwise"] : ["is", "then"]), s(void 0 !== r3.is, 'Switch statement missing "is"'), s(void 0 !== r3.then, 'Switch statement missing "then"');
            const c = { is: e3.$_compile(r3.is), then: e3.$_compile(r3.then) };
            if (a.isRef(r3.is) || n.isSchema(r3.is) || (c.is = c.is.required()), i2) {
              s(void 0 === o.otherwise || void 0 === r3.otherwise, 'Cannot specify "otherwise" inside and outside a "switch"');
              const t4 = void 0 !== o.otherwise ? o.otherwise : r3.otherwise;
              void 0 !== t4 && (s(void 0 === l.break, "Cannot specify both otherwise and break"), c.otherwise = e3.$_compile(t4));
            }
            l.switch.push(c);
          }
          return l;
        }, i.condition = function(e3, t3) {
          for (const r2 of ["then", "otherwise"]) void 0 === t3[r2] ? delete t3[r2] : t3[r2] = e3.$_compile(t3[r2]);
          return t3;
        };
      }, 6354: (e2, t2, r) => {
        "use strict";
        const s = r(5688), n = r(8160), a = r(3328);
        t2.Report = class {
          constructor(e3, r2, s2, n2, a2, i, o) {
            if (this.code = e3, this.flags = n2, this.messages = a2, this.path = i.path, this.prefs = o, this.state = i, this.value = r2, this.message = null, this.template = null, this.local = s2 || {}, this.local.label = t2.label(this.flags, this.state, this.prefs, this.messages), void 0 === this.value || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
              const e4 = this.path[this.path.length - 1];
              "object" != typeof e4 && (this.local.key = e4);
            }
          }
          _setTemplate(e3) {
            if (this.template = e3, !this.flags.label && 0 === this.path.length) {
              const e4 = this._template(this.template, "root");
              e4 && (this.local.label = e4);
            }
          }
          toString() {
            if (this.message) return this.message;
            const e3 = this.code;
            if (!this.prefs.errors.render) return this.code;
            const t3 = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
            return void 0 === t3 ? `Error code "${e3}" is not defined, your custom type is missing the correct messages definition` : (this.message = t3.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] }), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message);
          }
          _template(e3, r2) {
            return t2.template(this.value, e3, r2 || this.code, this.state, this.prefs);
          }
        }, t2.path = function(e3) {
          let t3 = "";
          for (const r2 of e3) "object" != typeof r2 && ("string" == typeof r2 ? (t3 && (t3 += "."), t3 += r2) : t3 += `[${r2}]`);
          return t3;
        }, t2.template = function(e3, t3, r2, s2, i) {
          if (!t3) return;
          if (a.isTemplate(t3)) return "root" !== r2 ? t3 : null;
          let o = i.errors.language;
          if (n.isResolvable(o) && (o = o.resolve(e3, s2, i)), o && t3[o]) {
            if (void 0 !== t3[o][r2]) return t3[o][r2];
            if (void 0 !== t3[o]["*"]) return t3[o]["*"];
          }
          return t3[r2] ? t3[r2] : t3["*"];
        }, t2.label = function(e3, r2, s2, n2) {
          if (!s2.errors.label) return "";
          if (e3.label) return e3.label;
          let a2 = r2.path;
          "key" === s2.errors.label && r2.path.length > 1 && (a2 = r2.path.slice(-1));
          return t2.path(a2) || t2.template(null, s2.messages, "root", r2, s2) || n2 && t2.template(null, n2, "root", r2, s2) || "value";
        }, t2.process = function(e3, r2, s2) {
          if (!e3) return null;
          const { override: n2, message: a2, details: i } = t2.details(e3);
          if (n2) return n2;
          if (s2.errors.stack) return new t2.ValidationError(a2, i, r2);
          const o = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          const l = new t2.ValidationError(a2, i, r2);
          return Error.stackTraceLimit = o, l;
        }, t2.details = function(e3, t3 = {}) {
          let r2 = [];
          const s2 = [];
          for (const n2 of e3) {
            if (n2 instanceof Error) {
              if (false !== t3.override) return { override: n2 };
              const e5 = n2.toString();
              r2.push(e5), s2.push({ message: e5, type: "override", context: { error: n2 } });
              continue;
            }
            const e4 = n2.toString();
            r2.push(e4), s2.push({ message: e4, path: n2.path.filter((e5) => "object" != typeof e5), type: n2.code, context: n2.local });
          }
          return r2.length > 1 && (r2 = [...new Set(r2)]), { message: r2.join(". "), details: s2 };
        }, t2.ValidationError = class extends Error {
          constructor(e3, t3, r2) {
            super(e3), this._original = r2, this.details = t3;
          }
          static isError(e3) {
            return e3 instanceof t2.ValidationError;
          }
        }, t2.ValidationError.prototype.isJoi = true, t2.ValidationError.prototype.name = "ValidationError", t2.ValidationError.prototype.annotate = s.error;
      }, 8901: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(8160), i = r(6914), o = {};
        t2.type = function(e3, t3) {
          const r2 = Object.getPrototypeOf(e3), l = n(r2), c = e3._assign(Object.create(l)), u = Object.assign({}, t3);
          delete u.base, l._definition = u;
          const f = r2._definition || {};
          u.messages = i.merge(f.messages, u.messages), u.properties = Object.assign({}, f.properties, u.properties), c.type = u.type, u.flags = Object.assign({}, f.flags, u.flags);
          const m = Object.assign({}, f.terms);
          if (u.terms) for (const e4 in u.terms) {
            const t4 = u.terms[e4];
            s(void 0 === c.$_terms[e4], "Invalid term override for", u.type, e4), c.$_terms[e4] = t4.init, m[e4] = t4;
          }
          u.terms = m, u.args || (u.args = f.args), u.prepare = o.prepare(u.prepare, f.prepare), u.coerce && ("function" == typeof u.coerce && (u.coerce = { method: u.coerce }), u.coerce.from && !Array.isArray(u.coerce.from) && (u.coerce = { method: u.coerce.method, from: [].concat(u.coerce.from) })), u.coerce = o.coerce(u.coerce, f.coerce), u.validate = o.validate(u.validate, f.validate);
          const h = Object.assign({}, f.rules);
          if (u.rules) for (const e4 in u.rules) {
            const t4 = u.rules[e4];
            s("object" == typeof t4, "Invalid rule definition for", u.type, e4);
            let r3 = t4.method;
            if (void 0 === r3 && (r3 = function() {
              return this.$_addRule(e4);
            }), r3 && (s(!l[e4], "Rule conflict in", u.type, e4), l[e4] = r3), s(!h[e4], "Rule conflict in", u.type, e4), h[e4] = t4, t4.alias) {
              const e5 = [].concat(t4.alias);
              for (const r4 of e5) l[r4] = t4.method;
            }
            t4.args && (t4.argsByName = /* @__PURE__ */ new Map(), t4.args = t4.args.map((e5) => ("string" == typeof e5 && (e5 = { name: e5 }), s(!t4.argsByName.has(e5.name), "Duplicated argument name", e5.name), a.isSchema(e5.assert) && (e5.assert = e5.assert.strict().label(e5.name)), t4.argsByName.set(e5.name, e5), e5)));
          }
          u.rules = h;
          const d = Object.assign({}, f.modifiers);
          if (u.modifiers) for (const e4 in u.modifiers) {
            s(!l[e4], "Rule conflict in", u.type, e4);
            const t4 = u.modifiers[e4];
            s("function" == typeof t4, "Invalid modifier definition for", u.type, e4);
            const r3 = function(t5) {
              return this.rule({ [e4]: t5 });
            };
            l[e4] = r3, d[e4] = t4;
          }
          if (u.modifiers = d, u.overrides) {
            l._super = r2, c.$_super = {};
            for (const e4 in u.overrides) s(r2[e4], "Cannot override missing", e4), u.overrides[e4][a.symbols.parent] = r2[e4], c.$_super[e4] = r2[e4].bind(c);
            Object.assign(l, u.overrides);
          }
          u.cast = Object.assign({}, f.cast, u.cast);
          const p = Object.assign({}, f.manifest, u.manifest);
          return p.build = o.build(u.manifest && u.manifest.build, f.manifest && f.manifest.build), u.manifest = p, u.rebuild = o.rebuild(u.rebuild, f.rebuild), c;
        }, o.build = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            return t3(e3(r2, s2), s2);
          } : e3 || t3;
        }, o.coerce = function(e3, t3) {
          return e3 && t3 ? { from: e3.from && t3.from ? [.../* @__PURE__ */ new Set([...e3.from, ...t3.from])] : null, method(r2, s2) {
            let n2;
            if ((!t3.from || t3.from.includes(typeof r2)) && (n2 = t3.method(r2, s2), n2)) {
              if (n2.errors || void 0 === n2.value) return n2;
              r2 = n2.value;
            }
            if (!e3.from || e3.from.includes(typeof r2)) {
              const t4 = e3.method(r2, s2);
              if (t4) return t4;
            }
            return n2;
          } } : e3 || t3;
        }, o.prepare = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            const n2 = e3(r2, s2);
            if (n2) {
              if (n2.errors || void 0 === n2.value) return n2;
              r2 = n2.value;
            }
            return t3(r2, s2) || n2;
          } : e3 || t3;
        }, o.rebuild = function(e3, t3) {
          return e3 && t3 ? function(r2) {
            t3(r2), e3(r2);
          } : e3 || t3;
        }, o.validate = function(e3, t3) {
          return e3 && t3 ? function(r2, s2) {
            const n2 = t3(r2, s2);
            if (n2) {
              if (n2.errors && (!Array.isArray(n2.errors) || n2.errors.length)) return n2;
              r2 = n2.value;
            }
            return e3(r2, s2) || n2;
          } : e3 || t3;
        };
      }, 5107: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(8652), i = r(8160), o = r(3292), l = r(6354), c = r(8901), u = r(9708), f = r(6133), m = r(3328), h = r(1152);
        let d;
        const p = { types: { alternatives: r(4946), any: r(8068), array: r(546), boolean: r(4937), date: r(7500), function: r(390), link: r(8785), number: r(3832), object: r(8966), string: r(7417), symbol: r(8826) }, aliases: { alt: "alternatives", bool: "boolean", func: "function" }, root: function() {
          const e3 = { _types: new Set(Object.keys(p.types)) };
          for (const t3 of e3._types) e3[t3] = function(...e4) {
            return s(!e4.length || ["alternatives", "link", "object"].includes(t3), "The", t3, "type does not allow arguments"), p.generate(this, p.types[t3], e4);
          };
          for (const t3 of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) e3[t3] = function(...e4) {
            return this.any()[t3](...e4);
          };
          Object.assign(e3, p.methods);
          for (const t3 in p.aliases) {
            const r2 = p.aliases[t3];
            e3[t3] = e3[r2];
          }
          return e3.x = e3.expression, h.setup && h.setup(e3), e3;
        } };
        p.methods = { ValidationError: l.ValidationError, version: i.version, cache: a.provider, assert(e3, t3, ...r2) {
          p.assert(e3, t3, true, r2);
        }, attempt: (e3, t3, ...r2) => p.assert(e3, t3, false, r2), build(e3) {
          return s("function" == typeof u.build, "Manifest functionality disabled"), u.build(this, e3);
        }, checkPreferences(e3) {
          i.checkPreferences(e3);
        }, compile(e3, t3) {
          return o.compile(this, e3, t3);
        }, defaults(e3) {
          s("function" == typeof e3, "modifier must be a function");
          const t3 = Object.assign({}, this);
          for (const r2 of t3._types) {
            const n2 = e3(t3[r2]());
            s(i.isSchema(n2), "modifier must return a valid schema object"), t3[r2] = function(...e4) {
              return p.generate(this, n2, e4);
            };
          }
          return t3;
        }, expression: (...e3) => new m(...e3), extend(...e3) {
          i.verifyFlat(e3, "extend"), d = d || r(3378), s(e3.length, "You need to provide at least one extension"), this.assert(e3, d.extensions);
          const t3 = Object.assign({}, this);
          t3._types = new Set(t3._types);
          for (let r2 of e3) {
            "function" == typeof r2 && (r2 = r2(t3)), this.assert(r2, d.extension);
            const e4 = p.expandExtension(r2, t3);
            for (const r3 of e4) {
              s(void 0 === t3[r3.type] || t3._types.has(r3.type), "Cannot override name", r3.type);
              const e5 = r3.base || this.any(), n2 = c.type(e5, r3);
              t3._types.add(r3.type), t3[r3.type] = function(...e6) {
                return p.generate(this, n2, e6);
              };
            }
          }
          return t3;
        }, isError: l.ValidationError.isError, isExpression: m.isTemplate, isRef: f.isRef, isSchema: i.isSchema, in: (...e3) => f.in(...e3), override: i.symbols.override, ref: (...e3) => f.create(...e3), types() {
          const e3 = {};
          for (const t3 of this._types) e3[t3] = this[t3]();
          for (const t3 in p.aliases) e3[t3] = this[t3]();
          return e3;
        } }, p.assert = function(e3, t3, r2, s2) {
          const a2 = s2[0] instanceof Error || "string" == typeof s2[0] ? s2[0] : null, o2 = null !== a2 ? s2[1] : s2[0], c2 = t3.validate(e3, i.preferences({ errors: { stack: true } }, o2 || {}));
          let u2 = c2.error;
          if (!u2) return c2.value;
          if (a2 instanceof Error) throw a2;
          const f2 = r2 && "function" == typeof u2.annotate ? u2.annotate() : u2.message;
          throw u2 instanceof l.ValidationError == 0 && (u2 = n(u2)), u2.message = a2 ? `${a2} ${f2}` : f2, u2;
        }, p.generate = function(e3, t3, r2) {
          return s(e3, "Must be invoked on a Joi instance."), t3.$_root = e3, t3._definition.args && r2.length ? t3._definition.args(t3, ...r2) : t3;
        }, p.expandExtension = function(e3, t3) {
          if ("string" == typeof e3.type) return [e3];
          const r2 = [];
          for (const s2 of t3._types) if (e3.type.test(s2)) {
            const n2 = Object.assign({}, e3);
            n2.type = s2, n2.base = t3[s2](), r2.push(n2);
          }
          return r2;
        }, e2.exports = p.root();
      }, 6914: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(3328);
        t2.compile = function(e3, t3) {
          if ("string" == typeof e3) return s(!t3, "Cannot set single message string"), new a(e3);
          if (a.isTemplate(e3)) return s(!t3, "Cannot set single message template"), e3;
          s("object" == typeof e3 && !Array.isArray(e3), "Invalid message options"), t3 = t3 ? n(t3) : {};
          for (let r2 in e3) {
            const n2 = e3[r2];
            if ("root" === r2 || a.isTemplate(n2)) {
              t3[r2] = n2;
              continue;
            }
            if ("string" == typeof n2) {
              t3[r2] = new a(n2);
              continue;
            }
            s("object" == typeof n2 && !Array.isArray(n2), "Invalid message for", r2);
            const i = r2;
            for (r2 in t3[i] = t3[i] || {}, n2) {
              const e4 = n2[r2];
              "root" === r2 || a.isTemplate(e4) ? t3[i][r2] = e4 : (s("string" == typeof e4, "Invalid message for", r2, "in", i), t3[i][r2] = new a(e4));
            }
          }
          return t3;
        }, t2.decompile = function(e3) {
          const t3 = {};
          for (let r2 in e3) {
            const s2 = e3[r2];
            if ("root" === r2) {
              t3.root = s2;
              continue;
            }
            if (a.isTemplate(s2)) {
              t3[r2] = s2.describe({ compact: true });
              continue;
            }
            const n2 = r2;
            for (r2 in t3[n2] = {}, s2) {
              const e4 = s2[r2];
              "root" !== r2 ? t3[n2][r2] = e4.describe({ compact: true }) : t3[n2].root = e4;
            }
          }
          return t3;
        }, t2.merge = function(e3, r2) {
          if (!e3) return t2.compile(r2);
          if (!r2) return e3;
          if ("string" == typeof r2) return new a(r2);
          if (a.isTemplate(r2)) return r2;
          const i = n(e3);
          for (let e4 in r2) {
            const t3 = r2[e4];
            if ("root" === e4 || a.isTemplate(t3)) {
              i[e4] = t3;
              continue;
            }
            if ("string" == typeof t3) {
              i[e4] = new a(t3);
              continue;
            }
            s("object" == typeof t3 && !Array.isArray(t3), "Invalid message for", e4);
            const n2 = e4;
            for (e4 in i[n2] = i[n2] || {}, t3) {
              const r3 = t3[e4];
              "root" === e4 || a.isTemplate(r3) ? i[n2][e4] = r3 : (s("string" == typeof r3, "Invalid message for", e4, "in", n2), i[n2][e4] = new a(r3));
            }
          }
          return i;
        };
      }, 2294: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8160), a = r(6133), i = {};
        t2.Ids = i.Ids = class {
          constructor() {
            this._byId = /* @__PURE__ */ new Map(), this._byKey = /* @__PURE__ */ new Map(), this._schemaChain = false;
          }
          clone() {
            const e3 = new i.Ids();
            return e3._byId = new Map(this._byId), e3._byKey = new Map(this._byKey), e3._schemaChain = this._schemaChain, e3;
          }
          concat(e3) {
            e3._schemaChain && (this._schemaChain = true);
            for (const [t3, r2] of e3._byId.entries()) s(!this._byKey.has(t3), "Schema id conflicts with existing key:", t3), this._byId.set(t3, r2);
            for (const [t3, r2] of e3._byKey.entries()) s(!this._byId.has(t3), "Schema key conflicts with existing id:", t3), this._byKey.set(t3, r2);
          }
          fork(e3, t3, r2) {
            const a2 = this._collect(e3);
            a2.push({ schema: r2 });
            const o = a2.shift();
            let l = { id: o.id, schema: t3(o.schema) };
            s(n.isSchema(l.schema), "adjuster function failed to return a joi schema type");
            for (const e4 of a2) l = { id: e4.id, schema: i.fork(e4.schema, l.id, l.schema) };
            return l.schema;
          }
          labels(e3, t3 = []) {
            const r2 = e3[0], s2 = this._get(r2);
            if (!s2) return [...t3, ...e3].join(".");
            const n2 = e3.slice(1);
            return t3 = [...t3, s2.schema._flags.label || r2], n2.length ? s2.schema._ids.labels(n2, t3) : t3.join(".");
          }
          reach(e3, t3 = []) {
            const r2 = e3[0], n2 = this._get(r2);
            s(n2, "Schema does not contain path", [...t3, ...e3].join("."));
            const a2 = e3.slice(1);
            return a2.length ? n2.schema._ids.reach(a2, [...t3, r2]) : n2.schema;
          }
          register(e3, { key: t3 } = {}) {
            if (!e3 || !n.isSchema(e3)) return;
            (e3.$_property("schemaChain") || e3._ids._schemaChain) && (this._schemaChain = true);
            const r2 = e3._flags.id;
            if (r2) {
              const t4 = this._byId.get(r2);
              s(!t4 || t4.schema === e3, "Cannot add different schemas with the same id:", r2), s(!this._byKey.has(r2), "Schema id conflicts with existing key:", r2), this._byId.set(r2, { schema: e3, id: r2 });
            }
            t3 && (s(!this._byKey.has(t3), "Schema already contains key:", t3), s(!this._byId.has(t3), "Schema key conflicts with existing id:", t3), this._byKey.set(t3, { schema: e3, id: t3 }));
          }
          reset() {
            this._byId = /* @__PURE__ */ new Map(), this._byKey = /* @__PURE__ */ new Map(), this._schemaChain = false;
          }
          _collect(e3, t3 = [], r2 = []) {
            const n2 = e3[0], a2 = this._get(n2);
            s(a2, "Schema does not contain path", [...t3, ...e3].join(".")), r2 = [a2, ...r2];
            const i2 = e3.slice(1);
            return i2.length ? a2.schema._ids._collect(i2, [...t3, n2], r2) : r2;
          }
          _get(e3) {
            return this._byId.get(e3) || this._byKey.get(e3);
          }
        }, i.fork = function(e3, r2, s2) {
          const n2 = t2.schema(e3, { each: (e4, { key: t3 }) => {
            if (r2 === (e4._flags.id || t3)) return s2;
          }, ref: false });
          return n2 ? n2.$_mutateRebuild() : e3;
        }, t2.schema = function(e3, t3) {
          let r2;
          for (const s2 in e3._flags) {
            if ("_" === s2[0]) continue;
            const n2 = i.scan(e3._flags[s2], { source: "flags", name: s2 }, t3);
            void 0 !== n2 && (r2 = r2 || e3.clone(), r2._flags[s2] = n2);
          }
          for (let s2 = 0; s2 < e3._rules.length; ++s2) {
            const n2 = e3._rules[s2], a2 = i.scan(n2.args, { source: "rules", name: n2.name }, t3);
            if (void 0 !== a2) {
              r2 = r2 || e3.clone();
              const t4 = Object.assign({}, n2);
              t4.args = a2, r2._rules[s2] = t4, r2._singleRules.get(n2.name) === n2 && r2._singleRules.set(n2.name, t4);
            }
          }
          for (const s2 in e3.$_terms) {
            if ("_" === s2[0]) continue;
            const n2 = i.scan(e3.$_terms[s2], { source: "terms", name: s2 }, t3);
            void 0 !== n2 && (r2 = r2 || e3.clone(), r2.$_terms[s2] = n2);
          }
          return r2;
        }, i.scan = function(e3, t3, r2, s2, o) {
          const l = s2 || [];
          if (null === e3 || "object" != typeof e3) return;
          let c;
          if (Array.isArray(e3)) {
            for (let s3 = 0; s3 < e3.length; ++s3) {
              const n2 = "terms" === t3.source && "keys" === t3.name && e3[s3].key, a2 = i.scan(e3[s3], t3, r2, [s3, ...l], n2);
              void 0 !== a2 && (c = c || e3.slice(), c[s3] = a2);
            }
            return c;
          }
          if (false !== r2.schema && n.isSchema(e3) || false !== r2.ref && a.isRef(e3)) {
            const s3 = r2.each(e3, { ...t3, path: l, key: o });
            if (s3 === e3) return;
            return s3;
          }
          for (const s3 in e3) {
            if ("_" === s3[0]) continue;
            const n2 = i.scan(e3[s3], t3, r2, [s3, ...l], o);
            void 0 !== n2 && (c = c || Object.assign({}, e3), c[s3] = n2);
          }
          return c;
        };
      }, 6133: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(9621), i = r(8160);
        let o;
        const l = { symbol: Symbol("ref"), defaults: { adjust: null, in: false, iterables: null, map: null, separator: ".", type: "value" } };
        t2.create = function(e3, t3 = {}) {
          s("string" == typeof e3, "Invalid reference key:", e3), i.assertOptions(t3, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), s(!t3.prefix || "object" == typeof t3.prefix, "options.prefix must be of type object");
          const r2 = Object.assign({}, l.defaults, t3);
          delete r2.prefix;
          const n2 = r2.separator, a2 = l.context(e3, n2, t3.prefix);
          if (r2.type = a2.type, e3 = a2.key, "value" === r2.type) if (a2.root && (s(!n2 || e3[0] !== n2, "Cannot specify relative path with root prefix"), r2.ancestor = "root", e3 || (e3 = null)), n2 && n2 === e3) e3 = null, r2.ancestor = 0;
          else if (void 0 !== r2.ancestor) s(!n2 || !e3 || e3[0] !== n2, "Cannot combine prefix with ancestor option");
          else {
            const [t4, s2] = l.ancestor(e3, n2);
            s2 && "" === (e3 = e3.slice(s2)) && (e3 = null), r2.ancestor = t4;
          }
          return r2.path = n2 ? null === e3 ? [] : e3.split(n2) : [e3], new l.Ref(r2);
        }, t2.in = function(e3, r2 = {}) {
          return t2.create(e3, { ...r2, in: true });
        }, t2.isRef = function(e3) {
          return !!e3 && !!e3[i.symbols.ref];
        }, l.Ref = class {
          constructor(e3) {
            s("object" == typeof e3, "Invalid reference construction"), i.assertOptions(e3, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), s([false, void 0].includes(e3.separator) || "string" == typeof e3.separator && 1 === e3.separator.length, "Invalid separator"), s(!e3.adjust || "function" == typeof e3.adjust, "options.adjust must be a function"), s(!e3.map || Array.isArray(e3.map), "options.map must be an array"), s(!e3.map || !e3.adjust, "Cannot set both map and adjust options"), Object.assign(this, l.defaults, e3), s("value" === this.type || void 0 === this.ancestor, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay();
          }
          resolve(e3, t3, r2, n2, a2 = {}) {
            return s(!this.in || a2.in, "Invalid in() reference usage"), "global" === this.type ? this._resolve(r2.context, t3, a2) : "local" === this.type ? this._resolve(n2, t3, a2) : this.ancestor ? "root" === this.ancestor ? this._resolve(t3.ancestors[t3.ancestors.length - 1], t3, a2) : (s(this.ancestor <= t3.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(t3.ancestors[this.ancestor - 1], t3, a2)) : this._resolve(e3, t3, a2);
          }
          _resolve(e3, t3, r2) {
            let s2;
            if ("value" === this.type && t3.mainstay.shadow && false !== r2.shadow && (s2 = t3.mainstay.shadow.get(this.absolute(t3))), void 0 === s2 && (s2 = a(e3, this.path, { iterables: this.iterables, functions: true })), this.adjust && (s2 = this.adjust(s2)), this.map) {
              const e4 = this.map.get(s2);
              void 0 !== e4 && (s2 = e4);
            }
            return t3.mainstay && t3.mainstay.tracer.resolve(t3, this, s2), s2;
          }
          toString() {
            return this.display;
          }
          absolute(e3) {
            return [...e3.path.slice(0, -this.ancestor), ...this.path];
          }
          clone() {
            return new l.Ref(this);
          }
          describe() {
            const e3 = { path: this.path };
            "value" !== this.type && (e3.type = this.type), "." !== this.separator && (e3.separator = this.separator), "value" === this.type && 1 !== this.ancestor && (e3.ancestor = this.ancestor), this.map && (e3.map = [...this.map]);
            for (const t3 of ["adjust", "iterables", "render"]) null !== this[t3] && void 0 !== this[t3] && (e3[t3] = this[t3]);
            return false !== this.in && (e3.in = true), { ref: e3 };
          }
          updateDisplay() {
            const e3 = null !== this.key ? this.key : "";
            if ("value" !== this.type) return void (this.display = `ref:${this.type}:${e3}`);
            if (!this.separator) return void (this.display = `ref:${e3}`);
            if (!this.ancestor) return void (this.display = `ref:${this.separator}${e3}`);
            if ("root" === this.ancestor) return void (this.display = `ref:root:${e3}`);
            if (1 === this.ancestor) return void (this.display = `ref:${e3 || ".."}`);
            const t3 = new Array(this.ancestor + 1).fill(this.separator).join("");
            this.display = `ref:${t3}${e3 || ""}`;
          }
        }, l.Ref.prototype[i.symbols.ref] = true, t2.build = function(e3) {
          return "value" === (e3 = Object.assign({}, l.defaults, e3)).type && void 0 === e3.ancestor && (e3.ancestor = 1), new l.Ref(e3);
        }, l.context = function(e3, t3, r2 = {}) {
          if (e3 = e3.trim(), r2) {
            const s2 = void 0 === r2.global ? "$" : r2.global;
            if (s2 !== t3 && e3.startsWith(s2)) return { key: e3.slice(s2.length), type: "global" };
            const n2 = void 0 === r2.local ? "#" : r2.local;
            if (n2 !== t3 && e3.startsWith(n2)) return { key: e3.slice(n2.length), type: "local" };
            const a2 = void 0 === r2.root ? "/" : r2.root;
            if (a2 !== t3 && e3.startsWith(a2)) return { key: e3.slice(a2.length), type: "value", root: true };
          }
          return { key: e3, type: "value" };
        }, l.ancestor = function(e3, t3) {
          if (!t3) return [1, 0];
          if (e3[0] !== t3) return [1, 0];
          if (e3[1] !== t3) return [0, 1];
          let r2 = 2;
          for (; e3[r2] === t3; ) ++r2;
          return [r2 - 1, r2];
        }, t2.toSibling = 0, t2.toParent = 1, t2.Manager = class {
          constructor() {
            this.refs = [];
          }
          register(e3, s2) {
            if (e3) if (s2 = void 0 === s2 ? t2.toParent : s2, Array.isArray(e3)) for (const t3 of e3) this.register(t3, s2);
            else if (i.isSchema(e3)) for (const t3 of e3._refs.refs) t3.ancestor - s2 >= 0 && this.refs.push({ ancestor: t3.ancestor - s2, root: t3.root });
            else t2.isRef(e3) && "value" === e3.type && e3.ancestor - s2 >= 0 && this.refs.push({ ancestor: e3.ancestor - s2, root: e3.root }), o = o || r(3328), o.isTemplate(e3) && this.register(e3.refs(), s2);
          }
          get length() {
            return this.refs.length;
          }
          clone() {
            const e3 = new t2.Manager();
            return e3.refs = n(this.refs), e3;
          }
          reset() {
            this.refs = [];
          }
          roots() {
            return this.refs.filter((e3) => !e3.ancestor).map((e3) => e3.root);
          }
        };
      }, 3378: (e2, t2, r) => {
        "use strict";
        const s = r(5107), n = {};
        n.wrap = s.string().min(1).max(2).allow(false), t2.preferences = s.object({ allowUnknown: s.boolean(), abortEarly: s.boolean(), artifacts: s.boolean(), cache: s.boolean(), context: s.object(), convert: s.boolean(), dateFormat: s.valid("date", "iso", "string", "time", "utc"), debug: s.boolean(), errors: { escapeHtml: s.boolean(), label: s.valid("path", "key", false), language: [s.string(), s.object().ref()], render: s.boolean(), stack: s.boolean(), wrap: { label: n.wrap, array: n.wrap, string: n.wrap } }, externals: s.boolean(), messages: s.object(), noDefaults: s.boolean(), nonEnumerables: s.boolean(), presence: s.valid("required", "optional", "forbidden"), skipFunctions: s.boolean(), stripUnknown: s.object({ arrays: s.boolean(), objects: s.boolean() }).or("arrays", "objects").allow(true, false), warnings: s.boolean() }).strict(), n.nameRx = /^[a-zA-Z0-9]\w*$/, n.rule = s.object({ alias: s.array().items(s.string().pattern(n.nameRx)).single(), args: s.array().items(s.string(), s.object({ name: s.string().pattern(n.nameRx).required(), ref: s.boolean(), assert: s.alternatives([s.function(), s.object().schema()]).conditional("ref", { is: true, then: s.required() }), normalize: s.function(), message: s.string().when("assert", { is: s.function(), then: s.required() }) })), convert: s.boolean(), manifest: s.boolean(), method: s.function().allow(false), multi: s.boolean(), validate: s.function() }), t2.extension = s.object({ type: s.alternatives([s.string(), s.object().regex()]).required(), args: s.function(), cast: s.object().pattern(n.nameRx, s.object({ from: s.function().maxArity(1).required(), to: s.function().minArity(1).maxArity(2).required() })), base: s.object().schema().when("type", { is: s.object().regex(), then: s.forbidden() }), coerce: [s.function().maxArity(3), s.object({ method: s.function().maxArity(3).required(), from: s.array().items(s.string()).single() })], flags: s.object().pattern(n.nameRx, s.object({ setter: s.string(), default: s.any() })), manifest: { build: s.function().arity(2) }, messages: [s.object(), s.string()], modifiers: s.object().pattern(n.nameRx, s.function().minArity(1).maxArity(2)), overrides: s.object().pattern(n.nameRx, s.function()), prepare: s.function().maxArity(3), rebuild: s.function().arity(1), rules: s.object().pattern(n.nameRx, n.rule), terms: s.object().pattern(n.nameRx, s.object({ init: s.array().allow(null).required(), manifest: s.object().pattern(/.+/, [s.valid("schema", "single"), s.object({ mapped: s.object({ from: s.string().required(), to: s.string().required() }).required() })]) })), validate: s.function().maxArity(3) }).strict(), t2.extensions = s.array().items(s.object(), s.function().arity(1)).strict(), n.desc = { buffer: s.object({ buffer: s.string() }), func: s.object({ function: s.function().required(), options: { literal: true } }), override: s.object({ override: true }), ref: s.object({ ref: s.object({ type: s.valid("value", "global", "local"), path: s.array().required(), separator: s.string().length(1).allow(false), ancestor: s.number().min(0).integer().allow("root"), map: s.array().items(s.array().length(2)).min(1), adjust: s.function(), iterables: s.boolean(), in: s.boolean(), render: s.boolean() }).required() }), regex: s.object({ regex: s.string().min(3) }), special: s.object({ special: s.valid("deep").required() }), template: s.object({ template: s.string().required(), options: s.object() }), value: s.object({ value: s.alternatives([s.object(), s.array()]).required() }) }, n.desc.entity = s.alternatives([s.array().items(s.link("...")), s.boolean(), s.function(), s.number(), s.string(), n.desc.buffer, n.desc.func, n.desc.ref, n.desc.regex, n.desc.special, n.desc.template, n.desc.value, s.link("/")]), n.desc.values = s.array().items(null, s.boolean(), s.function(), s.number().allow(1 / 0, -1 / 0), s.string().allow(""), s.symbol(), n.desc.buffer, n.desc.func, n.desc.override, n.desc.ref, n.desc.regex, n.desc.template, n.desc.value), n.desc.messages = s.object().pattern(/.+/, [s.string(), n.desc.template, s.object().pattern(/.+/, [s.string(), n.desc.template])]), t2.description = s.object({ type: s.string().required(), flags: s.object({ cast: s.string(), default: s.any(), description: s.string(), empty: s.link("/"), failover: n.desc.entity, id: s.string(), label: s.string(), only: true, presence: ["optional", "required", "forbidden"], result: ["raw", "strip"], strip: s.boolean(), unit: s.string() }).unknown(), preferences: { allowUnknown: s.boolean(), abortEarly: s.boolean(), artifacts: s.boolean(), cache: s.boolean(), convert: s.boolean(), dateFormat: ["date", "iso", "string", "time", "utc"], errors: { escapeHtml: s.boolean(), label: ["path", "key"], language: [s.string(), n.desc.ref], wrap: { label: n.wrap, array: n.wrap } }, externals: s.boolean(), messages: n.desc.messages, noDefaults: s.boolean(), nonEnumerables: s.boolean(), presence: ["required", "optional", "forbidden"], skipFunctions: s.boolean(), stripUnknown: s.object({ arrays: s.boolean(), objects: s.boolean() }).or("arrays", "objects").allow(true, false), warnings: s.boolean() }, allow: n.desc.values, invalid: n.desc.values, rules: s.array().min(1).items({ name: s.string().required(), args: s.object().min(1), keep: s.boolean(), message: [s.string(), n.desc.messages], warn: s.boolean() }), keys: s.object().pattern(/.*/, s.link("/")), link: n.desc.ref }).pattern(/^[a-z]\w*$/, s.any());
      }, 493: (e2, t2, r) => {
        "use strict";
        const s = r(8571), n = r(9621), a = r(8160), i = { value: Symbol("value") };
        e2.exports = i.State = class {
          constructor(e3, t3, r2) {
            this.path = e3, this.ancestors = t3, this.mainstay = r2.mainstay, this.schemas = r2.schemas, this.debug = null;
          }
          localize(e3, t3 = null, r2 = null) {
            const s2 = new i.State(e3, t3, this);
            return r2 && s2.schemas && (s2.schemas = [i.schemas(r2), ...s2.schemas]), s2;
          }
          nest(e3, t3) {
            const r2 = new i.State(this.path, this.ancestors, this);
            return r2.schemas = r2.schemas && [i.schemas(e3), ...r2.schemas], r2.debug = t3, r2;
          }
          shadow(e3, t3) {
            this.mainstay.shadow = this.mainstay.shadow || new i.Shadow(), this.mainstay.shadow.set(this.path, e3, t3);
          }
          snapshot() {
            this.mainstay.shadow && (this._snapshot = s(this.mainstay.shadow.node(this.path))), this.mainstay.snapshot();
          }
          restore() {
            this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0), this.mainstay.restore();
          }
          commit() {
            this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0), this.mainstay.commit();
          }
        }, i.schemas = function(e3) {
          return a.isSchema(e3) ? { schema: e3 } : e3;
        }, i.Shadow = class {
          constructor() {
            this._values = null;
          }
          set(e3, t3, r2) {
            if (!e3.length) return;
            if ("strip" === r2 && "number" == typeof e3[e3.length - 1]) return;
            this._values = this._values || /* @__PURE__ */ new Map();
            let s2 = this._values;
            for (let t4 = 0; t4 < e3.length; ++t4) {
              const r3 = e3[t4];
              let n2 = s2.get(r3);
              n2 || (n2 = /* @__PURE__ */ new Map(), s2.set(r3, n2)), s2 = n2;
            }
            s2[i.value] = t3;
          }
          get(e3) {
            const t3 = this.node(e3);
            if (t3) return t3[i.value];
          }
          node(e3) {
            if (this._values) return n(this._values, e3, { iterables: true });
          }
          override(e3, t3) {
            if (!this._values) return;
            const r2 = e3.slice(0, -1), s2 = e3[e3.length - 1], a2 = n(this._values, r2, { iterables: true });
            t3 ? a2.set(s2, t3) : a2 && a2.delete(s2);
          }
        };
      }, 3328: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(5277), i = r(1447), o = r(8160), l = r(6354), c = r(6133), u = { symbol: Symbol("template"), opens: new Array(1e3).join("\0"), closes: new Array(1e3).join(""), dateFormat: { date: Date.prototype.toDateString, iso: Date.prototype.toISOString, string: Date.prototype.toString, time: Date.prototype.toTimeString, utc: Date.prototype.toUTCString } };
        e2.exports = u.Template = class {
          constructor(e3, t3) {
            if (s("string" == typeof e3, "Template source must be a string"), s(!e3.includes("\0") && !e3.includes(""), "Template source cannot contain reserved control characters"), this.source = e3, this.rendered = e3, this._template = null, t3) {
              const { functions: e4, ...r2 } = t3;
              this._settings = Object.keys(r2).length ? n(r2) : void 0, this._functions = e4, this._functions && (s(Object.keys(this._functions).every((e5) => "string" == typeof e5), "Functions keys must be strings"), s(Object.values(this._functions).every((e5) => "function" == typeof e5), "Functions values must be functions"));
            } else this._settings = void 0, this._functions = void 0;
            this._parse();
          }
          _parse() {
            if (!this.source.includes("{")) return;
            const e3 = u.encode(this.source), t3 = u.split(e3);
            let r2 = false;
            const s2 = [], n2 = t3.shift();
            n2 && s2.push(n2);
            for (const e4 of t3) {
              const t4 = "{" !== e4[0], n3 = t4 ? "}" : "}}", a2 = e4.indexOf(n3);
              if (-1 === a2 || "{" === e4[1]) {
                s2.push(`{${u.decode(e4)}`);
                continue;
              }
              let i2 = e4.slice(t4 ? 0 : 1, a2);
              const o2 = ":" === i2[0];
              o2 && (i2 = i2.slice(1));
              const l2 = this._ref(u.decode(i2), { raw: t4, wrapped: o2 });
              s2.push(l2), "string" != typeof l2 && (r2 = true);
              const c2 = e4.slice(a2 + n3.length);
              c2 && s2.push(u.decode(c2));
            }
            r2 ? this._template = s2 : this.rendered = s2.join("");
          }
          static date(e3, t3) {
            return u.dateFormat[t3.dateFormat].call(e3);
          }
          describe(e3 = {}) {
            if (!this._settings && e3.compact) return this.source;
            const t3 = { template: this.source };
            return this._settings && (t3.options = this._settings), this._functions && (t3.functions = this._functions), t3;
          }
          static build(e3) {
            return new u.Template(e3.template, e3.options || e3.functions ? { ...e3.options, functions: e3.functions } : void 0);
          }
          isDynamic() {
            return !!this._template;
          }
          static isTemplate(e3) {
            return !!e3 && !!e3[o.symbols.template];
          }
          refs() {
            if (!this._template) return;
            const e3 = [];
            for (const t3 of this._template) "string" != typeof t3 && e3.push(...t3.refs);
            return e3;
          }
          resolve(e3, t3, r2, s2) {
            return this._template && 1 === this._template.length ? this._part(this._template[0], e3, t3, r2, s2, {}) : this.render(e3, t3, r2, s2);
          }
          _part(e3, ...t3) {
            return e3.ref ? e3.ref.resolve(...t3) : e3.formula.evaluate(t3);
          }
          render(e3, t3, r2, s2, n2 = {}) {
            if (!this.isDynamic()) return this.rendered;
            const i2 = [];
            for (const o2 of this._template) if ("string" == typeof o2) i2.push(o2);
            else {
              const l2 = this._part(o2, e3, t3, r2, s2, n2), c2 = u.stringify(l2, e3, t3, r2, s2, n2);
              if (void 0 !== c2) {
                const e4 = o2.raw || false === (n2.errors && n2.errors.escapeHtml) ? c2 : a(c2);
                i2.push(u.wrap(e4, o2.wrapped && r2.errors.wrap.label));
              }
            }
            return i2.join("");
          }
          _ref(e3, { raw: t3, wrapped: r2 }) {
            const s2 = [], n2 = (e4) => {
              const t4 = c.create(e4, this._settings);
              return s2.push(t4), (e5) => {
                const r3 = t4.resolve(...e5);
                return void 0 !== r3 ? r3 : null;
              };
            };
            try {
              const t4 = this._functions ? { ...u.functions, ...this._functions } : u.functions;
              var a2 = new i.Parser(e3, { reference: n2, functions: t4, constants: u.constants });
            } catch (t4) {
              throw t4.message = `Invalid template variable "${e3}" fails due to: ${t4.message}`, t4;
            }
            if (a2.single) {
              if ("reference" === a2.single.type) {
                const e4 = s2[0];
                return { ref: e4, raw: t3, refs: s2, wrapped: r2 || "local" === e4.type && "label" === e4.key };
              }
              return u.stringify(a2.single.value);
            }
            return { formula: a2, raw: t3, refs: s2 };
          }
          toString() {
            return this.source;
          }
        }, u.Template.prototype[o.symbols.template] = true, u.Template.prototype.isImmutable = true, u.encode = function(e3) {
          return e3.replace(/\\(\{+)/g, (e4, t3) => u.opens.slice(0, t3.length)).replace(/\\(\}+)/g, (e4, t3) => u.closes.slice(0, t3.length));
        }, u.decode = function(e3) {
          return e3.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
        }, u.split = function(e3) {
          const t3 = [];
          let r2 = "";
          for (let s2 = 0; s2 < e3.length; ++s2) {
            const n2 = e3[s2];
            if ("{" === n2) {
              let n3 = "";
              for (; s2 + 1 < e3.length && "{" === e3[s2 + 1]; ) n3 += "{", ++s2;
              t3.push(r2), r2 = n3;
            } else r2 += n2;
          }
          return t3.push(r2), t3;
        }, u.wrap = function(e3, t3) {
          return t3 ? 1 === t3.length ? `${t3}${e3}${t3}` : `${t3[0]}${e3}${t3[1]}` : e3;
        }, u.stringify = function(e3, t3, r2, s2, n2, a2 = {}) {
          const i2 = typeof e3, o2 = s2 && s2.errors && s2.errors.wrap || {};
          let l2 = false;
          if (c.isRef(e3) && e3.render && (l2 = e3.in, e3 = e3.resolve(t3, r2, s2, n2, { in: e3.in, ...a2 })), null === e3) return "null";
          if ("string" === i2) return u.wrap(e3, a2.arrayItems && o2.string);
          if ("number" === i2 || "function" === i2 || "symbol" === i2) return e3.toString();
          if ("object" !== i2) return JSON.stringify(e3);
          if (e3 instanceof Date) return u.Template.date(e3, s2);
          if (e3 instanceof Map) {
            const t4 = [];
            for (const [r3, s3] of e3.entries()) t4.push(`${r3.toString()} -> ${s3.toString()}`);
            e3 = t4;
          }
          if (!Array.isArray(e3)) return e3.toString();
          const f = [];
          for (const i3 of e3) f.push(u.stringify(i3, t3, r2, s2, n2, { arrayItems: true, ...a2 }));
          return u.wrap(f.join(", "), !l2 && o2.array);
        }, u.constants = { true: true, false: false, null: null, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }, u.functions = { if: (e3, t3, r2) => e3 ? t3 : r2, length: (e3) => "string" == typeof e3 ? e3.length : e3 && "object" == typeof e3 ? Array.isArray(e3) ? e3.length : Object.keys(e3).length : null, msg(e3) {
          const [t3, r2, s2, n2, a2] = this, i2 = a2.messages;
          if (!i2) return "";
          const o2 = l.template(t3, i2[0], e3, r2, s2) || l.template(t3, i2[1], e3, r2, s2);
          return o2 ? o2.render(t3, r2, s2, n2, a2) : "";
        }, number: (e3) => "number" == typeof e3 ? e3 : "string" == typeof e3 ? parseFloat(e3) : "boolean" == typeof e3 ? e3 ? 1 : 0 : e3 instanceof Date ? e3.getTime() : null };
      }, 4946: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(1687), a = r(8068), i = r(8160), o = r(3292), l = r(6354), c = r(6133), u = {};
        e2.exports = a.extend({ type: "alternatives", flags: { match: { default: "any" } }, terms: { matches: { init: [], register: c.toSibling } }, args: (e3, ...t3) => 1 === t3.length && Array.isArray(t3[0]) ? e3.try(...t3[0]) : e3.try(...t3), validate(e3, t3) {
          const { schema: r2, error: s2, state: a2, prefs: i2 } = t3;
          if (r2._flags.match) {
            const t4 = [], o3 = [];
            for (let s3 = 0; s3 < r2.$_terms.matches.length; ++s3) {
              const n2 = r2.$_terms.matches[s3], l2 = a2.nest(n2.schema, `match.${s3}`);
              l2.snapshot();
              const c3 = n2.schema.$_validate(e3, l2, i2);
              c3.errors ? (o3.push(c3.errors), l2.restore()) : (t4.push(c3.value), l2.commit());
            }
            if (0 === t4.length) return { errors: s2("alternatives.any", { details: o3.map((e4) => l.details(e4, { override: false })) }) };
            if ("one" === r2._flags.match) return 1 === t4.length ? { value: t4[0] } : { errors: s2("alternatives.one") };
            if (t4.length !== r2.$_terms.matches.length) return { errors: s2("alternatives.all", { details: o3.map((e4) => l.details(e4, { override: false })) }) };
            const c2 = (e4) => e4.$_terms.matches.some((e5) => "object" === e5.schema.type || "alternatives" === e5.schema.type && c2(e5.schema));
            return c2(r2) ? { value: t4.reduce((e4, t5) => n(e4, t5, { mergeArrays: false })) } : { value: t4[t4.length - 1] };
          }
          const o2 = [];
          for (let t4 = 0; t4 < r2.$_terms.matches.length; ++t4) {
            const s3 = r2.$_terms.matches[t4];
            if (s3.schema) {
              const r3 = a2.nest(s3.schema, `match.${t4}`);
              r3.snapshot();
              const n3 = s3.schema.$_validate(e3, r3, i2);
              if (!n3.errors) return r3.commit(), n3;
              r3.restore(), o2.push({ schema: s3.schema, reports: n3.errors });
              continue;
            }
            const n2 = s3.ref ? s3.ref.resolve(e3, a2, i2) : e3, l2 = s3.is ? [s3] : s3.switch;
            for (let r3 = 0; r3 < l2.length; ++r3) {
              const o3 = l2[r3], { is: c2, then: u2, otherwise: f } = o3, m = `match.${t4}${s3.switch ? "." + r3 : ""}`;
              if (c2.$_match(n2, a2.nest(c2, `${m}.is`), i2)) {
                if (u2) return u2.$_validate(e3, a2.nest(u2, `${m}.then`), i2);
              } else if (f) return f.$_validate(e3, a2.nest(f, `${m}.otherwise`), i2);
            }
          }
          return u.errors(o2, t3);
        }, rules: { conditional: { method(e3, t3) {
          s(!this._flags._endedSwitch, "Unreachable condition"), s(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), s(void 0 === t3.break, "Cannot use break option with alternatives conditional");
          const r2 = this.clone(), n2 = o.when(r2, e3, t3), a2 = n2.is ? [n2] : n2.switch;
          for (const e4 of a2) if (e4.then && e4.otherwise) {
            r2.$_setFlag("_endedSwitch", true, { clone: false });
            break;
          }
          return r2.$_terms.matches.push(n2), r2.$_mutateRebuild();
        } }, match: { method(e3) {
          if (s(["any", "one", "all"].includes(e3), "Invalid alternatives match mode", e3), "any" !== e3) for (const t3 of this.$_terms.matches) s(t3.schema, "Cannot combine match mode", e3, "with conditional rules");
          return this.$_setFlag("match", e3);
        } }, try: { method(...e3) {
          s(e3.length, "Missing alternative schemas"), i.verifyFlat(e3, "try"), s(!this._flags._endedSwitch, "Unreachable condition");
          const t3 = this.clone();
          for (const r2 of e3) t3.$_terms.matches.push({ schema: t3.$_compile(r2) });
          return t3.$_mutateRebuild();
        } } }, overrides: { label(e3) {
          return this.$_parent("label", e3).$_modify({ each: (t3, r2) => "is" !== r2.path[0] && "string" != typeof t3._flags.label ? t3.label(e3) : void 0, ref: false });
        } }, rebuild(e3) {
          e3.$_modify({ each: (t3) => {
            i.isSchema(t3) && "array" === t3.type && e3.$_setFlag("_arrayItems", true, { clone: false });
          } });
        }, manifest: { build(e3, t3) {
          if (t3.matches) for (const r2 of t3.matches) {
            const { schema: t4, ref: s2, is: n2, not: a2, then: i2, otherwise: o2 } = r2;
            e3 = t4 ? e3.try(t4) : s2 ? e3.conditional(s2, { is: n2, then: i2, not: a2, otherwise: o2, switch: r2.switch }) : e3.conditional(n2, { then: i2, otherwise: o2 });
          }
          return e3;
        } }, messages: { "alternatives.all": "{{#label}} does not match all of the required types", "alternatives.any": "{{#label}} does not match any of the allowed types", "alternatives.match": "{{#label}} does not match any of the allowed types", "alternatives.one": "{{#label}} matches more than one allowed type", "alternatives.types": "{{#label}} must be one of {{#types}}" } }), u.errors = function(e3, { error: t3, state: r2 }) {
          if (!e3.length) return { errors: t3("alternatives.any") };
          if (1 === e3.length) return { errors: e3[0].reports };
          const s2 = /* @__PURE__ */ new Set(), n2 = [];
          for (const { reports: a2, schema: i2 } of e3) {
            if (a2.length > 1) return u.unmatched(e3, t3);
            const o2 = a2[0];
            if (o2 instanceof l.Report == 0) return u.unmatched(e3, t3);
            if (o2.state.path.length !== r2.path.length) {
              n2.push({ type: i2.type, report: o2 });
              continue;
            }
            if ("any.only" === o2.code) {
              for (const e4 of o2.local.valids) s2.add(e4);
              continue;
            }
            const [c2, f] = o2.code.split(".");
            "base" !== f ? n2.push({ type: i2.type, report: o2 }) : "object.base" === o2.code ? s2.add(o2.local.type) : s2.add(c2);
          }
          return n2.length ? 1 === n2.length ? { errors: n2[0].report } : u.unmatched(e3, t3) : { errors: t3("alternatives.types", { types: [...s2] }) };
        }, u.unmatched = function(e3, t3) {
          const r2 = [];
          for (const t4 of e3) r2.push(...t4.reports);
          return { errors: t3("alternatives.match", l.details(r2, { override: false })) };
        };
      }, 8068: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(7629), a = r(8160), i = r(6914);
        e2.exports = n.extend({ type: "any", flags: { only: { default: false } }, terms: { alterations: { init: null }, examples: { init: null }, externals: { init: null }, metas: { init: [] }, notes: { init: [] }, shared: { init: null }, tags: { init: [] }, whens: { init: null } }, rules: { custom: { method(e3, t3) {
          return s("function" == typeof e3, "Method must be a function"), s(void 0 === t3 || t3 && "string" == typeof t3, "Description must be a non-empty string"), this.$_addRule({ name: "custom", args: { method: e3, description: t3 } });
        }, validate(e3, t3, { method: r2 }) {
          try {
            return r2(e3, t3);
          } catch (e4) {
            return t3.error("any.custom", { error: e4 });
          }
        }, args: ["method", "description"], multi: true }, messages: { method(e3) {
          return this.prefs({ messages: e3 });
        } }, shared: { method(e3) {
          s(a.isSchema(e3) && e3._flags.id, "Schema must be a schema with an id");
          const t3 = this.clone();
          return t3.$_terms.shared = t3.$_terms.shared || [], t3.$_terms.shared.push(e3), t3.$_mutateRegister(e3), t3;
        } }, warning: { method(e3, t3) {
          return s(e3 && "string" == typeof e3, "Invalid warning code"), this.$_addRule({ name: "warning", args: { code: e3, local: t3 }, warn: true });
        }, validate: (e3, t3, { code: r2, local: s2 }) => t3.error(r2, s2), args: ["code", "local"], multi: true } }, modifiers: { keep(e3, t3 = true) {
          e3.keep = t3;
        }, message(e3, t3) {
          e3.message = i.compile(t3);
        }, warn(e3, t3 = true) {
          e3.warn = t3;
        } }, manifest: { build(e3, t3) {
          for (const r2 in t3) {
            const s2 = t3[r2];
            if (["examples", "externals", "metas", "notes", "tags"].includes(r2)) for (const t4 of s2) e3 = e3[r2.slice(0, -1)](t4);
            else if ("alterations" !== r2) if ("whens" !== r2) {
              if ("shared" === r2) for (const t4 of s2) e3 = e3.shared(t4);
            } else for (const t4 of s2) {
              const { ref: r3, is: s3, not: n2, then: a2, otherwise: i2, concat: o } = t4;
              e3 = o ? e3.concat(o) : r3 ? e3.when(r3, { is: s3, not: n2, then: a2, otherwise: i2, switch: t4.switch, break: t4.break }) : e3.when(s3, { then: a2, otherwise: i2, break: t4.break });
            }
            else {
              const t4 = {};
              for (const { target: e4, adjuster: r3 } of s2) t4[e4] = r3;
              e3 = e3.alter(t4);
            }
          }
          return e3;
        } }, messages: { "any.custom": "{{#label}} failed custom validation because {{#error.message}}", "any.default": "{{#label}} threw an error when running default method", "any.failover": "{{#label}} threw an error when running failover method", "any.invalid": "{{#label}} contains an invalid value", "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}', "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}", "any.required": "{{#label}} is required", "any.unknown": "{{#label}} is not allowed" } });
      }, 546: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(9474), a = r(9621), i = r(8068), o = r(8160), l = r(3292), c = {};
        e2.exports = i.extend({ type: "array", flags: { single: { default: false }, sparse: { default: false } }, terms: { items: { init: [], manifest: "schema" }, ordered: { init: [], manifest: "schema" }, _exclusions: { init: [] }, _inclusions: { init: [] }, _requireds: { init: [] } }, coerce: { from: "object", method(e3, { schema: t3, state: r2, prefs: s2 }) {
          if (!Array.isArray(e3)) return;
          const n2 = t3.$_getRule("sort");
          return n2 ? c.sort(t3, e3, n2.args.options, r2, s2) : void 0;
        } }, validate(e3, { schema: t3, error: r2 }) {
          if (!Array.isArray(e3)) {
            if (t3._flags.single) {
              const t4 = [e3];
              return t4[o.symbols.arraySingle] = true, { value: t4 };
            }
            return { errors: r2("array.base") };
          }
          if (t3.$_getRule("items") || t3.$_terms.externals) return { value: e3.slice() };
        }, rules: { has: { method(e3) {
          e3 = this.$_compile(e3, { appendPath: true });
          const t3 = this.$_addRule({ name: "has", args: { schema: e3 } });
          return t3.$_mutateRegister(e3), t3;
        }, validate(e3, { state: t3, prefs: r2, error: s2 }, { schema: n2 }) {
          const a2 = [e3, ...t3.ancestors];
          for (let s3 = 0; s3 < e3.length; ++s3) {
            const i3 = t3.localize([...t3.path, s3], a2, n2);
            if (n2.$_match(e3[s3], i3, r2)) return e3;
          }
          const i2 = n2._flags.label;
          return i2 ? s2("array.hasKnown", { patternLabel: i2 }) : s2("array.hasUnknown", null);
        }, multi: true }, items: { method(...e3) {
          o.verifyFlat(e3, "items");
          const t3 = this.$_addRule("items");
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const s2 = o.tryWithPath(() => this.$_compile(e3[r2]), r2, { append: true });
            t3.$_terms.items.push(s2);
          }
          return t3.$_mutateRebuild();
        }, validate(e3, { schema: t3, error: r2, state: s2, prefs: n2, errorsArray: a2 }) {
          const i2 = t3.$_terms._requireds.slice(), l2 = t3.$_terms.ordered.slice(), u = [...t3.$_terms._inclusions, ...i2], f = !e3[o.symbols.arraySingle];
          delete e3[o.symbols.arraySingle];
          const m = a2();
          let h = e3.length;
          for (let a3 = 0; a3 < h; ++a3) {
            const o2 = e3[a3];
            let d = false, p = false;
            const g = f ? a3 : new Number(a3), y = [...s2.path, g];
            if (!t3._flags.sparse && void 0 === o2) {
              if (m.push(r2("array.sparse", { key: g, path: y, pos: a3, value: void 0 }, s2.localize(y))), n2.abortEarly) return m;
              l2.shift();
              continue;
            }
            const b = [e3, ...s2.ancestors];
            for (const e4 of t3.$_terms._exclusions) if (e4.$_match(o2, s2.localize(y, b, e4), n2, { presence: "ignore" })) {
              if (m.push(r2("array.excludes", { pos: a3, value: o2 }, s2.localize(y))), n2.abortEarly) return m;
              d = true, l2.shift();
              break;
            }
            if (d) continue;
            if (t3.$_terms.ordered.length) {
              if (l2.length) {
                const i3 = l2.shift(), u2 = i3.$_validate(o2, s2.localize(y, b, i3), n2);
                if (u2.errors) {
                  if (m.push(...u2.errors), n2.abortEarly) return m;
                } else if ("strip" === i3._flags.result) c.fastSplice(e3, a3), --a3, --h;
                else {
                  if (!t3._flags.sparse && void 0 === u2.value) {
                    if (m.push(r2("array.sparse", { key: g, path: y, pos: a3, value: void 0 }, s2.localize(y))), n2.abortEarly) return m;
                    continue;
                  }
                  e3[a3] = u2.value;
                }
                continue;
              }
              if (!t3.$_terms.items.length) {
                if (m.push(r2("array.orderedLength", { pos: a3, limit: t3.$_terms.ordered.length })), n2.abortEarly) return m;
                break;
              }
            }
            const v = [];
            let _ = i2.length;
            for (let l3 = 0; l3 < _; ++l3) {
              const u2 = s2.localize(y, b, i2[l3]);
              u2.snapshot();
              const f2 = i2[l3].$_validate(o2, u2, n2);
              if (v[l3] = f2, !f2.errors) {
                if (u2.commit(), e3[a3] = f2.value, p = true, c.fastSplice(i2, l3), --l3, --_, !t3._flags.sparse && void 0 === f2.value && (m.push(r2("array.sparse", { key: g, path: y, pos: a3, value: void 0 }, s2.localize(y))), n2.abortEarly)) return m;
                break;
              }
              u2.restore();
            }
            if (p) continue;
            const w = n2.stripUnknown && !!n2.stripUnknown.arrays || false;
            _ = u.length;
            for (const l3 of u) {
              let u2;
              const f2 = i2.indexOf(l3);
              if (-1 !== f2) u2 = v[f2];
              else {
                const i3 = s2.localize(y, b, l3);
                if (i3.snapshot(), u2 = l3.$_validate(o2, i3, n2), !u2.errors) {
                  i3.commit(), "strip" === l3._flags.result ? (c.fastSplice(e3, a3), --a3, --h) : t3._flags.sparse || void 0 !== u2.value ? e3[a3] = u2.value : (m.push(r2("array.sparse", { key: g, path: y, pos: a3, value: void 0 }, s2.localize(y))), d = true), p = true;
                  break;
                }
                i3.restore();
              }
              if (1 === _) {
                if (w) {
                  c.fastSplice(e3, a3), --a3, --h, p = true;
                  break;
                }
                if (m.push(...u2.errors), n2.abortEarly) return m;
                d = true;
                break;
              }
            }
            if (!d && (t3.$_terms._inclusions.length || t3.$_terms._requireds.length) && !p) {
              if (w) {
                c.fastSplice(e3, a3), --a3, --h;
                continue;
              }
              if (m.push(r2("array.includes", { pos: a3, value: o2 }, s2.localize(y))), n2.abortEarly) return m;
            }
          }
          return i2.length && c.fillMissedErrors(t3, m, i2, e3, s2, n2), l2.length && (c.fillOrderedErrors(t3, m, l2, e3, s2, n2), m.length || c.fillDefault(l2, e3, s2, n2)), m.length ? m : e3;
        }, priority: true, manifest: false }, length: { method(e3) {
          return this.$_addRule({ name: "length", args: { limit: e3 }, operator: "=" });
        }, validate: (e3, t3, { limit: r2 }, { name: s2, operator: n2, args: a2 }) => o.compare(e3.length, r2, n2) ? e3 : t3.error("array." + s2, { limit: a2.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: o.limit, message: "must be a positive integer" }] }, max: { method(e3) {
          return this.$_addRule({ name: "max", method: "length", args: { limit: e3 }, operator: "<=" });
        } }, min: { method(e3) {
          return this.$_addRule({ name: "min", method: "length", args: { limit: e3 }, operator: ">=" });
        } }, ordered: { method(...e3) {
          o.verifyFlat(e3, "ordered");
          const t3 = this.$_addRule("items");
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const s2 = o.tryWithPath(() => this.$_compile(e3[r2]), r2, { append: true });
            c.validateSingle(s2, t3), t3.$_mutateRegister(s2), t3.$_terms.ordered.push(s2);
          }
          return t3.$_mutateRebuild();
        } }, single: { method(e3) {
          const t3 = void 0 === e3 || !!e3;
          return s(!t3 || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", t3);
        } }, sort: { method(e3 = {}) {
          o.assertOptions(e3, ["by", "order"]);
          const t3 = { order: e3.order || "ascending" };
          return e3.by && (t3.by = l.ref(e3.by, { ancestor: 0 }), s(!t3.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({ name: "sort", args: { options: t3 } });
        }, validate(e3, { error: t3, state: r2, prefs: s2, schema: n2 }, { options: a2 }) {
          const { value: i2, errors: o2 } = c.sort(n2, e3, a2, r2, s2);
          if (o2) return o2;
          for (let r3 = 0; r3 < e3.length; ++r3) if (e3[r3] !== i2[r3]) return t3("array.sort", { order: a2.order, by: a2.by ? a2.by.key : "value" });
          return e3;
        }, convert: true }, sparse: { method(e3) {
          const t3 = void 0 === e3 || !!e3;
          return this._flags.sparse === t3 ? this : (t3 ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", t3, { clone: false });
        } }, unique: { method(e3, t3 = {}) {
          s(!e3 || "function" == typeof e3 || "string" == typeof e3, "comparator must be a function or a string"), o.assertOptions(t3, ["ignoreUndefined", "separator"]);
          const r2 = { name: "unique", args: { options: t3, comparator: e3 } };
          if (e3) if ("string" == typeof e3) {
            const s2 = o.default(t3.separator, ".");
            r2.path = s2 ? e3.split(s2) : [e3];
          } else r2.comparator = e3;
          return this.$_addRule(r2);
        }, validate(e3, { state: t3, error: r2, schema: i2 }, { comparator: o2, options: l2 }, { comparator: c2, path: u }) {
          const f = { string: /* @__PURE__ */ Object.create(null), number: /* @__PURE__ */ Object.create(null), undefined: /* @__PURE__ */ Object.create(null), boolean: /* @__PURE__ */ Object.create(null), bigint: /* @__PURE__ */ Object.create(null), object: /* @__PURE__ */ new Map(), function: /* @__PURE__ */ new Map(), custom: /* @__PURE__ */ new Map() }, m = c2 || n, h = l2.ignoreUndefined;
          for (let n2 = 0; n2 < e3.length; ++n2) {
            const i3 = u ? a(e3[n2], u) : e3[n2], l3 = c2 ? f.custom : f[typeof i3];
            if (s(l3, "Failed to find unique map container for type", typeof i3), l3 instanceof Map) {
              const s2 = l3.entries();
              let a2;
              for (; !(a2 = s2.next()).done; ) if (m(a2.value[0], i3)) {
                const s3 = t3.localize([...t3.path, n2], [e3, ...t3.ancestors]), i4 = { pos: n2, value: e3[n2], dupePos: a2.value[1], dupeValue: e3[a2.value[1]] };
                return u && (i4.path = o2), r2("array.unique", i4, s3);
              }
              l3.set(i3, n2);
            } else {
              if ((!h || void 0 !== i3) && void 0 !== l3[i3]) {
                const s2 = { pos: n2, value: e3[n2], dupePos: l3[i3], dupeValue: e3[l3[i3]] };
                return u && (s2.path = o2), r2("array.unique", s2, t3.localize([...t3.path, n2], [e3, ...t3.ancestors]));
              }
              l3[i3] = n2;
            }
          }
          return e3;
        }, args: ["comparator", "options"], multi: true } }, cast: { set: { from: Array.isArray, to: (e3, t3) => new Set(e3) } }, rebuild(e3) {
          e3.$_terms._inclusions = [], e3.$_terms._exclusions = [], e3.$_terms._requireds = [];
          for (const t3 of e3.$_terms.items) c.validateSingle(t3, e3), "required" === t3._flags.presence ? e3.$_terms._requireds.push(t3) : "forbidden" === t3._flags.presence ? e3.$_terms._exclusions.push(t3) : e3.$_terms._inclusions.push(t3);
          for (const t3 of e3.$_terms.ordered) c.validateSingle(t3, e3);
        }, manifest: { build: (e3, t3) => (t3.items && (e3 = e3.items(...t3.items)), t3.ordered && (e3 = e3.ordered(...t3.ordered)), e3) }, messages: { "array.base": "{{#label}} must be an array", "array.excludes": "{{#label}} contains an excluded value", "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}", "array.hasUnknown": "{{#label}} does not contain at least one required match", "array.includes": "{{#label}} does not match any of the allowed types", "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)", "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}", "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)", "array.length": "{{#label}} must contain {{#limit}} items", "array.max": "{{#label}} must contain less than or equal to {{#limit}} items", "array.min": "{{#label}} must contain at least {{#limit}} items", "array.orderedLength": "{{#label}} must contain at most {{#limit}} items", "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}", "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types", "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}", "array.sparse": "{{#label}} must not be a sparse array item", "array.unique": "{{#label}} contains a duplicate value" } }), c.fillMissedErrors = function(e3, t3, r2, s2, n2, a2) {
          const i2 = [];
          let o2 = 0;
          for (const e4 of r2) {
            const t4 = e4._flags.label;
            t4 ? i2.push(t4) : ++o2;
          }
          i2.length ? o2 ? t3.push(e3.$_createError("array.includesRequiredBoth", s2, { knownMisses: i2, unknownMisses: o2 }, n2, a2)) : t3.push(e3.$_createError("array.includesRequiredKnowns", s2, { knownMisses: i2 }, n2, a2)) : t3.push(e3.$_createError("array.includesRequiredUnknowns", s2, { unknownMisses: o2 }, n2, a2));
        }, c.fillOrderedErrors = function(e3, t3, r2, s2, n2, a2) {
          const i2 = [];
          for (const e4 of r2) "required" === e4._flags.presence && i2.push(e4);
          i2.length && c.fillMissedErrors(e3, t3, i2, s2, n2, a2);
        }, c.fillDefault = function(e3, t3, r2, s2) {
          const n2 = [];
          let a2 = true;
          for (let i2 = e3.length - 1; i2 >= 0; --i2) {
            const o2 = e3[i2], l2 = [t3, ...r2.ancestors], c2 = o2.$_validate(void 0, r2.localize(r2.path, l2, o2), s2).value;
            if (a2) {
              if (void 0 === c2) continue;
              a2 = false;
            }
            n2.unshift(c2);
          }
          n2.length && t3.push(...n2);
        }, c.fastSplice = function(e3, t3) {
          let r2 = t3;
          for (; r2 < e3.length; ) e3[r2++] = e3[r2];
          --e3.length;
        }, c.validateSingle = function(e3, t3) {
          ("array" === e3.type || e3._flags._arrayItems) && (s(!t3._flags.single, "Cannot specify array item with single rule enabled"), t3.$_setFlag("_arrayItems", true, { clone: false }));
        }, c.sort = function(e3, t3, r2, s2, n2) {
          const a2 = "ascending" === r2.order ? 1 : -1, i2 = -1 * a2, o2 = a2, l2 = (l3, u) => {
            let f = c.compare(l3, u, i2, o2);
            if (null !== f) return f;
            if (r2.by && (l3 = r2.by.resolve(l3, s2, n2), u = r2.by.resolve(u, s2, n2)), f = c.compare(l3, u, i2, o2), null !== f) return f;
            const m = typeof l3;
            if (m !== typeof u) throw e3.$_createError("array.sort.mismatching", t3, null, s2, n2);
            if ("number" !== m && "string" !== m) throw e3.$_createError("array.sort.unsupported", t3, { type: m }, s2, n2);
            return "number" === m ? (l3 - u) * a2 : l3 < u ? i2 : o2;
          };
          try {
            return { value: t3.slice().sort(l2) };
          } catch (e4) {
            return { errors: e4 };
          }
        }, c.compare = function(e3, t3, r2, s2) {
          return e3 === t3 ? 0 : void 0 === e3 ? 1 : void 0 === t3 ? -1 : null === e3 ? s2 : null === t3 ? r2 : null;
        };
      }, 4937: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8068), a = r(8160), i = r(2036), o = { isBool: function(e3) {
          return "boolean" == typeof e3;
        } };
        e2.exports = n.extend({ type: "boolean", flags: { sensitive: { default: false } }, terms: { falsy: { init: null, manifest: "values" }, truthy: { init: null, manifest: "values" } }, coerce(e3, { schema: t3 }) {
          if ("boolean" != typeof e3) {
            if ("string" == typeof e3) {
              const r2 = t3._flags.sensitive ? e3 : e3.toLowerCase();
              e3 = "true" === r2 || "false" !== r2 && e3;
            }
            return "boolean" != typeof e3 && (e3 = t3.$_terms.truthy && t3.$_terms.truthy.has(e3, null, null, !t3._flags.sensitive) || (!t3.$_terms.falsy || !t3.$_terms.falsy.has(e3, null, null, !t3._flags.sensitive)) && e3), { value: e3 };
          }
        }, validate(e3, { error: t3 }) {
          if ("boolean" != typeof e3) return { value: e3, errors: t3("boolean.base") };
        }, rules: { truthy: { method(...e3) {
          a.verifyFlat(e3, "truthy");
          const t3 = this.clone();
          t3.$_terms.truthy = t3.$_terms.truthy || new i();
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const n2 = e3[r2];
            s(void 0 !== n2, "Cannot call truthy with undefined"), t3.$_terms.truthy.add(n2);
          }
          return t3;
        } }, falsy: { method(...e3) {
          a.verifyFlat(e3, "falsy");
          const t3 = this.clone();
          t3.$_terms.falsy = t3.$_terms.falsy || new i();
          for (let r2 = 0; r2 < e3.length; ++r2) {
            const n2 = e3[r2];
            s(void 0 !== n2, "Cannot call falsy with undefined"), t3.$_terms.falsy.add(n2);
          }
          return t3;
        } }, sensitive: { method(e3 = true) {
          return this.$_setFlag("sensitive", e3);
        } } }, cast: { number: { from: o.isBool, to: (e3, t3) => e3 ? 1 : 0 }, string: { from: o.isBool, to: (e3, t3) => e3 ? "true" : "false" } }, manifest: { build: (e3, t3) => (t3.truthy && (e3 = e3.truthy(...t3.truthy)), t3.falsy && (e3 = e3.falsy(...t3.falsy)), e3) }, messages: { "boolean.base": "{{#label}} must be a boolean" } });
      }, 7500: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8068), a = r(8160), i = r(3328), o = { isDate: function(e3) {
          return e3 instanceof Date;
        } };
        e2.exports = n.extend({ type: "date", coerce: { from: ["number", "string"], method: (e3, { schema: t3 }) => ({ value: o.parse(e3, t3._flags.format) || e3 }) }, validate(e3, { schema: t3, error: r2, prefs: s2 }) {
          if (e3 instanceof Date && !isNaN(e3.getTime())) return;
          const n2 = t3._flags.format;
          return s2.convert && n2 && "string" == typeof e3 ? { value: e3, errors: r2("date.format", { format: n2 }) } : { value: e3, errors: r2("date.base") };
        }, rules: { compare: { method: false, validate(e3, t3, { date: r2 }, { name: s2, operator: n2, args: i2 }) {
          const o2 = "now" === r2 ? Date.now() : r2.getTime();
          return a.compare(e3.getTime(), o2, n2) ? e3 : t3.error("date." + s2, { limit: i2.date, value: e3 });
        }, args: [{ name: "date", ref: true, normalize: (e3) => "now" === e3 ? e3 : o.parse(e3), assert: (e3) => null !== e3, message: "must have a valid date format" }] }, format: { method(e3) {
          return s(["iso", "javascript", "unix"].includes(e3), "Unknown date format", e3), this.$_setFlag("format", e3);
        } }, greater: { method(e3) {
          return this.$_addRule({ name: "greater", method: "compare", args: { date: e3 }, operator: ">" });
        } }, iso: { method() {
          return this.format("iso");
        } }, less: { method(e3) {
          return this.$_addRule({ name: "less", method: "compare", args: { date: e3 }, operator: "<" });
        } }, max: { method(e3) {
          return this.$_addRule({ name: "max", method: "compare", args: { date: e3 }, operator: "<=" });
        } }, min: { method(e3) {
          return this.$_addRule({ name: "min", method: "compare", args: { date: e3 }, operator: ">=" });
        } }, timestamp: { method(e3 = "javascript") {
          return s(["javascript", "unix"].includes(e3), '"type" must be one of "javascript, unix"'), this.format(e3);
        } } }, cast: { number: { from: o.isDate, to: (e3, t3) => e3.getTime() }, string: { from: o.isDate, to: (e3, { prefs: t3 }) => i.date(e3, t3) } }, messages: { "date.base": "{{#label}} must be a valid date", "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format', "date.greater": "{{#label}} must be greater than {{:#limit}}", "date.less": "{{#label}} must be less than {{:#limit}}", "date.max": "{{#label}} must be less than or equal to {{:#limit}}", "date.min": "{{#label}} must be greater than or equal to {{:#limit}}", "date.format.iso": "ISO 8601 date", "date.format.javascript": "timestamp or number of milliseconds", "date.format.unix": "timestamp or number of seconds" } }), o.parse = function(e3, t3) {
          if (e3 instanceof Date) return e3;
          if ("string" != typeof e3 && (isNaN(e3) || !isFinite(e3))) return null;
          if (/^\s*$/.test(e3)) return null;
          if ("iso" === t3) return a.isIsoDate(e3) ? o.date(e3.toString()) : null;
          const r2 = e3;
          if ("string" == typeof e3 && /^[+-]?\d+(\.\d+)?$/.test(e3) && (e3 = parseFloat(e3)), t3) {
            if ("javascript" === t3) return o.date(1 * e3);
            if ("unix" === t3) return o.date(1e3 * e3);
            if ("string" == typeof r2) return null;
          }
          return o.date(e3);
        }, o.date = function(e3) {
          const t3 = new Date(e3);
          return isNaN(t3.getTime()) ? null : t3;
        };
      }, 390: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(7824);
        e2.exports = n.extend({ type: "function", properties: { typeof: "function" }, rules: { arity: { method(e3) {
          return s(Number.isSafeInteger(e3) && e3 >= 0, "n must be a positive integer"), this.$_addRule({ name: "arity", args: { n: e3 } });
        }, validate: (e3, t3, { n: r2 }) => e3.length === r2 ? e3 : t3.error("function.arity", { n: r2 }) }, class: { method() {
          return this.$_addRule("class");
        }, validate: (e3, t3) => /^\s*class\s/.test(e3.toString()) ? e3 : t3.error("function.class", { value: e3 }) }, minArity: { method(e3) {
          return s(Number.isSafeInteger(e3) && e3 > 0, "n must be a strict positive integer"), this.$_addRule({ name: "minArity", args: { n: e3 } });
        }, validate: (e3, t3, { n: r2 }) => e3.length >= r2 ? e3 : t3.error("function.minArity", { n: r2 }) }, maxArity: { method(e3) {
          return s(Number.isSafeInteger(e3) && e3 >= 0, "n must be a positive integer"), this.$_addRule({ name: "maxArity", args: { n: e3 } });
        }, validate: (e3, t3, { n: r2 }) => e3.length <= r2 ? e3 : t3.error("function.maxArity", { n: r2 }) } }, messages: { "function.arity": "{{#label}} must have an arity of {{#n}}", "function.class": "{{#label}} must be a class", "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}", "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}" } });
      }, 7824: (e2, t2, r) => {
        "use strict";
        const s = r(978), n = r(375), a = r(8571), i = r(3652), o = r(8068), l = r(8160), c = r(3292), u = r(6354), f = r(6133), m = r(3328), h = { renameDefaults: { alias: false, multiple: false, override: false } };
        e2.exports = o.extend({ type: "_keys", properties: { typeof: "object" }, flags: { unknown: { default: void 0 } }, terms: { dependencies: { init: null }, keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } }, patterns: { init: null }, renames: { init: null } }, args: (e3, t3) => e3.keys(t3), validate(e3, { schema: t3, error: r2, state: s2, prefs: n2 }) {
          if (!e3 || typeof e3 !== t3.$_property("typeof") || Array.isArray(e3)) return { value: e3, errors: r2("object.base", { type: t3.$_property("typeof") }) };
          if (!(t3.$_terms.renames || t3.$_terms.dependencies || t3.$_terms.keys || t3.$_terms.patterns || t3.$_terms.externals)) return;
          e3 = h.clone(e3, n2);
          const a2 = [];
          if (t3.$_terms.renames && !h.rename(t3, e3, s2, n2, a2)) return { value: e3, errors: a2 };
          if (!t3.$_terms.keys && !t3.$_terms.patterns && !t3.$_terms.dependencies) return { value: e3, errors: a2 };
          const i2 = new Set(Object.keys(e3));
          if (t3.$_terms.keys) {
            const r3 = [e3, ...s2.ancestors];
            for (const o2 of t3.$_terms.keys) {
              const t4 = o2.key, l2 = e3[t4];
              i2.delete(t4);
              const c2 = s2.localize([...s2.path, t4], r3, o2), u2 = o2.schema.$_validate(l2, c2, n2);
              if (u2.errors) {
                if (n2.abortEarly) return { value: e3, errors: u2.errors };
                void 0 !== u2.value && (e3[t4] = u2.value), a2.push(...u2.errors);
              } else "strip" === o2.schema._flags.result || void 0 === u2.value && void 0 !== l2 ? delete e3[t4] : void 0 !== u2.value && (e3[t4] = u2.value);
            }
          }
          if (i2.size || t3._flags._hasPatternMatch) {
            const r3 = h.unknown(t3, e3, i2, a2, s2, n2);
            if (r3) return r3;
          }
          if (t3.$_terms.dependencies) for (const r3 of t3.$_terms.dependencies) {
            if (null !== r3.key && false === h.isPresent(r3.options)(r3.key.resolve(e3, s2, n2, null, { shadow: false }))) continue;
            const i3 = h.dependencies[r3.rel](t3, r3, e3, s2, n2);
            if (i3) {
              const r4 = t3.$_createError(i3.code, e3, i3.context, s2, n2);
              if (n2.abortEarly) return { value: e3, errors: r4 };
              a2.push(r4);
            }
          }
          return { value: e3, errors: a2 };
        }, rules: { and: { method(...e3) {
          return l.verifyFlat(e3, "and"), h.dependency(this, "and", null, e3);
        } }, append: { method(e3) {
          return null == e3 || 0 === Object.keys(e3).length ? this : this.keys(e3);
        } }, assert: { method(e3, t3, r2) {
          m.isTemplate(e3) || (e3 = c.ref(e3)), n(void 0 === r2 || "string" == typeof r2, "Message must be a string"), t3 = this.$_compile(t3, { appendPath: true });
          const s2 = this.$_addRule({ name: "assert", args: { subject: e3, schema: t3, message: r2 } });
          return s2.$_mutateRegister(e3), s2.$_mutateRegister(t3), s2;
        }, validate(e3, { error: t3, prefs: r2, state: s2 }, { subject: n2, schema: a2, message: i2 }) {
          const o2 = n2.resolve(e3, s2, r2), l2 = f.isRef(n2) ? n2.absolute(s2) : [];
          return a2.$_match(o2, s2.localize(l2, [e3, ...s2.ancestors], a2), r2) ? e3 : t3("object.assert", { subject: n2, message: i2 });
        }, args: ["subject", "schema", "message"], multi: true }, instance: { method(e3, t3) {
          return n("function" == typeof e3, "constructor must be a function"), t3 = t3 || e3.name, this.$_addRule({ name: "instance", args: { constructor: e3, name: t3 } });
        }, validate: (e3, t3, { constructor: r2, name: s2 }) => e3 instanceof r2 ? e3 : t3.error("object.instance", { type: s2, value: e3 }), args: ["constructor", "name"] }, keys: { method(e3) {
          n(void 0 === e3 || "object" == typeof e3, "Object schema must be a valid object"), n(!l.isSchema(e3), "Object schema cannot be a joi schema");
          const t3 = this.clone();
          if (e3) if (Object.keys(e3).length) {
            t3.$_terms.keys = t3.$_terms.keys ? t3.$_terms.keys.filter((t4) => !e3.hasOwnProperty(t4.key)) : new h.Keys();
            for (const r2 in e3) l.tryWithPath(() => t3.$_terms.keys.push({ key: r2, schema: this.$_compile(e3[r2]) }), r2);
          } else t3.$_terms.keys = new h.Keys();
          else t3.$_terms.keys = null;
          return t3.$_mutateRebuild();
        } }, length: { method(e3) {
          return this.$_addRule({ name: "length", args: { limit: e3 }, operator: "=" });
        }, validate: (e3, t3, { limit: r2 }, { name: s2, operator: n2, args: a2 }) => l.compare(Object.keys(e3).length, r2, n2) ? e3 : t3.error("object." + s2, { limit: a2.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: l.limit, message: "must be a positive integer" }] }, max: { method(e3) {
          return this.$_addRule({ name: "max", method: "length", args: { limit: e3 }, operator: "<=" });
        } }, min: { method(e3) {
          return this.$_addRule({ name: "min", method: "length", args: { limit: e3 }, operator: ">=" });
        } }, nand: { method(...e3) {
          return l.verifyFlat(e3, "nand"), h.dependency(this, "nand", null, e3);
        } }, or: { method(...e3) {
          return l.verifyFlat(e3, "or"), h.dependency(this, "or", null, e3);
        } }, oxor: { method(...e3) {
          return h.dependency(this, "oxor", null, e3);
        } }, pattern: { method(e3, t3, r2 = {}) {
          const s2 = e3 instanceof RegExp;
          s2 || (e3 = this.$_compile(e3, { appendPath: true })), n(void 0 !== t3, "Invalid rule"), l.assertOptions(r2, ["fallthrough", "matches"]), s2 && n(!e3.flags.includes("g") && !e3.flags.includes("y"), "pattern should not use global or sticky mode"), t3 = this.$_compile(t3, { appendPath: true });
          const a2 = this.clone();
          a2.$_terms.patterns = a2.$_terms.patterns || [];
          const i2 = { [s2 ? "regex" : "schema"]: e3, rule: t3 };
          return r2.matches && (i2.matches = this.$_compile(r2.matches), "array" !== i2.matches.type && (i2.matches = i2.matches.$_root.array().items(i2.matches)), a2.$_mutateRegister(i2.matches), a2.$_setFlag("_hasPatternMatch", true, { clone: false })), r2.fallthrough && (i2.fallthrough = true), a2.$_terms.patterns.push(i2), a2.$_mutateRegister(t3), a2;
        } }, ref: { method() {
          return this.$_addRule("ref");
        }, validate: (e3, t3) => f.isRef(e3) ? e3 : t3.error("object.refType", { value: e3 }) }, regex: { method() {
          return this.$_addRule("regex");
        }, validate: (e3, t3) => e3 instanceof RegExp ? e3 : t3.error("object.regex", { value: e3 }) }, rename: { method(e3, t3, r2 = {}) {
          n("string" == typeof e3 || e3 instanceof RegExp, "Rename missing the from argument"), n("string" == typeof t3 || t3 instanceof m, "Invalid rename to argument"), n(t3 !== e3, "Cannot rename key to same name:", e3), l.assertOptions(r2, ["alias", "ignoreUndefined", "override", "multiple"]);
          const a2 = this.clone();
          a2.$_terms.renames = a2.$_terms.renames || [];
          for (const t4 of a2.$_terms.renames) n(t4.from !== e3, "Cannot rename the same key multiple times");
          return t3 instanceof m && a2.$_mutateRegister(t3), a2.$_terms.renames.push({ from: e3, to: t3, options: s(h.renameDefaults, r2) }), a2;
        } }, schema: { method(e3 = "any") {
          return this.$_addRule({ name: "schema", args: { type: e3 } });
        }, validate: (e3, t3, { type: r2 }) => !l.isSchema(e3) || "any" !== r2 && e3.type !== r2 ? t3.error("object.schema", { type: r2 }) : e3 }, unknown: { method(e3) {
          return this.$_setFlag("unknown", false !== e3);
        } }, with: { method(e3, t3, r2 = {}) {
          return h.dependency(this, "with", e3, t3, r2);
        } }, without: { method(e3, t3, r2 = {}) {
          return h.dependency(this, "without", e3, t3, r2);
        } }, xor: { method(...e3) {
          return l.verifyFlat(e3, "xor"), h.dependency(this, "xor", null, e3);
        } } }, overrides: { default(e3, t3) {
          return void 0 === e3 && (e3 = l.symbols.deepDefault), this.$_parent("default", e3, t3);
        } }, rebuild(e3) {
          if (e3.$_terms.keys) {
            const t3 = new i.Sorter();
            for (const r2 of e3.$_terms.keys) l.tryWithPath(() => t3.add(r2, { after: r2.schema.$_rootReferences(), group: r2.key }), r2.key);
            e3.$_terms.keys = new h.Keys(...t3.nodes);
          }
        }, manifest: { build(e3, t3) {
          if (t3.keys && (e3 = e3.keys(t3.keys)), t3.dependencies) for (const { rel: r2, key: s2 = null, peers: n2, options: a2 } of t3.dependencies) e3 = h.dependency(e3, r2, s2, n2, a2);
          if (t3.patterns) for (const { regex: r2, schema: s2, rule: n2, fallthrough: a2, matches: i2 } of t3.patterns) e3 = e3.pattern(r2 || s2, n2, { fallthrough: a2, matches: i2 });
          if (t3.renames) for (const { from: r2, to: s2, options: n2 } of t3.renames) e3 = e3.rename(r2, s2, n2);
          return e3;
        } }, messages: { "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}", "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}', "object.base": "{{#label}} must be of type {{#type}}", "object.instance": "{{#label}} must be an instance of {{:#type}}", "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}', "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}', "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}', "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}", "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}", "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}", "object.pattern.match": "{{#label}} keys failed to match pattern requirements", "object.refType": "{{#label}} must be a Joi reference", "object.regex": "{{#label}} must be a RegExp object", "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}", "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists", "object.schema": "{{#label}} must be a Joi schema of {{#type}} type", "object.unknown": "{{#label}} is not allowed", "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}", "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}", "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}" } }), h.clone = function(e3, t3) {
          if ("object" == typeof e3) {
            if (t3.nonEnumerables) return a(e3, { shallow: true });
            const r3 = Object.create(Object.getPrototypeOf(e3));
            return Object.assign(r3, e3), r3;
          }
          const r2 = function(...t4) {
            return e3.apply(this, t4);
          };
          return r2.prototype = a(e3.prototype), Object.defineProperty(r2, "name", { value: e3.name, writable: false }), Object.defineProperty(r2, "length", { value: e3.length, writable: false }), Object.assign(r2, e3), r2;
        }, h.dependency = function(e3, t3, r2, s2, a2) {
          n(null === r2 || "string" == typeof r2, t3, "key must be a strings"), a2 || (a2 = s2.length > 1 && "object" == typeof s2[s2.length - 1] ? s2.pop() : {}), l.assertOptions(a2, ["separator", "isPresent"]), s2 = [].concat(s2);
          const i2 = l.default(a2.separator, "."), o2 = [];
          for (const e4 of s2) n("string" == typeof e4, t3, "peers must be strings"), o2.push(c.ref(e4, { separator: i2, ancestor: 0, prefix: false }));
          null !== r2 && (r2 = c.ref(r2, { separator: i2, ancestor: 0, prefix: false }));
          const u2 = e3.clone();
          return u2.$_terms.dependencies = u2.$_terms.dependencies || [], u2.$_terms.dependencies.push(new h.Dependency(t3, r2, o2, s2, a2)), u2;
        }, h.dependencies = { and(e3, t3, r2, s2, n2) {
          const a2 = [], i2 = [], o2 = t3.peers.length, l2 = h.isPresent(t3.options);
          for (const e4 of t3.peers) false === l2(e4.resolve(r2, s2, n2, null, { shadow: false })) ? a2.push(e4.key) : i2.push(e4.key);
          if (a2.length !== o2 && i2.length !== o2) return { code: "object.and", context: { present: i2, presentWithLabels: h.keysToLabels(e3, i2), missing: a2, missingWithLabels: h.keysToLabels(e3, a2) } };
        }, nand(e3, t3, r2, s2, n2) {
          const a2 = [], i2 = h.isPresent(t3.options);
          for (const e4 of t3.peers) i2(e4.resolve(r2, s2, n2, null, { shadow: false })) && a2.push(e4.key);
          if (a2.length !== t3.peers.length) return;
          const o2 = t3.paths[0], l2 = t3.paths.slice(1);
          return { code: "object.nand", context: { main: o2, mainWithLabel: h.keysToLabels(e3, o2), peers: l2, peersWithLabels: h.keysToLabels(e3, l2) } };
        }, or(e3, t3, r2, s2, n2) {
          const a2 = h.isPresent(t3.options);
          for (const e4 of t3.peers) if (a2(e4.resolve(r2, s2, n2, null, { shadow: false }))) return;
          return { code: "object.missing", context: { peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths) } };
        }, oxor(e3, t3, r2, s2, n2) {
          const a2 = [], i2 = h.isPresent(t3.options);
          for (const e4 of t3.peers) i2(e4.resolve(r2, s2, n2, null, { shadow: false })) && a2.push(e4.key);
          if (!a2.length || 1 === a2.length) return;
          const o2 = { peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths) };
          return o2.present = a2, o2.presentWithLabels = h.keysToLabels(e3, a2), { code: "object.oxor", context: o2 };
        }, with(e3, t3, r2, s2, n2) {
          const a2 = h.isPresent(t3.options);
          for (const i2 of t3.peers) if (false === a2(i2.resolve(r2, s2, n2, null, { shadow: false }))) return { code: "object.with", context: { main: t3.key.key, mainWithLabel: h.keysToLabels(e3, t3.key.key), peer: i2.key, peerWithLabel: h.keysToLabels(e3, i2.key) } };
        }, without(e3, t3, r2, s2, n2) {
          const a2 = h.isPresent(t3.options);
          for (const i2 of t3.peers) if (a2(i2.resolve(r2, s2, n2, null, { shadow: false }))) return { code: "object.without", context: { main: t3.key.key, mainWithLabel: h.keysToLabels(e3, t3.key.key), peer: i2.key, peerWithLabel: h.keysToLabels(e3, i2.key) } };
        }, xor(e3, t3, r2, s2, n2) {
          const a2 = [], i2 = h.isPresent(t3.options);
          for (const e4 of t3.peers) i2(e4.resolve(r2, s2, n2, null, { shadow: false })) && a2.push(e4.key);
          if (1 === a2.length) return;
          const o2 = { peers: t3.paths, peersWithLabels: h.keysToLabels(e3, t3.paths) };
          return 0 === a2.length ? { code: "object.missing", context: o2 } : (o2.present = a2, o2.presentWithLabels = h.keysToLabels(e3, a2), { code: "object.xor", context: o2 });
        } }, h.keysToLabels = function(e3, t3) {
          return Array.isArray(t3) ? t3.map((t4) => e3.$_mapLabels(t4)) : e3.$_mapLabels(t3);
        }, h.isPresent = function(e3) {
          return "function" == typeof e3.isPresent ? e3.isPresent : (e4) => void 0 !== e4;
        }, h.rename = function(e3, t3, r2, s2, n2) {
          const a2 = {};
          for (const i2 of e3.$_terms.renames) {
            const o2 = [], l2 = "string" != typeof i2.from;
            if (l2) for (const e4 in t3) {
              if (void 0 === t3[e4] && i2.options.ignoreUndefined) continue;
              if (e4 === i2.to) continue;
              const r3 = i2.from.exec(e4);
              r3 && o2.push({ from: e4, to: i2.to, match: r3 });
            }
            else !Object.prototype.hasOwnProperty.call(t3, i2.from) || void 0 === t3[i2.from] && i2.options.ignoreUndefined || o2.push(i2);
            for (const c2 of o2) {
              const o3 = c2.from;
              let u2 = c2.to;
              if (u2 instanceof m && (u2 = u2.render(t3, r2, s2, c2.match)), o3 !== u2) {
                if (!i2.options.multiple && a2[u2] && (n2.push(e3.$_createError("object.rename.multiple", t3, { from: o3, to: u2, pattern: l2 }, r2, s2)), s2.abortEarly)) return false;
                if (Object.prototype.hasOwnProperty.call(t3, u2) && !i2.options.override && !a2[u2] && (n2.push(e3.$_createError("object.rename.override", t3, { from: o3, to: u2, pattern: l2 }, r2, s2)), s2.abortEarly)) return false;
                void 0 === t3[o3] ? delete t3[u2] : t3[u2] = t3[o3], a2[u2] = true, i2.options.alias || delete t3[o3];
              }
            }
          }
          return true;
        }, h.unknown = function(e3, t3, r2, s2, n2, a2) {
          if (e3.$_terms.patterns) {
            let i2 = false;
            const o2 = e3.$_terms.patterns.map((e4) => {
              if (e4.matches) return i2 = true, [];
            }), l2 = [t3, ...n2.ancestors];
            for (const i3 of r2) {
              const c2 = t3[i3], u2 = [...n2.path, i3];
              for (let f2 = 0; f2 < e3.$_terms.patterns.length; ++f2) {
                const m2 = e3.$_terms.patterns[f2];
                if (m2.regex) {
                  const e4 = m2.regex.test(i3);
                  if (n2.mainstay.tracer.debug(n2, "rule", `pattern.${f2}`, e4 ? "pass" : "error"), !e4) continue;
                } else if (!m2.schema.$_match(i3, n2.nest(m2.schema, `pattern.${f2}`), a2)) continue;
                r2.delete(i3);
                const h2 = n2.localize(u2, l2, { schema: m2.rule, key: i3 }), d = m2.rule.$_validate(c2, h2, a2);
                if (d.errors) {
                  if (a2.abortEarly) return { value: t3, errors: d.errors };
                  s2.push(...d.errors);
                }
                if (m2.matches && o2[f2].push(i3), t3[i3] = d.value, !m2.fallthrough) break;
              }
            }
            if (i2) for (let r3 = 0; r3 < o2.length; ++r3) {
              const i3 = o2[r3];
              if (!i3) continue;
              const c2 = e3.$_terms.patterns[r3].matches, f2 = n2.localize(n2.path, l2, c2), m2 = c2.$_validate(i3, f2, a2);
              if (m2.errors) {
                const r4 = u.details(m2.errors, { override: false });
                r4.matches = i3;
                const o3 = e3.$_createError("object.pattern.match", t3, r4, n2, a2);
                if (a2.abortEarly) return { value: t3, errors: o3 };
                s2.push(o3);
              }
            }
          }
          if (r2.size && (e3.$_terms.keys || e3.$_terms.patterns)) {
            if (a2.stripUnknown && void 0 === e3._flags.unknown || a2.skipFunctions) {
              const e4 = !(!a2.stripUnknown || true !== a2.stripUnknown && !a2.stripUnknown.objects);
              for (const s3 of r2) e4 ? (delete t3[s3], r2.delete(s3)) : "function" == typeof t3[s3] && r2.delete(s3);
            }
            if (!l.default(e3._flags.unknown, a2.allowUnknown)) for (const i2 of r2) {
              const r3 = n2.localize([...n2.path, i2], []), o2 = e3.$_createError("object.unknown", t3[i2], { child: i2 }, r3, a2, { flags: false });
              if (a2.abortEarly) return { value: t3, errors: o2 };
              s2.push(o2);
            }
          }
        }, h.Dependency = class {
          constructor(e3, t3, r2, s2, n2) {
            this.rel = e3, this.key = t3, this.peers = r2, this.paths = s2, this.options = n2;
          }
          describe() {
            const e3 = { rel: this.rel, peers: this.paths };
            return null !== this.key && (e3.key = this.key.key), "." !== this.peers[0].separator && (e3.options = { ...e3.options, separator: this.peers[0].separator }), this.options.isPresent && (e3.options = { ...e3.options, isPresent: this.options.isPresent }), e3;
          }
        }, h.Keys = class extends Array {
          concat(e3) {
            const t3 = this.slice(), r2 = /* @__PURE__ */ new Map();
            for (let e4 = 0; e4 < t3.length; ++e4) r2.set(t3[e4].key, e4);
            for (const s2 of e3) {
              const e4 = s2.key, n2 = r2.get(e4);
              void 0 !== n2 ? t3[n2] = { key: e4, schema: t3[n2].schema.concat(s2.schema) } : t3.push(s2);
            }
            return t3;
          }
        };
      }, 8785: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8068), a = r(8160), i = r(3292), o = r(6354), l = {};
        e2.exports = n.extend({ type: "link", properties: { schemaChain: true }, terms: { link: { init: null, manifest: "single", register: false } }, args: (e3, t3) => e3.ref(t3), validate(e3, { schema: t3, state: r2, prefs: n2 }) {
          s(t3.$_terms.link, "Uninitialized link schema");
          const a2 = l.generate(t3, e3, r2, n2), i2 = t3.$_terms.link[0].ref;
          return a2.$_validate(e3, r2.nest(a2, `link:${i2.display}:${a2.type}`), n2);
        }, generate: (e3, t3, r2, s2) => l.generate(e3, t3, r2, s2), rules: { ref: { method(e3) {
          s(!this.$_terms.link, "Cannot reinitialize schema"), e3 = i.ref(e3), s("value" === e3.type || "local" === e3.type, "Invalid reference type:", e3.type), s("local" === e3.type || "root" === e3.ancestor || e3.ancestor > 0, "Link cannot reference itself");
          const t3 = this.clone();
          return t3.$_terms.link = [{ ref: e3 }], t3;
        } }, relative: { method(e3 = true) {
          return this.$_setFlag("relative", e3);
        } } }, overrides: { concat(e3) {
          s(this.$_terms.link, "Uninitialized link schema"), s(a.isSchema(e3), "Invalid schema object"), s("link" !== e3.type, "Cannot merge type link with another link");
          const t3 = this.clone();
          return t3.$_terms.whens || (t3.$_terms.whens = []), t3.$_terms.whens.push({ concat: e3 }), t3.$_mutateRebuild();
        } }, manifest: { build: (e3, t3) => (s(t3.link, "Invalid link description missing link"), e3.ref(t3.link)) } }), l.generate = function(e3, t3, r2, s2) {
          let n2 = r2.mainstay.links.get(e3);
          if (n2) return n2._generate(t3, r2, s2).schema;
          const a2 = e3.$_terms.link[0].ref, { perspective: i2, path: o2 } = l.perspective(a2, r2);
          l.assert(i2, "which is outside of schema boundaries", a2, e3, r2, s2);
          try {
            n2 = o2.length ? i2.$_reach(o2) : i2;
          } catch (t4) {
            l.assert(false, "to non-existing schema", a2, e3, r2, s2);
          }
          return l.assert("link" !== n2.type, "which is another link", a2, e3, r2, s2), e3._flags.relative || r2.mainstay.links.set(e3, n2), n2._generate(t3, r2, s2).schema;
        }, l.perspective = function(e3, t3) {
          if ("local" === e3.type) {
            for (const { schema: r2, key: s2 } of t3.schemas) {
              if ((r2._flags.id || s2) === e3.path[0]) return { perspective: r2, path: e3.path.slice(1) };
              if (r2.$_terms.shared) {
                for (const t4 of r2.$_terms.shared) if (t4._flags.id === e3.path[0]) return { perspective: t4, path: e3.path.slice(1) };
              }
            }
            return { perspective: null, path: null };
          }
          return "root" === e3.ancestor ? { perspective: t3.schemas[t3.schemas.length - 1].schema, path: e3.path } : { perspective: t3.schemas[e3.ancestor] && t3.schemas[e3.ancestor].schema, path: e3.path };
        }, l.assert = function(e3, t3, r2, n2, a2, i2) {
          e3 || s(false, `"${o.label(n2._flags, a2, i2)}" contains link reference "${r2.display}" ${t3}`);
        };
      }, 3832: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8068), a = r(8160), i = { numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i, precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/, exponentialPartRegex: /[eE][+-]?\d+$/, leadingSignAndZerosRegex: /^[+-]?(0*)?/, dotRegex: /\./, trailingZerosRegex: /0+$/, decimalPlaces(e3) {
          const t3 = e3.toString(), r2 = t3.indexOf("."), s2 = t3.indexOf("e");
          return (r2 < 0 ? 0 : (s2 < 0 ? t3.length : s2) - r2 - 1) + (s2 < 0 ? 0 : Math.max(0, -parseInt(t3.slice(s2 + 1))));
        } };
        e2.exports = n.extend({ type: "number", flags: { unsafe: { default: false } }, coerce: { from: "string", method(e3, { schema: t3, error: r2 }) {
          if (!e3.match(i.numberRx)) return;
          e3 = e3.trim();
          const s2 = { value: parseFloat(e3) };
          if (0 === s2.value && (s2.value = 0), !t3._flags.unsafe) if (e3.match(/e/i)) {
            if (i.extractSignificantDigits(e3) !== i.extractSignificantDigits(String(s2.value))) return s2.errors = r2("number.unsafe"), s2;
          } else {
            const t4 = s2.value.toString();
            if (t4.match(/e/i)) return s2;
            if (t4 !== i.normalizeDecimal(e3)) return s2.errors = r2("number.unsafe"), s2;
          }
          return s2;
        } }, validate(e3, { schema: t3, error: r2, prefs: s2 }) {
          if (e3 === 1 / 0 || e3 === -1 / 0) return { value: e3, errors: r2("number.infinity") };
          if (!a.isNumber(e3)) return { value: e3, errors: r2("number.base") };
          const n2 = { value: e3 };
          if (s2.convert) {
            const e4 = t3.$_getRule("precision");
            if (e4) {
              const t4 = Math.pow(10, e4.args.limit);
              n2.value = Math.round(n2.value * t4) / t4;
            }
          }
          return 0 === n2.value && (n2.value = 0), !t3._flags.unsafe && (e3 > Number.MAX_SAFE_INTEGER || e3 < Number.MIN_SAFE_INTEGER) && (n2.errors = r2("number.unsafe")), n2;
        }, rules: { compare: { method: false, validate: (e3, t3, { limit: r2 }, { name: s2, operator: n2, args: i2 }) => a.compare(e3, r2, n2) ? e3 : t3.error("number." + s2, { limit: i2.limit, value: e3 }), args: [{ name: "limit", ref: true, assert: a.isNumber, message: "must be a number" }] }, greater: { method(e3) {
          return this.$_addRule({ name: "greater", method: "compare", args: { limit: e3 }, operator: ">" });
        } }, integer: { method() {
          return this.$_addRule("integer");
        }, validate: (e3, t3) => Math.trunc(e3) - e3 == 0 ? e3 : t3.error("number.integer") }, less: { method(e3) {
          return this.$_addRule({ name: "less", method: "compare", args: { limit: e3 }, operator: "<" });
        } }, max: { method(e3) {
          return this.$_addRule({ name: "max", method: "compare", args: { limit: e3 }, operator: "<=" });
        } }, min: { method(e3) {
          return this.$_addRule({ name: "min", method: "compare", args: { limit: e3 }, operator: ">=" });
        } }, multiple: { method(e3) {
          const t3 = "number" == typeof e3 ? i.decimalPlaces(e3) : null, r2 = Math.pow(10, t3);
          return this.$_addRule({ name: "multiple", args: { base: e3, baseDecimalPlace: t3, pfactor: r2 } });
        }, validate: (e3, t3, { base: r2, baseDecimalPlace: s2, pfactor: n2 }, a2) => i.decimalPlaces(e3) > s2 ? t3.error("number.multiple", { multiple: a2.args.base, value: e3 }) : Math.round(n2 * e3) % Math.round(n2 * r2) == 0 ? e3 : t3.error("number.multiple", { multiple: a2.args.base, value: e3 }), args: [{ name: "base", ref: true, assert: (e3) => "number" == typeof e3 && isFinite(e3) && e3 > 0, message: "must be a positive number" }, "baseDecimalPlace", "pfactor"], multi: true }, negative: { method() {
          return this.sign("negative");
        } }, port: { method() {
          return this.$_addRule("port");
        }, validate: (e3, t3) => Number.isSafeInteger(e3) && e3 >= 0 && e3 <= 65535 ? e3 : t3.error("number.port") }, positive: { method() {
          return this.sign("positive");
        } }, precision: { method(e3) {
          return s(Number.isSafeInteger(e3), "limit must be an integer"), this.$_addRule({ name: "precision", args: { limit: e3 } });
        }, validate(e3, t3, { limit: r2 }) {
          const s2 = e3.toString().match(i.precisionRx);
          return Math.max((s2[1] ? s2[1].length : 0) - (s2[2] ? parseInt(s2[2], 10) : 0), 0) <= r2 ? e3 : t3.error("number.precision", { limit: r2, value: e3 });
        }, convert: true }, sign: { method(e3) {
          return s(["negative", "positive"].includes(e3), "Invalid sign", e3), this.$_addRule({ name: "sign", args: { sign: e3 } });
        }, validate: (e3, t3, { sign: r2 }) => "negative" === r2 && e3 < 0 || "positive" === r2 && e3 > 0 ? e3 : t3.error(`number.${r2}`) }, unsafe: { method(e3 = true) {
          return s("boolean" == typeof e3, "enabled must be a boolean"), this.$_setFlag("unsafe", e3);
        } } }, cast: { string: { from: (e3) => "number" == typeof e3, to: (e3, t3) => e3.toString() } }, messages: { "number.base": "{{#label}} must be a number", "number.greater": "{{#label}} must be greater than {{#limit}}", "number.infinity": "{{#label}} cannot be infinity", "number.integer": "{{#label}} must be an integer", "number.less": "{{#label}} must be less than {{#limit}}", "number.max": "{{#label}} must be less than or equal to {{#limit}}", "number.min": "{{#label}} must be greater than or equal to {{#limit}}", "number.multiple": "{{#label}} must be a multiple of {{#multiple}}", "number.negative": "{{#label}} must be a negative number", "number.port": "{{#label}} must be a valid port", "number.positive": "{{#label}} must be a positive number", "number.precision": "{{#label}} must have no more than {{#limit}} decimal places", "number.unsafe": "{{#label}} must be a safe number" } }), i.extractSignificantDigits = function(e3) {
          return e3.replace(i.exponentialPartRegex, "").replace(i.dotRegex, "").replace(i.trailingZerosRegex, "").replace(i.leadingSignAndZerosRegex, "");
        }, i.normalizeDecimal = function(e3) {
          return (e3 = e3.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && e3.endsWith("0") && (e3 = e3.replace(/0+$/, "")), "-0" === e3 ? "0" : e3;
        };
      }, 8966: (e2, t2, r) => {
        "use strict";
        const s = r(7824);
        e2.exports = s.extend({ type: "object", cast: { map: { from: (e3) => e3 && "object" == typeof e3, to: (e3, t3) => new Map(Object.entries(e3)) } } });
      }, 7417: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(5380), a = r(1745), i = r(9959), o = r(6064), l = r(9926), c = r(5752), u = r(8068), f = r(8160), m = { tlds: l instanceof Set && { tlds: { allow: l, deny: null } }, base64Regex: { true: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ }, false: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/ } }, dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/, hexRegex: { withPrefix: /^0x[0-9a-f]+$/i, withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i, withoutPrefix: /^[0-9a-f]+$/i }, ipRegex: i.regex({ cidr: "forbidden" }).regex, isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/, guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" }, guidVersions: { uuidv1: "1", uuidv2: "2", uuidv3: "3", uuidv4: "4", uuidv5: "5", uuidv6: "6", uuidv7: "7", uuidv8: "8" }, guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]), normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"] };
        e2.exports = u.extend({ type: "string", flags: { insensitive: { default: false }, truncate: { default: false } }, terms: { replacements: { init: null } }, coerce: { from: "string", method(e3, { schema: t3, state: r2, prefs: s2 }) {
          const n2 = t3.$_getRule("normalize");
          n2 && (e3 = e3.normalize(n2.args.form));
          const a2 = t3.$_getRule("case");
          a2 && (e3 = "upper" === a2.args.direction ? e3.toLocaleUpperCase() : e3.toLocaleLowerCase());
          const i2 = t3.$_getRule("trim");
          if (i2 && i2.args.enabled && (e3 = e3.trim()), t3.$_terms.replacements) for (const r3 of t3.$_terms.replacements) e3 = e3.replace(r3.pattern, r3.replacement);
          const o2 = t3.$_getRule("hex");
          if (o2 && o2.args.options.byteAligned && e3.length % 2 != 0 && (e3 = `0${e3}`), t3.$_getRule("isoDate")) {
            const t4 = m.isoDate(e3);
            t4 && (e3 = t4);
          }
          if (t3._flags.truncate) {
            const n3 = t3.$_getRule("max");
            if (n3) {
              let a3 = n3.args.limit;
              if (f.isResolvable(a3) && (a3 = a3.resolve(e3, r2, s2), !f.limit(a3))) return { value: e3, errors: t3.$_createError("any.ref", a3, { ref: n3.args.limit, arg: "limit", reason: "must be a positive integer" }, r2, s2) };
              e3 = e3.slice(0, a3);
            }
          }
          return { value: e3 };
        } }, validate(e3, { schema: t3, error: r2 }) {
          if ("string" != typeof e3) return { value: e3, errors: r2("string.base") };
          if ("" === e3) {
            const s2 = t3.$_getRule("min");
            if (s2 && 0 === s2.args.limit) return;
            return { value: e3, errors: r2("string.empty") };
          }
        }, rules: { alphanum: { method() {
          return this.$_addRule("alphanum");
        }, validate: (e3, t3) => /^[a-zA-Z0-9]+$/.test(e3) ? e3 : t3.error("string.alphanum") }, base64: { method(e3 = {}) {
          return f.assertOptions(e3, ["paddingRequired", "urlSafe"]), e3 = { urlSafe: false, paddingRequired: true, ...e3 }, s("boolean" == typeof e3.paddingRequired, "paddingRequired must be boolean"), s("boolean" == typeof e3.urlSafe, "urlSafe must be boolean"), this.$_addRule({ name: "base64", args: { options: e3 } });
        }, validate: (e3, t3, { options: r2 }) => m.base64Regex[r2.paddingRequired][r2.urlSafe].test(e3) ? e3 : t3.error("string.base64") }, case: { method(e3) {
          return s(["lower", "upper"].includes(e3), "Invalid case:", e3), this.$_addRule({ name: "case", args: { direction: e3 } });
        }, validate: (e3, t3, { direction: r2 }) => "lower" === r2 && e3 === e3.toLocaleLowerCase() || "upper" === r2 && e3 === e3.toLocaleUpperCase() ? e3 : t3.error(`string.${r2}case`), convert: true }, creditCard: { method() {
          return this.$_addRule("creditCard");
        }, validate(e3, t3) {
          let r2 = e3.length, s2 = 0, n2 = 1;
          for (; r2--; ) {
            const t4 = e3.charAt(r2) * n2;
            s2 += t4 - 9 * (t4 > 9), n2 ^= 3;
          }
          return s2 > 0 && s2 % 10 == 0 ? e3 : t3.error("string.creditCard");
        } }, dataUri: { method(e3 = {}) {
          return f.assertOptions(e3, ["paddingRequired"]), e3 = { paddingRequired: true, ...e3 }, s("boolean" == typeof e3.paddingRequired, "paddingRequired must be boolean"), this.$_addRule({ name: "dataUri", args: { options: e3 } });
        }, validate(e3, t3, { options: r2 }) {
          const s2 = e3.match(m.dataUriRegex);
          if (s2) {
            if (!s2[2]) return e3;
            if ("base64" !== s2[2]) return e3;
            if (m.base64Regex[r2.paddingRequired].false.test(s2[3])) return e3;
          }
          return t3.error("string.dataUri");
        } }, domain: { method(e3) {
          e3 && f.assertOptions(e3, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          const t3 = m.addressOptions(e3);
          return this.$_addRule({ name: "domain", args: { options: e3 }, address: t3 });
        }, validate: (e3, t3, r2, { address: s2 }) => n.isValid(e3, s2) ? e3 : t3.error("string.domain") }, email: { method(e3 = {}) {
          f.assertOptions(e3, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), s(void 0 === e3.multiple || "boolean" == typeof e3.multiple, "multiple option must be an boolean");
          const t3 = m.addressOptions(e3), r2 = new RegExp(`\\s*[${e3.separator ? o(e3.separator) : ","}]\\s*`);
          return this.$_addRule({ name: "email", args: { options: e3 }, regex: r2, address: t3 });
        }, validate(e3, t3, { options: r2 }, { regex: s2, address: n2 }) {
          const i2 = r2.multiple ? e3.split(s2) : [e3], o2 = [];
          for (const e4 of i2) a.isValid(e4, n2) || o2.push(e4);
          return o2.length ? t3.error("string.email", { value: e3, invalids: o2 }) : e3;
        } }, guid: { alias: "uuid", method(e3 = {}) {
          f.assertOptions(e3, ["version", "separator"]);
          let t3 = "";
          if (e3.version) {
            const r3 = [].concat(e3.version);
            s(r3.length >= 1, "version must have at least 1 valid version specified");
            const n3 = /* @__PURE__ */ new Set();
            for (let e4 = 0; e4 < r3.length; ++e4) {
              const a2 = r3[e4];
              s("string" == typeof a2, "version at position " + e4 + " must be a string");
              const i2 = m.guidVersions[a2.toLowerCase()];
              s(i2, "version at position " + e4 + " must be one of " + Object.keys(m.guidVersions).join(", ")), s(!n3.has(i2), "version at position " + e4 + " must not be a duplicate"), t3 += i2, n3.add(i2);
            }
          }
          s(m.guidSeparators.has(e3.separator), 'separator must be one of true, false, "-", or ":"');
          const r2 = void 0 === e3.separator ? "[:-]?" : true === e3.separator ? "[:-]" : false === e3.separator ? "[]?" : `\\${e3.separator}`, n2 = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${r2})[0-9A-F]{4}\\2?[${t3 || "0-9A-F"}][0-9A-F]{3}\\2?[${t3 ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
          return this.$_addRule({ name: "guid", args: { options: e3 }, regex: n2 });
        }, validate(e3, t3, r2, { regex: s2 }) {
          const n2 = s2.exec(e3);
          return n2 ? m.guidBrackets[n2[1]] !== n2[n2.length - 1] ? t3.error("string.guid") : e3 : t3.error("string.guid");
        } }, hex: { method(e3 = {}) {
          return f.assertOptions(e3, ["byteAligned", "prefix"]), e3 = { byteAligned: false, prefix: false, ...e3 }, s("boolean" == typeof e3.byteAligned, "byteAligned must be boolean"), s("boolean" == typeof e3.prefix || "optional" === e3.prefix, 'prefix must be boolean or "optional"'), this.$_addRule({ name: "hex", args: { options: e3 } });
        }, validate: (e3, t3, { options: r2 }) => ("optional" === r2.prefix ? m.hexRegex.withOptionalPrefix : true === r2.prefix ? m.hexRegex.withPrefix : m.hexRegex.withoutPrefix).test(e3) ? r2.byteAligned && e3.length % 2 != 0 ? t3.error("string.hexAlign") : e3 : t3.error("string.hex") }, hostname: { method() {
          return this.$_addRule("hostname");
        }, validate: (e3, t3) => n.isValid(e3, { minDomainSegments: 1 }) || m.ipRegex.test(e3) ? e3 : t3.error("string.hostname") }, insensitive: { method() {
          return this.$_setFlag("insensitive", true);
        } }, ip: { method(e3 = {}) {
          f.assertOptions(e3, ["cidr", "version"]);
          const { cidr: t3, versions: r2, regex: s2 } = i.regex(e3), n2 = e3.version ? r2 : void 0;
          return this.$_addRule({ name: "ip", args: { options: { cidr: t3, version: n2 } }, regex: s2 });
        }, validate: (e3, t3, { options: r2 }, { regex: s2 }) => s2.test(e3) ? e3 : r2.version ? t3.error("string.ipVersion", { value: e3, cidr: r2.cidr, version: r2.version }) : t3.error("string.ip", { value: e3, cidr: r2.cidr }) }, isoDate: { method() {
          return this.$_addRule("isoDate");
        }, validate: (e3, { error: t3 }) => m.isoDate(e3) ? e3 : t3("string.isoDate") }, isoDuration: { method() {
          return this.$_addRule("isoDuration");
        }, validate: (e3, t3) => m.isoDurationRegex.test(e3) ? e3 : t3.error("string.isoDuration") }, length: { method(e3, t3) {
          return m.length(this, "length", e3, "=", t3);
        }, validate(e3, t3, { limit: r2, encoding: s2 }, { name: n2, operator: a2, args: i2 }) {
          const o2 = !s2 && e3.length;
          return f.compare(o2, r2, a2) ? e3 : t3.error("string." + n2, { limit: i2.limit, value: e3, encoding: s2 });
        }, args: [{ name: "limit", ref: true, assert: f.limit, message: "must be a positive integer" }, "encoding"] }, lowercase: { method() {
          return this.case("lower");
        } }, max: { method(e3, t3) {
          return m.length(this, "max", e3, "<=", t3);
        }, args: ["limit", "encoding"] }, min: { method(e3, t3) {
          return m.length(this, "min", e3, ">=", t3);
        }, args: ["limit", "encoding"] }, normalize: { method(e3 = "NFC") {
          return s(m.normalizationForms.includes(e3), "normalization form must be one of " + m.normalizationForms.join(", ")), this.$_addRule({ name: "normalize", args: { form: e3 } });
        }, validate: (e3, { error: t3 }, { form: r2 }) => e3 === e3.normalize(r2) ? e3 : t3("string.normalize", { value: e3, form: r2 }), convert: true }, pattern: { alias: "regex", method(e3, t3 = {}) {
          s(e3 instanceof RegExp, "regex must be a RegExp"), s(!e3.flags.includes("g") && !e3.flags.includes("y"), "regex should not use global or sticky mode"), "string" == typeof t3 && (t3 = { name: t3 }), f.assertOptions(t3, ["invert", "name"]);
          const r2 = ["string.pattern", t3.invert ? ".invert" : "", t3.name ? ".name" : ".base"].join("");
          return this.$_addRule({ name: "pattern", args: { regex: e3, options: t3 }, errorCode: r2 });
        }, validate: (e3, t3, { regex: r2, options: s2 }, { errorCode: n2 }) => r2.test(e3) ^ s2.invert ? e3 : t3.error(n2, { name: s2.name, regex: r2, value: e3 }), args: ["regex", "options"], multi: true }, replace: { method(e3, t3) {
          "string" == typeof e3 && (e3 = new RegExp(o(e3), "g")), s(e3 instanceof RegExp, "pattern must be a RegExp"), s("string" == typeof t3, "replacement must be a String");
          const r2 = this.clone();
          return r2.$_terms.replacements || (r2.$_terms.replacements = []), r2.$_terms.replacements.push({ pattern: e3, replacement: t3 }), r2;
        } }, token: { method() {
          return this.$_addRule("token");
        }, validate: (e3, t3) => /^\w+$/.test(e3) ? e3 : t3.error("string.token") }, trim: { method(e3 = true) {
          return s("boolean" == typeof e3, "enabled must be a boolean"), this.$_addRule({ name: "trim", args: { enabled: e3 } });
        }, validate: (e3, t3, { enabled: r2 }) => r2 && e3 !== e3.trim() ? t3.error("string.trim") : e3, convert: true }, truncate: { method(e3 = true) {
          return s("boolean" == typeof e3, "enabled must be a boolean"), this.$_setFlag("truncate", e3);
        } }, uppercase: { method() {
          return this.case("upper");
        } }, uri: { method(e3 = {}) {
          f.assertOptions(e3, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]), e3.domain && f.assertOptions(e3.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
          const { regex: t3, scheme: r2 } = c.regex(e3), s2 = e3.domain ? m.addressOptions(e3.domain) : null;
          return this.$_addRule({ name: "uri", args: { options: e3 }, regex: t3, domain: s2, scheme: r2 });
        }, validate(e3, t3, { options: r2 }, { regex: s2, domain: a2, scheme: i2 }) {
          if (["http:/", "https:/"].includes(e3)) return t3.error("string.uri");
          let o2 = s2.exec(e3);
          if (!o2 && t3.prefs.convert && r2.encodeUri) {
            const t4 = encodeURI(e3);
            o2 = s2.exec(t4), o2 && (e3 = t4);
          }
          if (o2) {
            const s3 = o2[1] || o2[2];
            return !a2 || r2.allowRelative && !s3 || n.isValid(s3, a2) ? e3 : t3.error("string.domain", { value: s3 });
          }
          return r2.relativeOnly ? t3.error("string.uriRelativeOnly") : r2.scheme ? t3.error("string.uriCustomScheme", { scheme: i2, value: e3 }) : t3.error("string.uri");
        } } }, manifest: { build(e3, t3) {
          if (t3.replacements) for (const { pattern: r2, replacement: s2 } of t3.replacements) e3 = e3.replace(r2, s2);
          return e3;
        } }, messages: { "string.alphanum": "{{#label}} must only contain alpha-numeric characters", "string.base": "{{#label}} must be a string", "string.base64": "{{#label}} must be a valid base64 string", "string.creditCard": "{{#label}} must be a credit card", "string.dataUri": "{{#label}} must be a valid dataUri string", "string.domain": "{{#label}} must contain a valid domain name", "string.email": "{{#label}} must be a valid email", "string.empty": "{{#label}} is not allowed to be empty", "string.guid": "{{#label}} must be a valid GUID", "string.hex": "{{#label}} must only contain hexadecimal characters", "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned", "string.hostname": "{{#label}} must be a valid hostname", "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR", "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR", "string.isoDate": "{{#label}} must be in iso format", "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration", "string.length": "{{#label}} length must be {{#limit}} characters long", "string.lowercase": "{{#label}} must only contain lowercase characters", "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long", "string.min": "{{#label}} length must be at least {{#limit}} characters long", "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form", "string.token": "{{#label}} must only contain alpha-numeric and underscore characters", "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}", "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern", "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}", "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern", "string.trim": "{{#label}} must not have leading or trailing whitespace", "string.uri": "{{#label}} must be a valid uri", "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern", "string.uriRelativeOnly": "{{#label}} must be a valid relative uri", "string.uppercase": "{{#label}} must only contain uppercase characters" } }), m.addressOptions = function(e3) {
          if (!e3) return m.tlds || e3;
          if (s(void 0 === e3.minDomainSegments || Number.isSafeInteger(e3.minDomainSegments) && e3.minDomainSegments > 0, "minDomainSegments must be a positive integer"), s(void 0 === e3.maxDomainSegments || Number.isSafeInteger(e3.maxDomainSegments) && e3.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"), false === e3.tlds) return e3;
          if (true === e3.tlds || void 0 === e3.tlds) return s(m.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, m.tlds);
          s("object" == typeof e3.tlds, "tlds must be true, false, or an object");
          const t3 = e3.tlds.deny;
          if (t3) return Array.isArray(t3) && (e3 = Object.assign({}, e3, { tlds: { deny: new Set(t3) } })), s(e3.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), s(!e3.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), m.validateTlds(e3.tlds.deny, "tlds.deny"), e3;
          const r2 = e3.tlds.allow;
          return r2 ? true === r2 ? (s(m.tlds, "Built-in TLD list disabled"), Object.assign({}, e3, m.tlds)) : (Array.isArray(r2) && (e3 = Object.assign({}, e3, { tlds: { allow: new Set(r2) } })), s(e3.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), m.validateTlds(e3.tlds.allow, "tlds.allow"), e3) : e3;
        }, m.validateTlds = function(e3, t3) {
          for (const r2 of e3) s(n.isValid(r2, { minDomainSegments: 1, maxDomainSegments: 1 }), `${t3} must contain valid top level domain names`);
        }, m.isoDate = function(e3) {
          if (!f.isIsoDate(e3)) return null;
          /.*T.*[+-]\d\d$/.test(e3) && (e3 += "00");
          const t3 = new Date(e3);
          return isNaN(t3.getTime()) ? null : t3.toISOString();
        }, m.length = function(e3, t3, r2, n2, a2) {
          return s(!a2 || false, "Invalid encoding:", a2), e3.$_addRule({ name: t3, method: "length", args: { limit: r2, encoding: a2 }, operator: n2 });
        };
      }, 8826: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8068), a = {};
        a.Map = class extends Map {
          slice() {
            return new a.Map(this);
          }
        }, e2.exports = n.extend({ type: "symbol", terms: { map: { init: new a.Map() } }, coerce: { method(e3, { schema: t3, error: r2 }) {
          const s2 = t3.$_terms.map.get(e3);
          return s2 && (e3 = s2), t3._flags.only && "symbol" != typeof e3 ? { value: e3, errors: r2("symbol.map", { map: t3.$_terms.map }) } : { value: e3 };
        } }, validate(e3, { error: t3 }) {
          if ("symbol" != typeof e3) return { value: e3, errors: t3("symbol.base") };
        }, rules: { map: { method(e3) {
          e3 && !e3[Symbol.iterator] && "object" == typeof e3 && (e3 = Object.entries(e3)), s(e3 && e3[Symbol.iterator], "Iterable must be an iterable or object");
          const t3 = this.clone(), r2 = [];
          for (const n2 of e3) {
            s(n2 && n2[Symbol.iterator], "Entry must be an iterable");
            const [e4, a2] = n2;
            s("object" != typeof e4 && "function" != typeof e4 && "symbol" != typeof e4, "Key must not be of type object, function, or Symbol"), s("symbol" == typeof a2, "Value must be a Symbol"), t3.$_terms.map.set(e4, a2), r2.push(a2);
          }
          return t3.valid(...r2);
        } } }, manifest: { build: (e3, t3) => (t3.map && (e3 = e3.map(t3.map)), e3) }, messages: { "symbol.base": "{{#label}} must be a symbol", "symbol.map": "{{#label}} must be one of {{#map}}" } });
      }, 8863: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(738), i = r(9621), o = r(8160), l = r(6354), c = r(493), u = { result: Symbol("result") };
        t2.entry = function(e3, t3, r2) {
          let n2 = o.defaults;
          r2 && (s(void 0 === r2.warnings, "Cannot override warnings preference in synchronous validation"), s(void 0 === r2.artifacts, "Cannot override artifacts preference in synchronous validation"), n2 = o.preferences(o.defaults, r2));
          const a2 = u.entry(e3, t3, n2);
          s(!a2.mainstay.externals.length, "Schema with external rules must use validateAsync()");
          const i2 = { value: a2.value };
          return a2.error && (i2.error = a2.error), a2.mainstay.warnings.length && (i2.warning = l.details(a2.mainstay.warnings)), a2.mainstay.debug && (i2.debug = a2.mainstay.debug), a2.mainstay.artifacts && (i2.artifacts = a2.mainstay.artifacts), i2;
        }, t2.entryAsync = async function(e3, t3, r2) {
          let s2 = o.defaults;
          r2 && (s2 = o.preferences(o.defaults, r2));
          const n2 = u.entry(e3, t3, s2), a2 = n2.mainstay;
          if (n2.error) throw a2.debug && (n2.error.debug = a2.debug), n2.error;
          if (a2.externals.length) {
            let t4 = n2.value;
            const c3 = [];
            for (const n3 of a2.externals) {
              const f = n3.state.path, m = "link" === n3.schema.type ? a2.links.get(n3.schema) : null;
              let h, d, p = t4;
              const g = f.length ? [t4] : [], y = f.length ? i(e3, f) : e3;
              if (f.length) {
                h = f[f.length - 1];
                let e4 = t4;
                for (const t5 of f.slice(0, -1)) e4 = e4[t5], g.unshift(e4);
                d = g[0], p = d[h];
              }
              try {
                const e4 = (e5, t5) => (m || n3.schema).$_createError(e5, p, t5, n3.state, s2), i2 = await n3.method(p, { schema: n3.schema, linked: m, state: n3.state, prefs: r2, original: y, error: e4, errorsArray: u.errorsArray, warn: (e5, t5) => a2.warnings.push((m || n3.schema).$_createError(e5, p, t5, n3.state, s2)), message: (e5, t5) => (m || n3.schema).$_createError("external", p, t5, n3.state, s2, { messages: e5 }) });
                if (void 0 === i2 || i2 === p) continue;
                if (i2 instanceof l.Report) {
                  if (a2.tracer.log(n3.schema, n3.state, "rule", "external", "error"), c3.push(i2), s2.abortEarly) break;
                  continue;
                }
                if (Array.isArray(i2) && i2[o.symbols.errors]) {
                  if (a2.tracer.log(n3.schema, n3.state, "rule", "external", "error"), c3.push(...i2), s2.abortEarly) break;
                  continue;
                }
                d ? (a2.tracer.value(n3.state, "rule", p, i2, "external"), d[h] = i2) : (a2.tracer.value(n3.state, "rule", t4, i2, "external"), t4 = i2);
              } catch (e4) {
                throw s2.errors.label && (e4.message += ` (${n3.label})`), e4;
              }
            }
            if (n2.value = t4, c3.length) throw n2.error = l.process(c3, e3, s2), a2.debug && (n2.error.debug = a2.debug), n2.error;
          }
          if (!s2.warnings && !s2.debug && !s2.artifacts) return n2.value;
          const c2 = { value: n2.value };
          return a2.warnings.length && (c2.warning = l.details(a2.warnings)), a2.debug && (c2.debug = a2.debug), a2.artifacts && (c2.artifacts = a2.artifacts), c2;
        }, u.Mainstay = class {
          constructor(e3, t3, r2) {
            this.externals = [], this.warnings = [], this.tracer = e3, this.debug = t3, this.links = r2, this.shadow = null, this.artifacts = null, this._snapshots = [];
          }
          snapshot() {
            this._snapshots.push({ externals: this.externals.slice(), warnings: this.warnings.slice() });
          }
          restore() {
            const e3 = this._snapshots.pop();
            this.externals = e3.externals, this.warnings = e3.warnings;
          }
          commit() {
            this._snapshots.pop();
          }
        }, u.entry = function(e3, r2, s2) {
          const { tracer: n2, cleanup: a2 } = u.tracer(r2, s2), i2 = s2.debug ? [] : null, o2 = r2._ids._schemaChain ? /* @__PURE__ */ new Map() : null, f = new u.Mainstay(n2, i2, o2), m = r2._ids._schemaChain ? [{ schema: r2 }] : null, h = new c([], [], { mainstay: f, schemas: m }), d = t2.validate(e3, r2, h, s2);
          a2 && r2.$_root.untrace();
          const p = l.process(d.errors, e3, s2);
          return { value: d.value, error: p, mainstay: f };
        }, u.tracer = function(e3, t3) {
          return e3.$_root._tracer ? { tracer: e3.$_root._tracer._register(e3) } : t3.debug ? (s(e3.$_root.trace, "Debug mode not supported"), { tracer: e3.$_root.trace()._register(e3), cleanup: true }) : { tracer: u.ignore };
        }, t2.validate = function(e3, t3, r2, s2, n2 = {}) {
          if (t3.$_terms.whens && (t3 = t3._generate(e3, r2, s2).schema), t3._preferences && (s2 = u.prefs(t3, s2)), t3._cache && s2.cache) {
            const s3 = t3._cache.get(e3);
            if (r2.mainstay.tracer.debug(r2, "validate", "cached", !!s3), s3) return s3;
          }
          const a2 = (n3, a3, i3) => t3.$_createError(n3, e3, a3, i3 || r2, s2), i2 = { original: e3, prefs: s2, schema: t3, state: r2, error: a2, errorsArray: u.errorsArray, warn: (e4, t4, s3) => r2.mainstay.warnings.push(a2(e4, t4, s3)), message: (n3, a3) => t3.$_createError("custom", e3, a3, r2, s2, { messages: n3 }) };
          r2.mainstay.tracer.entry(t3, r2);
          const l2 = t3._definition;
          if (l2.prepare && void 0 !== e3 && s2.convert) {
            const t4 = l2.prepare(e3, i2);
            if (t4) {
              if (r2.mainstay.tracer.value(r2, "prepare", e3, t4.value), t4.errors) return u.finalize(t4.value, [].concat(t4.errors), i2);
              e3 = t4.value;
            }
          }
          if (l2.coerce && void 0 !== e3 && s2.convert && (!l2.coerce.from || l2.coerce.from.includes(typeof e3))) {
            const t4 = l2.coerce.method(e3, i2);
            if (t4) {
              if (r2.mainstay.tracer.value(r2, "coerced", e3, t4.value), t4.errors) return u.finalize(t4.value, [].concat(t4.errors), i2);
              e3 = t4.value;
            }
          }
          const c2 = t3._flags.empty;
          c2 && c2.$_match(u.trim(e3, t3), r2.nest(c2), o.defaults) && (r2.mainstay.tracer.value(r2, "empty", e3, void 0), e3 = void 0);
          const f = n2.presence || t3._flags.presence || (t3._flags._endedSwitch ? null : s2.presence);
          if (void 0 === e3) {
            if ("forbidden" === f) return u.finalize(e3, null, i2);
            if ("required" === f) return u.finalize(e3, [t3.$_createError("any.required", e3, null, r2, s2)], i2);
            if ("optional" === f) {
              if (t3._flags.default !== o.symbols.deepDefault) return u.finalize(e3, null, i2);
              r2.mainstay.tracer.value(r2, "default", e3, {}), e3 = {};
            }
          } else if ("forbidden" === f) return u.finalize(e3, [t3.$_createError("any.unknown", e3, null, r2, s2)], i2);
          const m = [];
          if (t3._valids) {
            const n3 = t3._valids.get(e3, r2, s2, t3._flags.insensitive);
            if (n3) return s2.convert && (r2.mainstay.tracer.value(r2, "valids", e3, n3.value), e3 = n3.value), r2.mainstay.tracer.filter(t3, r2, "valid", n3), u.finalize(e3, null, i2);
            if (t3._flags.only) {
              const n4 = t3.$_createError("any.only", e3, { valids: t3._valids.values({ display: true }) }, r2, s2);
              if (s2.abortEarly) return u.finalize(e3, [n4], i2);
              m.push(n4);
            }
          }
          if (t3._invalids) {
            const n3 = t3._invalids.get(e3, r2, s2, t3._flags.insensitive);
            if (n3) {
              r2.mainstay.tracer.filter(t3, r2, "invalid", n3);
              const a3 = t3.$_createError("any.invalid", e3, { invalids: t3._invalids.values({ display: true }) }, r2, s2);
              if (s2.abortEarly) return u.finalize(e3, [a3], i2);
              m.push(a3);
            }
          }
          if (l2.validate) {
            const t4 = l2.validate(e3, i2);
            if (t4 && (r2.mainstay.tracer.value(r2, "base", e3, t4.value), e3 = t4.value, t4.errors)) {
              if (!Array.isArray(t4.errors)) return m.push(t4.errors), u.finalize(e3, m, i2);
              if (t4.errors.length) return m.push(...t4.errors), u.finalize(e3, m, i2);
            }
          }
          return t3._rules.length ? u.rules(e3, m, i2) : u.finalize(e3, m, i2);
        }, u.rules = function(e3, t3, r2) {
          const { schema: s2, state: n2, prefs: a2 } = r2;
          for (const i2 of s2._rules) {
            const l2 = s2._definition.rules[i2.method];
            if (l2.convert && a2.convert) {
              n2.mainstay.tracer.log(s2, n2, "rule", i2.name, "full");
              continue;
            }
            let c2, f = i2.args;
            if (i2._resolve.length) {
              f = Object.assign({}, f);
              for (const t4 of i2._resolve) {
                const r3 = l2.argsByName.get(t4), i3 = f[t4].resolve(e3, n2, a2), u2 = r3.normalize ? r3.normalize(i3) : i3, m2 = o.validateArg(u2, null, r3);
                if (m2) {
                  c2 = s2.$_createError("any.ref", i3, { arg: t4, ref: f[t4], reason: m2 }, n2, a2);
                  break;
                }
                f[t4] = u2;
              }
            }
            c2 = c2 || l2.validate(e3, r2, f, i2);
            const m = u.rule(c2, i2);
            if (m.errors) {
              if (n2.mainstay.tracer.log(s2, n2, "rule", i2.name, "error"), i2.warn) {
                n2.mainstay.warnings.push(...m.errors);
                continue;
              }
              if (a2.abortEarly) return u.finalize(e3, m.errors, r2);
              t3.push(...m.errors);
            } else n2.mainstay.tracer.log(s2, n2, "rule", i2.name, "pass"), n2.mainstay.tracer.value(n2, "rule", e3, m.value, i2.name), e3 = m.value;
          }
          return u.finalize(e3, t3, r2);
        }, u.rule = function(e3, t3) {
          return e3 instanceof l.Report ? (u.error(e3, t3), { errors: [e3], value: null }) : Array.isArray(e3) && e3[o.symbols.errors] ? (e3.forEach((e4) => u.error(e4, t3)), { errors: e3, value: null }) : { errors: null, value: e3 };
        }, u.error = function(e3, t3) {
          return t3.message && e3._setTemplate(t3.message), e3;
        }, u.finalize = function(e3, t3, r2) {
          t3 = t3 || [];
          const { schema: n2, state: a2, prefs: i2 } = r2;
          if (t3.length) {
            const s2 = u.default("failover", void 0, t3, r2);
            void 0 !== s2 && (a2.mainstay.tracer.value(a2, "failover", e3, s2), e3 = s2, t3 = []);
          }
          if (t3.length && n2._flags.error) if ("function" == typeof n2._flags.error) {
            t3 = n2._flags.error(t3), Array.isArray(t3) || (t3 = [t3]);
            for (const e4 of t3) s(e4 instanceof Error || e4 instanceof l.Report, "error() must return an Error object");
          } else t3 = [n2._flags.error];
          if (void 0 === e3) {
            const s2 = u.default("default", e3, t3, r2);
            a2.mainstay.tracer.value(a2, "default", e3, s2), e3 = s2;
          }
          if (n2._flags.cast && void 0 !== e3) {
            const t4 = n2._definition.cast[n2._flags.cast];
            if (t4.from(e3)) {
              const s2 = t4.to(e3, r2);
              a2.mainstay.tracer.value(a2, "cast", e3, s2, n2._flags.cast), e3 = s2;
            }
          }
          if (n2.$_terms.externals && i2.externals && false !== i2._externals) for (const { method: e4 } of n2.$_terms.externals) a2.mainstay.externals.push({ method: e4, schema: n2, state: a2, label: l.label(n2._flags, a2, i2) });
          const o2 = { value: e3, errors: t3.length ? t3 : null };
          return n2._flags.result && (o2.value = "strip" === n2._flags.result ? void 0 : r2.original, a2.mainstay.tracer.value(a2, n2._flags.result, e3, o2.value), a2.shadow(e3, n2._flags.result)), n2._cache && false !== i2.cache && !n2._refs.length && n2._cache.set(r2.original, o2), void 0 === e3 || o2.errors || void 0 === n2._flags.artifact || (a2.mainstay.artifacts = a2.mainstay.artifacts || /* @__PURE__ */ new Map(), a2.mainstay.artifacts.has(n2._flags.artifact) || a2.mainstay.artifacts.set(n2._flags.artifact, []), a2.mainstay.artifacts.get(n2._flags.artifact).push(a2.path)), o2;
        }, u.prefs = function(e3, t3) {
          const r2 = t3 === o.defaults;
          return r2 && e3._preferences[o.symbols.prefs] ? e3._preferences[o.symbols.prefs] : (t3 = o.preferences(t3, e3._preferences), r2 && (e3._preferences[o.symbols.prefs] = t3), t3);
        }, u.default = function(e3, t3, r2, s2) {
          const { schema: a2, state: i2, prefs: l2 } = s2, c2 = a2._flags[e3];
          if (l2.noDefaults || void 0 === c2) return t3;
          if (i2.mainstay.tracer.log(a2, i2, "rule", e3, "full"), !c2) return c2;
          if ("function" == typeof c2) {
            const t4 = c2.length ? [n(i2.ancestors[0]), s2] : [];
            try {
              return c2(...t4);
            } catch (t5) {
              return void r2.push(a2.$_createError(`any.${e3}`, null, { error: t5 }, i2, l2));
            }
          }
          return "object" != typeof c2 ? c2 : c2[o.symbols.literal] ? c2.literal : o.isResolvable(c2) ? c2.resolve(t3, i2, l2) : n(c2);
        }, u.trim = function(e3, t3) {
          if ("string" != typeof e3) return e3;
          const r2 = t3.$_getRule("trim");
          return r2 && r2.args.enabled ? e3.trim() : e3;
        }, u.ignore = { active: false, debug: a, entry: a, filter: a, log: a, resolve: a, value: a }, u.errorsArray = function() {
          const e3 = [];
          return e3[o.symbols.errors] = true, e3;
        };
      }, 2036: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(9474), a = r(8160), i = {};
        e2.exports = i.Values = class {
          constructor(e3, t3) {
            this._values = new Set(e3), this._refs = new Set(t3), this._lowercase = i.lowercases(e3), this._override = false;
          }
          get length() {
            return this._values.size + this._refs.size;
          }
          add(e3, t3) {
            a.isResolvable(e3) ? this._refs.has(e3) || (this._refs.add(e3), t3 && t3.register(e3)) : this.has(e3, null, null, false) || (this._values.add(e3), "string" == typeof e3 && this._lowercase.set(e3.toLowerCase(), e3));
          }
          static merge(e3, t3, r2) {
            if (e3 = e3 || new i.Values(), t3) {
              if (t3._override) return t3.clone();
              for (const r3 of [...t3._values, ...t3._refs]) e3.add(r3);
            }
            if (r2) for (const t4 of [...r2._values, ...r2._refs]) e3.remove(t4);
            return e3.length ? e3 : null;
          }
          remove(e3) {
            a.isResolvable(e3) ? this._refs.delete(e3) : (this._values.delete(e3), "string" == typeof e3 && this._lowercase.delete(e3.toLowerCase()));
          }
          has(e3, t3, r2, s2) {
            return !!this.get(e3, t3, r2, s2);
          }
          get(e3, t3, r2, s2) {
            if (!this.length) return false;
            if (this._values.has(e3)) return { value: e3 };
            if ("string" == typeof e3 && e3 && s2) {
              const t4 = this._lowercase.get(e3.toLowerCase());
              if (t4) return { value: t4 };
            }
            if (!this._refs.size && "object" != typeof e3) return false;
            if ("object" == typeof e3) {
              for (const t4 of this._values) if (n(t4, e3)) return { value: t4 };
            }
            if (t3) for (const a2 of this._refs) {
              const i2 = a2.resolve(e3, t3, r2, null, { in: true });
              if (void 0 === i2) continue;
              const o = a2.in && "object" == typeof i2 ? Array.isArray(i2) ? i2 : Object.keys(i2) : [i2];
              for (const t4 of o) if (typeof t4 == typeof e3) {
                if (s2 && e3 && "string" == typeof e3) {
                  if (t4.toLowerCase() === e3.toLowerCase()) return { value: t4, ref: a2 };
                } else if (n(t4, e3)) return { value: t4, ref: a2 };
              }
            }
            return false;
          }
          override() {
            this._override = true;
          }
          values(e3) {
            if (e3 && e3.display) {
              const e4 = [];
              for (const t3 of [...this._values, ...this._refs]) void 0 !== t3 && e4.push(t3);
              return e4;
            }
            return Array.from([...this._values, ...this._refs]);
          }
          clone() {
            const e3 = new i.Values(this._values, this._refs);
            return e3._override = this._override, e3;
          }
          concat(e3) {
            s(!e3._override, "Cannot concat override set of values");
            const t3 = new i.Values([...this._values, ...e3._values], [...this._refs, ...e3._refs]);
            return t3._override = this._override, t3;
          }
          describe() {
            const e3 = [];
            this._override && e3.push({ override: true });
            for (const t3 of this._values.values()) e3.push(t3 && "object" == typeof t3 ? { value: t3 } : t3);
            for (const t3 of this._refs.values()) e3.push(t3.describe());
            return e3;
          }
        }, i.Values.prototype[a.symbols.values] = true, i.Values.prototype.slice = i.Values.prototype.clone, i.lowercases = function(e3) {
          const t3 = /* @__PURE__ */ new Map();
          if (e3) for (const r2 of e3) "string" == typeof r2 && t3.set(r2.toLowerCase(), r2);
          return t3;
        };
      }, 978: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(1687), i = r(9621), o = {};
        e2.exports = function(e3, t3, r2 = {}) {
          if (s(e3 && "object" == typeof e3, "Invalid defaults value: must be an object"), s(!t3 || true === t3 || "object" == typeof t3, "Invalid source value: must be true, falsy or an object"), s("object" == typeof r2, "Invalid options: must be an object"), !t3) return null;
          if (r2.shallow) return o.applyToDefaultsWithShallow(e3, t3, r2);
          const i2 = n(e3);
          if (true === t3) return i2;
          const l = void 0 !== r2.nullOverride && r2.nullOverride;
          return a(i2, t3, { nullOverride: l, mergeArrays: false });
        }, o.applyToDefaultsWithShallow = function(e3, t3, r2) {
          const l = r2.shallow;
          s(Array.isArray(l), "Invalid keys");
          const c = /* @__PURE__ */ new Map(), u = true === t3 ? null : /* @__PURE__ */ new Set();
          for (let r3 of l) {
            r3 = Array.isArray(r3) ? r3 : r3.split(".");
            const s2 = i(e3, r3);
            s2 && "object" == typeof s2 ? c.set(s2, u && i(t3, r3) || s2) : u && u.add(r3);
          }
          const f = n(e3, {}, c);
          if (!u) return f;
          for (const e4 of u) o.reachCopy(f, t3, e4);
          const m = void 0 !== r2.nullOverride && r2.nullOverride;
          return a(f, t3, { nullOverride: m, mergeArrays: false });
        }, o.reachCopy = function(e3, t3, r2) {
          for (const e4 of r2) {
            if (!(e4 in t3)) return;
            const r3 = t3[e4];
            if ("object" != typeof r3 || null === r3) return;
            t3 = r3;
          }
          const s2 = t3;
          let n2 = e3;
          for (let e4 = 0; e4 < r2.length - 1; ++e4) {
            const t4 = r2[e4];
            "object" != typeof n2[t4] && (n2[t4] = {}), n2 = n2[t4];
          }
          n2[r2[r2.length - 1]] = s2;
        };
      }, 375: (e2, t2, r) => {
        "use strict";
        const s = r(7916);
        e2.exports = function(e3, ...t3) {
          if (!e3) {
            if (1 === t3.length && t3[0] instanceof Error) throw t3[0];
            throw new s(t3);
          }
        };
      }, 8571: (e2, t2, r) => {
        "use strict";
        const s = r(9621), n = r(4277), a = r(7043), i = { needsProtoHack: /* @__PURE__ */ new Set([n.set, n.map, n.weakSet, n.weakMap]) };
        e2.exports = i.clone = function(e3, t3 = {}, r2 = null) {
          if ("object" != typeof e3 || null === e3) return e3;
          let s2 = i.clone, o = r2;
          if (t3.shallow) {
            if (true !== t3.shallow) return i.cloneWithShallow(e3, t3);
            s2 = (e4) => e4;
          } else if (o) {
            const t4 = o.get(e3);
            if (t4) return t4;
          } else o = /* @__PURE__ */ new Map();
          const l = n.getInternalProto(e3);
          if (l === n.buffer) return false;
          if (l === n.date) return new Date(e3.getTime());
          if (l === n.regex) return new RegExp(e3);
          const c = i.base(e3, l, t3);
          if (c === e3) return e3;
          if (o && o.set(e3, c), l === n.set) for (const r3 of e3) c.add(s2(r3, t3, o));
          else if (l === n.map) for (const [r3, n2] of e3) c.set(r3, s2(n2, t3, o));
          const u = a.keys(e3, t3);
          for (const r3 of u) {
            if ("__proto__" === r3) continue;
            if (l === n.array && "length" === r3) {
              c.length = e3.length;
              continue;
            }
            const a2 = Object.getOwnPropertyDescriptor(e3, r3);
            a2 ? a2.get || a2.set ? Object.defineProperty(c, r3, a2) : a2.enumerable ? c[r3] = s2(e3[r3], t3, o) : Object.defineProperty(c, r3, { enumerable: false, writable: true, configurable: true, value: s2(e3[r3], t3, o) }) : Object.defineProperty(c, r3, { enumerable: true, writable: true, configurable: true, value: s2(e3[r3], t3, o) });
          }
          return c;
        }, i.cloneWithShallow = function(e3, t3) {
          const r2 = t3.shallow;
          (t3 = Object.assign({}, t3)).shallow = false;
          const n2 = /* @__PURE__ */ new Map();
          for (const t4 of r2) {
            const r3 = s(e3, t4);
            "object" != typeof r3 && "function" != typeof r3 || n2.set(r3, r3);
          }
          return i.clone(e3, t3, n2);
        }, i.base = function(e3, t3, r2) {
          if (false === r2.prototype) return i.needsProtoHack.has(t3) ? new t3.constructor() : t3 === n.array ? [] : {};
          const s2 = Object.getPrototypeOf(e3);
          if (s2 && s2.isImmutable) return e3;
          if (t3 === n.array) {
            const e4 = [];
            return s2 !== t3 && Object.setPrototypeOf(e4, s2), e4;
          }
          if (i.needsProtoHack.has(t3)) {
            const e4 = new s2.constructor();
            return s2 !== t3 && Object.setPrototypeOf(e4, s2), e4;
          }
          return Object.create(s2);
        };
      }, 9474: (e2, t2, r) => {
        "use strict";
        const s = r(4277), n = { mismatched: null };
        e2.exports = function(e3, t3, r2) {
          return r2 = Object.assign({ prototype: true }, r2), !!n.isDeepEqual(e3, t3, r2, []);
        }, n.isDeepEqual = function(e3, t3, r2, a) {
          if (e3 === t3) return 0 !== e3 || 1 / e3 == 1 / t3;
          const i = typeof e3;
          if (i !== typeof t3) return false;
          if (null === e3 || null === t3) return false;
          if ("function" === i) {
            if (!r2.deepFunction || e3.toString() !== t3.toString()) return false;
          } else if ("object" !== i) return e3 != e3 && t3 != t3;
          const o = n.getSharedType(e3, t3, !!r2.prototype);
          switch (o) {
            case s.buffer:
              return false;
            case s.promise:
              return e3 === t3;
            case s.regex:
              return e3.toString() === t3.toString();
            case n.mismatched:
              return false;
          }
          for (let r3 = a.length - 1; r3 >= 0; --r3) if (a[r3].isSame(e3, t3)) return true;
          a.push(new n.SeenEntry(e3, t3));
          try {
            return !!n.isDeepEqualObj(o, e3, t3, r2, a);
          } finally {
            a.pop();
          }
        }, n.getSharedType = function(e3, t3, r2) {
          if (r2) return Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3) ? n.mismatched : s.getInternalProto(e3);
          const a = s.getInternalProto(e3);
          return a !== s.getInternalProto(t3) ? n.mismatched : a;
        }, n.valueOf = function(e3) {
          const t3 = e3.valueOf;
          if (void 0 === t3) return e3;
          try {
            return t3.call(e3);
          } catch (e4) {
            return e4;
          }
        }, n.hasOwnEnumerableProperty = function(e3, t3) {
          return Object.prototype.propertyIsEnumerable.call(e3, t3);
        }, n.isSetSimpleEqual = function(e3, t3) {
          for (const r2 of Set.prototype.values.call(e3)) if (!Set.prototype.has.call(t3, r2)) return false;
          return true;
        }, n.isDeepEqualObj = function(e3, t3, r2, a, i) {
          const { isDeepEqual: o, valueOf: l, hasOwnEnumerableProperty: c } = n, { keys: u, getOwnPropertySymbols: f } = Object;
          if (e3 === s.array) {
            if (!a.part) {
              if (t3.length !== r2.length) return false;
              for (let e4 = 0; e4 < t3.length; ++e4) if (!o(t3[e4], r2[e4], a, i)) return false;
              return true;
            }
            for (const e4 of t3) for (const t4 of r2) if (o(e4, t4, a, i)) return true;
          } else if (e3 === s.set) {
            if (t3.size !== r2.size) return false;
            if (!n.isSetSimpleEqual(t3, r2)) {
              const e4 = new Set(Set.prototype.values.call(r2));
              for (const r3 of Set.prototype.values.call(t3)) {
                if (e4.delete(r3)) continue;
                let t4 = false;
                for (const s2 of e4) if (o(r3, s2, a, i)) {
                  e4.delete(s2), t4 = true;
                  break;
                }
                if (!t4) return false;
              }
            }
          } else if (e3 === s.map) {
            if (t3.size !== r2.size) return false;
            for (const [e4, s2] of Map.prototype.entries.call(t3)) {
              if (void 0 === s2 && !Map.prototype.has.call(r2, e4)) return false;
              if (!o(s2, Map.prototype.get.call(r2, e4), a, i)) return false;
            }
          } else if (e3 === s.error && (t3.name !== r2.name || t3.message !== r2.message)) return false;
          const m = l(t3), h = l(r2);
          if ((t3 !== m || r2 !== h) && !o(m, h, a, i)) return false;
          const d = u(t3);
          if (!a.part && d.length !== u(r2).length && !a.skip) return false;
          let p = 0;
          for (const e4 of d) if (a.skip && a.skip.includes(e4)) void 0 === r2[e4] && ++p;
          else {
            if (!c(r2, e4)) return false;
            if (!o(t3[e4], r2[e4], a, i)) return false;
          }
          if (!a.part && d.length - p !== u(r2).length) return false;
          if (false !== a.symbols) {
            const e4 = f(t3), s2 = new Set(f(r2));
            for (const n2 of e4) {
              if (!a.skip || !a.skip.includes(n2)) {
                if (c(t3, n2)) {
                  if (!c(r2, n2)) return false;
                  if (!o(t3[n2], r2[n2], a, i)) return false;
                } else if (c(r2, n2)) return false;
              }
              s2.delete(n2);
            }
            for (const e5 of s2) if (c(r2, e5)) return false;
          }
          return true;
        }, n.SeenEntry = class {
          constructor(e3, t3) {
            this.obj = e3, this.ref = t3;
          }
          isSame(e3, t3) {
            return this.obj === e3 && this.ref === t3;
          }
        };
      }, 7916: (e2, t2, r) => {
        "use strict";
        const s = r(8761);
        e2.exports = class extends Error {
          constructor(e3) {
            super(e3.filter((e4) => "" !== e4).map((e4) => "string" == typeof e4 ? e4 : e4 instanceof Error ? e4.message : s(e4)).join(" ") || "Unknown error"), "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, t2.assert);
          }
        };
      }, 5277: (e2) => {
        "use strict";
        const t2 = {};
        e2.exports = function(e3) {
          if (!e3) return "";
          let r = "";
          for (let s = 0; s < e3.length; ++s) {
            const n = e3.charCodeAt(s);
            t2.isSafe(n) ? r += e3[s] : r += t2.escapeHtmlChar(n);
          }
          return r;
        }, t2.escapeHtmlChar = function(e3) {
          return t2.namedHtml.get(e3) || (e3 >= 256 ? "&#" + e3 + ";" : `&#x${e3.toString(16).padStart(2, "0")};`);
        }, t2.isSafe = function(e3) {
          return t2.safeCharCodes.has(e3);
        }, t2.namedHtml = /* @__PURE__ */ new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [34, "&quot;"], [160, "&nbsp;"], [162, "&cent;"], [163, "&pound;"], [164, "&curren;"], [169, "&copy;"], [174, "&reg;"]]), t2.safeCharCodes = function() {
          const e3 = /* @__PURE__ */ new Set();
          for (let t3 = 32; t3 < 123; ++t3) (t3 >= 97 || t3 >= 65 && t3 <= 90 || t3 >= 48 && t3 <= 57 || 32 === t3 || 46 === t3 || 44 === t3 || 45 === t3 || 58 === t3 || 95 === t3) && e3.add(t3);
          return e3;
        }();
      }, 6064: (e2) => {
        "use strict";
        e2.exports = function(e3) {
          return e3.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
        };
      }, 738: (e2) => {
        "use strict";
        e2.exports = function() {
        };
      }, 1687: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(8571), a = r(7043), i = {};
        e2.exports = i.merge = function(e3, t3, r2) {
          if (s(e3 && "object" == typeof e3, "Invalid target value: must be an object"), s(null == t3 || "object" == typeof t3, "Invalid source value: must be null, undefined, or an object"), !t3) return e3;
          if (r2 = Object.assign({ nullOverride: true, mergeArrays: true }, r2), Array.isArray(t3)) {
            s(Array.isArray(e3), "Cannot merge array onto an object"), r2.mergeArrays || (e3.length = 0);
            for (let s2 = 0; s2 < t3.length; ++s2) e3.push(n(t3[s2], { symbols: r2.symbols }));
            return e3;
          }
          const o = a.keys(t3, r2);
          for (let s2 = 0; s2 < o.length; ++s2) {
            const a2 = o[s2];
            if ("__proto__" === a2 || !Object.prototype.propertyIsEnumerable.call(t3, a2)) continue;
            const l = t3[a2];
            if (l && "object" == typeof l) {
              if (e3[a2] === l) continue;
              !e3[a2] || "object" != typeof e3[a2] || Array.isArray(e3[a2]) !== Array.isArray(l) || l instanceof Date || l instanceof RegExp ? e3[a2] = n(l, { symbols: r2.symbols }) : i.merge(e3[a2], l, r2);
            } else (null != l || r2.nullOverride) && (e3[a2] = l);
          }
          return e3;
        };
      }, 9621: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = {};
        e2.exports = function(e3, t3, r2) {
          if (false === t3 || null == t3) return e3;
          "string" == typeof (r2 = r2 || {}) && (r2 = { separator: r2 });
          const a = Array.isArray(t3);
          s(!a || !r2.separator, "Separator option is not valid for array-based chain");
          const i = a ? t3 : t3.split(r2.separator || ".");
          let o = e3;
          for (let e4 = 0; e4 < i.length; ++e4) {
            let a2 = i[e4];
            const l = r2.iterables && n.iterables(o);
            if (Array.isArray(o) || "set" === l) {
              const e5 = Number(a2);
              Number.isInteger(e5) && (a2 = e5 < 0 ? o.length + e5 : e5);
            }
            if (!o || "function" == typeof o && false === r2.functions || !l && void 0 === o[a2]) {
              s(!r2.strict || e4 + 1 === i.length, "Missing segment", a2, "in reach path ", t3), s("object" == typeof o || true === r2.functions || "function" != typeof o, "Invalid segment", a2, "in reach path ", t3), o = r2.default;
              break;
            }
            o = l ? "set" === l ? [...o][a2] : o.get(a2) : o[a2];
          }
          return o;
        }, n.iterables = function(e3) {
          return e3 instanceof Set ? "set" : e3 instanceof Map ? "map" : void 0;
        };
      }, 8761: (e2) => {
        "use strict";
        e2.exports = function(...e3) {
          try {
            return JSON.stringify(...e3);
          } catch (e4) {
            return "[Cannot display object: " + e4.message + "]";
          }
        };
      }, 4277: (e2, t2) => {
        "use strict";
        const r = {};
        t2 = e2.exports = { array: Array.prototype, buffer: false, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, r.typeMap = /* @__PURE__ */ new Map([["[object Error]", t2.error], ["[object Map]", t2.map], ["[object Promise]", t2.promise], ["[object Set]", t2.set], ["[object WeakMap]", t2.weakMap], ["[object WeakSet]", t2.weakSet]]), t2.getInternalProto = function(e3) {
          if (Array.isArray(e3)) return t2.array;
          if (e3 instanceof Date) return t2.date;
          if (e3 instanceof RegExp) return t2.regex;
          if (e3 instanceof Error) return t2.error;
          const s = Object.prototype.toString.call(e3);
          return r.typeMap.get(s) || t2.generic;
        };
      }, 7043: (e2, t2) => {
        "use strict";
        t2.keys = function(e3, t3 = {}) {
          return false !== t3.symbols ? Reflect.ownKeys(e3) : Object.getOwnPropertyNames(e3);
        };
      }, 3652: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = {};
        t2.Sorter = class {
          constructor() {
            this._items = [], this.nodes = [];
          }
          add(e3, t3) {
            const r2 = [].concat((t3 = t3 || {}).before || []), n2 = [].concat(t3.after || []), a = t3.group || "?", i = t3.sort || 0;
            s(!r2.includes(a), `Item cannot come before itself: ${a}`), s(!r2.includes("?"), "Item cannot come before unassociated items"), s(!n2.includes(a), `Item cannot come after itself: ${a}`), s(!n2.includes("?"), "Item cannot come after unassociated items"), Array.isArray(e3) || (e3 = [e3]);
            for (const t4 of e3) {
              const e4 = { seq: this._items.length, sort: i, before: r2, after: n2, group: a, node: t4 };
              this._items.push(e4);
            }
            if (!t3.manual) {
              const e4 = this._sort();
              s(e4, "item", "?" !== a ? `added into group ${a}` : "", "created a dependencies error");
            }
            return this.nodes;
          }
          merge(e3) {
            Array.isArray(e3) || (e3 = [e3]);
            for (const t4 of e3) if (t4) for (const e4 of t4._items) this._items.push(Object.assign({}, e4));
            this._items.sort(n.mergeSort);
            for (let e4 = 0; e4 < this._items.length; ++e4) this._items[e4].seq = e4;
            const t3 = this._sort();
            return s(t3, "merge created a dependencies error"), this.nodes;
          }
          sort() {
            const e3 = this._sort();
            return s(e3, "sort created a dependencies error"), this.nodes;
          }
          _sort() {
            const e3 = {}, t3 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ Object.create(null);
            for (const s3 of this._items) {
              const n3 = s3.seq, a2 = s3.group;
              r2[a2] = r2[a2] || [], r2[a2].push(n3), e3[n3] = s3.before;
              for (const e4 of s3.after) t3[e4] = t3[e4] || [], t3[e4].push(n3);
            }
            for (const t4 in e3) {
              const s3 = [];
              for (const n3 in e3[t4]) {
                const a2 = e3[t4][n3];
                r2[a2] = r2[a2] || [], s3.push(...r2[a2]);
              }
              e3[t4] = s3;
            }
            for (const s3 in t3) if (r2[s3]) for (const n3 of r2[s3]) e3[n3].push(...t3[s3]);
            const s2 = {};
            for (const t4 in e3) {
              const r3 = e3[t4];
              for (const e4 of r3) s2[e4] = s2[e4] || [], s2[e4].push(t4);
            }
            const n2 = {}, a = [];
            for (let e4 = 0; e4 < this._items.length; ++e4) {
              let t4 = e4;
              if (s2[e4]) {
                t4 = null;
                for (let e5 = 0; e5 < this._items.length; ++e5) {
                  if (true === n2[e5]) continue;
                  s2[e5] || (s2[e5] = []);
                  const r3 = s2[e5].length;
                  let a2 = 0;
                  for (let t5 = 0; t5 < r3; ++t5) n2[s2[e5][t5]] && ++a2;
                  if (a2 === r3) {
                    t4 = e5;
                    break;
                  }
                }
              }
              null !== t4 && (n2[t4] = true, a.push(t4));
            }
            if (a.length !== this._items.length) return false;
            const i = {};
            for (const e4 of this._items) i[e4.seq] = e4;
            this._items = [], this.nodes = [];
            for (const e4 of a) {
              const t4 = i[e4];
              this.nodes.push(t4.node), this._items.push(t4);
            }
            return true;
          }
        }, n.mergeSort = (e3, t3) => e3.sort === t3.sort ? 0 : e3.sort < t3.sort ? -1 : 1;
      }, 5380: (e2, t2, r) => {
        "use strict";
        const s = r(443), n = r(2178), a = { minDomainSegments: 2, nonAsciiRx: /[^\x00-\x7f]/, domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/, tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, URL: s.URL || URL };
        t2.analyze = function(e3, t3 = {}) {
          if (!e3) return n.code("DOMAIN_NON_EMPTY_STRING");
          if ("string" != typeof e3) throw new Error("Invalid input: domain must be a string");
          if (e3.length > 256) return n.code("DOMAIN_TOO_LONG");
          if (a.nonAsciiRx.test(e3)) {
            if (false === t3.allowUnicode) return n.code("DOMAIN_INVALID_UNICODE_CHARS");
            e3 = e3.normalize("NFC");
          }
          if (a.domainControlRx.test(e3)) return n.code("DOMAIN_INVALID_CHARS");
          e3 = a.punycode(e3), t3.allowFullyQualified && "." === e3[e3.length - 1] && (e3 = e3.slice(0, -1));
          const r2 = t3.minDomainSegments || a.minDomainSegments, s2 = e3.split(".");
          if (s2.length < r2) return n.code("DOMAIN_SEGMENTS_COUNT");
          if (t3.maxDomainSegments && s2.length > t3.maxDomainSegments) return n.code("DOMAIN_SEGMENTS_COUNT_MAX");
          const i = t3.tlds;
          if (i) {
            const e4 = s2[s2.length - 1].toLowerCase();
            if (i.deny && i.deny.has(e4) || i.allow && !i.allow.has(e4)) return n.code("DOMAIN_FORBIDDEN_TLDS");
          }
          for (let e4 = 0; e4 < s2.length; ++e4) {
            const t4 = s2[e4];
            if (!t4.length) return n.code("DOMAIN_EMPTY_SEGMENT");
            if (t4.length > 63) return n.code("DOMAIN_LONG_SEGMENT");
            if (e4 < s2.length - 1) {
              if (!a.domainSegmentRx.test(t4)) return n.code("DOMAIN_INVALID_CHARS");
            } else if (!a.tldSegmentRx.test(t4)) return n.code("DOMAIN_INVALID_TLDS_CHARS");
          }
          return null;
        }, t2.isValid = function(e3, r2) {
          return !t2.analyze(e3, r2);
        }, a.punycode = function(e3) {
          e3.includes("%") && (e3 = e3.replace(/%/g, "%25"));
          try {
            return new a.URL(`http://${e3}`).host;
          } catch (t3) {
            return e3;
          }
        };
      }, 1745: (e2, t2, r) => {
        "use strict";
        const s = r(9848), n = r(5380), a = r(2178), i = { nonAsciiRx: /[^\x00-\x7f]/, encoder: new (s.TextEncoder || TextEncoder)() };
        t2.analyze = function(e3, t3) {
          return i.email(e3, t3);
        }, t2.isValid = function(e3, t3) {
          return !i.email(e3, t3);
        }, i.email = function(e3, t3 = {}) {
          if ("string" != typeof e3) throw new Error("Invalid input: email must be a string");
          if (!e3) return a.code("EMPTY_STRING");
          const r2 = !i.nonAsciiRx.test(e3);
          if (!r2) {
            if (false === t3.allowUnicode) return a.code("FORBIDDEN_UNICODE");
            e3 = e3.normalize("NFC");
          }
          const s2 = e3.split("@");
          if (2 !== s2.length) return s2.length > 2 ? a.code("MULTIPLE_AT_CHAR") : a.code("MISSING_AT_CHAR");
          const [o, l] = s2;
          if (!o) return a.code("EMPTY_LOCAL");
          if (!t3.ignoreLength) {
            if (e3.length > 254) return a.code("ADDRESS_TOO_LONG");
            if (i.encoder.encode(o).length > 64) return a.code("LOCAL_TOO_LONG");
          }
          return i.local(o, r2) || n.analyze(l, t3);
        }, i.local = function(e3, t3) {
          const r2 = e3.split(".");
          for (const e4 of r2) {
            if (!e4.length) return a.code("EMPTY_LOCAL_SEGMENT");
            if (t3) {
              if (!i.atextRx.test(e4)) return a.code("INVALID_LOCAL_CHARS");
            } else for (const t4 of e4) {
              if (i.atextRx.test(t4)) continue;
              const e5 = i.binary(t4);
              if (!i.atomRx.test(e5)) return a.code("INVALID_LOCAL_CHARS");
            }
          }
        }, i.binary = function(e3) {
          return Array.from(i.encoder.encode(e3)).map((e4) => String.fromCharCode(e4)).join("");
        }, i.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, i.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));
      }, 2178: (e2, t2) => {
        "use strict";
        t2.codes = { EMPTY_STRING: "Address must be a non-empty string", FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters", MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character", MISSING_AT_CHAR: "Address must contain one @ character", EMPTY_LOCAL: "Address local part cannot be empty", ADDRESS_TOO_LONG: "Address too long", LOCAL_TOO_LONG: "Address local part too long", EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment", INVALID_LOCAL_CHARS: "Address local part contains invalid character", DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string", DOMAIN_TOO_LONG: "Domain too long", DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters", DOMAIN_INVALID_CHARS: "Domain contains invalid character", DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character", DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments", DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments", DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD", DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment", DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long" }, t2.code = function(e3) {
          return { code: e3, error: t2.codes[e3] };
        };
      }, 9959: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(5752);
        t2.regex = function(e3 = {}) {
          s(void 0 === e3.cidr || "string" == typeof e3.cidr, "options.cidr must be a string");
          const t3 = e3.cidr ? e3.cidr.toLowerCase() : "optional";
          s(["required", "optional", "forbidden"].includes(t3), "options.cidr must be one of required, optional, forbidden"), s(void 0 === e3.version || "string" == typeof e3.version || Array.isArray(e3.version), "options.version must be a string or an array of string");
          let r2 = e3.version || ["ipv4", "ipv6", "ipvfuture"];
          Array.isArray(r2) || (r2 = [r2]), s(r2.length >= 1, "options.version must have at least 1 version specified");
          for (let e4 = 0; e4 < r2.length; ++e4) s("string" == typeof r2[e4], "options.version must only contain strings"), r2[e4] = r2[e4].toLowerCase(), s(["ipv4", "ipv6", "ipvfuture"].includes(r2[e4]), "options.version contains unknown version " + r2[e4] + " - must be one of ipv4, ipv6, ipvfuture");
          r2 = Array.from(new Set(r2));
          const a = `(?:${r2.map((e4) => {
            if ("forbidden" === t3) return n.ip[e4];
            const r3 = `\\/${"ipv4" === e4 ? n.ip.v4Cidr : n.ip.v6Cidr}`;
            return "required" === t3 ? `${n.ip[e4]}${r3}` : `${n.ip[e4]}(?:${r3})?`;
          }).join("|")})`, i = new RegExp(`^${a}$`);
          return { cidr: t3, versions: r2, regex: i, raw: a };
        };
      }, 5752: (e2, t2, r) => {
        "use strict";
        const s = r(375), n = r(6064), a = { generate: function() {
          const e3 = {}, t3 = "\\dA-Fa-f", r2 = "[" + t3 + "]", s2 = "\\w-\\.~", n2 = "!\\$&'\\(\\)\\*\\+,;=", a2 = "%" + t3, i = s2 + a2 + n2 + ":@", o = "[" + i + "]", l = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
          e3.ipv4address = "(?:" + l + "\\.){3}" + l;
          const c = r2 + "{1,4}", u = "(?:" + c + ":" + c + "|" + e3.ipv4address + ")", f = "(?:" + c + ":){6}" + u, m = "::(?:" + c + ":){5}" + u, h = "(?:" + c + ")?::(?:" + c + ":){4}" + u, d = "(?:(?:" + c + ":){0,1}" + c + ")?::(?:" + c + ":){3}" + u, p = "(?:(?:" + c + ":){0,2}" + c + ")?::(?:" + c + ":){2}" + u, g = "(?:(?:" + c + ":){0,3}" + c + ")?::" + c + ":" + u, y = "(?:(?:" + c + ":){0,4}" + c + ")?::" + u, b = "(?:(?:" + c + ":){0,5}" + c + ")?::" + c, v = "(?:(?:" + c + ":){0,6}" + c + ")?::";
          e3.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", e3.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", e3.ipv6address = "(?:" + f + "|" + m + "|" + h + "|" + d + "|" + p + "|" + g + "|" + y + "|" + b + "|" + v + ")", e3.ipvFuture = "v" + r2 + "+\\.[" + s2 + n2 + ":]+", e3.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", e3.schemeRegex = new RegExp(e3.scheme);
          const _ = "[" + s2 + a2 + n2 + ":]*", w = "[" + s2 + a2 + n2 + "]{1,255}", $ = "(?:\\[(?:" + e3.ipv6address + "|" + e3.ipvFuture + ")\\]|" + e3.ipv4address + "|" + w + ")", x = "(?:" + _ + "@)?" + $ + "(?::\\d*)?", j = "(?:" + _ + "@)?(" + $ + ")(?::\\d*)?", k = o + "*", R = o + "+", S = "(?:\\/" + k + ")*", A = "\\/(?:" + R + S + ")?", O = R + S, E = "[" + s2 + a2 + n2 + "@]+" + S, D = "(?:\\/\\/\\/" + k + S + ")";
          return e3.hierPart = "(?:(?:\\/\\/" + x + S + ")|" + A + "|" + O + "|" + D + ")", e3.hierPartCapture = "(?:(?:\\/\\/" + j + S + ")|" + A + "|" + O + ")", e3.relativeRef = "(?:(?:\\/\\/" + x + S + ")|" + A + "|" + E + "|)", e3.relativeRefCapture = "(?:(?:\\/\\/" + j + S + ")|" + A + "|" + E + "|)", e3.query = "[" + i + "\\/\\?]*(?=#|$)", e3.queryWithSquareBrackets = "[" + i + "\\[\\]\\/\\?]*(?=#|$)", e3.fragment = "[" + i + "\\/\\?]*", e3;
        } };
        a.rfc3986 = a.generate(), t2.ip = { v4Cidr: a.rfc3986.ipv4Cidr, v6Cidr: a.rfc3986.ipv6Cidr, ipv4: a.rfc3986.ipv4address, ipv6: a.rfc3986.ipv6address, ipvfuture: a.rfc3986.ipvFuture }, a.createRegex = function(e3) {
          const t3 = a.rfc3986, r2 = "(?:\\?" + (e3.allowQuerySquareBrackets ? t3.queryWithSquareBrackets : t3.query) + ")?(?:#" + t3.fragment + ")?", i = e3.domain ? t3.relativeRefCapture : t3.relativeRef;
          if (e3.relativeOnly) return a.wrap(i + r2);
          let o = "";
          if (e3.scheme) {
            s(e3.scheme instanceof RegExp || "string" == typeof e3.scheme || Array.isArray(e3.scheme), "scheme must be a RegExp, String, or Array");
            const r3 = [].concat(e3.scheme);
            s(r3.length >= 1, "scheme must have at least 1 scheme specified");
            const a2 = [];
            for (let e4 = 0; e4 < r3.length; ++e4) {
              const i2 = r3[e4];
              s(i2 instanceof RegExp || "string" == typeof i2, "scheme at position " + e4 + " must be a RegExp or String"), i2 instanceof RegExp ? a2.push(i2.source.toString()) : (s(t3.schemeRegex.test(i2), "scheme at position " + e4 + " must be a valid scheme"), a2.push(n(i2)));
            }
            o = a2.join("|");
          }
          const l = "(?:" + (o ? "(?:" + o + ")" : t3.scheme) + ":" + (e3.domain ? t3.hierPartCapture : t3.hierPart) + ")", c = e3.allowRelative ? "(?:" + l + "|" + i + ")" : l;
          return a.wrap(c + r2, o);
        }, a.wrap = function(e3, t3) {
          return { raw: e3 = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${e3}`, regex: new RegExp(`^${e3}$`), scheme: t3 };
        }, a.uriRegex = a.createRegex({}), t2.regex = function(e3 = {}) {
          return e3.scheme || e3.allowRelative || e3.relativeOnly || e3.allowQuerySquareBrackets || e3.domain ? a.createRegex(e3) : a.uriRegex;
        };
      }, 1447: (e2, t2) => {
        "use strict";
        const r = { operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"], operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"], operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]], operatorsPrefix: ["!", "n"], literals: { '"': '"', "`": "`", "'": "'", "[": "]" }, numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/, tokenRx: /^[\w\$\#\.\@\:\{\}]+$/, symbol: Symbol("formula"), settings: Symbol("settings") };
        t2.Parser = class {
          constructor(e3, t3 = {}) {
            if (!t3[r.settings] && t3.constants) for (const e4 in t3.constants) {
              const r2 = t3.constants[e4];
              if (null !== r2 && !["boolean", "number", "string"].includes(typeof r2)) throw new Error(`Formula constant ${e4} contains invalid ${typeof r2} value type`);
            }
            this.settings = t3[r.settings] ? t3 : Object.assign({ [r.settings]: true, constants: {}, functions: {} }, t3), this.single = null, this._parts = null, this._parse(e3);
          }
          _parse(e3) {
            let s = [], n = "", a = 0, i = false;
            const o = (e4) => {
              if (a) throw new Error("Formula missing closing parenthesis");
              const o2 = s.length ? s[s.length - 1] : null;
              if (i || n || e4) {
                if (o2 && "reference" === o2.type && ")" === e4) return o2.type = "function", o2.value = this._subFormula(n, o2.value), void (n = "");
                if (")" === e4) {
                  const e5 = new t2.Parser(n, this.settings);
                  s.push({ type: "segment", value: e5 });
                } else if (i) {
                  if ("]" === i) return s.push({ type: "reference", value: n }), void (n = "");
                  s.push({ type: "literal", value: n });
                } else if (r.operatorCharacters.includes(n)) o2 && "operator" === o2.type && r.operators.includes(o2.value + n) ? o2.value += n : s.push({ type: "operator", value: n });
                else if (n.match(r.numberRx)) s.push({ type: "constant", value: parseFloat(n) });
                else if (void 0 !== this.settings.constants[n]) s.push({ type: "constant", value: this.settings.constants[n] });
                else {
                  if (!n.match(r.tokenRx)) throw new Error(`Formula contains invalid token: ${n}`);
                  s.push({ type: "reference", value: n });
                }
                n = "";
              }
            };
            for (const t3 of e3) i ? t3 === i ? (o(), i = false) : n += t3 : a ? "(" === t3 ? (n += t3, ++a) : ")" === t3 ? (--a, a ? n += t3 : o(t3)) : n += t3 : t3 in r.literals ? i = r.literals[t3] : "(" === t3 ? (o(), ++a) : r.operatorCharacters.includes(t3) ? (o(), n = t3, o()) : " " !== t3 ? n += t3 : o();
            o(), s = s.map((e4, t3) => "operator" !== e4.type || "-" !== e4.value || t3 && "operator" !== s[t3 - 1].type ? e4 : { type: "operator", value: "n" });
            let l = false;
            for (const e4 of s) {
              if ("operator" === e4.type) {
                if (r.operatorsPrefix.includes(e4.value)) continue;
                if (!l) throw new Error("Formula contains an operator in invalid position");
                if (!r.operators.includes(e4.value)) throw new Error(`Formula contains an unknown operator ${e4.value}`);
              } else if (l) throw new Error("Formula missing expected operator");
              l = !l;
            }
            if (!l) throw new Error("Formula contains invalid trailing operator");
            1 === s.length && ["reference", "literal", "constant"].includes(s[0].type) && (this.single = { type: "reference" === s[0].type ? "reference" : "value", value: s[0].value }), this._parts = s.map((e4) => {
              if ("operator" === e4.type) return r.operatorsPrefix.includes(e4.value) ? e4 : e4.value;
              if ("reference" !== e4.type) return e4.value;
              if (this.settings.tokenRx && !this.settings.tokenRx.test(e4.value)) throw new Error(`Formula contains invalid reference ${e4.value}`);
              return this.settings.reference ? this.settings.reference(e4.value) : r.reference(e4.value);
            });
          }
          _subFormula(e3, s) {
            const n = this.settings.functions[s];
            if ("function" != typeof n) throw new Error(`Formula contains unknown function ${s}`);
            let a = [];
            if (e3) {
              let t3 = "", n2 = 0, i = false;
              const o = () => {
                if (!t3) throw new Error(`Formula contains function ${s} with invalid arguments ${e3}`);
                a.push(t3), t3 = "";
              };
              for (let s2 = 0; s2 < e3.length; ++s2) {
                const a2 = e3[s2];
                i ? (t3 += a2, a2 === i && (i = false)) : a2 in r.literals && !n2 ? (t3 += a2, i = r.literals[a2]) : "," !== a2 || n2 ? (t3 += a2, "(" === a2 ? ++n2 : ")" === a2 && --n2) : o();
              }
              o();
            }
            return a = a.map((e4) => new t2.Parser(e4, this.settings)), function(e4) {
              const t3 = [];
              for (const r2 of a) t3.push(r2.evaluate(e4));
              return n.call(e4, ...t3);
            };
          }
          evaluate(e3) {
            const t3 = this._parts.slice();
            for (let s = t3.length - 2; s >= 0; --s) {
              const n = t3[s];
              if (n && "operator" === n.type) {
                const a = t3[s + 1];
                t3.splice(s + 1, 1);
                const i = r.evaluate(a, e3);
                t3[s] = r.single(n.value, i);
              }
            }
            return r.operatorsOrder.forEach((s) => {
              for (let n = 1; n < t3.length - 1; ) if (s.includes(t3[n])) {
                const s2 = t3[n], a = r.evaluate(t3[n - 1], e3), i = r.evaluate(t3[n + 1], e3);
                t3.splice(n, 2);
                const o = r.calculate(s2, a, i);
                t3[n - 1] = 0 === o ? 0 : o;
              } else n += 2;
            }), r.evaluate(t3[0], e3);
          }
        }, t2.Parser.prototype[r.symbol] = true, r.reference = function(e3) {
          return function(t3) {
            return t3 && void 0 !== t3[e3] ? t3[e3] : null;
          };
        }, r.evaluate = function(e3, t3) {
          return null === e3 ? null : "function" == typeof e3 ? e3(t3) : e3[r.symbol] ? e3.evaluate(t3) : e3;
        }, r.single = function(e3, t3) {
          if ("!" === e3) return !t3;
          const r2 = -t3;
          return 0 === r2 ? 0 : r2;
        }, r.calculate = function(e3, t3, s) {
          if ("??" === e3) return r.exists(t3) ? t3 : s;
          if ("string" == typeof t3 || "string" == typeof s) {
            if ("+" === e3) return (t3 = r.exists(t3) ? t3 : "") + (r.exists(s) ? s : "");
          } else switch (e3) {
            case "^":
              return Math.pow(t3, s);
            case "*":
              return t3 * s;
            case "/":
              return t3 / s;
            case "%":
              return t3 % s;
            case "+":
              return t3 + s;
            case "-":
              return t3 - s;
          }
          switch (e3) {
            case "<":
              return t3 < s;
            case "<=":
              return t3 <= s;
            case ">":
              return t3 > s;
            case ">=":
              return t3 >= s;
            case "==":
              return t3 === s;
            case "!=":
              return t3 !== s;
            case "&&":
              return t3 && s;
            case "||":
              return t3 || s;
          }
          return null;
        }, r.exists = function(e3) {
          return null != e3;
        };
      }, 9926: () => {
      }, 5688: () => {
      }, 9708: () => {
      }, 1152: () => {
      }, 443: () => {
      }, 9848: () => {
      }, 5934: (e2) => {
        "use strict";
        e2.exports = JSON.parse('{"version":"17.13.3"}');
      } }, t = {}, function r(s) {
        var n = t[s];
        if (void 0 !== n) return n.exports;
        var a = t[s] = { exports: {} };
        return e[s](a, a.exports, r), a.exports;
      }(5107);
      var e, t;
    });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/validations/messageObject.js
var require_messageObject = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/validations/messageObject.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMessageObj = void 0;
    var Joi = require_joi_browser_min();
    var messageTypes_1 = require_messageTypes();
    var constants_1 = require_constants();
    var extractValidValues = (obj) => {
      const validValues = [];
      for (const key in obj) {
        if (typeof obj[key] === "string") {
          validValues.push(obj[key]);
        } else if (typeof obj[key] === "object") {
          validValues.push(...extractValidValues(obj[key]));
        }
      }
      return validValues;
    };
    var messageObjSchema = Joi.object({
      content: Joi.string().required().allow("")
    });
    var metaMessageObjSchema = Joi.object({
      content: Joi.string().valid(...Object.values(extractValidValues(messageTypes_1.CHAT.META))).required(),
      info: Joi.object({
        affected: Joi.array().items(Joi.string()).required(),
        arbitrary: Joi.object().pattern(Joi.string(), Joi.any())
      }).required()
    });
    var reationMessageObjSchema = Joi.object({
      content: Joi.string().valid(...Object.values(extractValidValues(messageTypes_1.CHAT.REACTION))).required(),
      reference: Joi.string().required()
    });
    var receiptMessageObjSchema = Joi.object({
      content: Joi.string().valid(...Object.values(extractValidValues(messageTypes_1.CHAT.RECEIPT))).required(),
      reference: Joi.string().required()
    });
    var userActivityMessageObjSchema = Joi.object({
      content: Joi.string().valid(...Object.values(extractValidValues(messageTypes_1.CHAT.UA))).required(),
      info: Joi.object({
        affected: Joi.array().items(Joi.string()).required(),
        arbitrary: Joi.object().pattern(Joi.string(), Joi.any())
      }).required()
    });
    var intentMessageObjSchema = Joi.object({
      content: Joi.string().valid(...Object.values(extractValidValues(messageTypes_1.CHAT.INTENT)))
    });
    var replyMessageObjSchema = Joi.object({
      content: Joi.object({
        messageType: Joi.string().valid(...Object.values([
          constants_1.MessageType.TEXT,
          constants_1.MessageType.IMAGE,
          constants_1.MessageType.AUDIO,
          constants_1.MessageType.VIDEO,
          constants_1.MessageType.FILE,
          constants_1.MessageType.MEDIA_EMBED
        ])).required(),
        messageObj: Joi.object({
          content: Joi.string().required()
          // Change the validation as needed
        }).required()
      }).required(),
      reference: Joi.string().required()
    });
    var compositeMessageObjSchema = Joi.object({
      content: Joi.array().items(Joi.object({
        messageType: Joi.string().valid(...Object.values([
          constants_1.MessageType.TEXT,
          constants_1.MessageType.IMAGE,
          constants_1.MessageType.AUDIO,
          constants_1.MessageType.VIDEO,
          constants_1.MessageType.FILE,
          constants_1.MessageType.MEDIA_EMBED
        ])).required(),
        messageObj: Joi.object({
          content: Joi.string().required()
        }).required()
      })).required()
    });
    var validateMessageObj = (messageObj, messageType) => {
      let error = void 0;
      switch (messageType) {
        case constants_1.MessageType.TEXT:
        case constants_1.MessageType.IMAGE:
        case constants_1.MessageType.VIDEO:
        case constants_1.MessageType.AUDIO:
        case constants_1.MessageType.FILE:
        case constants_1.MessageType.MEDIA_EMBED:
        case constants_1.MessageType.GIF: {
          error = messageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.META: {
          error = metaMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.REACTION: {
          error = reationMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.RECEIPT: {
          error = receiptMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.USER_ACTIVITY: {
          error = userActivityMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.INTENT: {
          error = intentMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.REPLY: {
          error = replyMessageObjSchema.validate(messageObj).error;
          break;
        }
        case constants_1.MessageType.COMPOSITE: {
          error = compositeMessageObjSchema.validate(messageObj).error;
          break;
        }
        default: {
          throw new Error("Invalid MessageType");
        }
      }
      if (error) {
        throw new Error(`Unable to parse this messageType. Please ensure 'messageObj' is properly defined.`);
      }
    };
    exports.validateMessageObj = validateMessageObj;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/send.js
var require_send = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/send.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendCore = exports.send = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var conversationHash_1 = require_conversationHash();
    var helpers_3 = require_helpers();
    var messageObject_1 = require_messageObject();
    var axiosUtil_1 = require_axiosUtil();
    var getGroupInfo_1 = require_getGroupInfo();
    var validationError_1 = require_validationError();
    var PUSH_CHAT = require_chat2();
    var send = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.sendCore)(options, helpers_2.PGPHelper);
    });
    exports.send = send;
    var sendCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c;
      try {
        const computedOptions = computeOptions(options);
        let { messageType, messageObj, account, to, signer, pgpPrivateKey, env } = computedOptions;
        yield validateOptions(computedOptions);
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const sender = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        let receiver = yield (0, helpers_1.convertToValidDID)(to, env);
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const isChatId = (0, helpers_1.isValidPushCAIP)(to) ? false : true;
        let isGroup = false;
        let group = null;
        if (isChatId) {
          const request = {
            recipient: to,
            account,
            env
          };
          const chatInfo = yield PUSH_CHAT.getChatInfo(request);
          isGroup = (_b = (_a = chatInfo === null || chatInfo === void 0 ? void 0 : chatInfo.meta) === null || _a === void 0 ? void 0 : _a.group) !== null && _b !== void 0 ? _b : false;
          group = isGroup ? yield (0, getGroupInfo_1.getGroupInfo)({
            chatId: to,
            env
          }) : null;
          if (!isGroup) {
            const participants = (_c = chatInfo.participants) !== null && _c !== void 0 ? _c : [];
            const messageSentTo = participants.find((participant) => participant !== (0, helpers_1.walletToPCAIP10)(account));
            to = messageSentTo;
            receiver = to;
          }
        }
        let messageContent;
        if (messageType === constants_1.MessageType.REPLY || messageType === constants_1.MessageType.COMPOSITE) {
          messageContent = "MessageType Not Supported by this sdk version. Plz upgrade !!!";
        } else {
          messageContent = messageObj.content;
        }
        const conversationResponse = yield (0, conversationHash_1.conversationHash)({
          conversationId: receiver,
          account: sender.did,
          env
        });
        let apiEndpoint;
        if (!isGroup && conversationResponse && !(conversationResponse === null || conversationResponse === void 0 ? void 0 : conversationResponse.threadHash)) {
          apiEndpoint = `${API_BASE_URL}/v1/chat/request`;
        } else {
          apiEndpoint = `${API_BASE_URL}/v1/chat/message`;
        }
        const body = yield (0, helpers_3.sendMessagePayloadCore)(receiver, sender, messageObj, messageContent, messageType, group, env, pgpHelper);
        const response = yield (0, axiosUtil_1.axiosPost)(apiEndpoint, body);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.send.name);
      }
    });
    exports.sendCore = sendCore;
    var validateOptions = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { messageType, messageObj, account, to, signer, pgpPrivateKey, env } = options;
      if (!account && !signer) {
        throw new Error(`Unable to detect sender. Please ensure that either 'account' or 'signer' is properly defined.`);
      }
      if (!signer && !pgpPrivateKey) {
        throw new Error(`Unable to decrypt keys. Please ensure that either 'signer' or 'pgpPrivateKey' is properly defined.`);
      }
      const wallet = (0, helpers_2.getWallet)({ account, signer });
      const address = yield (0, helpers_2.getAccountAddress)(wallet);
      if (!(0, helpers_1.isValidPushCAIP)(address)) {
        throw new Error(`Invalid sender. Please ensure that either 'account' or 'signer' is properly defined.`);
      }
      (0, messageObject_1.validateMessageObj)(messageObj, messageType);
    });
    var computeOptions = (options) => {
      var _a, _b, _c;
      const messageType = ((_a = options.message) === null || _a === void 0 ? void 0 : _a.type) !== void 0 ? options.message.type : (_b = options.messageType) !== null && _b !== void 0 ? _b : "Text";
      let messageObj = options.message;
      if (messageObj === void 0) {
        if (options.messageObj === void 0 && ![
          constants_1.MessageType.TEXT,
          constants_1.MessageType.IMAGE,
          constants_1.MessageType.FILE,
          constants_1.MessageType.MEDIA_EMBED,
          constants_1.MessageType.GIF
        ].includes(messageType)) {
          throw new Error("Options.message is required");
        } else {
          messageObj = options.messageObj !== void 0 ? options.messageObj : {
            content: (_c = options.messageContent) !== null && _c !== void 0 ? _c : ""
          };
        }
      } else {
        const { type } = messageObj, rest = tslib_1.__rest(messageObj, ["type"]);
        messageObj = rest;
      }
      if (messageType === constants_1.MessageType.REPLY) {
        if (typeof messageObj.content === "object") {
          const _d = messageObj.content, { type } = _d, rest = tslib_1.__rest(_d, ["type"]);
          messageObj.content = {
            messageType: type,
            messageObj: rest
          };
        } else {
          throw new Error("Options.message is not properly defined for Reply");
        }
      }
      if (messageType === constants_1.MessageType.COMPOSITE) {
        if (messageObj.content instanceof Array) {
          messageObj.content = messageObj.content.map((obj) => {
            const { type } = obj, rest = tslib_1.__rest(obj, ["type"]);
            return {
              messageType: type,
              messageObj: rest
            };
          });
        } else {
          throw new Error("Options.message is not properly defined for Composite");
        }
      }
      const account = options.account !== void 0 ? options.account : null;
      const to = options.to !== void 0 ? options.to : options.receiverAddress;
      if (to === void 0) {
        throw new Error("Options.to is required");
      }
      const signer = options.signer !== void 0 ? options.signer : null;
      const pgpPrivateKey = options.pgpPrivateKey !== void 0 ? options.pgpPrivateKey : null;
      const env = options.env !== void 0 ? options.env : constants_1.default.ENV.PROD;
      return {
        messageType,
        messageObj,
        account,
        to,
        signer,
        pgpPrivateKey,
        env
      };
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/historicalMessages.js
var require_historicalMessages = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/historicalMessages.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.historyCore = exports.history = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var helpers_1 = require_helpers2();
    var user_1 = require_user();
    var helpers_2 = require_helpers();
    var FetchLimit;
    (function(FetchLimit2) {
      FetchLimit2[FetchLimit2["MIN"] = 1] = "MIN";
      FetchLimit2[FetchLimit2["DEFAULT"] = 10] = "DEFAULT";
      FetchLimit2[FetchLimit2["MAX"] = 30] = "MAX";
    })(FetchLimit || (FetchLimit = {}));
    var history = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.historyCore)(options, helpers_2.PGPHelper);
    });
    exports.history = history;
    var historyCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { threadhash, limit = FetchLimit.DEFAULT, pgpPrivateKey = "", account, toDecrypt = false, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (limit < FetchLimit.MIN || limit > FetchLimit.MAX) {
          if (limit < FetchLimit.MIN)
            throw new Error(`Limit must be more than equal to ${FetchLimit.MIN}`);
          else
            throw new Error(`Limit must be less than equal to ${FetchLimit.MAX}`);
        }
        const messages = yield (0, helpers_2.getMessagesService)({ threadhash, limit, env });
        const updatedMessages = (0, helpers_2.addDeprecatedInfoToMessages)(messages);
        const connectedUser = yield (0, user_1.get)({ account: (0, helpers_1.pCAIP10ToWallet)(account), env });
        if (toDecrypt) {
          return yield (0, helpers_2.decryptConversation)({
            messages: updatedMessages,
            connectedUser,
            pgpPrivateKey,
            pgpHelper,
            env
          });
        }
        return messages;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.history.name);
      }
    });
    exports.historyCore = historyCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/latestMessage.js
var require_latestMessage = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/latestMessage.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.latestCore = exports.latest = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var historicalMessages_1 = require_historicalMessages();
    var latest = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.latestCore)(options, helpers_1.PGPHelper);
    });
    exports.latest = latest;
    var latestCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { threadhash, pgpPrivateKey = "", account, toDecrypt = false, env = constants_1.default.ENV.PROD } = options || {};
      return (0, historicalMessages_1.history)({
        threadhash,
        toDecrypt,
        limit: 1,
        pgpPrivateKey,
        account,
        env
      });
    });
    exports.latestCore = latestCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/createGroupV2.js
var require_createGroupV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/createGroupV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupCoreV2 = exports.createGroupV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var validationError_1 = require_validationError();
    var axiosUtil_1 = require_axiosUtil();
    var createGroupV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.createGroupCoreV2)(options, helpers_2.PGPHelper);
    });
    exports.createGroupV2 = createGroupV2;
    var createGroupCoreV2 = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account = null, signer = null, pgpPrivateKey = null, env = constants_1.default.ENV.PROD, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins } = options;
      try {
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        const convertedMembersPromise = members.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedAdminsPromise = admins.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          return (0, helpers_1.convertToValidDID)(each, env);
        }));
        const convertedMembers = yield Promise.all(convertedMembersPromise);
        const convertedAdmins = yield Promise.all(convertedAdminsPromise);
        createGroupV2OptionsValidator(options);
        const profileVerificationBody = {
          groupName,
          groupDescription,
          groupImage,
          rules,
          isPublic,
          groupType
        };
        const profileHash = CryptoJS.SHA256(JSON.stringify(profileVerificationBody)).toString();
        const profileSignature = yield pgpHelper.sign({
          message: profileHash,
          signingKey: connectedUser.privateKey
        });
        const profileVerificationProof = `pgpv2:${profileSignature}:${connectedUser.did}`;
        const configVerificationBody = {
          meta,
          scheduleAt,
          scheduleEnd,
          status
        };
        const configHash = CryptoJS.SHA256(JSON.stringify(configVerificationBody)).toString();
        const configSignature = yield pgpHelper.sign({
          message: configHash,
          signingKey: connectedUser.privateKey
        });
        const configVerificationProof = `pgpv2:${configSignature}:${connectedUser.did}`;
        const idempotentVerificationBody = {
          members: convertedMembers,
          admins: convertedAdmins
        };
        const idempotentHash = CryptoJS.SHA256(JSON.stringify(idempotentVerificationBody)).toString();
        const idempotentSignature = yield pgpHelper.sign({
          message: idempotentHash,
          signingKey: connectedUser.privateKey
        });
        const idempotentVerificationProof = `pgpv2:${idempotentSignature}:${connectedUser.did}`;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v2/chat/groups`;
        const body = {
          groupName,
          groupDescription,
          groupImage,
          rules,
          isPublic,
          groupType,
          profileVerificationProof,
          config: {
            meta,
            scheduleAt,
            scheduleEnd,
            status,
            configVerificationProof
          },
          members: convertedMembers,
          admins: convertedAdmins,
          idempotentVerificationProof
        };
        const response = yield (0, axiosUtil_1.axiosPost)(apiEndpoint, body);
        return response.data;
      } catch (error) {
        throw (0, validationError_1.handleError)(error, exports.createGroupV2.name);
      }
    });
    exports.createGroupCoreV2 = createGroupCoreV2;
    var createGroupV2OptionsValidator = (options) => {
      const { account = null, signer = null, pgpPrivateKey = null, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins } = options;
      if (!pgpPrivateKey && !signer) {
        throw new Error(`At least one from pgpPrivateKey or signer is necessary!`);
      }
      if (groupName == null || groupName.length == 0) {
        throw new Error(`groupName cannot be null or empty`);
      }
      if (groupName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
      }
      if (groupDescription && groupDescription.length > 150) {
        throw new Error(`groupDescription cannot be more than 150 characters`);
      }
      for (let i = 0; i < members.length; i++) {
        if (members[i] && !(0, helpers_1.isValidPushCAIP)(members[i])) {
          throw new Error(`Invalid member address!`);
        }
      }
      for (let i = 0; i < admins.length; i++) {
        if (!(0, helpers_1.isValidPushCAIP)(admins[i])) {
          throw new Error(`Invalid admin address!`);
        }
      }
      (0, helpers_2.validateScheduleDates)(scheduleAt, scheduleEnd);
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupByName.js
var require_getGroupByName = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupByName.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupByName = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var getGroupByName = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { groupName, env = constants_1.default.ENV.PROD } = options || {};
      try {
        console.log("=============================================");
        console.log("NOTICE: The method 'getGroupByName' will be deprecated on January 1st, 2024. Please update your code to remove this.");
        console.log("=============================================");
        if (groupName == null || groupName.length == 0) {
          throw new Error(`Group Name cannot be null or empty`);
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups?groupName=${groupName}`;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getGroupByName.name);
      }
    });
    exports.getGroupByName = getGroupByName;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupAccess.js
var require_getGroupAccess = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupAccess.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupAccess = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var getGroupAccess = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, did, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (chatId == null || chatId.length === 0) {
          throw new Error(`chatId cannot be null or empty`);
        }
        if (did == null || did.length === 0) {
          throw new Error(`did cannot be null or empty`);
        }
        const user = yield (0, helpers_1.convertToValidDID)(did, env);
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}/access/${user}`;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getGroupAccess.name);
      }
    });
    exports.getGroupAccess = getGroupAccess;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/searchGroups.js
var require_searchGroups = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/searchGroups.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var search = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { searchTerm, pageNumber, pageSize, env = constants_1.default.ENV.PROD } = options || {};
      try {
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/search`;
        const response = yield (0, axiosUtil_1.axiosPost)(requestUrl, {
          searchTerm,
          pageNumber,
          pageSize
        });
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.search.name);
      }
    });
    exports.search = search;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/rejectRequest.js
var require_rejectRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/rejectRequest.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reject = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var reject = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account = null, signer = null, senderAddress, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      if (account == null && signer == null) {
        throw new Error(`At least one from account or signer is necessary!`);
      }
      const wallet = (0, helpers_2.getWallet)({ account, signer });
      const address = yield (0, helpers_2.getAccountAddress)(wallet);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/request/reject`;
      let isGroup = true;
      if ((0, helpers_1.isValidPushCAIP)(senderAddress)) {
        isGroup = false;
      }
      const connectedUser = yield (0, helpers_2.getConnectedUserV2)(wallet, pgpPrivateKey, env);
      let fromDID = yield (0, helpers_1.convertToValidDID)(senderAddress, env);
      let toDID = yield (0, helpers_1.convertToValidDID)(address, env);
      if (isGroup) {
        fromDID = yield (0, helpers_1.convertToValidDID)(address, env);
        toDID = yield (0, helpers_1.convertToValidDID)(senderAddress, env);
      }
      const bodyToBeHashed = {
        fromDID,
        toDID
      };
      const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
      const signature = yield (0, helpers_2.sign)({
        message: hash,
        signingKey: connectedUser.privateKey
      });
      const body = (0, helpers_2.rejectRequestPayload)(fromDID, toDID, "pgp", signature);
      return (0, axiosUtil_1.axiosPut)(apiEndpoint, body).then((response) => {
        return response.data;
      }).catch((err) => {
        throw (0, validationError_1.handleError)(err, exports.reject.name);
      });
    });
    exports.reject = reject;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/modifyRole.js
var require_modifyRole = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/modifyRole.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modifyRoles = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var updateGroupMembers_1 = require_updateGroupMembers();
    var modifyRoles = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, newRole, members, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2) } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        if (!members || members.length === 0) {
          throw new Error("Members array cannot be empty!");
        }
        const upsertPayload = {
          admins: newRole === "ADMIN" ? members : [],
          members: newRole === "MEMBER" ? members : []
        };
        const groupMemberUpdateOptions = {
          chatId,
          upsert: upsertPayload,
          remove: [],
          account,
          signer,
          pgpPrivateKey,
          env,
          overrideSecretKeyGeneration
        };
        return yield (0, updateGroupMembers_1.updateGroupMembers)(groupMemberUpdateOptions);
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.modifyRoles.name);
      }
    });
    exports.modifyRoles = modifyRoles;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getChatInfo.js
var require_getChatInfo = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getChatInfo.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChatInfo = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var validationError_1 = require_validationError();
    var helpers_1 = require_helpers2();
    var axiosUtil_1 = require_axiosUtil();
    var getChatInfo = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { recipient, account, env = constants_1.default.ENV.PROD } = options;
      try {
        if (!recipient || !account) {
          throw new Error("receipient and account cannot be null or empty");
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/${yield (0, helpers_1.convertToValidDID)(recipient, env)}/address/${yield (0, helpers_1.convertToValidDID)(account, env)}`;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getChatInfo.name);
      }
    });
    exports.getChatInfo = getChatInfo;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/index.js
var require_chat2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptConversation = exports.decryptPGPKey = exports.decryptWithWalletRPCMethod = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_chats(), exports);
    tslib_1.__exportStar(require_chat(), exports);
    tslib_1.__exportStar(require_requests2(), exports);
    tslib_1.__exportStar(require_send(), exports);
    tslib_1.__exportStar(require_conversationHash(), exports);
    tslib_1.__exportStar(require_approveRequest(), exports);
    tslib_1.__exportStar(require_historicalMessages(), exports);
    tslib_1.__exportStar(require_latestMessage(), exports);
    var crypto_1 = require_crypto();
    Object.defineProperty(exports, "decryptWithWalletRPCMethod", { enumerable: true, get: function() {
      return crypto_1.decryptWithWalletRPCMethod;
    } });
    var crypto_2 = require_crypto();
    Object.defineProperty(exports, "decryptPGPKey", { enumerable: true, get: function() {
      return crypto_2.decryptPGPKey;
    } });
    var helpers_1 = require_helpers();
    Object.defineProperty(exports, "decryptConversation", { enumerable: true, get: function() {
      return helpers_1.decryptConversation;
    } });
    tslib_1.__exportStar(require_payloadHelper(), exports);
    tslib_1.__exportStar(require_createGroup(), exports);
    tslib_1.__exportStar(require_createGroupV2(), exports);
    tslib_1.__exportStar(require_updateGroup(), exports);
    tslib_1.__exportStar(require_getGroup(), exports);
    tslib_1.__exportStar(require_getGroupByName(), exports);
    tslib_1.__exportStar(require_addMembers(), exports);
    tslib_1.__exportStar(require_addAdmins(), exports);
    tslib_1.__exportStar(require_removeMembers(), exports);
    tslib_1.__exportStar(require_removeAdmins(), exports);
    tslib_1.__exportStar(require_getGroupAccess(), exports);
    tslib_1.__exportStar(require_searchGroups(), exports);
    tslib_1.__exportStar(require_rejectRequest(), exports);
    tslib_1.__exportStar(require_getGroupMemberStatus(), exports);
    tslib_1.__exportStar(require_getGroupMembers(), exports);
    tslib_1.__exportStar(require_getGroupInfo(), exports);
    tslib_1.__exportStar(require_getGroupMemberCount(), exports);
    tslib_1.__exportStar(require_getGroupMembersPublicKeys(), exports);
    tslib_1.__exportStar(require_modifyRole(), exports);
    tslib_1.__exportStar(require_getChatInfo(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/getAccess.js
var require_getAccess = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/getAccess.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAccess = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var chat_1 = require_chat2();
    var getAccess = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { spaceId, did, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (spaceId == null || spaceId.length === 0) {
          throw new Error(`spaceId cannot be null or empty`);
        }
        if (did == null || did.length === 0) {
          throw new Error(`did cannot be null or empty`);
        }
        const access = yield (0, chat_1.getGroupAccess)({ chatId: spaceId, did, env });
        return (0, chat_1.groupAccessToSpaceAccess)(access);
      } catch (err) {
        console.error(`[Push SDK] - API - Error - API ${exports.getAccess.name} -:  `, err);
        throw Error(`[Push SDK] - API - Error - API ${exports.getAccess.name} -: ${err}`);
      }
    });
    exports.getAccess = getAccess;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/search.js
var require_search = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/search.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var search = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { searchTerm, pageNumber, pageSize, env = constants_1.default.ENV.PROD } = options || {};
      try {
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/spaces/search`;
        return (0, axiosUtil_1.axiosPost)(requestUrl, {
          searchTerm,
          pageNumber,
          pageSize
        }).then((response) => {
          return response.data;
        }).catch((err) => {
          var _a, _b;
          if ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data) {
            throw new Error((_b = err === null || err === void 0 ? void 0 : err.response) === null || _b === void 0 ? void 0 : _b.data);
          }
          throw new Error(err);
        });
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.search.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.search.name} -: ${err}`);
      }
    });
    exports.search = search;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/createV2.js
var require_createV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/createV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var chat_1 = require_chat2();
    function createV2(options) {
      var _a;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signer, spaceName, spaceDescription, listeners, spaceImage, speakers, isPublic, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, rules, config } = options || {};
        const spaceRules = rules ? (0, helpers_1.convertSpaceRulesToRules)(rules) : null;
        try {
          const group = yield (0, chat_1.createGroupV2)({
            signer,
            groupName: spaceName,
            groupDescription: spaceDescription,
            members: listeners,
            groupImage: spaceImage,
            admins: speakers,
            isPublic,
            env,
            pgpPrivateKey,
            groupType: "spaces",
            config: {
              meta: null,
              scheduleAt: config.scheduleAt,
              scheduleEnd: (_a = config.scheduleEnd) !== null && _a !== void 0 ? _a : null,
              status: "PENDING"
            },
            rules: spaceRules
          });
          return (0, helpers_1.groupInfoDtoToSpaceInfoDto)(group);
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${createV2.name} -:  `, err);
          throw new Error(`[Push SDK] - API  - Error - API ${createV2.name} -: ${err}`);
        }
      });
    }
    exports.createV2 = createV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/spaceFeed.js
var require_spaceFeed = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/spaceFeed.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spaceFeed = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var axiosUtil_1 = require_axiosUtil();
    var spaceFeed = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, pgpPrivateKey, env = constants_1.default.ENV.PROD, toDecrypt = false, recipient } = options || {};
      const user = yield (0, helpers_1.convertToValidDID)(account, env);
      const recipientWallet = yield (0, helpers_1.convertToValidDID)(recipient, env);
      if (!(0, helpers_1.isValidPushCAIP)(user))
        throw new Error(`Invalid address ${user}`);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/spaces/users/${user}/space/${recipientWallet}`;
      try {
        const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
        const space = response.data;
        if (Object.keys(space).length !== 0) {
          const [feed] = yield (0, helpers_2.getSpaceInboxLists)({
            lists: [space],
            user,
            toDecrypt,
            pgpPrivateKey,
            env
          });
          return feed;
        } else {
          return space;
        }
      } catch (err) {
        console.error(`[Push SDK] - API ${exports.spaceFeed.name}: `, err);
        throw Error(`[Push SDK] - API ${exports.spaceFeed.name}: ${err}`);
      }
    });
    exports.spaceFeed = spaceFeed;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/update.js
var require_update = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/update.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.update = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types();
    var helpers_1 = require_helpers();
    var updateGroup_1 = require_updateGroup();
    var get_1 = require_get();
    function update(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { spaceName, spaceImage, spaceDescription, scheduleAt, scheduleEnd, meta } = options || {};
        try {
          const space = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env
          });
          const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
          const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
          if (space.status === types_1.ChatStatus.ACTIVE && scheduleAt) {
            throw new Error("Unable change the start date/time of an active space");
          }
          if (space.status === types_1.ChatStatus.ENDED && scheduleEnd) {
            throw new Error("Unable change the end date/time of an ended space");
          }
          const group = yield (0, updateGroup_1.updateGroup)({
            chatId: this.spaceSpecificData.spaceId,
            groupName: spaceName ? spaceName : space.spaceName,
            groupImage: spaceImage ? spaceImage : space.spaceImage,
            groupDescription: spaceDescription ? spaceDescription : space.spaceDescription,
            members: convertedMembers,
            admins: convertedAdmins,
            signer: this.signer,
            env: this.env,
            pgpPrivateKey: this.pgpPrivateKey,
            scheduleAt: scheduleAt ? scheduleAt : space.scheduleAt,
            scheduleEnd: scheduleEnd ? scheduleEnd : space.scheduleEnd,
            meta: meta ? meta : space.meta
          });
          this.setSpaceSpecificData(() => Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { liveSpaceData: this.spaceSpecificData.liveSpaceData }));
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${update.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${update.name} -: ${err}`);
        }
      });
    }
    exports.update = update;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/helpers/sendLiveSpaceData.js
var require_sendLiveSpaceData = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/helpers/sendLiveSpaceData.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var chat_1 = require_chat2();
    var constants_1 = require_constants();
    var sendLiveSpaceData = ({ liveSpaceData, action, spaceId, pgpPrivateKey, signer, env }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      yield (0, chat_1.send)({
        receiverAddress: spaceId,
        pgpPrivateKey,
        env,
        signer,
        messageType: constants_1.MessageType.META,
        messageObj: {
          content: action,
          info: {
            affected: [],
            arbitrary: liveSpaceData
          }
        }
      });
    });
    exports.default = sendLiveSpaceData;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/start.js
var require_start = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/start.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.start = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types();
    var helpers_1 = require_helpers();
    var get_1 = require_get();
    var updateGroup_1 = require_updateGroup();
    var immer_1 = require_cjs2();
    var helpers_2 = require_helpers2();
    var messageTypes_1 = require_messageTypes();
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    function start() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          !this.data.local.stream && (yield this.create({ audio: true, video: false }));
          const space = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env
          });
          if (space.status !== types_1.ChatStatus.PENDING) {
            throw new Error("Unable to start the space as it is not in the pending state");
          }
          if (this.data.local.address !== (0, helpers_2.pCAIP10ToWallet)(space.spaceCreator)) {
            throw new Error("Only host is allowed to start a space");
          }
          const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
          const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
          const group = yield (0, updateGroup_1.updateGroup)({
            chatId: this.spaceSpecificData.spaceId,
            groupName: space.spaceName,
            groupImage: space.spaceImage,
            groupDescription: space.spaceDescription,
            members: convertedMembers,
            admins: convertedAdmins,
            signer: this.signer,
            env: this.env,
            pgpPrivateKey: this.pgpPrivateKey,
            scheduleAt: space.scheduleAt,
            scheduleEnd: space.scheduleEnd,
            status: types_1.ChatStatus.ACTIVE
          });
          const liveSpaceData = {
            host: {
              address: this.data.local.address,
              audio: this.data.local.audio,
              emojiReactions: null
            },
            coHosts: [],
            speakers: [],
            listeners: []
          };
          yield (0, sendLiveSpaceData_1.default)({
            liveSpaceData,
            action: messageTypes_1.CHAT.META.SPACE.CREATE,
            spaceId: this.spaceSpecificData.spaceId,
            signer: this.signer,
            pgpPrivateKey: this.pgpPrivateKey,
            env: this.env
          });
          this.setSpaceData((oldSpaceData) => {
            return (0, immer_1.produce)(oldSpaceData, (draft) => {
              draft = Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { liveSpaceData, connectionData: draft.connectionData });
              draft.connectionData.meta.broadcast = {
                livepeerInfo: null,
                hostAddress: this.data.local.address
              };
            });
          });
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${start.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${start.name} -: ${err}`);
        }
      });
    }
    exports.start = start;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/inviteToPromote.js
var require_inviteToPromote = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/inviteToPromote.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inviteToPromote = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var constants_1 = require_constants2();
    function inviteToPromote(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { inviteeAddress, role } = options || {};
        this.setSpaceSpecificData((oldData) => {
          return (0, immer_1.produce)(oldData, (draft) => {
            if (draft.inviteeDetails)
              draft.inviteeDetails[inviteeAddress] = role;
          });
        });
        this.request({
          senderAddress: this.data.local.address,
          recipientAddress: inviteeAddress,
          chatId: this.spaceSpecificData.spaceId,
          details: {
            type: constants_1.SPACE_REQUEST_TYPE.INVITE_TO_PROMOTE,
            data: {
              role
            }
          }
        });
      });
    }
    exports.inviteToPromote = inviteToPromote;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/acceptPromotionInvite.js
var require_acceptPromotionInvite = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/acceptPromotionInvite.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.acceptPromotionInvite = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    function acceptPromotionInvite(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signalData, invitorAddress, spaceId } = options || {};
        this.acceptRequest({
          signalData,
          senderAddress: this.data.local.address,
          recipientAddress: invitorAddress,
          chatId: spaceId,
          details: {
            type: constants_1.SPACE_ACCEPT_REQUEST_TYPE.ACCEPT_INVITE,
            data: {}
          }
        });
      });
    }
    exports.acceptPromotionInvite = acceptPromotionInvite;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/connectInvitee.js
var require_connectInvitee = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/connectInvitee.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectInvitee = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var addSpeakers_1 = require_addSpeakers();
    function connectInvitee(options) {
      var _a;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signalData, inviteeAddress } = options || {};
        if (!((_a = this.spaceSpecificData) === null || _a === void 0 ? void 0 : _a.inviteeDetails) || !Object.keys(this.spaceSpecificData.inviteeDetails).includes(inviteeAddress)) {
          return Promise.resolve();
        }
        const role = this.spaceSpecificData.inviteeDetails[inviteeAddress];
        this.setSpaceSpecificData((oldData) => {
          return (0, immer_1.produce)(oldData, (draft) => {
            if (draft.inviteeDetails)
              delete draft.inviteeDetails[inviteeAddress];
          });
        });
        yield (0, addSpeakers_1.addSpeakers)({
          spaceId: this.spaceSpecificData.spaceId,
          signer: this.signer,
          pgpPrivateKey: this.pgpPrivateKey,
          speakers: [inviteeAddress]
        });
        this.connect({ signalData, peerAddress: inviteeAddress });
      });
    }
    exports.connectInvitee = connectInvitee;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/rejectPromotionInvite.js
var require_rejectPromotionInvite = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/rejectPromotionInvite.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rejectPromotionInvite = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    function rejectPromotionInvite(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { invitorAddress } = options || {};
        this.disconnect({
          peerAddress: invitorAddress
        });
      });
    }
    exports.rejectPromotionInvite = rejectPromotionInvite;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/requestToBePromoted.js
var require_requestToBePromoted = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/requestToBePromoted.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestToBePromoted = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    function requestToBePromoted(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { role, promotorAddress } = options || {};
        this.request({
          senderAddress: this.data.local.address,
          recipientAddress: (0, helpers_1.pCAIP10ToWallet)(promotorAddress),
          chatId: this.spaceSpecificData.spaceId,
          details: {
            type: constants_1.SPACE_REQUEST_TYPE.REQUEST_TO_PROMOTE,
            data: {
              role
            }
          }
        });
      });
    }
    exports.requestToBePromoted = requestToBePromoted;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/acceptPromotionRequest.js
var require_acceptPromotionRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/acceptPromotionRequest.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.acceptPromotionRequest = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var addSpeakers_1 = require_addSpeakers();
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    var helpers_1 = require_helpers2();
    var types_1 = require_types();
    function acceptPromotionRequest(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signalData, promoteeAddress, spaceId, role } = options || {};
        yield (0, addSpeakers_1.addSpeakers)({
          spaceId: this.spaceSpecificData.spaceId,
          signer: this.signer,
          pgpPrivateKey: this.pgpPrivateKey,
          speakers: [(0, helpers_1.pCAIP10ToWallet)(promoteeAddress)],
          env: this.env
        });
        const modifiedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
          const listenerIndex = this.spaceSpecificData.liveSpaceData.listeners.findIndex((listener) => (0, helpers_1.pCAIP10ToWallet)(listener.address) === (0, helpers_1.pCAIP10ToWallet)(promoteeAddress));
          draft.listeners.splice(listenerIndex, 1);
          draft.speakers.push({
            address: (0, helpers_1.pCAIP10ToWallet)(promoteeAddress),
            emojiReactions: null,
            audio: null
          });
        });
        yield (0, sendLiveSpaceData_1.default)({
          spaceId: this.spaceSpecificData.spaceId,
          pgpPrivateKey: this.pgpPrivateKey,
          env: this.env,
          signer: this.signer,
          liveSpaceData: modifiedLiveSpaceData,
          action: types_1.CHAT.META.SPACE.SPEAKER.PRVILEGE
        });
      });
    }
    exports.acceptPromotionRequest = acceptPromotionRequest;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/rejectPromotionRequest.js
var require_rejectPromotionRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/rejectPromotionRequest.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rejectPromotionRequest = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    var messageTypes_1 = require_messageTypes();
    var helpers_1 = require_helpers2();
    function rejectPromotionRequest(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { promoteeAddress } = options || {};
        this.disconnect({
          peerAddress: (0, helpers_1.pCAIP10ToWallet)(promoteeAddress)
        });
        const updatedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
          const listnerIndex = this.spaceSpecificData.liveSpaceData.listeners.findIndex((listener) => listener.address === (0, helpers_1.pCAIP10ToWallet)(promoteeAddress));
          if (listnerIndex > -1)
            draft.listeners[listnerIndex].handRaised = false;
        });
        this.setSpaceSpecificData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: updatedLiveSpaceData }));
        yield (0, sendLiveSpaceData_1.default)({
          liveSpaceData: updatedLiveSpaceData,
          pgpPrivateKey: this.pgpPrivateKey,
          env: this.env,
          spaceId: this.spaceSpecificData.spaceId,
          signer: this.signer,
          action: messageTypes_1.CHAT.META.GROUP.USER.INTERACTION
          // TODO: Add a reject request type
        });
      });
    }
    exports.rejectPromotionRequest = rejectPromotionRequest;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/connectPromotor.js
var require_connectPromotor = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/connectPromotor.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectPromotor = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    function connectPromotor(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { signalData, promotorAddress } = options || {};
        this.connect({ signalData, peerAddress: promotorAddress });
      });
    }
    exports.connectPromotor = connectPromotor;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/join.js
var require_join = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/join.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.join = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var types_1 = require_types();
    var approve_1 = require_approve();
    var get_1 = require_get();
    var getIncomingIndexFromAddress_1 = require_getIncomingIndexFromAddress();
    var getPlainAddress_1 = require_getPlainAddress();
    function join() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          const space = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env
          });
          if (space.status !== types_1.ChatStatus.ACTIVE)
            throw new Error("Space not active yet");
          let isSpeaker = false;
          let isListner = false;
          const localAddress = (0, getPlainAddress_1.default)(this.data.local.address);
          space.members.forEach((member) => {
            if ((0, getPlainAddress_1.default)(member.wallet) === localAddress) {
              if (member.isSpeaker) {
                isSpeaker = true;
              } else {
                isListner = true;
              }
            }
          });
          let isSpeakerPending = false;
          space.pendingMembers.forEach((pendingMember) => {
            if ((0, getPlainAddress_1.default)(pendingMember.wallet) === localAddress && pendingMember.isSpeaker) {
              isSpeakerPending = true;
            }
          });
          const hostAddress = (0, getPlainAddress_1.default)(space.spaceCreator);
          const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, hostAddress);
          if ((isSpeaker || isSpeakerPending) && incomingIndex > -1) {
            return Promise.resolve();
          }
          if (!isSpeaker && !isListner) {
            yield (0, approve_1.approve)({
              signer: this.signer,
              pgpPrivateKey: this.pgpPrivateKey,
              senderAddress: this.spaceSpecificData.spaceId,
              env: this.env
            });
          }
          if (isSpeaker || isSpeakerPending) {
            !this.data.local.stream && (yield this.create({ audio: true, video: false }));
            yield this.request({
              senderAddress: this.data.local.address,
              recipientAddress: hostAddress,
              chatId: this.spaceSpecificData.spaceId,
              details: {
                type: constants_1.SPACE_REQUEST_TYPE.JOIN_SPEAKER,
                data: {}
              }
            });
          }
          const updatedSpace = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env
          });
          this.setSpaceSpecificData(() => Object.assign(Object.assign({}, updatedSpace), { liveSpaceData: this.spaceSpecificData.liveSpaceData }));
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${join.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${join.name} -: ${err}`);
        }
      });
    }
    exports.join = join;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/leave.js
var require_leave = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/leave.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.leave = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    function leave() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          this.data.incoming.slice(1).forEach(({ address }) => {
            this.disconnect({
              peerAddress: address,
              details: {
                type: constants_1.SPACE_DISCONNECT_TYPE.LEAVE,
                data: {}
              }
            });
          });
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${stop.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${stop.name} -: ${err}`);
        }
      });
    }
    exports.leave = leave;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/stop.js
var require_stop = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/stop.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stop = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers();
    var updateGroup_1 = require_updateGroup();
    var get_1 = require_get();
    var types_1 = require_types();
    var constants_1 = require_constants2();
    function stop2() {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          const space = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env
          });
          if (space.status === types_1.ChatStatus.ENDED) {
            throw new Error("Space already ended");
          }
          const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
          const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
          const group = yield (0, updateGroup_1.updateGroup)({
            chatId: this.spaceSpecificData.spaceId,
            groupName: space.spaceName,
            groupImage: space.spaceImage,
            groupDescription: space.spaceDescription,
            members: convertedMembers,
            admins: convertedAdmins,
            signer: this.signer,
            env: this.env,
            pgpPrivateKey: this.pgpPrivateKey,
            scheduleAt: space.scheduleAt,
            scheduleEnd: space.scheduleEnd,
            status: types_1.ChatStatus.ENDED
          });
          this.setSpaceSpecificData(() => Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { liveSpaceData: this.spaceSpecificData.liveSpaceData }));
          this.data.incoming.slice(1).forEach(({ address }) => {
            this.disconnect({
              peerAddress: address,
              details: {
                type: constants_1.SPACE_DISCONNECT_TYPE.STOP,
                data: {}
              }
            });
          });
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API ${stop2.name} -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API ${stop2.name} -: ${err}`);
        }
      });
    }
    exports.stop = stop2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/helpers/getLiveSpaceData.js
var require_getLiveSpaceData = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/helpers/getLiveSpaceData.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var chat_1 = require_chat2();
    var constants_1 = require_constants();
    var Space_1 = require_Space();
    var getLiveSpaceData = ({ localAddress, spaceId, pgpPrivateKey, env }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b;
      const threadhash = (yield (0, chat_1.conversationHash)({
        account: localAddress,
        conversationId: spaceId,
        env
      })).threadHash;
      let liveSpaceData = Space_1.initLiveSpaceData;
      const messages = yield (0, chat_1.history)({
        threadhash,
        account: localAddress,
        pgpPrivateKey,
        toDecrypt: true,
        env
      });
      let latestMetaMessage = null;
      for (const message of messages) {
        if (message.messageType === constants_1.MessageType.META && typeof message.messageObj === "object" && message.messageObj !== null) {
          latestMetaMessage = message;
          break;
        }
      }
      if (latestMetaMessage !== null && typeof latestMetaMessage.messageObj === "object" && latestMetaMessage.messageObj !== null) {
        liveSpaceData = (_b = (_a = latestMetaMessage.messageObj) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.arbitrary;
      }
      return liveSpaceData;
    });
    exports.default = getLiveSpaceData;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/initialize.js
var require_initialize = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/initialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initialize = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var types_1 = require_types();
    var get_1 = require_get();
    var getLiveSpaceData_1 = require_getLiveSpaceData();
    function initialize(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { spaceId } = options || {};
        const space = yield (0, get_1.get)({
          spaceId,
          env: this.env
        });
        let liveSpaceData = this.spaceSpecificData.liveSpaceData;
        if (space.status === types_1.ChatStatus.ACTIVE) {
          liveSpaceData = yield (0, getLiveSpaceData_1.default)({
            localAddress: this.data.local.address,
            spaceId,
            pgpPrivateKey: this.pgpPrivateKey,
            env: this.env
          });
        }
        this.setSpaceSpecificData(() => Object.assign(Object.assign({}, space), { liveSpaceData }));
      });
    }
    exports.initialize = initialize;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/helpers/addToMergedStream.js
var require_addToMergedStream = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/helpers/addToMergedStream.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var addToMergedStream = (mergeObject, streamToBeAdded) => {
      mergeObject.addStream(streamToBeAdded, void 0);
    };
    exports.default = addToMergedStream;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/broadcastRaisedHand.js
var require_broadcastRaisedHand = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/broadcastRaisedHand.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.broadcastRaisedHand = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    var messageTypes_1 = require_messageTypes();
    var helpers_1 = require_helpers2();
    function broadcastRaisedHand(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { promoteeAddress } = options || {};
        const updatedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
          const listenerIndex = this.spaceSpecificData.liveSpaceData.listeners.findIndex((listener) => (0, helpers_1.pCAIP10ToWallet)(listener.address) === (0, helpers_1.pCAIP10ToWallet)(promoteeAddress));
          if (listenerIndex !== -1)
            draft.listeners[listenerIndex].handRaised = true;
        });
        this.setSpaceSpecificData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: updatedLiveSpaceData }));
        yield (0, sendLiveSpaceData_1.default)({
          liveSpaceData: updatedLiveSpaceData,
          pgpPrivateKey: this.pgpPrivateKey,
          env: this.env,
          spaceId: this.spaceSpecificData.spaceId,
          signer: this.signer,
          action: messageTypes_1.CHAT.META.GROUP.USER.INTERACTION
        });
      });
    }
    exports.broadcastRaisedHand = broadcastRaisedHand;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/onReceiveMetaMessage.js
var require_onReceiveMetaMessage = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/onReceiveMetaMessage.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onReceiveMetaMessage = void 0;
    var constants_1 = require_constants();
    function onReceiveMetaMessage(options) {
      var _a, _b;
      const { receivedMetaMessage } = options || {};
      if (receivedMetaMessage.messageType !== constants_1.MessageType.META || typeof receivedMetaMessage.messageObj !== "object" || !((_b = (_a = receivedMetaMessage === null || receivedMetaMessage === void 0 ? void 0 : receivedMetaMessage.messageObj) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.arbitrary)) {
        return;
      }
      const receivedLiveSpaceData = receivedMetaMessage.messageObj.info.arbitrary;
      this.setSpaceSpecificData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: receivedLiveSpaceData }));
    }
    exports.onReceiveMetaMessage = onReceiveMetaMessage;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/onJoinListener.js
var require_onJoinListener = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/onJoinListener.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onJoinListener = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    var get_1 = require_get();
    var helpers_1 = require_helpers2();
    var immer_1 = require_cjs2();
    var messageTypes_1 = require_messageTypes();
    function onJoinListener(options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { receivedAddress } = options || {};
        if ((0, helpers_1.pCAIP10ToWallet)(this.spaceSpecificData.spaceCreator) !== this.data.local.address) {
          return;
        }
        const updatedSpace = yield (0, get_1.get)({
          spaceId: this.spaceSpecificData.spaceId,
          env: this.env
        });
        const isAddressListener = updatedSpace.members.find((member) => (0, helpers_1.pCAIP10ToWallet)(member.wallet) === (0, helpers_1.pCAIP10ToWallet)(receivedAddress) && !member.isSpeaker);
        if (!isAddressListener) {
          return;
        }
        const modifiedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
          const isListenerAlreadyAdded = this.spaceSpecificData.liveSpaceData.listeners.find((currentListener) => (0, helpers_1.pCAIP10ToWallet)(currentListener.address) === (0, helpers_1.pCAIP10ToWallet)(receivedAddress));
          if (isListenerAlreadyAdded) {
          } else {
            draft.listeners.push({
              address: (0, helpers_1.pCAIP10ToWallet)(receivedAddress),
              handRaised: false,
              emojiReactions: null
            });
          }
        });
        this.setSpaceSpecificData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: modifiedLiveSpaceData }));
        yield (0, sendLiveSpaceData_1.default)({
          spaceId: this.spaceSpecificData.spaceId,
          pgpPrivateKey: this.pgpPrivateKey,
          env: this.env,
          signer: this.signer,
          liveSpaceData: modifiedLiveSpaceData,
          action: messageTypes_1.CHAT.META.SPACE.LISTENER.ADD
        });
      });
    }
    exports.onJoinListener = onJoinListener;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/Space.js
var require_Space = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/Space.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Space = exports.initSpaceData = exports.initSpaceSpecificData = exports.initLiveSpaceData = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var constants_1 = require_constants();
    var video_1 = require_video();
    var update_1 = require_update();
    var start_1 = require_start();
    var inviteToPromote_1 = require_inviteToPromote();
    var acceptPromotionInvite_1 = require_acceptPromotionInvite();
    var connectInvitee_1 = require_connectInvitee();
    var rejectPromotionInvite_1 = require_rejectPromotionInvite();
    var requestToBePromoted_1 = require_requestToBePromoted();
    var acceptPromotionRequest_1 = require_acceptPromotionRequest();
    var rejectPromotionRequest_1 = require_rejectPromotionRequest();
    var connectPromotor_1 = require_connectPromotor();
    var join_1 = require_join();
    var leave_1 = require_leave();
    var stop_1 = require_stop();
    var initialize_1 = require_initialize();
    var addToMergedStream_1 = require_addToMergedStream();
    var types_1 = require_types();
    var constants_2 = require_constants2();
    var sendLiveSpaceData_1 = require_sendLiveSpaceData();
    var messageTypes_1 = require_messageTypes();
    var broadcastRaisedHand_1 = require_broadcastRaisedHand();
    var onReceiveMetaMessage_1 = require_onReceiveMetaMessage();
    var onJoinListener_1 = require_onJoinListener();
    var helpers_1 = require_helpers2();
    exports.initLiveSpaceData = {
      host: {
        address: "",
        audio: null,
        emojiReactions: null
      },
      coHosts: [],
      speakers: [],
      listeners: []
    };
    exports.initSpaceSpecificData = {
      members: [],
      pendingMembers: [],
      contractAddressERC20: null,
      numberOfERC20: -1,
      contractAddressNFT: null,
      numberOfNFTTokens: -1,
      verificationProof: "",
      spaceImage: null,
      spaceName: "",
      isPublic: false,
      spaceDescription: "",
      spaceCreator: "",
      spaceId: "",
      scheduleAt: null,
      scheduleEnd: null,
      status: null,
      inviteeDetails: {},
      liveSpaceData: exports.initLiveSpaceData
    };
    exports.initSpaceData = Object.assign(Object.assign({}, exports.initSpaceSpecificData), { connectionData: video_1.initVideoCallData });
    var Space = class extends video_1.Video {
      constructor(options) {
        const {
          signer,
          pgpPrivateKey,
          address,
          chainId,
          env = constants_1.default.ENV.PROD,
          setSpaceData
          // to update the 'spaceData' state maintained by the developer
        } = options || {};
        super({
          signer,
          chainId,
          pgpPrivateKey,
          env,
          callType: constants_2.VIDEO_CALL_TYPE.PUSH_SPACE,
          onReceiveStream: (receivedStream, senderAddress, audio) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.spaceSpecificData.status === types_1.ChatStatus.ACTIVE && ((_a = this.data.meta.broadcast) === null || _a === void 0 ? void 0 : _a.hostAddress) && this.data.meta.broadcast.hostAddress === this.data.local.address) {
              (0, addToMergedStream_1.default)(this.mergedStream, receivedStream);
              const updatedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
                const listenerIndex = this.spaceSpecificData.liveSpaceData.listeners.findIndex((listener) => listener.address === senderAddress);
                draft.speakers.push({
                  address: senderAddress,
                  audio,
                  emojiReactions: listenerIndex > -1 ? this.spaceSpecificData.liveSpaceData.listeners[listenerIndex].emojiReactions : null
                });
                if (listenerIndex > -1)
                  draft.listeners.splice(listenerIndex, 1);
              });
              this.setSpaceSpecificData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: updatedLiveSpaceData }));
              yield (0, sendLiveSpaceData_1.default)({
                liveSpaceData: updatedLiveSpaceData,
                pgpPrivateKey: this.pgpPrivateKey,
                env: this.env,
                spaceId: this.spaceSpecificData.spaceId,
                signer: this.signer,
                action: messageTypes_1.CHAT.META.GROUP.ADMIN.PRVILEGE
                // TODO: Add a meta action for SPEAKER_JOINED
              });
            }
          }),
          setData: function() {
            return;
          }
          // setData will be overridden below
        });
        this.mergedStream = null;
        this.initialize = initialize_1.initialize;
        this.update = update_1.update;
        this.createAudioStream = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.create({ audio: true, video: false });
        });
        this.start = start_1.start;
        this.onReceiveMetaMessage = onReceiveMetaMessage_1.onReceiveMetaMessage;
        this.onJoinListener = onJoinListener_1.onJoinListener;
        this.inviteToPromote = inviteToPromote_1.inviteToPromote;
        this.acceptPromotionInvite = acceptPromotionInvite_1.acceptPromotionInvite;
        this.connectInvitee = connectInvitee_1.connectInvitee;
        this.rejectPromotionInvite = rejectPromotionInvite_1.rejectPromotionInvite;
        this.requestToBePromoted = requestToBePromoted_1.requestToBePromoted;
        this.broadcastRaisedHand = broadcastRaisedHand_1.broadcastRaisedHand;
        this.acceptPromotionRequest = acceptPromotionRequest_1.acceptPromotionRequest;
        this.connectPromotor = connectPromotor_1.connectPromotor;
        this.rejectPromotionRequest = rejectPromotionRequest_1.rejectPromotionRequest;
        this.join = join_1.join;
        this.leave = leave_1.leave;
        this.stop = stop_1.stop;
        this.setData = function(fn) {
          const newVideoData = fn(this.data);
          setSpaceData(() => Object.assign(Object.assign({}, this.spaceSpecificData), { connectionData: newVideoData }));
          this.data = newVideoData;
        };
        this.setSpaceSpecificData = function(fn) {
          const newSpaceSpecificData = fn(this.spaceSpecificData);
          setSpaceData(() => Object.assign(Object.assign({}, newSpaceSpecificData), { connectionData: this.data }));
          this.spaceSpecificData = newSpaceSpecificData;
        };
        this.setSpaceData = function(fn) {
          const _a = fn(Object.assign(Object.assign({}, this.spaceSpecificData), { connectionData: this.data })), { connectionData: newConnectionData } = _a, newSpaceSpecificData = tslib_1.__rest(_a, ["connectionData"]);
          this.spaceSpecificData = newSpaceSpecificData;
          this.setData(() => newConnectionData);
        };
        this.setData((oldVideoCallData) => {
          return (0, immer_1.produce)(oldVideoCallData, (draft) => {
            draft.local.address = (0, helpers_1.pCAIP10ToWallet)(address);
          });
        });
        setSpaceData(() => exports.initSpaceData);
        this.spaceSpecificData = exports.initSpaceSpecificData;
      }
    };
    exports.Space = Space;
    exports.default = Space;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/index.js
var require_space = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.space = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_getPlainAddress(), exports);
    tslib_1.__exportStar(require_spaces(), exports);
    tslib_1.__exportStar(require_trending(), exports);
    tslib_1.__exportStar(require_get(), exports);
    tslib_1.__exportStar(require_info(), exports);
    tslib_1.__exportStar(require_create(), exports);
    tslib_1.__exportStar(require_update_out(), exports);
    tslib_1.__exportStar(require_addSpeakers(), exports);
    tslib_1.__exportStar(require_removeSpeakers(), exports);
    tslib_1.__exportStar(require_addListeners(), exports);
    tslib_1.__exportStar(require_removeListeners(), exports);
    tslib_1.__exportStar(require_approve(), exports);
    tslib_1.__exportStar(require_requests(), exports);
    tslib_1.__exportStar(require_getAccess(), exports);
    tslib_1.__exportStar(require_search(), exports);
    tslib_1.__exportStar(require_createV2(), exports);
    var spaceFeed_1 = require_spaceFeed();
    Object.defineProperty(exports, "space", { enumerable: true, get: function() {
      return spaceFeed_1.spaceFeed;
    } });
    tslib_1.__exportStar(require_Space(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/constantsV2.js
var require_constantsV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/constantsV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var PushNotificationTypes_1 = require_PushNotificationTypes();
    var pushAPITypes_1 = require_pushAPITypes();
    var pushStreamTypes_1 = require_pushStreamTypes();
    var space_1 = require_space();
    var types_1 = require_types();
    var video_1 = require_video();
    var CONSTANTS = {
      ENV: constants_1.ENV,
      STREAM: pushStreamTypes_1.STREAM,
      CHAT: {
        LIST_TYPE: pushAPITypes_1.ChatListType,
        MESSAGE_TYPE: constants_1.MessageType,
        GROUP: {
          RULES: {
            CONDITION_TYPE: types_1.ConditionType,
            CATEGORY: types_1.GROUP_RULES_CATEGORY,
            SUBCATEGORY: types_1.GROUP_RULES_SUB_CATEGORY,
            PERMISSION: types_1.GROUP_RULES_PERMISSION,
            INVITER_ROLE: types_1.GROUP_INVITER_ROLE
          }
        }
      },
      VIDEO: {
        EVENT: pushStreamTypes_1.VideoEventType,
        STATUS: types_1.VideoCallStatus,
        INITIAL_DATA: video_1.initVideoCallData
      },
      SPACE: {
        EVENT: pushStreamTypes_1.SpaceEventType,
        INITIAL_DATA: space_1.initSpaceData
      },
      ALPHA_FEATURES: constants_1.ALPHA_FEATURES,
      USER: { ENCRYPTION_TYPE: constants_1.ENCRYPTION_TYPE },
      NOTIFICATION: {
        TYPE: types_1.NotifictaionType,
        CHANNEL: {
          LIST_TYPE: PushNotificationTypes_1.ChannelListType
        }
      },
      FILTER: {
        CHANNEL_LIST: {
          SORT: PushNotificationTypes_1.ChannelListSortType,
          ORDER: PushNotificationTypes_1.ChannelListOrderType
        },
        NOTIFICATION_TYPE: types_1.NotifictaionType
      }
    };
    exports.default = CONSTANTS;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/getChannels.js
var require_getChannels = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/getChannels.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChannels = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constantsV2_1 = require_constantsV2();
    var helpers_1 = require_helpers2();
    var axiosUtil_1 = require_axiosUtil();
    var getChannels = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { env = constantsV2_1.default.ENV.PROD, page = 1, limit = 10, sort = constantsV2_1.default.FILTER.CHANNEL_LIST.SORT.SUBSCRIBER, order = constantsV2_1.default.FILTER.CHANNEL_LIST.ORDER.DESCENDING } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/channels`;
      const requestUrl = `${apiEndpoint}?page=${page}&limit=${limit}&sort=${sort}&order=${order}`;
      return yield (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        return response.data;
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
        throw Error(`[Push SDK] - API  - Error - API ${requestUrl} -: ${err}`);
      });
    });
    exports.getChannels = getChannels;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/getDelegates.js
var require_getDelegates = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/getDelegates.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDelegates = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var getDelegates = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { channel, env = constants_1.default.ENV.PROD } = options || {};
      const _channel = yield (0, helpers_1.getCAIPAddress)(env, channel, "Channel");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/channels`;
      const requestUrl = `${apiEndpoint}/${_channel}/delegates`;
      return yield (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        var _a;
        return (_a = response.data) === null || _a === void 0 ? void 0 : _a.delegates;
      }).catch((err) => {
        console.error(`[EPNS-SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getDelegates = getDelegates;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/parseSubscribersAPI.js
var require_parseSubscribersAPI = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/parseSubscribersAPI.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSubscrbersApiResponse = void 0;
    var parseSettings_1 = require_parseSettings();
    function parseSubscrbersApiResponse(response) {
      const parsedSubscribers = response.subscribers.map((apisubscribers) => {
        return {
          subscriber: apisubscribers.subscriber,
          settings: apisubscribers.settings ? (0, parseSettings_1.parseSettings)(apisubscribers.settings) : null
        };
      });
      return {
        itemcount: response.itemcount,
        subscribers: [...parsedSubscribers]
      };
    }
    exports.parseSubscrbersApiResponse = parseSubscrbersApiResponse;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/getSubscribers.js
var require_getSubscribers2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/getSubscribers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSubscribers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var parseSubscribersAPI_1 = require_parseSubscribersAPI();
    var getSubscribers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      try {
        const { channel, page = 1, limit = 10, category = null, setting = false, env = constants_1.default.ENV.PROD, raw = true } = options || {};
        try {
          if (channel == null || channel.length == 0) {
            throw new Error(`channel cannot be null or empty`);
          }
          if (page <= 0) {
            throw new Error("page must be greater than 0");
          }
          if (limit <= 0) {
            throw new Error("limit must be greater than 0");
          }
          if (limit > 30) {
            throw new Error("limit must be lesser than or equal to 30");
          }
          const _channel = yield (0, helpers_1.getCAIPAddress)(env, channel, "Channel");
          const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
          let apiEndpoint = `${API_BASE_URL}/v1/channels/${_channel}/subscribers?page=${page}&limit=${limit}&setting=${setting}`;
          if (category) {
            apiEndpoint = apiEndpoint + `&category=${category}`;
          }
          return yield (0, axiosUtil_1.axiosGet)(apiEndpoint).then((response) => {
            if (raw)
              return response.data;
            else
              return (0, parseSubscribersAPI_1.parseSubscrbersApiResponse)(response.data);
          }).catch((err) => {
            console.error(`[Push SDK] - API ${apiEndpoint}: `, err);
          });
        } catch (err) {
          console.error(`[Push SDK] - API  - Error - API send() -:  `, err);
          throw Error(`[Push SDK] - API  - Error - API send() -: ${err}`);
        }
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API send() -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API send() -: ${err}`);
      }
    });
    exports.getSubscribers = getSubscribers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/search.js
var require_search2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/search.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var search = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { query, env = constants_1.default.ENV.PROD, page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT } = options || {};
      if (!query)
        throw Error('"query" not provided!');
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/channels/search/`;
      const queryObj = {
        page,
        limit: (0, helpers_1.getLimit)(limit),
        query
      };
      const requestUrl = `${apiEndpoint}?${(0, helpers_1.getQueryParams)(queryObj)}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => response.data.channels).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.search = search;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/signature.helpers.js
var require_signature_helpers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/signature.helpers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTypeInformationV2 = exports.getTypeInformation = exports.getSubscriptionMessageV2 = exports.getSubscriptionMessage = exports.getDomainInformation = void 0;
    var getDomainInformation = (chainId, verifyingContract) => {
      return {
        name: "EPNS COMM V1",
        chainId,
        verifyingContract
      };
    };
    exports.getDomainInformation = getDomainInformation;
    var getSubscriptionMessage = (channel, userAddress, action) => {
      const actionTypeKey = action === "Unsubscribe" ? "unsubscriber" : "subscriber";
      return {
        channel,
        [actionTypeKey]: userAddress,
        action
      };
    };
    exports.getSubscriptionMessage = getSubscriptionMessage;
    var getSubscriptionMessageV2 = (channel, userAddress, action, userSetting) => {
      const actionTypeKey = action === "Unsubscribe" ? "unsubscriber" : "subscriber";
      if (action == "Subscribe") {
        return JSON.stringify({
          channel,
          [actionTypeKey]: userAddress,
          action,
          userSetting: userSetting !== null && userSetting !== void 0 ? userSetting : ""
        }, null, 4);
      } else {
        return JSON.stringify({
          channel,
          [actionTypeKey]: userAddress,
          action
        }, null, 4);
      }
    };
    exports.getSubscriptionMessageV2 = getSubscriptionMessageV2;
    var getTypeInformation = (action) => {
      if (action === "Subscribe") {
        return {
          Subscribe: [
            { name: "channel", type: "address" },
            { name: "subscriber", type: "address" },
            { name: "action", type: "string" }
          ]
        };
      }
      return {
        Unsubscribe: [
          { name: "channel", type: "address" },
          { name: "unsubscriber", type: "address" },
          { name: "action", type: "string" }
        ]
      };
    };
    exports.getTypeInformation = getTypeInformation;
    var getTypeInformationV2 = () => {
      return {
        Data: [{ name: "data", type: "string" }]
      };
    };
    exports.getTypeInformationV2 = getTypeInformationV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/subscribe.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribe = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var signature_helpers_1 = require_signature_helpers();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var subscribe = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { signer, channelAddress, userAddress, verifyingContractAddress, origin, env = constants_1.default.ENV.PROD, onSuccess, onError } = options || {};
      try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, "Channel");
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
          throw Error("Invalid Channel CAIP!");
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, "User");
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
          throw Error("Invalid User CAIP!");
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/subscribe`;
        const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
        const typeInformation = (0, signature_helpers_1.getTypeInformation)("Subscribe");
        const messageInformation = (0, signature_helpers_1.getSubscriptionMessage)(channelCAIPDetails.address, userCAIPDetails.address, "Subscribe");
        const pushSigner = new helpers_1.Signer(signer);
        const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, "Subscribe");
        const verificationProof = signature;
        const body = {
          verificationProof,
          message: Object.assign(Object.assign({}, messageInformation), { channel: _channelAddress, subscriber: _userAddress }),
          origin
        };
        yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === "function")
          onSuccess();
        return { status: "success", message: "successfully opted into channel" };
      } catch (err) {
        if (typeof onError === "function")
          onError(err);
        return {
          status: "error",
          message: err instanceof Error ? err.message : JSON.stringify(err)
        };
      }
    });
    exports.subscribe = subscribe;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/subscribeV2.js
var require_subscribeV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/subscribeV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribeV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var signature_helpers_1 = require_signature_helpers();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var subscribeV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b;
      const { signer, channelAddress, userAddress, settings = void 0, verifyingContractAddress, env = constants_1.default.ENV.PROD, origin, onSuccess, onError } = options || {};
      try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, "Channel");
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
          throw Error("Invalid Channel CAIP!");
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, "User");
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
          throw Error("Invalid User CAIP!");
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/subscribe`;
        const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
        const typeInformation = (0, signature_helpers_1.getTypeInformationV2)();
        const messageInformation = {
          data: (0, signature_helpers_1.getSubscriptionMessageV2)(channelCAIPDetails.address, userCAIPDetails.address, "Subscribe", settings)
        };
        const pushSigner = new helpers_1.Signer(signer);
        const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, "Data");
        const verificationProof = signature;
        const body = {
          verificationProof: `eip712v2:${verificationProof}`,
          message: messageInformation.data,
          origin
        };
        const res = yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === "function")
          onSuccess();
        return { status: res.status, message: "successfully opted into channel" };
      } catch (err) {
        if (typeof onError === "function")
          onError(err);
        return {
          status: (_b = (_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : "",
          message: err instanceof Error ? err.message : JSON.stringify(err)
        };
      }
    });
    exports.subscribeV2 = subscribeV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/unsubscribe.js
var require_unsubscribe = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/unsubscribe.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsubscribe = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var signature_helpers_1 = require_signature_helpers();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var unsubscribe = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { signer, channelAddress, userAddress, verifyingContractAddress, env = constants_1.default.ENV.PROD, onSuccess, onError } = options || {};
      try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, "Channel");
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
          throw Error("Invalid Channel CAIP!");
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, "User");
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
          throw Error("Invalid User CAIP!");
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/unsubscribe`;
        const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
        const typeInformation = (0, signature_helpers_1.getTypeInformation)("Unsubscribe");
        const messageInformation = (0, signature_helpers_1.getSubscriptionMessage)(channelCAIPDetails.address, userCAIPDetails.address, "Unsubscribe");
        const pushSigner = new helpers_1.Signer(signer);
        const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, "Unsubscribe");
        const verificationProof = signature;
        const body = {
          verificationProof,
          message: Object.assign(Object.assign({}, messageInformation), { channel: _channelAddress, unsubscriber: _userAddress })
        };
        yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === "function")
          onSuccess();
        return { status: "success", message: "successfully opted out channel" };
      } catch (err) {
        if (typeof onError === "function")
          onError(err);
        return {
          status: "error",
          message: err instanceof Error ? err.message : JSON.stringify(err)
        };
      }
    });
    exports.unsubscribe = unsubscribe;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/unsubscribeV2.js
var require_unsubscribeV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/unsubscribeV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unsubscribeV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var signature_helpers_1 = require_signature_helpers();
    var constants_1 = require_constants();
    var axiosUtil_1 = require_axiosUtil();
    var unsubscribeV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b;
      const { signer, channelAddress, userAddress, verifyingContractAddress, env = constants_1.default.ENV.PROD, onSuccess, onError } = options || {};
      try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, "Channel");
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
          throw Error("Invalid Channel CAIP!");
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, "User");
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
          throw Error("Invalid User CAIP!");
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/unsubscribe`;
        const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
        const typeInformation = (0, signature_helpers_1.getTypeInformationV2)();
        const messageInformation = {
          data: (0, signature_helpers_1.getSubscriptionMessageV2)(channelCAIPDetails.address, userCAIPDetails.address, "Unsubscribe")
        };
        const pushSigner = new helpers_1.Signer(signer);
        const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, "Data");
        const verificationProof = signature;
        const body = {
          verificationProof: `eip712v2:${verificationProof}`,
          message: messageInformation.data
        };
        const res = yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === "function")
          onSuccess();
        return { status: res.status, message: "successfully opted out channel" };
      } catch (err) {
        if (typeof onError === "function")
          onError(err);
        return {
          status: (_b = (_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : "",
          message: err instanceof Error ? err.message : JSON.stringify(err)
        };
      }
    });
    exports.unsubscribeV2 = unsubscribeV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/channels/index.js
var require_channels = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/channels/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_getSubscribers(), exports);
    tslib_1.__exportStar(require_getChannel(), exports);
    tslib_1.__exportStar(require_getChannelNotifications(), exports);
    tslib_1.__exportStar(require_getChannels(), exports);
    tslib_1.__exportStar(require_getDelegates(), exports);
    tslib_1.__exportStar(require_getSubscribers2(), exports);
    tslib_1.__exportStar(require_search2(), exports);
    tslib_1.__exportStar(require_subscribe(), exports);
    tslib_1.__exportStar(require_subscribeV2(), exports);
    tslib_1.__exportStar(require_unsubscribe(), exports);
    tslib_1.__exportStar(require_unsubscribeV2(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupProfile.js
var require_updateGroupProfile = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupProfile.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGroupProfile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var getGroupInfo_1 = require_getGroupInfo();
    var validationError_1 = require_validationError();
    var updateGroupProfile = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, groupName, groupImage, groupDescription, rules, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const address = yield (0, helpers_2.getAccountAddress)(wallet);
        (0, helpers_2.updateGroupRequestValidator)(chatId, groupName, [], [], address, groupDescription);
        const group = yield (0, getGroupInfo_1.getGroupInfo)({
          chatId,
          env
        });
        const bodyToBeHashed = {
          groupName,
          groupDescription,
          groupImage,
          rules: rules !== null && rules !== void 0 ? rules : {},
          isPublic: group.isPublic,
          groupType: group.groupType
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const connectedUser = yield (0, helpers_2.getConnectedUserV2)(wallet, pgpPrivateKey, env);
        const signature = yield (0, helpers_2.sign)({
          message: hash,
          signingKey: connectedUser.privateKey
        });
        const sigType = "pgpv2";
        const profileVerificationProof = sigType + ":" + signature + ":" + connectedUser.did;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups/${chatId}/profile`;
        const { isPublic: is_public, groupType: group_type } = bodyToBeHashed, body = tslib_1.__rest(bodyToBeHashed, ["isPublic", "groupType"]);
        body.profileVerificationProof = profileVerificationProof;
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.updateGroupProfile.name);
      }
    });
    exports.updateGroupProfile = updateGroupProfile;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/user.js
var require_user2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/user.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.User = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PUSH_USER = require_user();
    var User = class {
      constructor(account, env) {
        this.account = account;
        this.env = env;
      }
      info(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          return yield PUSH_USER.get({
            account: accountToUse,
            env: this.env
          });
        });
      }
    };
    exports.User = User;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupConfig.js
var require_updateGroupConfig = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/updateGroupConfig.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateGroupConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers();
    var CryptoJS = require_crypto_js();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var updateGroupConfig = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, meta, scheduleAt, scheduleEnd, status, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const bodyToBeHashed = {
          meta,
          scheduleAt,
          scheduleEnd,
          status
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const connectedUser = yield (0, helpers_2.getConnectedUserV2)(wallet, pgpPrivateKey, env);
        const signature = yield (0, helpers_2.sign)({
          message: hash,
          signingKey: connectedUser.privateKey
        });
        const sigType = "pgpv2";
        const configVerificationProof = sigType + ":" + signature + ":" + connectedUser.did;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups/${chatId}/config`;
        const body = bodyToBeHashed;
        body.configVerificationProof = configVerificationProof;
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.updateGroupConfig.name);
      }
    });
    exports.updateGroupConfig = updateGroupConfig;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/chat.js
var require_chat3 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/chat.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var pushAPITypes_1 = require_pushAPITypes();
    var PUSH_USER = require_user();
    var PUSH_CHAT = require_chat2();
    var helpers_1 = require_helpers();
    var helpers_2 = require_helpers2();
    var updateGroupProfile_1 = require_updateGroupProfile();
    var user_1 = require_user2();
    var updateGroupConfig_1 = require_updateGroupConfig();
    var PushAPI_1 = require_PushAPI();
    var Chat = class {
      constructor(account, env, alpha, decryptedPgpPvtKey, signer, progressHook) {
        this.account = account;
        this.env = env;
        this.alpha = alpha;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.signer = signer;
        this.progressHook = progressHook;
        this.group = {
          create: (name, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const groupParams = {
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              env: this.env,
              groupName: name,
              groupDescription: (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : null,
              groupImage: (_b = options === null || options === void 0 ? void 0 : options.image) !== null && _b !== void 0 ? _b : null,
              rules: (_c = options === null || options === void 0 ? void 0 : options.rules) !== null && _c !== void 0 ? _c : {},
              isPublic: !(options === null || options === void 0 ? void 0 : options.private),
              groupType: "default",
              config: {
                meta: null,
                scheduleAt: null,
                scheduleEnd: null,
                status: null
              },
              members: (options === null || options === void 0 ? void 0 : options.members) ? options.members : [],
              admins: (options === null || options === void 0 ? void 0 : options.admins) ? options.admins : []
            };
            const response = yield PUSH_CHAT.createGroupV2(groupParams);
            if (this.scalabilityV2Feature) {
              return response;
            } else {
              return yield PUSH_CHAT.getGroup({
                chatId: response.chatId,
                env: this.env
              });
            }
          }),
          participants: {
            list: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
              const { page = 1, limit = 20, filter = { pending: void 0, role: void 0 } } = options !== null && options !== void 0 ? options : {};
              const getGroupMembersOptions = {
                chatId,
                page,
                limit,
                pending: filter.pending,
                role: filter.role,
                env: this.env
              };
              const members = yield PUSH_CHAT.getGroupMembers(getGroupMembersOptions);
              return { members };
            }),
            count: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
              const count = yield PUSH_CHAT.getGroupMemberCount({
                chatId,
                env: this.env
              });
              return {
                participants: count.overallCount - count.pendingCount,
                pending: count.pendingCount
              };
            }),
            status: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
              const accountId = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
              const status = yield PUSH_CHAT.getGroupMemberStatus({
                chatId,
                did: accountId,
                env: this.env
              });
              return {
                pending: status.isPending,
                role: status.isAdmin ? "admin" : "member",
                participant: status.isMember
              };
            })
          },
          permissions: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const getGroupAccessOptions = {
              chatId,
              did: this.account,
              env: this.env
            };
            return yield PUSH_CHAT.getGroupAccess(getGroupAccessOptions);
          }),
          info: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.scalabilityV2Feature ? yield PUSH_CHAT.getGroupInfo({
              chatId,
              env: this.env
            }) : yield PUSH_CHAT.getGroup({
              chatId,
              env: this.env
            });
          }),
          update: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const group = yield PUSH_CHAT.getGroupInfo({
              chatId,
              env: this.env
            });
            if (!group) {
              throw new Error("Group not found");
            }
            const updateGroupProfileOptions = {
              chatId,
              groupName: options.name ? options.name : group.groupName,
              groupDescription: options.description !== void 0 ? options.description : group.groupDescription,
              groupImage: options.image !== void 0 ? options.image : group.groupImage,
              rules: options.rules ? options.rules : group.rules,
              account: this.account,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              env: this.env
            };
            const updateGroupConfigOptions = {
              chatId,
              meta: options.meta ? options.meta : group.meta,
              scheduleAt: options.scheduleAt ? options.scheduleAt : group.scheduleAt,
              scheduleEnd: options.scheduleEnd ? options.scheduleEnd : group.scheduleEnd,
              status: options.status ? options.status : group.status,
              account: this.account,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              env: this.env
            };
            yield (0, updateGroupProfile_1.updateGroupProfile)(updateGroupProfileOptions);
            const response = yield (0, updateGroupConfig_1.updateGroupConfig)(updateGroupConfigOptions);
            if (this.scalabilityV2Feature) {
              return response;
            } else {
              return yield PUSH_CHAT.getGroup({
                chatId: response.chatId,
                env: this.env
              });
            }
          }),
          add: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const { role, accounts } = options;
            const validRoles = ["ADMIN", "MEMBER"];
            if (!validRoles.includes(role)) {
              throw new Error("Invalid role provided.");
            }
            if (!accounts || accounts.length === 0) {
              throw new Error("accounts array cannot be empty!");
            }
            accounts.forEach((account2) => {
              if (!(0, helpers_2.isValidPushCAIP)(account2)) {
                throw new Error(`Invalid account address: ${account2}`);
              }
            });
            let response;
            if (role === "ADMIN") {
              response = yield PUSH_CHAT.addAdmins({
                chatId,
                admins: accounts,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            } else {
              response = yield PUSH_CHAT.addMembers({
                chatId,
                members: accounts,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            }
            if (this.scalabilityV2Feature) {
              return response;
            } else {
              return yield PUSH_CHAT.getGroup({
                chatId: response.chatId,
                env: this.env
              });
            }
          }),
          remove: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { accounts } = options;
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            if (!accounts || accounts.length === 0) {
              throw new Error("Accounts array cannot be empty!");
            }
            accounts.forEach((account2) => {
              if (!(0, helpers_2.isValidPushCAIP)(account2)) {
                throw new Error(`Invalid account address: ${account2}`);
              }
            });
            const adminsToRemove = [];
            const membersToRemove = [];
            for (const account2 of accounts) {
              const status = yield PUSH_CHAT.getGroupMemberStatus({
                chatId,
                did: account2,
                env: this.env
              });
              if (status.isAdmin) {
                adminsToRemove.push(account2);
              } else if (status.isMember) {
                membersToRemove.push(account2);
              }
            }
            if (adminsToRemove.length > 0) {
              yield PUSH_CHAT.removeAdmins({
                chatId,
                admins: adminsToRemove,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            }
            if (membersToRemove.length > 0) {
              yield PUSH_CHAT.removeMembers({
                chatId,
                members: membersToRemove,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            }
            return yield this.group.info(chatId);
          }),
          modify: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { role, accounts } = options;
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const validRoles = ["ADMIN", "MEMBER"];
            if (!validRoles.includes(role)) {
              throw new Error("Invalid role provided.");
            }
            if (!accounts || accounts.length === 0) {
              throw new Error("accounts array cannot be empty!");
            }
            accounts.forEach((account2) => {
              if (!(0, helpers_2.isValidPushCAIP)(account2)) {
                throw new Error(`Invalid account address: ${account2}`);
              }
            });
            return yield PUSH_CHAT.modifyRoles({
              chatId,
              newRole: role,
              members: accounts,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: !this.scalabilityV2Feature
            });
          }),
          join: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const status = yield PUSH_CHAT.getGroupMemberStatus({
              chatId: target,
              did: this.account,
              env: this.env
            });
            if (status.isPending) {
              yield PUSH_CHAT.approve({
                senderAddress: target,
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            } else if (!status.isMember) {
              yield PUSH_CHAT.addMembers({
                chatId: target,
                members: [this.account],
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            }
            return yield this.group.info(target);
          }),
          leave: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            const status = yield PUSH_CHAT.getGroupMemberStatus({
              chatId: target,
              did: this.account,
              env: this.env
            });
            let response;
            if (status.isAdmin) {
              response = yield PUSH_CHAT.removeAdmins({
                chatId: target,
                admins: [this.account],
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            } else {
              response = yield PUSH_CHAT.removeMembers({
                chatId: target,
                members: [this.account],
                env: this.env,
                account: this.account,
                signer: this.signer,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                overrideSecretKeyGeneration: !this.scalabilityV2Feature
              });
            }
            if (this.scalabilityV2Feature) {
              return response;
            } else {
              return yield PUSH_CHAT.getGroup({
                chatId: response.chatId,
                env: this.env
              });
            }
          }),
          reject: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.decryptedPgpPvtKey) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            yield PUSH_CHAT.reject({
              senderAddress: target,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey
            });
          })
        };
        this.userInstance = new user_1.User(this.account, this.env);
        this.scalabilityV2Feature = this.alpha.feature.includes(constants_1.ALPHA_FEATURES.SCALABILITY_V2);
      }
      list(type, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          const listParams = {
            account: accountToUse,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            page: options === null || options === void 0 ? void 0 : options.page,
            limit: options === null || options === void 0 ? void 0 : options.limit,
            env: this.env,
            toDecrypt: !!this.decryptedPgpPvtKey
            // Set to false if signer is undefined or null,
          };
          switch (type) {
            case pushAPITypes_1.ChatListType.CHATS:
              return yield PUSH_CHAT.chats(listParams);
            case pushAPITypes_1.ChatListType.REQUESTS:
              return yield PUSH_CHAT.requests(listParams);
            default:
              throw new Error("Invalid Chat List Type");
          }
        });
      }
      latest(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { threadHash, intent } = yield PUSH_CHAT.conversationHash({
            conversationId: target,
            account: this.account,
            env: this.env
          });
          if (!threadHash)
            return {};
          const latestMessages = yield PUSH_CHAT.latest({
            threadhash: threadHash,
            toDecrypt: !!this.decryptedPgpPvtKey,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            account: this.account,
            env: this.env
          });
          const listType = intent ? "CHATS" : "REQUESTS";
          return latestMessages.map((message) => Object.assign(Object.assign({}, message), { listType }));
        });
      }
      history(target, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let reference;
          const { threadHash, intent } = yield PUSH_CHAT.conversationHash({
            conversationId: target,
            account: this.account,
            env: this.env
          });
          if (!(options === null || options === void 0 ? void 0 : options.reference)) {
            reference = threadHash;
          } else {
            reference = options.reference;
          }
          if (!reference)
            return [];
          const historyMessages = yield PUSH_CHAT.history({
            account: this.account,
            env: this.env,
            threadhash: reference,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            toDecrypt: !!this.decryptedPgpPvtKey,
            limit: options === null || options === void 0 ? void 0 : options.limit
          });
          const listType = intent ? "CHATS" : "REQUESTS";
          return historyMessages.map((message) => Object.assign(Object.assign({}, message), { listType }));
        });
      }
      message(target, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let reference;
          const { threadHash, intent } = yield PUSH_CHAT.conversationHash({
            conversationId: target,
            account: this.account,
            env: this.env
          });
          reference = (options === null || options === void 0 ? void 0 : options.reference) || threadHash;
          if (!reference)
            return {};
          const historyMessages = yield this.history(target, { reference, limit: 1 });
          const listType = intent ? "CHATS" : "REQUESTS";
          return historyMessages.length > 0 ? Object.assign(Object.assign({}, historyMessages[0]), { listType }) : null;
        });
      }
      send(recipient, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          if (!options.type) {
            options.type = constants_1.MessageType.TEXT;
          }
          const sendParams = {
            message: options,
            to: recipient,
            account: this.account,
            signer: this.signer,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            env: this.env
          };
          return yield PUSH_CHAT.send(sendParams);
        });
      }
      decrypt(messagePayloads) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return yield PUSH_CHAT.decryptConversation({
            pgpPrivateKey: this.decryptedPgpPvtKey,
            env: this.env,
            messages: messagePayloads,
            pgpHelper: helpers_1.PGPHelper,
            connectedUser: yield this.userInstance.info()
          });
        });
      }
      accept(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return yield PUSH_CHAT.approve({
            senderAddress: target,
            env: this.env,
            account: this.account,
            signer: this.signer,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            overrideSecretKeyGeneration: !this.scalabilityV2Feature
          });
        });
      }
      reject(target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          yield PUSH_CHAT.reject({
            senderAddress: target,
            env: this.env,
            account: this.account,
            signer: this.signer,
            pgpPrivateKey: this.decryptedPgpPvtKey
          });
        });
      }
      block(users) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const user = yield PUSH_USER.get({
            account: this.account,
            env: this.env
          });
          for (const element of users) {
            if (!(0, helpers_2.isValidPushCAIP)(element)) {
              throw new Error("Invalid address in the users: " + element);
            }
          }
          if (!user.profile.blockedUsersList) {
            user.profile.blockedUsersList = [];
          }
          user.profile.blockedUsersList = [
            .../* @__PURE__ */ new Set([...user.profile.blockedUsersList, ...users])
          ];
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return yield PUSH_USER.profile.update({
            pgpPrivateKey: this.decryptedPgpPvtKey,
            account: this.account,
            profile: {
              name: user.profile.name,
              desc: user.profile.desc,
              picture: user.profile.picture,
              blockedUsersList: user.profile.blockedUsersList
            },
            env: this.env,
            progressHook: this.progressHook
          });
        });
      }
      unblock(users) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const user = yield PUSH_USER.get({
            account: this.account,
            env: this.env
          });
          for (const element of users) {
            if (!(0, helpers_2.isValidPushCAIP)(element)) {
              throw new Error("Invalid address in the users: " + element);
            }
          }
          if (!user.profile.blockedUsersList) {
            return user;
          }
          const userDIDsPromises = users.map((user2) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield (0, helpers_2.convertToValidDID)(user2, this.env)).toLowerCase();
          }));
          const userDIDs = yield Promise.all(userDIDsPromises);
          user.profile.blockedUsersList = user.profile.blockedUsersList.filter((blockedUser) => {
            !userDIDs.includes(blockedUser.toLowerCase());
          });
          return yield PUSH_USER.profile.update({
            pgpPrivateKey: this.decryptedPgpPvtKey,
            account: this.account,
            profile: {
              name: user.profile.name,
              desc: user.profile.desc,
              picture: user.profile.picture,
              blockedUsersList: user.profile.blockedUsersList
            },
            env: this.env,
            progressHook: this.progressHook
          });
        });
      }
      info(recipient, options) {
        var _a, _b, _c;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          const request = {
            recipient,
            account: accountToUse,
            env: this.env
          };
          try {
            const chatInfo = yield PUSH_CHAT.getChatInfo(request);
            const isGroupChat = (_b = (_a = chatInfo.meta) === null || _a === void 0 ? void 0 : _a.group) !== null && _b !== void 0 ? _b : false;
            let finalRecipient = recipient;
            if (isGroupChat) {
              finalRecipient = chatInfo.chatId;
            } else {
              const participants = (_c = chatInfo.participants) !== null && _c !== void 0 ? _c : [];
              const participant = participants.find((participant2) => participant2 !== (0, helpers_2.walletToPCAIP10)(accountToUse));
              if (participant) {
                finalRecipient = participant;
              }
            }
            const response = {
              meta: chatInfo.meta,
              list: chatInfo.list,
              participants: chatInfo.participants,
              chatId: chatInfo.chatId,
              recipient: finalRecipient
            };
            return response;
          } catch (error) {
            console.error(`Error in Chat.info: `, error);
            throw new Error(`Error fetching chat info: ${error}`);
          }
        });
      }
    };
    exports.Chat = Chat;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/profile.js
var require_profile = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/profile.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Profile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PUSH_USER = require_user();
    var PushAPI_1 = require_PushAPI();
    var Profile = class {
      constructor(account, env, cache, decryptedPgpPvtKey, progressHook) {
        this.account = account;
        this.env = env;
        this.cache = cache;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.progressHook = progressHook;
      }
      info(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          const cacheKey = `profile-${accountToUse}`;
          if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
          }
          const response = yield PUSH_USER.get({
            account: accountToUse,
            env: this.env
          });
          this.cache.set(cacheKey, response.profile);
          return response.profile;
        });
      }
      update(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.decryptedPgpPvtKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const { name, desc, picture } = options;
          const response = yield PUSH_USER.profile.update({
            pgpPrivateKey: this.decryptedPgpPvtKey,
            account: this.account,
            profile: { name, desc, picture },
            env: this.env,
            progressHook: this.progressHook
          });
          const cacheKey = `profile-${this.account}`;
          this.cache.delete(cacheKey);
          return response.profile;
        });
      }
    };
    exports.Profile = Profile;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/encryption.js
var require_encryption = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/encryption.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encryption = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PUSH_USER = require_user();
    var PushAPI_1 = require_PushAPI();
    var user_1 = require_user2();
    var Encryption = class {
      constructor(account, env, decryptedPgpPvtKey, pgpPublicKey, signer, progressHook) {
        this.account = account;
        this.env = env;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.pgpPublicKey = pgpPublicKey;
        this.signer = signer;
        this.progressHook = progressHook;
        this.userInstance = new user_1.User(this.account, this.env);
      }
      info() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const userInfo = yield this.userInstance.info();
          let decryptedPassword;
          if (this.signer) {
            decryptedPassword = yield PUSH_USER.decryptAuth({
              account: this.account,
              env: this.env,
              signer: this.signer,
              progressHook: this.progressHook,
              additionalMeta: {
                NFTPGP_V1: {
                  encryptedPassword: JSON.stringify(JSON.parse(userInfo.encryptedPrivateKey).encryptedPassword)
                }
              }
            });
          }
          return Object.assign({ decryptedPgpPrivateKey: this.decryptedPgpPvtKey, pgpPublicKey: this.pgpPublicKey }, decryptedPassword !== void 0 && decryptedPassword !== null ? { decryptedPassword } : {});
        });
      }
      update(updatedEncryptionType, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          if (!this.decryptedPgpPvtKey || !this.pgpPublicKey) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return yield PUSH_USER.auth.update({
            account: this.account,
            pgpEncryptionVersion: updatedEncryptionType,
            additionalMeta: options === null || options === void 0 ? void 0 : options.versionMeta,
            progressHook: this.progressHook,
            signer: this.signer,
            env: this.env,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            pgpPublicKey: this.pgpPublicKey
          });
        });
      }
    };
    exports.Encryption = Encryption;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushstream/socketClient.js
var require_socketClient = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushstream/socketClient.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSocketConnection = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var socket_io_client_1 = require_cjs3();
    var config_1 = require_config();
    var helpers_1 = require_helpers2();
    function createSocketConnection({ user, env, socketType = "notification", socketOptions }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { autoConnect = true, reconnectionAttempts = 5, reconnectionDelay, reconnectionDelayMax } = socketOptions || {};
        let pushWSUrl = config_1.API_BASE_URL[env];
        if (pushWSUrl.endsWith("/apis")) {
          pushWSUrl = pushWSUrl.substring(0, pushWSUrl.length - 5);
        }
        const transports = ["websocket"];
        let pushSocket = null;
        try {
          const userAddressInCAIP = socketType === "chat" ? (0, helpers_1.walletToPCAIP10)(user) : yield (0, helpers_1.getCAIPAddress)(env, user, "User");
          const query = socketType === "notification" ? { address: userAddressInCAIP } : { mode: "chat", did: userAddressInCAIP };
          pushSocket = (0, socket_io_client_1.io)(pushWSUrl, Object.assign(Object.assign({
            transports,
            query,
            autoConnect,
            reconnectionAttempts
          }, reconnectionDelay !== void 0 && { reconnectionDelay }), reconnectionDelayMax !== void 0 && { reconnectionDelayMax }));
        } catch (e) {
          console.error("[PUSH-SDK] - Socket connection error: ", e);
        }
        return pushSocket;
      });
    }
    exports.createSocketConnection = createSocketConnection;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushstream/DataModifier.js
var require_DataModifier = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushstream/DataModifier.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataModifier = void 0;
    var pushStreamTypes_1 = require_pushStreamTypes();
    var types_1 = require_types();
    var constants_1 = require_constants2();
    var DataModifier = class _DataModifier {
      static handleChatGroupEvent(data, includeRaw = false) {
        switch (data.eventType) {
          case "create":
            return this.mapToCreateGroupEvent(data, includeRaw);
          case "update":
            return this.mapToUpdateGroupEvent(data, includeRaw);
          case pushStreamTypes_1.GroupEventType.JoinGroup:
            return this.mapToJoinGroupEvent(data, includeRaw);
          case pushStreamTypes_1.GroupEventType.LeaveGroup:
            return this.mapToLeaveGroupEvent(data, includeRaw);
          case pushStreamTypes_1.MessageEventType.Request:
            return this.mapToRequestEvent(data, includeRaw);
          case pushStreamTypes_1.GroupEventType.Remove:
            return this.mapToRemoveEvent(data, includeRaw);
          case pushStreamTypes_1.GroupEventType.RoleChange:
            return this.mapToRoleChangeEvent(data, includeRaw);
          default:
            console.warn("Unknown eventType:", data.eventType);
            return data;
        }
      }
      static mapToJoinGroupEvent(data, includeRaw) {
        const baseEventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          chatId: data.chatId,
          from: data.from,
          to: data.to,
          event: pushStreamTypes_1.GroupEventType.JoinGroup
        };
        return includeRaw ? Object.assign(Object.assign({}, baseEventData), { raw: { verificationProof: data.verificationProof } }) : baseEventData;
      }
      static mapToLeaveGroupEvent(data, includeRaw) {
        const baseEventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          chatId: data.chatId,
          from: data.from,
          to: data.to,
          event: pushStreamTypes_1.GroupEventType.LeaveGroup
        };
        return includeRaw ? Object.assign(Object.assign({}, baseEventData), { raw: { verificationProof: data.verificationProof } }) : baseEventData;
      }
      static mapToRequestEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          chatId: data.chatId,
          from: data.from,
          to: data.to,
          event: pushStreamTypes_1.MessageEventType.Request,
          meta: {
            group: data.isGroup || false
          }
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToRemoveEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          chatId: data.chatId,
          from: data.from,
          to: data.to,
          event: pushStreamTypes_1.GroupEventType.Remove
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToRoleChangeEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          chatId: data.chatId,
          from: data.from,
          to: data.to,
          newRole: data.newRole,
          event: pushStreamTypes_1.GroupEventType.RoleChange
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static buildChatGroupEventMetaAndRaw(incomingData, includeRaw) {
        const meta = {
          name: incomingData.groupName,
          description: incomingData.groupDescription,
          image: incomingData.groupImage,
          owner: incomingData.groupCreator,
          private: !incomingData.isPublic,
          rules: incomingData.rules || {}
        };
        if (includeRaw) {
          const raw = {
            verificationProof: incomingData.verificationProof
          };
          return { meta, raw };
        }
        return { meta };
      }
      static mapToGroupEvent(eventType, incomingData, includeRaw) {
        const { meta, raw } = this.buildChatGroupEventMetaAndRaw(incomingData, includeRaw);
        const groupEvent = {
          event: eventType,
          origin: incomingData.messageOrigin,
          timestamp: incomingData.timestamp,
          chatId: incomingData.chatId,
          from: incomingData.from,
          meta
        };
        if (includeRaw) {
          groupEvent.raw = raw;
        }
        return groupEvent;
      }
      static mapToCreateGroupEvent(incomingData, includeRaw) {
        return this.mapToGroupEvent(pushStreamTypes_1.GroupEventType.CreateGroup, incomingData, includeRaw);
      }
      static mapToUpdateGroupEvent(incomingData, includeRaw) {
        return this.mapToGroupEvent(pushStreamTypes_1.GroupEventType.UpdateGroup, incomingData, includeRaw);
      }
      static mapToMessageEvent(data, includeRaw = false, eventType) {
        if (data.hasIntent === false && eventType === "message") {
          eventType = pushStreamTypes_1.MessageEventType.Request;
        }
        const messageEvent = {
          event: eventType,
          origin: data.messageOrigin,
          timestamp: data.timestamp.toString(),
          chatId: data.chatId,
          from: data.fromCAIP10,
          to: [data.toCAIP10],
          message: Object.assign({ type: data.messageType }, data.messageObj),
          meta: {
            group: data.isGroup || false
          },
          reference: data.cid
        };
        if (includeRaw) {
          const rawData = {
            fromCAIP10: data.fromCAIP10,
            toCAIP10: data.toCAIP10,
            fromDID: data.fromDID,
            toDID: data.toDID,
            encType: data.encType,
            encryptedSecret: data.encryptedSecret,
            signature: data.signature,
            sigType: data.sigType,
            verificationProof: data.verificationProof,
            previousReference: data.link
          };
          messageEvent.raw = rawData;
        }
        return messageEvent;
      }
      static handleChatEvent(data, includeRaw = false) {
        if (!data) {
          console.error("Error in handleChatEvent: data is undefined or null");
          throw new Error("data is undefined or null");
        }
        const eventTypeMap = {
          Chat: pushStreamTypes_1.MessageEventType.Message,
          Request: pushStreamTypes_1.MessageEventType.Request,
          Approve: pushStreamTypes_1.MessageEventType.Accept,
          Reject: pushStreamTypes_1.MessageEventType.Reject
        };
        const key = data.eventType || data.messageCategory;
        if (!eventTypeMap[key]) {
          console.error("Error in handleChatEvent: Invalid eventType or messageCategory", JSON.stringify(data));
          throw new Error("Invalid eventType or messageCategory in data");
        }
        const eventType = eventTypeMap[key];
        if (eventType) {
          return this.mapToMessageEvent(data, includeRaw, eventType);
        } else {
          console.warn("Unknown eventType:", data.eventType || data.messageCategory);
          return data;
        }
      }
      static mapToNotificationEvent(data, notificationEventType, origin, includeRaw = false) {
        var _a, _b, _c;
        const notificationType = Object.keys(pushStreamTypes_1.NOTIFICATION.TYPE).find((key) => pushStreamTypes_1.NOTIFICATION.TYPE[key] === data.payload.data.type) || "BROADCAST";
        let recipients;
        if (Array.isArray(data.payload.recipients)) {
          recipients = data.payload.recipients;
        } else if (typeof data.payload.recipients === "string") {
          recipients = [data.payload.recipients];
        } else {
          recipients = Object.keys(data.payload.recipients);
        }
        const notificationEvent = {
          event: notificationEventType,
          origin,
          timestamp: data.epoch,
          from: data.sender,
          to: recipients,
          notifID: data.payload_id.toString(),
          channel: {
            name: data.payload.data.app,
            icon: data.payload.data.icon,
            url: data.payload.data.url
          },
          meta: {
            type: "NOTIFICATION." + notificationType
          },
          message: {
            notification: {
              title: data.payload.notification.title,
              body: data.payload.notification.body
            },
            payload: {
              title: data.payload.data.asub,
              body: data.payload.data.amsg,
              cta: data.payload.data.acta,
              embed: data.payload.data.aimg,
              meta: {
                domain: ((_a = data.payload.data.additionalMeta) === null || _a === void 0 ? void 0 : _a.domain) || "push.org",
                type: (_b = data.payload.data.additionalMeta) === null || _b === void 0 ? void 0 : _b.type,
                data: (_c = data.payload.data.additionalMeta) === null || _c === void 0 ? void 0 : _c.data
              }
            }
          },
          config: {
            expiry: data.payload.data.etime,
            silent: data.payload.data.silent === "1",
            hidden: data.payload.data.hidden === "1"
          },
          source: data.source
        };
        if (includeRaw) {
          notificationEvent.raw = {
            verificationProof: data.payload.verificationProof
          };
        }
        return notificationEvent;
      }
      static convertToProposedName(currentEventName) {
        switch (currentEventName) {
          case "message":
            return pushStreamTypes_1.ProposedEventNames.Message;
          case "request":
            return pushStreamTypes_1.ProposedEventNames.Request;
          case "accept":
            return pushStreamTypes_1.ProposedEventNames.Accept;
          case "reject":
            return pushStreamTypes_1.ProposedEventNames.Reject;
          case "leaveGroup":
            return pushStreamTypes_1.ProposedEventNames.LeaveGroup;
          case "joinGroup":
            return pushStreamTypes_1.ProposedEventNames.JoinGroup;
          case "createGroup":
            return pushStreamTypes_1.ProposedEventNames.CreateGroup;
          case "updateGroup":
            return pushStreamTypes_1.ProposedEventNames.UpdateGroup;
          case "remove":
            return pushStreamTypes_1.ProposedEventNames.Remove;
          case "roleChange":
            return pushStreamTypes_1.ProposedEventNames.RoleChange;
          default:
            throw new Error(`Unknown current event name: ${currentEventName}`);
        }
      }
      static convertToProposedNameForSpace(currentEventName) {
        switch (currentEventName) {
          case "create":
            return pushStreamTypes_1.ProposedEventNames.CreateSpace;
          case "update":
            return pushStreamTypes_1.ProposedEventNames.UpdateSpace;
          case "request":
            return pushStreamTypes_1.ProposedEventNames.SpaceRequest;
          case "accept":
            return pushStreamTypes_1.ProposedEventNames.SpaceAccept;
          case "reject":
            return pushStreamTypes_1.ProposedEventNames.SpaceReject;
          case "leaveSpace":
            return pushStreamTypes_1.ProposedEventNames.LeaveSpace;
          case "joinSpace":
            return pushStreamTypes_1.ProposedEventNames.JoinSpace;
          case "remove":
            return pushStreamTypes_1.ProposedEventNames.SpaceRemove;
          case "start":
            return pushStreamTypes_1.ProposedEventNames.StartSpace;
          case "stop":
            return pushStreamTypes_1.ProposedEventNames.StopSpace;
          default:
            throw new Error(`Unknown current event name: ${currentEventName}`);
        }
      }
      static handleToField(data) {
        var _a;
        switch (data.event) {
          case pushStreamTypes_1.ProposedEventNames.LeaveGroup:
          case pushStreamTypes_1.ProposedEventNames.JoinGroup:
            data.to = null;
            break;
          case pushStreamTypes_1.ProposedEventNames.Accept:
          case pushStreamTypes_1.ProposedEventNames.Reject:
            if ((_a = data.meta) === null || _a === void 0 ? void 0 : _a.group) {
              data.to = null;
            }
            break;
          default:
            break;
        }
      }
      static handleSpaceEvent(data, includeRaw = false) {
        switch (data.eventType) {
          case "create":
            return this.mapToCreateSpaceEvent(data, includeRaw);
          case "update":
            return this.mapToUpdateSpaceEvent(data, includeRaw);
          case "request":
            return this.mapToRequestSpaceEvent(data, includeRaw);
          case "remove":
            return this.mapToRemoveSpaceEvent(data, includeRaw);
          case "joinSpace":
            return this.mapToJoinSpaceEvent(data, includeRaw);
          case "leaveSpace":
            return this.mapToLeaveSpaceEvent(data, includeRaw);
          case "start":
            return this.mapToStartSpaceEvent(data, includeRaw);
          case "stop":
            return this.mapToStopSpaceEvent(data, includeRaw);
          default:
            switch (data.messageCategory) {
              case "Approve":
                return this.mapToSpaceApproveEvent(data, includeRaw);
              case "Reject":
                return this.mapToSpaceRejectEvent(data, includeRaw);
              default:
                console.warn("Unknown eventType or messageCategory for space:", data.eventType, data.messageCategory);
                return data;
            }
        }
      }
      static mapToCreateSpaceEvent(data, includeRaw) {
        const baseEventData = {
          event: data.eventType,
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.spaceCreator,
          meta: {
            name: data.spaceName,
            description: data.spaceDescription,
            image: data.spaceImage,
            owner: data.spaceCreator,
            private: !data.isPublic,
            rules: data.rules || {}
          }
        };
        if (includeRaw) {
          baseEventData.raw = {
            verificationProof: data.verificationProof || ""
          };
        }
        return baseEventData;
      }
      static mapToUpdateSpaceEvent(data, includeRaw) {
        const baseEventData = {
          event: data.eventType,
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.spaceCreator,
          meta: {
            name: data.spaceName,
            description: data.spaceDescription,
            image: data.spaceImage,
            owner: data.spaceCreator,
            private: !data.isPublic,
            rules: data.rules || {}
          }
        };
        if (includeRaw) {
          baseEventData.raw = {
            verificationProof: data.verificationProof || ""
          };
        }
        return baseEventData;
      }
      static mapToRequestSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: data.to,
          event: pushStreamTypes_1.MessageEventType.Request
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToSpaceApproveEvent(data, includeRaw) {
        const baseEventData = {
          event: "request",
          origin: data.messageOrigin === "other" ? "self" : "other",
          timestamp: data.timestamp,
          spaceId: data.chatId,
          from: data.fromCAIP10,
          to: [data.toCAIP10]
        };
        if (includeRaw) {
          baseEventData.raw = {
            verificationProof: data.verificationProof || ""
          };
        }
        return baseEventData;
      }
      static mapToSpaceRejectEvent(data, includeRaw) {
        const baseEventData = {
          event: "reject",
          origin: data.messageOrigin === "other" ? "other" : "self",
          timestamp: data.timestamp.toString(),
          spaceId: data.chatId,
          from: data.fromCAIP10,
          to: null
        };
        if (includeRaw) {
          baseEventData.raw = {
            verificationProof: data.verificationProof || ""
          };
        }
        return baseEventData;
      }
      static mapToRemoveSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: data.to,
          event: "remove"
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToJoinSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: data.to,
          event: data.eventType
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToLeaveSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: data.to,
          event: data.eventType
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToStartSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: null,
          event: data.eventType
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static mapToStopSpaceEvent(data, includeRaw) {
        const eventData = {
          origin: data.messageOrigin,
          timestamp: data.timestamp,
          spaceId: data.spaceId,
          from: data.from,
          to: null,
          event: data.eventType
        };
        if (includeRaw) {
          eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
      }
      static convertToProposedNameForVideo(currentVideoStatus) {
        switch (currentVideoStatus) {
          case types_1.VideoCallStatus.INITIALIZED:
            return pushStreamTypes_1.VideoEventType.REQUEST;
          case types_1.VideoCallStatus.RECEIVED:
            return pushStreamTypes_1.VideoEventType.APPROVE;
          case types_1.VideoCallStatus.CONNECTED:
            return pushStreamTypes_1.VideoEventType.CONNECT;
          case types_1.VideoCallStatus.ENDED:
            return pushStreamTypes_1.VideoEventType.DISCONNECT;
          case types_1.VideoCallStatus.DISCONNECTED:
            return pushStreamTypes_1.VideoEventType.DENY;
          case types_1.VideoCallStatus.RETRY_INITIALIZED:
            return pushStreamTypes_1.VideoEventType.RETRY_REQUEST;
          case types_1.VideoCallStatus.RETRY_RECEIVED:
            return pushStreamTypes_1.VideoEventType.RETRY_APPROVE;
          default:
            throw new Error(`Unknown video call status: ${currentVideoStatus}`);
        }
      }
      static mapToVideoEvent(data, origin, includeRaw = false) {
        var _a, _b;
        const { senderAddress, signalData, status, chatId } = JSON.parse((_a = data.payload.data.additionalMeta) === null || _a === void 0 ? void 0 : _a.data);
        const rules = (_b = data.payload.rules) !== null && _b !== void 0 ? _b : {
          access: {
            type: constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT,
            data: {
              chatId
            }
          }
        };
        const peerInfo = {
          address: senderAddress,
          signal: signalData,
          meta: {
            rules
          }
        };
        const videoEventType = _DataModifier.convertToProposedNameForVideo(status);
        const videoEvent = {
          event: videoEventType,
          origin,
          timestamp: data.epoch,
          peerInfo
        };
        if (includeRaw) {
          videoEvent.raw = {
            verificationProof: data.payload.verificationProof
          };
        }
        return videoEvent;
      }
    };
    exports.DataModifier = DataModifier;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushstream/PushStream.js
var require_PushStream = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushstream/PushStream.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PushStream = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var socketClient_1 = require_socketClient();
    var constants_1 = require_constants();
    var pushStreamTypes_1 = require_pushStreamTypes();
    var DataModifier_1 = require_DataModifier();
    var helpers_1 = require_helpers2();
    var chat_1 = require_chat3();
    var config_1 = require_config();
    var payloads_1 = require_payloads();
    var uuid_1 = require_commonjs_browser();
    var PushStream = class _PushStream extends events_1.EventEmitter {
      constructor(account, _listen, options, decryptedPgpPvtKey, progressHook, signer) {
        var _a;
        super();
        this._listen = _listen;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.progressHook = progressHook;
        this.signer = signer;
        this.account = account;
        this.raw = (_a = options.raw) !== null && _a !== void 0 ? _a : false;
        this.options = options;
        this.listen = _listen;
        this.disconnected = false;
        this.uid = (0, uuid_1.v4)();
        this.chatSocketCount = 0;
        this.notifSocketCount = 0;
        this.chatSocketConnected = false;
        this.notifSocketConnected = false;
        this.chatInstance = new chat_1.Chat(this.account, this.options.env, config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD], this.decryptedPgpPvtKey, this.signer, this.progressHook);
      }
      static initialize(account, listen, env, decryptedPgpPvtKey, progressHook, signer, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const defaultOptions = {
            raw: false,
            connection: {
              auto: true,
              retries: 3
            },
            env
          };
          if (!listen || listen.length === 0) {
            throw new Error("The listen property must have at least one STREAM type.");
          }
          const settings = Object.assign(Object.assign({}, defaultOptions), options);
          const accountToUse = settings.overrideAccount || account;
          if (listen.includes("*")) {
            listen = Object.values(pushStreamTypes_1.STREAM);
          }
          const stream = new _PushStream(accountToUse, listen, settings, decryptedPgpPvtKey, progressHook, signer);
          return stream;
        });
      }
      reinit(listen, newOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.uid = (0, uuid_1.v4)();
          this.listen = listen;
          this.options = Object.assign(Object.assign({}, this.options), newOptions);
          yield this.disconnect();
          yield this.connect();
        });
      }
      connect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
              var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
              const shouldInitializeChatSocket = !this.listen || this.listen.length === 0 || this.listen.includes(pushStreamTypes_1.STREAM.CHAT) || this.listen.includes(pushStreamTypes_1.STREAM.CHAT_OPS) || this.listen.includes(pushStreamTypes_1.STREAM.SPACE) || this.listen.includes(pushStreamTypes_1.STREAM.SPACE_OPS);
              const shouldInitializeNotifSocket = !this.listen || this.listen.length === 0 || this.listen.includes(pushStreamTypes_1.STREAM.NOTIF) || this.listen.includes(pushStreamTypes_1.STREAM.NOTIF_OPS) || this.listen.includes(pushStreamTypes_1.STREAM.VIDEO);
              let isChatSocketConnected = false;
              let isNotifSocketConnected = false;
              const checkAndEmitConnectEvent = () => {
                if ((shouldInitializeChatSocket && isChatSocketConnected || !shouldInitializeChatSocket) && (shouldInitializeNotifSocket && isNotifSocketConnected || !shouldInitializeNotifSocket)) {
                  this.emit(pushStreamTypes_1.STREAM.CONNECT);
                  console.log("RestAPI::PushStream::connect - Emitted STREAM.CONNECT");
                  resolve();
                }
              };
              const TIMEOUT_DURATION = 5e3;
              setTimeout(() => {
                if (!(this.notifSocketConnected || this.chatSocketConnected)) {
                  reject(new Error("Connection timeout"));
                }
              }, TIMEOUT_DURATION);
              const handleSocketDisconnection = (socketType) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (socketType === "chat") {
                  isChatSocketConnected = false;
                  this.chatSocketConnected = false;
                  this.chatSocketCount--;
                  if (isNotifSocketConnected) {
                    if (this.pushNotificationSocket && this.pushNotificationSocket.connected) {
                      console.log("RestAPI::PushStream::handleSocketDisconnection - Disconnecting Notification Socket...");
                      this.pushNotificationSocket.disconnect();
                    }
                  } else {
                    this.emit(pushStreamTypes_1.STREAM.DISCONNECT);
                    console.log("RestAPI::PushStream::handleSocketDisconnection - Emitted STREAM.DISCONNECT for chat.");
                  }
                } else if (socketType === "notif") {
                  isNotifSocketConnected = false;
                  this.notifSocketConnected = false;
                  this.notifSocketCount--;
                  if (isChatSocketConnected) {
                    if (this.pushChatSocket && this.pushChatSocket.connected) {
                      console.log("RestAPI::PushStream::handleSocketDisconnection - Disconnecting Chat Socket...");
                      this.pushChatSocket.disconnect();
                    }
                  } else {
                    this.emit(pushStreamTypes_1.STREAM.DISCONNECT);
                    console.log("RestAPI::PushStream::handleSocketDisconnection - Emitted STREAM.DISCONNECT for notification.");
                  }
                }
              });
              if (shouldInitializeChatSocket) {
                if (!this.pushChatSocket) {
                  console.log("RestAPI::PushStream::ChatSocket::Create - pushChatSocket does not exist, creating new socket connection...");
                  this.pushChatSocket = yield (0, socketClient_1.createSocketConnection)({
                    user: (0, helpers_1.walletToPCAIP10)(this.account),
                    socketType: "chat",
                    socketOptions: {
                      autoConnect: (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.auto) !== null && _c !== void 0 ? _c : true,
                      reconnectionAttempts: (_f = (_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.connection) === null || _e === void 0 ? void 0 : _e.retries) !== null && _f !== void 0 ? _f : 3
                    },
                    env: (_g = this.options) === null || _g === void 0 ? void 0 : _g.env
                  });
                  if (!this.pushChatSocket) {
                    reject(new Error("RestAPI::PushStream::ChatSocket::Error - Push chat socket not connected"));
                  }
                } else if (this.pushChatSocket && !this.chatSocketConnected) {
                  console.log("RestAPI::PushStream::ChatSocket::Reconnect - Attempting to reconnect push chat socket...");
                  this.pushChatSocket.connect();
                } else {
                  console.log("RestAPI::PushStream::ChatSocket::Status - Push chat socket already connected");
                }
              }
              if (shouldInitializeNotifSocket) {
                if (!this.pushNotificationSocket) {
                  console.log("RestAPI::PushStream::NotifSocket::Create - pushNotificationSocket does not exist, creating new socket connection...");
                  this.pushNotificationSocket = yield (0, socketClient_1.createSocketConnection)({
                    user: (0, helpers_1.pCAIP10ToWallet)(this.account),
                    env: (_h = this.options) === null || _h === void 0 ? void 0 : _h.env,
                    socketOptions: {
                      autoConnect: (_l = (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.connection) === null || _k === void 0 ? void 0 : _k.auto) !== null && _l !== void 0 ? _l : true,
                      reconnectionAttempts: (_p = (_o = (_m = this.options) === null || _m === void 0 ? void 0 : _m.connection) === null || _o === void 0 ? void 0 : _o.retries) !== null && _p !== void 0 ? _p : 3
                    }
                  });
                  if (!this.pushNotificationSocket) {
                    reject(new Error("RestAPI::PushStream::NotifSocket::Error - Push notification socket not connected"));
                  }
                } else if (this.pushNotificationSocket && !this.notifSocketConnected) {
                  console.log("RestAPI::PushStream::NotifSocket::Reconnect - Attempting to reconnect push notification socket...");
                  this.notifSocketCount++;
                  this.pushNotificationSocket.connect();
                } else {
                  console.log("RestAPI::PushStream::NotifSocket::Status - Push notification socket already connected");
                }
              }
              const shouldEmit = (eventType) => {
                if (!this.listen || this.listen.length === 0) {
                  return true;
                }
                return this.listen.includes(eventType);
              };
              if (this.pushChatSocket) {
                this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  isChatSocketConnected = true;
                  this.chatSocketCount++;
                  this.chatSocketConnected = true;
                  checkAndEmitConnectEvent();
                  console.log(`RestAPI::PushStream::EVENTS.CONNECT::Chat Socket Connected (ID: ${this.pushChatSocket.id})`);
                }));
                this.pushChatSocket.on(pushStreamTypes_1.EVENTS.DISCONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  yield handleSocketDisconnection("chat");
                }));
                this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CHAT_GROUPS, (data) => {
                  try {
                    const modifiedData = DataModifier_1.DataModifier.handleChatGroupEvent(data, this.raw);
                    modifiedData.event = DataModifier_1.DataModifier.convertToProposedName(modifiedData.event);
                    modifiedData.streamUid = this.uid;
                    DataModifier_1.DataModifier.handleToField(modifiedData);
                    if (this.shouldEmitChat(data.chatId)) {
                      if (data.eventType === pushStreamTypes_1.GroupEventType.JoinGroup || data.eventType === pushStreamTypes_1.GroupEventType.LeaveGroup || data.eventType === pushStreamTypes_1.MessageEventType.Request || data.eventType === pushStreamTypes_1.GroupEventType.Remove || data.eventType === pushStreamTypes_1.GroupEventType.RoleChange) {
                        if (shouldEmit(pushStreamTypes_1.STREAM.CHAT)) {
                          this.emit(pushStreamTypes_1.STREAM.CHAT, modifiedData);
                        }
                      } else {
                        if (shouldEmit(pushStreamTypes_1.STREAM.CHAT_OPS)) {
                          this.emit(pushStreamTypes_1.STREAM.CHAT_OPS, modifiedData);
                        }
                      }
                    }
                  } catch (error) {
                    console.error("Error handling CHAT_GROUPS event:", error, "Data:", data);
                  }
                });
                this.pushChatSocket.on(pushStreamTypes_1.EVENTS.CHAT_RECEIVED_MESSAGE, (data) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  try {
                    if (data.messageCategory == "Chat" || data.messageCategory == "Request") {
                      if (this.decryptedPgpPvtKey) {
                        data = yield this.chatInstance.decrypt([data]);
                        data = data[0];
                      }
                    }
                    const modifiedData = DataModifier_1.DataModifier.handleChatEvent(data, this.raw);
                    modifiedData.event = DataModifier_1.DataModifier.convertToProposedName(modifiedData.event);
                    DataModifier_1.DataModifier.handleToField(modifiedData);
                    if (this.shouldEmitChat(data.chatId)) {
                      if (shouldEmit(pushStreamTypes_1.STREAM.CHAT)) {
                        this.emit(pushStreamTypes_1.STREAM.CHAT, modifiedData);
                      }
                    }
                  } catch (error) {
                    console.error("Error handling CHAT_RECEIVED_MESSAGE event:", error, "Data:", data);
                  }
                }));
                this.pushChatSocket.on("SPACES", (data) => {
                  try {
                    const modifiedData = DataModifier_1.DataModifier.handleSpaceEvent(data, this.raw);
                    modifiedData.event = DataModifier_1.DataModifier.convertToProposedNameForSpace(modifiedData.event);
                    DataModifier_1.DataModifier.handleToField(modifiedData);
                    if (this.shouldEmitSpace(data.spaceId)) {
                      if (data.eventType === pushStreamTypes_1.SpaceEventType.Join || data.eventType === pushStreamTypes_1.SpaceEventType.Leave || data.eventType === pushStreamTypes_1.MessageEventType.Request || data.eventType === pushStreamTypes_1.SpaceEventType.Remove || data.eventType === pushStreamTypes_1.SpaceEventType.Start || data.eventType === pushStreamTypes_1.SpaceEventType.Stop) {
                        if (shouldEmit(pushStreamTypes_1.STREAM.SPACE)) {
                          this.emit(pushStreamTypes_1.STREAM.SPACE, modifiedData);
                        }
                      } else {
                        if (shouldEmit(pushStreamTypes_1.STREAM.SPACE_OPS)) {
                          this.emit(pushStreamTypes_1.STREAM.SPACE_OPS, modifiedData);
                        }
                      }
                    }
                  } catch (error) {
                    console.error("Error handling SPACES event:", error, "Data:", data);
                  }
                });
                this.pushChatSocket.on("SPACES_MESSAGES", (data) => {
                  try {
                    const modifiedData = DataModifier_1.DataModifier.handleSpaceEvent(data, this.raw);
                    modifiedData.event = DataModifier_1.DataModifier.convertToProposedNameForSpace(modifiedData.event);
                    DataModifier_1.DataModifier.handleToField(modifiedData);
                    if (this.shouldEmitSpace(data.spaceId)) {
                      if (shouldEmit(pushStreamTypes_1.STREAM.SPACE)) {
                        this.emit(pushStreamTypes_1.STREAM.SPACE, modifiedData);
                      }
                    }
                  } catch (error) {
                    console.error("Error handling SPACES event:", error, "Data:", data);
                  }
                });
              }
              if (this.pushNotificationSocket) {
                this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.CONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  console.log(`RestAPI::PushStream::NotifSocket::Connect - Notification Socket Connected (ID: ${this.pushNotificationSocket.id})`);
                  isNotifSocketConnected = true;
                  this.notifSocketCount++;
                  this.notifSocketConnected = true;
                  checkAndEmitConnectEvent();
                }));
                this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.DISCONNECT, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  console.log("RestAPI::PushStream::NotifSocket::Disconnect - Notification socket disconnected.");
                  yield handleSocketDisconnection("notif");
                }));
                this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.USER_FEEDS, (data) => {
                  var _a2;
                  try {
                    if (((_a2 = data.payload.data.additionalMeta) === null || _a2 === void 0 ? void 0 : _a2.type) === `${payloads_1.ADDITIONAL_META_TYPE.PUSH_VIDEO}+1` && shouldEmit(pushStreamTypes_1.STREAM.VIDEO) && this.shouldEmitVideo(data.sender)) {
                      const modifiedData = DataModifier_1.DataModifier.mapToVideoEvent(data, this.account === data.sender ? pushStreamTypes_1.MessageOrigin.Self : pushStreamTypes_1.MessageOrigin.Other, this.raw);
                      this.emit(pushStreamTypes_1.STREAM.VIDEO, modifiedData);
                    } else {
                      const modifiedData = DataModifier_1.DataModifier.mapToNotificationEvent(data, pushStreamTypes_1.NotificationEventType.INBOX, this.account === data.sender ? "self" : "other", this.raw);
                      if (this.shouldEmitChannel(modifiedData.from)) {
                        if (shouldEmit(pushStreamTypes_1.STREAM.NOTIF)) {
                          this.emit(pushStreamTypes_1.STREAM.NOTIF, modifiedData);
                        }
                      }
                    }
                  } catch (error) {
                    console.error(`RestAPI::PushStream::NotifSocket::UserFeeds::Error - Error handling event: ${error}, Data: ${JSON.stringify(data)}`);
                  }
                });
                this.pushNotificationSocket.on(pushStreamTypes_1.EVENTS.USER_SPAM_FEEDS, (data) => {
                  try {
                    const modifiedData = DataModifier_1.DataModifier.mapToNotificationEvent(data, pushStreamTypes_1.NotificationEventType.SPAM, this.account === data.sender ? "self" : "other", this.raw);
                    modifiedData.origin = this.account === modifiedData.from ? "self" : "other";
                    if (this.shouldEmitChannel(modifiedData.from)) {
                      if (shouldEmit(pushStreamTypes_1.STREAM.NOTIF)) {
                        this.emit(pushStreamTypes_1.STREAM.NOTIF, modifiedData);
                      }
                    }
                  } catch (error) {
                    console.error("Error handling USER_SPAM_FEEDS event:", error, "Data:", data);
                  }
                });
              }
              this.disconnected = false;
            }))();
          });
        });
      }
      connected() {
        console.log(`RestAPI::PushStream::connected::Notification Socket Connected: ${this.notifSocketConnected}`);
        console.log(`RestAPI::PushStream::connected::Chat Socket Connected: ${this.chatSocketConnected}`);
        return this.notifSocketConnected || this.chatSocketConnected;
      }
      disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.pushChatSocket && this.chatSocketConnected) {
            this.pushChatSocket.disconnect();
            console.log("RestAPI::PushStream::disconnect::Push chat socket disconnected.");
          }
          if (this.pushNotificationSocket && this.notifSocketConnected) {
            this.pushNotificationSocket.disconnect();
            console.log("RestAPI::PushStream::disconnect::Push notification socket disconnected.");
          }
        });
      }
      info() {
        return {
          options: this.options,
          listen: this.listen
        };
      }
      shouldEmitChat(dataChatId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.chats) || this.options.filter.chats.length === 0 || this.options.filter.chats.includes("*")) {
          return true;
        }
        return this.options.filter.chats.includes(dataChatId);
      }
      shouldEmitSpace(dataSpaceId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.spaces) || this.options.filter.spaces.length === 0 || this.options.filter.spaces.includes("*")) {
          return true;
        }
        return this.options.filter.spaces.includes(dataSpaceId);
      }
      shouldEmitChannel(dataChannelId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.channels) || this.options.filter.channels.length === 0 || this.options.filter.channels.includes("*")) {
          return true;
        }
        return this.options.filter.channels.includes(dataChannelId);
      }
      shouldEmitVideo(dataVideoId) {
        var _a;
        if (!((_a = this.options.filter) === null || _a === void 0 ? void 0 : _a.video) || this.options.filter.video.length === 0 || this.options.filter.video.includes("*")) {
          return true;
        }
        return this.options.filter.video.includes(dataVideoId);
      }
    };
    exports.PushStream = PushStream;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/pushNotificationBase.js
var require_pushNotificationBase = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/pushNotificationBase.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PushNotificationBaseClass = exports.FEED_MAP = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var config = require_config();
    var helpers_1 = require_helpers();
    var constants_2 = require_constants2();
    var ethers_1 = (init_lib(), __toCommonJS(lib_exports));
    var viem_1 = require_cjs();
    var PUSH_CHANNEL = require_channels();
    var helpers_2 = require_helpers2();
    var axiosUtil_1 = require_axiosUtil();
    var PushAPI_1 = require_PushAPI();
    var viem = require_cjs();
    var ERROR_ACCOUNT_NEEDED = "Account is required";
    var BROADCAST_TYPE = "*";
    var LENGTH_UPPER_LIMIT = 125;
    var LENGTH_LOWER_LIMTI = 1;
    var SETTING_DELIMITER = "-";
    var SETTING_SEPARATOR = "+";
    var RANGE_TYPE = 3;
    var SLIDER_TYPE = 2;
    var BOOLEAN_TYPE = 1;
    var DEFAULT_ENABLE_VALUE = "1";
    var DEFAULT_TICKER_VALUE = "1";
    exports.FEED_MAP = {
      INBOX: false,
      SPAM: true
    };
    var PushNotificationBaseClass = class {
      constructor(signer, env, account) {
        this.signer = signer;
        this.env = env;
        this.guestMode = !!(account && signer);
        this.account = account;
        this.initializeCoreContract({ signer: this.signer, env: this.env });
      }
      initializeCoreContract(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { env = constants_1.ENV.STAGING, signer = null } = options || {};
          let derivedAccount;
          let coreContract;
          if (signer) {
            derivedAccount = yield (0, helpers_1.getAccountAddress)({
              account: null,
              signer
            });
            const pushSigner = new helpers_2.Signer(signer);
            if (pushSigner.isViemSigner(signer)) {
              const client = (0, viem_1.createPublicClient)({
                chain: config.TOKEN_VIEM_NETWORK_MAP[env],
                transport: (0, viem_1.http)()
              });
              coreContract = (0, viem_1.getContract)({
                abi: config.ABIS.CORE,
                address: config.CORE_CONFIG[env].EPNS_CORE_CONTRACT,
                publicClient: client,
                walletClient: signer
              });
            } else {
              coreContract = new ethers_1.ethers.Contract(config.CORE_CONFIG[env].EPNS_CORE_CONTRACT, config.ABIS.CORE, signer);
            }
          }
          this.coreContract = coreContract;
        });
      }
      // check if addresses is supplied either by user or derived from signer object or if its guest mode
      checkUserAddressExists(user) {
        if (!user && !this.account && !this.guestMode)
          throw new Error(ERROR_ACCOUNT_NEEDED);
        return true;
      }
      // checks if the signer object is supplied
      checkSignerObjectExists() {
        if (!this.signer)
          throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
        return true;
      }
      // get type of notification from recipient
      getNotificationType(recipient, channel) {
        if (recipient.length == 1) {
          if (recipient[0] == BROADCAST_TYPE) {
            return { recipient: channel, type: constants_2.NOTIFICATION_TYPE["BROADCAST"] };
          } else {
            return {
              recipient: recipient[0],
              type: constants_2.NOTIFICATION_TYPE["TARGETTED"]
            };
          }
        }
        return { recipient, type: constants_2.NOTIFICATION_TYPE["SUBSET"] };
      }
      // get identity type for lowlevel call
      generateNotificationLowLevelPayload({ signer, env, recipients, options, channel, channelInfo }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        if (!channel) {
          channel = `${this.account}`;
        }
        const notificationType = this.getNotificationType(recipients, channel);
        const identityType = constants_2.IDENTITY_TYPE.DIRECT_PAYLOAD;
        let index = "";
        const settings = channelInfo && channelInfo.channel_settings ? JSON.parse(channelInfo.channel_settings) : null;
        const channelFound = channelInfo ? true : false;
        if (((_a = options.payload) === null || _a === void 0 ? void 0 : _a.category) && settings) {
          if (settings[options.payload.category - 1].type == SLIDER_TYPE) {
            index = options.payload.category + SETTING_DELIMITER + SLIDER_TYPE + SETTING_DELIMITER + settings[options.payload.category - 1].default;
          }
          if (settings[options.payload.category - 1].type == BOOLEAN_TYPE) {
            index = options.payload.category + SETTING_DELIMITER + BOOLEAN_TYPE;
          }
          if (settings[options.payload.category - 1].type == RANGE_TYPE) {
            index = options.payload.category + SETTING_DELIMITER + RANGE_TYPE + SETTING_DELIMITER + settings[options.payload.category - 1].default.lower;
          }
        }
        const notificationPayload = {
          signer,
          channel,
          type: notificationType.type,
          identityType,
          notification: options.notification,
          payload: {
            title: (_c = (_b = options.payload) === null || _b === void 0 ? void 0 : _b.title) !== null && _c !== void 0 ? _c : options.notification.title,
            body: (_e = (_d = options.payload) === null || _d === void 0 ? void 0 : _d.body) !== null && _e !== void 0 ? _e : options.notification.body,
            cta: (_g = (_f = options.payload) === null || _f === void 0 ? void 0 : _f.cta) !== null && _g !== void 0 ? _g : "",
            img: (_j = (_h = options.payload) === null || _h === void 0 ? void 0 : _h.embed) !== null && _j !== void 0 ? _j : "",
            hidden: (_k = options.config) === null || _k === void 0 ? void 0 : _k.hidden,
            etime: (_l = options.config) === null || _l === void 0 ? void 0 : _l.expiry,
            silent: (_m = options.config) === null || _m === void 0 ? void 0 : _m.silent,
            additionalMeta: (_o = options.payload) === null || _o === void 0 ? void 0 : _o.meta,
            index: ((_p = options.payload) === null || _p === void 0 ? void 0 : _p.category) ? index : ""
          },
          recipients: notificationType.recipient,
          graph: (_q = options.advanced) === null || _q === void 0 ? void 0 : _q.graph,
          ipfsHash: (_r = options.advanced) === null || _r === void 0 ? void 0 : _r.ipfs,
          env,
          chatId: (_s = options.advanced) === null || _s === void 0 ? void 0 : _s.chatid,
          pgpPrivateKey: (_t = options.advanced) === null || _t === void 0 ? void 0 : _t.pgpPrivateKey,
          channelFound
        };
        return notificationPayload;
      }
      // check if the fields are empty
      isEmpty(field) {
        if (field.trim().length == 0) {
          return true;
        }
        return false;
      }
      // check if the length is valid
      isValidLength(data, upperLen = LENGTH_UPPER_LIMIT, lowerLen = LENGTH_LOWER_LIMTI) {
        return data.length >= lowerLen && data.length <= upperLen;
      }
      // check if url is valid
      isValidUrl(urlString) {
        const urlPattern = new RegExp("^((?:https|http):\\/\\/)((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
        return !!urlPattern.test(urlString);
      }
      // check all the fields of channel
      verifyEmptyChannelParameters(options) {
        if (this.isEmpty(options.name)) {
          throw new Error("Channel name cannot be empty");
        } else if (this.isEmpty(options.description)) {
          throw new Error("Channel description cannot be empty");
        } else if (this.isEmpty(options.icon)) {
          throw new Error("Channel icon cannot be empty");
        } else if (this.isEmpty(options.url)) {
          throw new Error("Channel url cannot ne empty");
        } else {
          return true;
        }
      }
      // check for valid length and url
      validateParameterLength(options) {
        if (!this.isValidLength(options.name)) {
          throw new Error(`Channel name should not exceed ${LENGTH_UPPER_LIMIT} characters`);
        } else if (!this.isValidLength(options.description)) {
          throw new Error(`Channel description should not exceed ${LENGTH_UPPER_LIMIT} characters`);
        } else if (!this.isValidLength(options.url) || !this.isValidUrl(options.url)) {
          throw new Error(`Channel url either excees ${LENGTH_UPPER_LIMIT} characters or is not a valid url`);
        } else {
          return true;
        }
      }
      validateChannelParameters(options) {
        return this.verifyEmptyChannelParameters(options) && this.validateParameterLength(options);
      }
      // create contract instance
      createContractInstance(contractAddress, contractABI, network) {
        if (!this.signer) {
          throw new Error("Signer is not provided");
        }
        let contract;
        const pushSigner = this.signer ? new helpers_2.Signer(this.signer) : null;
        if (pushSigner === null || pushSigner === void 0 ? void 0 : pushSigner.isViemSigner(this.signer)) {
          const client = (0, viem_1.createPublicClient)({
            chain: network,
            transport: (0, viem_1.http)()
          });
          contract = (0, viem_1.getContract)({
            abi: contractABI,
            address: contractAddress,
            publicClient: client,
            walletClient: this.signer
          });
        } else {
          contract = new ethers_1.ethers.Contract(contractAddress, contractABI, this.signer);
        }
        return contract;
      }
      fetchBalance(contract, userAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error("Signer is not provided");
          }
          let balance;
          const pushSigner = new helpers_2.Signer(this.signer);
          try {
            if (pushSigner.isViemSigner(this.signer)) {
              balance = BigInt(yield contract.read.balanceOf({
                args: [userAddress]
              }));
            } else {
              balance = BigInt(yield contract.balanceOf(userAddress));
            }
            return balance;
          } catch (err) {
            throw new Error(JSON.stringify(err));
          }
        });
      }
      fetchAllownace(contract, userAddress, spenderAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error("Signer is not provided");
          }
          const pushSigner = new helpers_2.Signer(this.signer);
          let allowance;
          try {
            if (!pushSigner.isViemSigner(this.signer)) {
              allowance = BigInt(yield contract["allowance"](userAddress, spenderAddress));
            } else {
              allowance = BigInt(yield contract.read.allowance({
                args: [userAddress, spenderAddress]
              }));
            }
            return allowance;
          } catch (error) {
            throw new Error(JSON.stringify(error));
          }
        });
      }
      fetchUpdateCounter(contract, userAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error("Signer is not provided");
          }
          let count;
          const pushSigner = new helpers_2.Signer(this.signer);
          try {
            if (!pushSigner.isViemSigner(this.signer)) {
              count = BigInt(yield contract["channelUpdateCounter"](userAddress));
            } else {
              count = BigInt(yield contract.read.channelUpdateCounter({
                args: [userAddress]
              }));
            }
            return count + BigInt(1);
          } catch (error) {
            throw new Error(JSON.stringify(error));
          }
        });
      }
      approveToken(contract, spenderAddress, amount) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer || !this.signer.provider) {
                throw new Error("ethers provider/signer is not provided");
              }
              const approvalTrxPromise = contract["approve"](spenderAddress, amount);
              const approvalTrx = yield approvalTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(approvalTrx.hash);
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const approvalTrxPromise = contract.write.approve({
                args: [spenderAddress, amount]
              });
              const approvalTrxRes = yield approvalTrxPromise;
            }
            return true;
          } catch (error) {
            console.error(error);
            return false;
          }
        });
      }
      createChannel(contract, channelType, identityBytes, fees) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let createChannelRes;
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            if (!pushSigner.isViemSigner(this.signer)) {
              const createChannelPromise = contract["createChannelWithPUSH"](channelType, identityBytes, fees, this.getTimeBound(), {
                gasLimit: 1e6
              });
              const createChannelTrx = yield createChannelPromise;
              const createChannelTrxStatus = yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(createChannelTrx.hash);
              if ((createChannelTrxStatus === null || createChannelTrxStatus === void 0 ? void 0 : createChannelTrxStatus.status) == 0) {
                throw new Error("Something Went wrong while creating your channel");
              }
              createChannelRes = createChannelTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const createChannelPromise = contract.write.createChannelWithPUSH({
                args: [
                  channelType,
                  (0, viem_1.toHex)(new Uint8Array(identityBytes)),
                  fees,
                  this.getTimeBound()
                ]
              });
              createChannelRes = yield createChannelPromise;
            }
            return createChannelRes;
          } catch (error) {
            throw new Error(error === null || error === void 0 ? void 0 : error.message);
          }
        });
      }
      updateChannel(contract, account, identityBytes, fees) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          let updateChannelRes;
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            if (!pushSigner.isViemSigner(this.signer)) {
              const updateChannelPromise = contract["updateChannelMeta"](account, identityBytes, fees, {
                gasLimit: 1e6
              });
              const updateChannelTrx = yield updateChannelPromise;
              const updateChannelTrxStatus = yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(updateChannelTrx.hash);
              if ((updateChannelTrxStatus === null || updateChannelTrxStatus === void 0 ? void 0 : updateChannelTrxStatus.status) == 0) {
                throw new Error("Something Went wrong while updating your channel");
              }
              updateChannelRes = updateChannelTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const updateChannelPromise = contract.write.updateChannelMeta({
                args: [account, (0, viem_1.toHex)(new Uint8Array(identityBytes)), fees]
              });
              updateChannelRes = yield updateChannelPromise;
            }
            return updateChannelRes;
          } catch (error) {
            throw new Error(error === null || error === void 0 ? void 0 : error.message);
          }
        });
      }
      verifyChannel(contract, channelToBeVerified) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let verifyTrxRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const verifyTrxPromise = contract["verify"](channelToBeVerified);
              const verifyTrx = yield verifyTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(verifyTrx.hash);
              verifyTrxRes = verifyTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const verifyTrxPromise = contract.write.verify({
                args: [channelToBeVerified]
              });
              verifyTrxRes = yield verifyTrxPromise;
            }
            return verifyTrxRes;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      createChanelSettings(contract, numberOfSettings, settings, description, fees) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let createSettingsRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const createSettingsPromise = contract["createChannelSettings"](numberOfSettings, settings, description, fees);
              const createSettings = yield createSettingsPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(createSettings.hash);
              createSettingsRes = createSettings.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const createSettingsTrxPromise = contract.write.createChannelSettings({
                args: [numberOfSettings, settings, description, fees]
              });
              createSettingsRes = yield createSettingsTrxPromise;
            }
            return createSettingsRes;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      addDelegator(contract, delegatee) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let addDelegateRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const addDelegateTrxPromise = contract["addDelegate"](delegatee);
              const addDelegateTrx = yield addDelegateTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(addDelegateTrx.hash);
              addDelegateRes = addDelegateTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const addDelegateTrxPromise = contract.write.addDelegate({
                args: [delegatee]
              });
              addDelegateRes = yield addDelegateTrxPromise;
            }
            return addDelegateRes;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      removeDelegator(contract, delegatee) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let removeDelegateRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const removeDelegateTrxPromise = contract["removeDelegate"](delegatee);
              const removeDelegateTrx = yield removeDelegateTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(removeDelegateTrx.hash);
              removeDelegateRes = removeDelegateTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const removeDelegateTrxPromise = contract.write.removeDelegate({
                args: [delegatee]
              });
              removeDelegateRes = yield removeDelegateTrxPromise;
            }
            return removeDelegateRes;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      getChainId(signer) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error("Signer is not provided");
          }
          const pushSigner = new helpers_2.Signer(this.signer);
          return pushSigner.getChainId();
        });
      }
      uploadToIPFSViaPushNode(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const response = yield (0, axiosUtil_1.axiosPost)(`${config.CORE_CONFIG[this.env].API_BASE_URL}/v1/ipfs/upload`, { data });
            return response.data.cid;
          } catch (error) {
            throw new Error("Something went wrong while uploading data to IPFS");
          }
        });
      }
      getTimeBound(timeStamp) {
        return 0;
      }
      getMinimalSetting(configuration) {
        var _a, _b;
        let notificationSetting = "";
        let notificationSettingDescription = "";
        for (let i = 0; i < configuration.length; i++) {
          const ele = configuration[i];
          if (ele.type == BOOLEAN_TYPE) {
            notificationSetting = notificationSetting + SETTING_SEPARATOR + BOOLEAN_TYPE + SETTING_DELIMITER + ele.default;
          }
          if (ele.type == SLIDER_TYPE) {
            if (ele.data) {
              const enabled = ele.data && ele.data.enabled != void 0 ? Number(ele.data.enabled).toString() : DEFAULT_ENABLE_VALUE;
              const ticker = (_a = ele.data.ticker) !== null && _a !== void 0 ? _a : DEFAULT_TICKER_VALUE;
              notificationSetting = notificationSetting + SETTING_SEPARATOR + SLIDER_TYPE + SETTING_DELIMITER + enabled + SETTING_DELIMITER + ele.default + SETTING_DELIMITER + ele.data.lower + SETTING_DELIMITER + ele.data.upper + SETTING_DELIMITER + ticker;
            }
          }
          if (ele.type == RANGE_TYPE) {
            if (ele.default && typeof ele.default == "object" && ele.data) {
              const enabled = ele.data && ele.data.enabled != void 0 ? Number(ele.data.enabled).toString() : DEFAULT_ENABLE_VALUE;
              const ticker = (_b = ele.data.ticker) !== null && _b !== void 0 ? _b : DEFAULT_TICKER_VALUE;
              notificationSetting = notificationSetting + SETTING_SEPARATOR + RANGE_TYPE + SETTING_DELIMITER + enabled + SETTING_DELIMITER + ele.default.lower + SETTING_DELIMITER + ele.default.upper + SETTING_DELIMITER + ele.data.lower + SETTING_DELIMITER + ele.data.upper + SETTING_DELIMITER + ticker;
            }
          }
          notificationSettingDescription = notificationSettingDescription + SETTING_SEPARATOR + ele.description;
        }
        return {
          setting: notificationSetting.replace(/^\+/, ""),
          description: notificationSettingDescription.replace(/^\+/, "")
        };
      }
      getMinimalUserSetting(setting) {
        var _a, _b;
        if (!setting) {
          return null;
        }
        let userSetting = "";
        let numberOfSettings = 0;
        for (let i = 0; i < setting.length; i++) {
          const ele = setting[i];
          const enabled = ele.enabled ? 1 : 0;
          if (ele.enabled)
            numberOfSettings++;
          if (Object.keys(ele).includes("value")) {
            if (typeof ele.value == "number")
              userSetting = userSetting + SLIDER_TYPE + SETTING_DELIMITER + enabled + SETTING_DELIMITER + ele.value;
            else {
              userSetting = userSetting + RANGE_TYPE + SETTING_DELIMITER + enabled + SETTING_DELIMITER + ((_a = ele.value) === null || _a === void 0 ? void 0 : _a.lower) + SETTING_DELIMITER + ((_b = ele.value) === null || _b === void 0 ? void 0 : _b.upper);
            }
          } else {
            userSetting = userSetting + BOOLEAN_TYPE + SETTING_DELIMITER + enabled;
          }
          if (i != setting.length - 1)
            userSetting = userSetting + SETTING_SEPARATOR;
        }
        return numberOfSettings + SETTING_SEPARATOR + userSetting;
      }
      /**
       * @param address Address of the channel or alias
       * @returns Channel info for the address
       */
      getChannelOrAliasInfo(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const channelOrAliasCaip = (0, helpers_2.validateCAIP)(address) ? address : (0, helpers_2.getFallbackETHCAIPAddress)(this.env, this.account);
            const { networkId } = (0, helpers_2.getCAIPDetails)(channelOrAliasCaip);
            let channelInCaip = channelOrAliasCaip;
            if (networkId !== "1" && networkId !== "11155111") {
              const aliasInfo = yield this.getAliasInfo(address);
              channelInCaip = (aliasInfo === null || aliasInfo === void 0 ? void 0 : aliasInfo.channel) || channelInCaip;
            }
            const channelInfo = yield PUSH_CHANNEL.getChannel({
              channel: channelInCaip,
              env: this.env
            });
            return channelInfo || null;
          } catch (error) {
            return null;
          }
        });
      }
      initiateAddAlias(contract, alias) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let addAliasRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const addAliasTrxPromise = contract["verifyChannelAlias"](alias);
              const addAliasTrx = yield addAliasTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(addAliasTrx.hash);
              addAliasRes = addAliasTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const addAliasTrxPromise = contract.write.verifyChannelAlias({
                args: [alias]
              });
              addAliasRes = yield addAliasTrxPromise;
            }
            return addAliasRes;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      verifyAlias(contract, channelAddress) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            if (!this.signer) {
              throw new Error("Signer is not provided");
            }
            const pushSigner = new helpers_2.Signer(this.signer);
            let verifyAliasRes;
            if (!pushSigner.isViemSigner(this.signer)) {
              if (!this.signer.provider) {
                throw new Error("ethers provider is not provided");
              }
              const addAliasTrxPromise = contract["verifyChannelAlias"](channelAddress);
              const addAliasTrx = yield addAliasTrxPromise;
              yield (_b = (_a = this.signer) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.waitForTransaction(addAliasTrx.hash);
              verifyAliasRes = addAliasTrx.hash;
            } else {
              if (!contract.write) {
                throw new Error("viem signer is not provided");
              }
              const addAliasTrxPromise = contract.write.verifyChannelAlias({
                args: [channelAddress]
              });
              verifyAliasRes = yield addAliasTrxPromise;
            }
            const networkDetails = yield pushSigner.getChainId();
            const aliasAddress = yield pushSigner.getAddress();
            const aliasIncaip = `eip155:${networkDetails}:${aliasAddress}`;
            const channelInfo = yield this.getChannelOrAliasInfo(aliasIncaip);
            return { verifyAliasRes, channelInfo };
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      /**
       * @param aliasInCaip Alias address in CAIP format
       * @returns Channel info for the alias
       */
      getAliasInfo(aliasInCaip) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const API_BASE_URL = (0, helpers_2.getAPIBaseUrls)(this.env);
          const apiEndpoint = `${API_BASE_URL}/v1/alias`;
          const requestUrl = `${apiEndpoint}/${aliasInCaip}/channel`;
          try {
            const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
            return response.data;
          } catch (error) {
            return null;
          }
        });
      }
      getAddressFromCaip(caipAddress) {
        return caipAddress === null || caipAddress === void 0 ? void 0 : caipAddress.split(":")[(caipAddress === null || caipAddress === void 0 ? void 0 : caipAddress.split(":").length) - 1];
      }
      isValidPCaip(address) {
        const addressComponents = address.split(":");
        return addressComponents.length == 2 && addressComponents[0] == "eip155" && viem.isAddress(addressComponents[1]);
      }
    };
    exports.PushNotificationBaseClass = PushNotificationBaseClass;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/alias.js
var require_alias2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/alias.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Alias = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var config = config_1;
    var PUSH_ALIAS = require_alias();
    var pushNotificationBase_1 = require_pushNotificationBase();
    var Alias = class extends pushNotificationBase_1.PushNotificationBaseClass {
      constructor(signer, env, account) {
        super(signer, env, account);
        this.info = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            return yield PUSH_ALIAS.getAliasInfo(Object.assign(Object.assign({}, options), { env: this.env }));
          } catch (error) {
            throw new Error(`Push SDK Error: API : alias::info : ${error}`);
          }
        });
        this.initiate = (alias, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            const networkDetails = yield this.getChainId(this.signer);
            const caip = `eip155:${networkDetails}`;
            if (!config_1.default[this.env][caip] || !config.VIEM_CONFIG[this.env][caip]) {
              throw new Error("Unsupported Chainid");
            }
            const commAddress = config_1.default[this.env][caip].EPNS_COMMUNICATOR_CONTRACT;
            const commContract = this.createContractInstance(commAddress, config.ABIS.COMM, config.VIEM_CONFIG[this.env][caip].NETWORK);
            const addAliasRes = yield this.initiateAddAlias(commContract, alias);
            let resp = { tx: addAliasRes };
            if (options === null || options === void 0 ? void 0 : options.raw) {
              resp = Object.assign(Object.assign({}, resp), { "raw": {
                "initiateVerificationProof": addAliasRes
              } });
            }
            return resp;
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : alias::add : ${error}`);
          }
        });
        this.verify = (channelAddress, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            const networkDetails = yield this.getChainId(this.signer);
            const caip = `eip155:${networkDetails}`;
            if (!config_1.default[this.env][caip] || !config.VIEM_CONFIG[this.env][caip]) {
              throw new Error("Unsupported Chainid");
            }
            const commAddress = config_1.default[this.env][caip].EPNS_COMMUNICATOR_CONTRACT;
            const commContract = this.createContractInstance(commAddress, config.ABIS.COMM, config.VIEM_CONFIG[this.env][caip].NETWORK);
            const { verifyAliasRes, channelInfo } = yield this.verifyAlias(commContract, channelAddress);
            let resp = { tx: verifyAliasRes };
            if (options === null || options === void 0 ? void 0 : options.raw) {
              resp = Object.assign(Object.assign({}, resp), { "raw": {
                "initiateVerificationProof": channelInfo.initiate_verification_proof,
                "verifyVerificationProof": verifyAliasRes
              } });
            }
            return resp;
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : alias::verify : ${error}`);
          }
        });
      }
    };
    exports.Alias = Alias;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/delegate.js
var require_delegate = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/delegate.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Delegate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var config_1 = require_config();
    var config = config_1;
    var PUSH_CHANNEL = require_channels();
    var helpers_1 = require_helpers2();
    var pushNotificationBase_1 = require_pushNotificationBase();
    var Delegate = class extends pushNotificationBase_1.PushNotificationBaseClass {
      constructor(signer, env, account) {
        super(signer, env, account);
        this.get = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            let channel = (options === null || options === void 0 ? void 0 : options.channel) ? options.channel : this.account ? (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account) : null;
            this.checkUserAddressExists(channel);
            channel = (0, helpers_1.validateCAIP)(channel) ? channel : (0, helpers_1.getFallbackETHCAIPAddress)(this.env, channel);
            this.checkUserAddressExists(channel);
            return yield PUSH_CHANNEL.getDelegates({
              channel,
              env: this.env
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : delegate::get : ${error}`);
          }
        });
        this.add = (delegate) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            if ((0, helpers_1.validateCAIP)(delegate)) {
              delegate = this.getAddressFromCaip(delegate);
            }
            const networkDetails = yield this.getChainId(this.signer);
            const caip = `eip155:${networkDetails}`;
            if (!config_1.default[this.env][caip] || !config.VIEM_CONFIG[this.env][caip]) {
              throw new Error("Unsupported Chainid");
            }
            const commAddress = config_1.default[this.env][caip].EPNS_COMMUNICATOR_CONTRACT;
            const commContract = this.createContractInstance(commAddress, config.ABIS.COMM, config.VIEM_CONFIG[this.env][caip].NETWORK);
            const addDelegateRes = yield this.addDelegator(commContract, delegate);
            return { transactionHash: addDelegateRes };
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : delegate::add : ${error}`);
          }
        });
        this.remove = (delegate) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            if ((0, helpers_1.validateCAIP)(delegate)) {
              delegate = this.getAddressFromCaip(delegate);
            }
            const networkDetails = yield this.getChainId(this.signer);
            const caip = `eip155:${networkDetails}`;
            if (!config_1.default[this.env][caip] || !config.VIEM_CONFIG[this.env][caip]) {
              throw new Error("Unsupported Chainid");
            }
            const commAddress = config_1.default[this.env][caip].EPNS_COMMUNICATOR_CONTRACT;
            const commContract = this.createContractInstance(commAddress, config.ABIS.COMM, config.VIEM_CONFIG[this.env][caip].NETWORK);
            const removeDelegateRes = yield this.removeDelegator(commContract, delegate);
            return { transactionHash: removeDelegateRes };
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : delegate::remove : ${error}`);
          }
        });
      }
    };
    exports.Delegate = Delegate;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/channel.js
var require_channel = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/channel.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Channel = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var viem = require_cjs();
    var PUSH_CHANNEL = require_channels();
    var config = require_config();
    var helpers_1 = require_helpers2();
    var PUSH_PAYLOAD = require_payloads();
    var progressHook_1 = require_progressHook();
    var PushNotificationTypes_1 = require_PushNotificationTypes();
    var alias_1 = require_alias2();
    var delegate_1 = require_delegate();
    var pushNotificationBase_1 = require_pushNotificationBase();
    var Channel = class extends pushNotificationBase_1.PushNotificationBaseClass {
      constructor(signer, env, account) {
        super(signer, env, account);
        this.info = (channel, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { raw = true } = options || {};
            this.checkUserAddressExists(channel);
            channel = channel !== null && channel !== void 0 ? channel : (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account);
            return yield PUSH_CHANNEL.getChannel({
              channel,
              env: this.env,
              raw
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : channel::info : ${error}`);
          }
        });
        this.search = (query, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT } = options || {};
            return yield PUSH_CHANNEL.search({
              query,
              page,
              limit,
              env: this.env
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : channel::search : ${error}`);
          }
        });
        this.subscribers = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          try {
            let channel = (options === null || options === void 0 ? void 0 : options.channel) ? options.channel : this.account ? (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account) : null;
            this.checkUserAddressExists(channel);
            channel = (0, helpers_1.validateCAIP)(channel) ? channel : (0, helpers_1.getFallbackETHCAIPAddress)(this.env, channel);
            if (options && options.page) {
              return yield PUSH_CHANNEL.getSubscribers({
                channel,
                env: this.env,
                page: options.page,
                limit: (_a = options.limit) !== null && _a !== void 0 ? _a : 10,
                setting: (_b = options.setting) !== null && _b !== void 0 ? _b : false,
                category: options.category,
                raw: options.raw
              });
            } else {
              return yield PUSH_CHANNEL._getSubscribers({
                channel,
                env: this.env
              });
            }
          } catch (error) {
            throw new Error(`Push SDK Error: API : channel::subscribers : ${error}`);
          }
        });
        this.send = (recipients, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          var _c, _d;
          try {
            this.checkSignerObjectExists();
            const channelInfo = yield this.getChannelOrAliasInfo((_c = options.channel) !== null && _c !== void 0 ? _c : this.account);
            const lowLevelPayload = this.generateNotificationLowLevelPayload({
              signer: this.signer,
              env: this.env,
              recipients,
              options,
              channel: (_d = options.channel) !== null && _d !== void 0 ? _d : this.account,
              channelInfo
            });
            return yield PUSH_PAYLOAD.sendNotification(lowLevelPayload);
          } catch (error) {
            throw new Error(`Push SDK Error: API : channel::send : ${error}`);
          }
        });
        this.create = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { name, description, url, icon, alias = null, progressHook } = options || {};
          try {
            let aliasInfo;
            this.validateChannelParameters(options);
            const pushTokenContract = yield this.createContractInstance(config.TOKEN[this.env], config.ABIS.TOKEN, config.TOKEN_VIEM_NETWORK_MAP[this.env]);
            const balance = yield this.fetchBalance(pushTokenContract, this.account);
            const fees = viem.parseUnits(config.MIN_TOKEN_BALANCE[this.env].toString(), 18);
            if (fees > balance) {
              throw new Error("Insufficient PUSH balance");
            }
            if (alias) {
              if (!(0, helpers_1.validateCAIP)(alias)) {
                throw new Error("Invalid alias CAIP");
              }
              const aliasDetails = (0, helpers_1.getCAIPDetails)(alias);
              aliasInfo = {
                [`${aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.blockchain}:${aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.networkId}`]: aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.address
              };
            }
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-01"]);
            const input = {
              name,
              info: description,
              url,
              icon,
              aliasDetails: aliasInfo !== null && aliasInfo !== void 0 ? aliasInfo : {}
            };
            const cid = yield this.uploadToIPFSViaPushNode(JSON.stringify(input));
            const allowanceAmount = yield this.fetchAllownace(pushTokenContract, this.account, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT);
            if (!(allowanceAmount >= fees)) {
              progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-02"]);
              const approvalRes = yield this.approveToken(pushTokenContract, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT, fees);
              if (!approvalRes) {
                throw new Error("Something went wrong while approving the token");
              }
            }
            const channelType = config.CHANNEL_TYPE["GENERAL"];
            const identity = "1+" + cid;
            const identityBytes = viem.stringToBytes(identity);
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-03"]);
            const createChannelRes = yield this.createChannel(this.coreContract, channelType, identityBytes, fees);
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-04"]);
            return { transactionHash: createChannelRes };
          } catch (error) {
            const errorProgressHook = progressHook_1.default["PUSH-ERROR-02"];
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook("Create Channel", error));
            throw new Error(`Push SDK Error: Contract : createChannelWithPUSH : ${error}`);
          }
        });
        this.update = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { name, description, url, icon, alias = null, progressHook } = options || {};
          try {
            let aliasInfo;
            this.validateChannelParameters(options);
            const pushTokenContract = yield this.createContractInstance(config.TOKEN[this.env], config.ABIS.TOKEN, config.TOKEN_VIEM_NETWORK_MAP[this.env]);
            const balance = yield this.fetchBalance(pushTokenContract, this.account);
            const counter = yield this.fetchUpdateCounter(this.coreContract, this.account);
            const fees = viem.parseUnits(config.MIN_TOKEN_BALANCE[this.env].toString(), 18);
            const totalFees = fees * counter;
            if (totalFees > balance) {
              throw new Error("Insufficient PUSH balance");
            }
            if (alias) {
              if (!(0, helpers_1.validateCAIP)(alias)) {
                throw new Error("Invalid alias CAIP");
              }
              const aliasDetails = (0, helpers_1.getCAIPDetails)(alias);
              aliasInfo = {
                [`${aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.blockchain}:${aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.networkId}`]: aliasDetails === null || aliasDetails === void 0 ? void 0 : aliasDetails.address
              };
            }
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPDATE-01"]);
            const input = {
              name,
              info: description,
              url,
              icon,
              aliasDetails: aliasInfo !== null && aliasInfo !== void 0 ? aliasInfo : {}
            };
            const cid = yield this.uploadToIPFSViaPushNode(JSON.stringify(input));
            const allowanceAmount = yield this.fetchAllownace(pushTokenContract, this.account, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT);
            if (!(allowanceAmount >= totalFees)) {
              progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPDATE-02"]);
              const approvalRes = yield this.approveToken(pushTokenContract, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT, totalFees);
              if (!approvalRes) {
                throw new Error("Something went wrong while approving the token");
              }
            }
            const identity = "1+" + cid;
            const identityBytes = viem.stringToBytes(identity);
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPDATE-03"]);
            const updateChannelRes = yield this.updateChannel(this.coreContract, this.account, identityBytes, totalFees);
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPDATE-04"]);
            return { transactionHash: updateChannelRes };
          } catch (error) {
            const errorProgressHook = progressHook_1.default["PUSH-ERROR-02"];
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook("Update Channel", error));
            throw new Error(`Push SDK Error: Contract channel::update : ${error}`);
          }
        });
        this.verify = (channelToBeVerified) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            if ((0, helpers_1.validateCAIP)(channelToBeVerified)) {
              channelToBeVerified = channelToBeVerified.split(":")[2];
            }
            if (!viem.isAddress(channelToBeVerified)) {
              throw new Error("Invalid channel address");
            }
            const channelDetails = yield this.info(this.account);
            if ((channelDetails === null || channelDetails === void 0 ? void 0 : channelDetails.verified_status) == 0) {
              throw new Error("Only verified channel can verify other channel");
            }
            const res = yield this.verifyChannel(this.coreContract, channelToBeVerified);
            if (!res) {
              throw new Error("Something went wrong while verifying the channel");
            }
            return { transactionHash: res };
          } catch (error) {
            throw new Error(`Push SDK Error: Contract channel::verify : ${error}`);
          }
        });
        this.setting = (configuration) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            this.checkSignerObjectExists();
            const pushTokenContract = yield this.createContractInstance(config.TOKEN[this.env], config.ABIS.TOKEN, config.TOKEN_VIEM_NETWORK_MAP[this.env]);
            const balance = yield this.fetchBalance(pushTokenContract, this.account);
            const fees = viem.parseUnits(config.MIN_TOKEN_BALANCE[this.env].toString(), 18);
            const counter = yield this.fetchUpdateCounter(this.coreContract, this.account);
            const totalFees = fees * counter;
            if (totalFees > balance) {
              throw new Error("Insufficient PUSH balance");
            }
            const allowanceAmount = yield this.fetchAllownace(pushTokenContract, this.account, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT);
            if (!(allowanceAmount >= totalFees)) {
              const approveRes = yield this.approveToken(pushTokenContract, config.CORE_CONFIG[this.env].EPNS_CORE_CONTRACT, totalFees);
              if (!approveRes) {
                throw new Error("Something went wrong while approving your token");
              }
            }
            const { setting, description } = this.getMinimalSetting(configuration);
            const createSettingsRes = yield this.createChanelSettings(this.coreContract, configuration.length, setting, description, fees);
            return { transactionHash: createSettingsRes };
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : channel::setting : ${error}`);
          }
        });
        this.notifications = (account2, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { page, limit, filter = null, raw = true } = options || {};
            return yield PUSH_CHANNEL.getChannelNotifications({
              channel: account2,
              env: this.env,
              filter,
              raw,
              page,
              limit
            });
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : channel::notifications : ${error}`);
          }
        });
        this.list = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { page, limit, sort = PushNotificationTypes_1.ChannelListSortType.SUBSCRIBER, order = PushNotificationTypes_1.ChannelListOrderType.DESCENDING } = options || {};
            return yield PUSH_CHANNEL.getChannels({
              env: this.env,
              page,
              limit,
              sort,
              order
            });
          } catch (error) {
            throw new Error(`Push SDK Error: Contract : channel::list : ${error}`);
          }
        });
        this.delegate = new delegate_1.Delegate(signer, env, account);
        this.alias = new alias_1.Alias(signer, env, account);
      }
    };
    exports.Channel = Channel;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushNotification/notification.js
var require_notification = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushNotification/notification.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Notification = exports.FEED_MAP = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var PushNotificationTypes_1 = require_PushNotificationTypes();
    var PUSH_USER = require_user();
    var PUSH_CHANNEL = require_channels();
    var helpers_1 = require_helpers2();
    var pushNotificationBase_1 = require_pushNotificationBase();
    var ERROR_CHANNEL_NEEDED = "Channel is needed";
    exports.FEED_MAP = {
      INBOX: false,
      SPAM: true
    };
    var Notification = class extends pushNotificationBase_1.PushNotificationBaseClass {
      constructor(signer, env, account) {
        super(signer, env, account);
        this.list = (spam = PushNotificationTypes_1.FeedType.INBOX, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, channels = [], raw = false } = options || {};
          try {
            let account2;
            if (options === null || options === void 0 ? void 0 : options.account) {
              if (this.isValidPCaip(options.account)) {
                account2 = (0, helpers_1.pCAIP10ToWallet)(options.account);
              } else {
                account2 = options.account;
              }
            } else if (this.account) {
              account2 = (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account);
            }
            this.checkUserAddressExists(account2);
            const nonCaipAccount = this.getAddressFromCaip(account2);
            if (channels.length == 0) {
              return yield PUSH_USER.getFeeds({
                user: nonCaipAccount,
                page,
                limit,
                spam: exports.FEED_MAP[spam],
                raw,
                env: this.env
              });
            } else {
              const promises = channels.map((channel) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return yield PUSH_USER.getFeedsPerChannel({
                  user: nonCaipAccount,
                  page,
                  limit,
                  spam: exports.FEED_MAP[spam],
                  raw,
                  env: this.env,
                  channels: [channel]
                });
              }));
              const results = yield Promise.all(promises);
              const feedRes = results.flat();
              return feedRes;
            }
          } catch (error) {
            throw new Error(`Push SDK Error: API : notifcaiton::list : ${error}`);
          }
        });
        this.subscriptions = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const {
              // TODO: to be used once pagination is implemeted at API level
              page = constants_1.default.PAGINATION.INITIAL_PAGE,
              limit = constants_1.default.PAGINATION.LIMIT,
              channel = null,
              raw
            } = options || {};
            let account2;
            if (options === null || options === void 0 ? void 0 : options.account) {
              if (this.isValidPCaip(options.account)) {
                account2 = (0, helpers_1.pCAIP10ToWallet)(options.account);
              } else {
                account2 = options.account;
              }
            } else if (this.account) {
              account2 = (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account);
            }
            this.checkUserAddressExists(account2);
            return yield PUSH_USER.getSubscriptions({
              user: account2,
              env: this.env,
              channel,
              raw
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : notifcaiton::subscriptions : ${error}`);
          }
        });
        this.subscribe = (channel, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { onSuccess, onError, settings } = options || {};
            this.checkSignerObjectExists();
            this.checkUserAddressExists();
            if (!channel && channel != "") {
              throw new Error(ERROR_CHANNEL_NEEDED);
            }
            if (this.isValidPCaip(channel)) {
              channel = (0, helpers_1.pCAIP10ToWallet)(channel);
            }
            if (!(0, helpers_1.validateCAIP)(channel)) {
              channel = (0, helpers_1.getFallbackETHCAIPAddress)(this.env, channel);
            }
            const caipDetail = (0, helpers_1.getCAIPDetails)(channel);
            const userAddressInCaip = (0, helpers_1.getCAIPWithChainId)(this.account, parseInt(caipDetail === null || caipDetail === void 0 ? void 0 : caipDetail.networkId));
            const minimalSetting = this.getMinimalUserSetting(settings);
            return yield PUSH_CHANNEL.subscribeV2({
              signer: this.signer,
              channelAddress: channel,
              userAddress: userAddressInCaip,
              env: this.env,
              settings: minimalSetting !== null && minimalSetting !== void 0 ? minimalSetting : "",
              onSuccess,
              onError
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : notifcaiton::subscribe : ${error}`);
          }
        });
        this.unsubscribe = (channel, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const { onSuccess, onError } = options || {};
            this.checkUserAddressExists();
            this.checkSignerObjectExists();
            if (!channel && channel != "") {
              return new Error(ERROR_CHANNEL_NEEDED);
            }
            if (this.isValidPCaip(channel)) {
              channel = (0, helpers_1.pCAIP10ToWallet)(channel);
            }
            if (!(0, helpers_1.validateCAIP)(channel)) {
              channel = (0, helpers_1.getFallbackETHCAIPAddress)(this.env, channel);
            }
            const caipDetail = (0, helpers_1.getCAIPDetails)(channel);
            const userAddressInCaip = (0, helpers_1.getCAIPWithChainId)(this.account, parseInt(caipDetail === null || caipDetail === void 0 ? void 0 : caipDetail.networkId));
            return yield PUSH_CHANNEL.unsubscribeV2({
              signer: this.signer,
              channelAddress: channel,
              userAddress: userAddressInCaip,
              env: this.env,
              onSuccess,
              onError
            });
          } catch (error) {
            throw new Error(`Push SDK Error: API : notifcaiton::unsubscribe : ${error}`);
          }
        });
      }
    };
    exports.Notification = Notification;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/space/SpaceV2.js
var require_SpaceV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/space/SpaceV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpaceV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var SpaceV2 = class {
      constructor({ spaceV1Instance, spaceInfo }) {
        this.spaceV1Instance = spaceV1Instance;
        this.spaceInfo = spaceInfo;
      }
      start() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.start();
        });
      }
      join() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.join();
        });
      }
      update(updateSpaceOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.update(updateSpaceOptions);
        });
      }
      leave() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.leave();
        });
      }
      stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.stop();
        });
      }
      requestForMic() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.requestToBePromoted({
            role: constants_1.SPACE_INVITE_ROLES.SPEAKER,
            promotorAddress: this.spaceInfo.spaceCreator
          });
        });
      }
      acceptMicRequest({ address, signal }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.acceptPromotionRequest({
            promoteeAddress: address,
            spaceId: this.spaceInfo.spaceId,
            role: constants_1.SPACE_INVITE_ROLES.SPEAKER,
            signalData: signal
          });
        });
      }
      rejectMicRequest({ address }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.rejectPromotionRequest({
            promoteeAddress: address
          });
        });
      }
      inviteToPromote({ address }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.inviteToPromote({
            inviteeAddress: address,
            role: constants_1.SPACE_INVITE_ROLES.SPEAKER
          });
        });
      }
      acceptPromotionInvite({ signal }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.acceptPromotionInvite({
            invitorAddress: this.spaceInfo.spaceCreator,
            spaceId: this.spaceInfo.spaceId,
            signalData: signal
          });
        });
      }
      rejectPromotionInvite() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.spaceV1Instance.rejectPromotionInvite({
            invitorAddress: this.spaceInfo.spaceCreator
          });
        });
      }
      config({ audio }) {
        if (typeof audio === "boolean") {
          this.spaceV1Instance.enableAudio({ state: audio });
        }
      }
    };
    exports.SpaceV2 = SpaceV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/space.js
var require_space2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/space.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Space = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pushAPITypes_1 = require_pushAPITypes();
    var PUSH_SPACE = require_space();
    var PUSH_CHAT = require_chat2();
    var PushAPI_1 = require_PushAPI();
    var updateGroupProfile_1 = require_updateGroupProfile();
    var updateGroupConfig_1 = require_updateGroupConfig();
    var chat_1 = require_chat2();
    var helpers_1 = require_helpers2();
    var chat_2 = require_chat3();
    var helpers_2 = require_helpers2();
    var SpaceV2_1 = require_SpaceV2();
    var Space_1 = require_Space();
    var Space = class {
      constructor(account, env, decryptedPgpPvtKey, signer, progressHook) {
        this.account = account;
        this.env = env;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.signer = signer;
        this.progressHook = progressHook;
        this.participants = {
          list: (chatId, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { page = 1, limit = 20 } = options !== null && options !== void 0 ? options : {};
            const getGroupMembersOptions = {
              chatId,
              page,
              limit,
              env: this.env
            };
            const chatMembers = yield PUSH_CHAT.getGroupMembers(getGroupMembersOptions);
            const members = chatMembers.map((member) => {
              return {
                address: member.address,
                intent: member.intent,
                role: member.role.toUpperCase() === "ADMIN" ? "SPEAKER" : "LISTENER",
                userInfo: member.userInfo
              };
            });
            return { members };
          }),
          count: (chatId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const count = yield PUSH_CHAT.getGroupMemberCount({
              chatId,
              env: this.env
            });
            return {
              participants: count.overallCount - count.pendingCount,
              pending: count.pendingCount
            };
          }),
          status: (chatId, accountId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const status = yield PUSH_CHAT.getGroupMemberStatus({
              chatId,
              did: accountId,
              env: this.env
            });
            return {
              pending: status.isPending,
              role: status.isAdmin ? "SPEAKER" : "LISTENER",
              participant: status.isMember
            };
          })
        };
        this.chatInstance = new chat_2.Chat(this.account, this.env, { feature: [] }, this.decryptedPgpPvtKey, this.signer);
      }
      create(name, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error("Signer is required to create a space.");
          }
          const createSpaceOptions = {
            signer: this.signer,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            spaceName: name,
            spaceDescription: options.description || null,
            listeners: options.participants.listeners,
            speakers: options.participants.speakers,
            spaceImage: options.image || null,
            isPublic: typeof options.private === "boolean" ? !options.private : true,
            rules: options.rules || {},
            config: {
              scheduleAt: options.schedule.start,
              scheduleEnd: options.schedule.end || null
            },
            env: this.env
          };
          return yield PUSH_SPACE.createV2(createSpaceOptions);
        });
      }
      update(spaceId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          let group = null;
          try {
            group = yield PUSH_CHAT.getGroupInfo({
              chatId: spaceId,
              env: this.env
            });
            if (!group) {
              throw new Error("Space not found");
            }
          } catch (error) {
            throw new Error("Space not found");
          }
          const updateGroupProfileOptions = {
            chatId: spaceId,
            groupName: options.name ? options.name : group.groupName,
            groupDescription: options.description ? options.description : group.groupDescription,
            groupImage: options.image ? options.image : group.groupImage,
            rules: options.rules ? options.rules : group.rules,
            account: this.account,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            env: this.env
          };
          const updateGroupConfigOptions = {
            chatId: spaceId,
            meta: options.meta ? options.meta : group.meta,
            scheduleAt: options.scheduleAt ? options.scheduleAt : group.scheduleAt,
            scheduleEnd: options.scheduleEnd ? options.scheduleEnd : group.scheduleEnd,
            status: options.status ? options.status : group.status,
            account: this.account,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            env: this.env
          };
          yield (0, updateGroupProfile_1.updateGroupProfile)(updateGroupProfileOptions);
          const groupDto = yield (0, updateGroupConfig_1.updateGroupConfig)(updateGroupConfigOptions);
          return (0, chat_1.groupInfoDtoToSpaceInfoDto)(groupDto);
        });
      }
      info(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const groupDto = yield PUSH_CHAT.getGroupInfo({
            chatId: spaceId,
            env: this.env
          });
          return (0, chat_1.groupInfoDtoToSpaceInfoDto)(groupDto);
        });
      }
      permissions(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const getGroupAccessOptions = {
            chatId: spaceId,
            did: this.account,
            env: this.env
          };
          return yield PUSH_CHAT.getGroupAccess(getGroupAccessOptions);
        });
      }
      add(spaceId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const { role, accounts } = options;
          const validRoles = ["SPEAKER", "LISTENER"];
          if (!validRoles.includes(role)) {
            throw new Error("Invalid role provided.");
          }
          if (!accounts || accounts.length === 0) {
            throw new Error("accounts array cannot be empty!");
          }
          accounts.forEach((account) => {
            if (!(0, helpers_1.isValidPushCAIP)(account)) {
              throw new Error(`Invalid account address: ${account}`);
            }
          });
          let response;
          if (role === "SPEAKER") {
            response = yield PUSH_CHAT.addAdmins({
              chatId: spaceId,
              admins: accounts,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          } else {
            response = yield PUSH_CHAT.addMembers({
              chatId: spaceId,
              members: accounts,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          }
          return (0, chat_1.groupInfoDtoToSpaceInfoDto)(response);
        });
      }
      remove(spaceId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { accounts } = options;
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          if (!accounts || accounts.length === 0) {
            throw new Error("Accounts array cannot be empty!");
          }
          accounts.forEach((account) => {
            if (!(0, helpers_1.isValidPushCAIP)(account)) {
              throw new Error(`Invalid account address: ${account}`);
            }
          });
          const adminsToRemove = [];
          const membersToRemove = [];
          for (const account of accounts) {
            const status = yield PUSH_CHAT.getGroupMemberStatus({
              chatId: spaceId,
              did: account,
              env: this.env
            });
            if (status.isAdmin) {
              adminsToRemove.push(account);
            } else if (status.isMember) {
              membersToRemove.push(account);
            }
          }
          if (adminsToRemove.length > 0) {
            yield PUSH_CHAT.removeAdmins({
              chatId: spaceId,
              admins: adminsToRemove,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          }
          if (membersToRemove.length > 0) {
            yield PUSH_CHAT.removeMembers({
              chatId: spaceId,
              members: membersToRemove,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          }
          return yield this.info(spaceId);
        });
      }
      modify(spaceId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { role, accounts } = options;
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const validRoles = ["SPEAKER", "LISTENER"];
          if (!validRoles.includes(role)) {
            throw new Error("Invalid role provided.");
          }
          if (!accounts || accounts.length === 0) {
            throw new Error("accounts array cannot be empty!");
          }
          accounts.forEach((account) => {
            if (!(0, helpers_1.isValidPushCAIP)(account)) {
              throw new Error(`Invalid account address: ${account}`);
            }
          });
          let newRole = null;
          if (role === "SPEAKER") {
            newRole = "ADMIN";
          } else {
            newRole = "MEMBER";
          }
          const response = yield PUSH_CHAT.modifyRoles({
            chatId: spaceId,
            newRole,
            members: accounts,
            env: this.env,
            account: this.account,
            signer: this.signer,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            overrideSecretKeyGeneration: false
          });
          return (0, chat_1.groupInfoDtoToSpaceInfoDto)(response);
        });
      }
      join(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const status = yield PUSH_CHAT.getGroupMemberStatus({
            chatId: spaceId,
            did: this.account,
            env: this.env
          });
          if (status.isPending) {
            yield PUSH_CHAT.approve({
              senderAddress: spaceId,
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          } else if (!status.isMember) {
            yield PUSH_CHAT.addMembers({
              chatId: spaceId,
              members: [this.account],
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          }
          return yield this.info(spaceId);
        });
      }
      leave(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          const status = yield PUSH_CHAT.getGroupMemberStatus({
            chatId: spaceId,
            did: this.account,
            env: this.env
          });
          let response;
          if (status.isAdmin) {
            response = yield PUSH_CHAT.removeAdmins({
              chatId: spaceId,
              admins: [this.account],
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          } else {
            response = yield PUSH_CHAT.removeMembers({
              chatId: spaceId,
              members: [this.account],
              env: this.env,
              account: this.account,
              signer: this.signer,
              pgpPrivateKey: this.decryptedPgpPvtKey,
              overrideSecretKeyGeneration: false
            });
          }
          return (0, chat_1.groupInfoDtoToSpaceInfoDto)(response);
        });
      }
      search(term, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { page = 1, limit = 20 } = options !== null && options !== void 0 ? options : {};
          const response = yield PUSH_SPACE.search({
            searchTerm: term,
            pageNumber: page,
            pageSize: limit,
            env: this.env
          });
          return response.map((space) => PUSH_CHAT.spaceDtoToSpaceInfoDto(space));
        });
      }
      trending(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { page = 1, limit = 20 } = options !== null && options !== void 0 ? options : {};
          const response = yield PUSH_SPACE.trending({
            page,
            limit,
            env: this.env
          });
          return response;
        });
      }
      list(type, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          const listParams = {
            account: accountToUse,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            page: options === null || options === void 0 ? void 0 : options.page,
            limit: options === null || options === void 0 ? void 0 : options.limit,
            env: this.env,
            toDecrypt: !!this.decryptedPgpPvtKey
            // Set to false if signer is undefined or null,
          };
          switch (type) {
            case pushAPITypes_1.SpaceListType.SPACES:
              return yield PUSH_SPACE.spaces(listParams);
            case pushAPITypes_1.SpaceListType.REQUESTS:
              return yield PUSH_SPACE.requests(listParams);
            default:
              throw new Error("Invalid Space List Type");
          }
        });
      }
      accept(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return this.chatInstance.accept(spaceId);
        });
      }
      reject(spaceId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!this.signer) {
            throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
          }
          return this.chatInstance.reject(spaceId);
        });
      }
      get chat() {
        return {
          send: (recipient, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.chatInstance.send(recipient, options);
          }),
          decrypt: (messages) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signer) {
              throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            return yield this.chatInstance.decrypt(messages);
          }),
          latest: (target) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.chatInstance.latest(target);
          }),
          history: (target, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.chatInstance.history(target, options);
          })
        };
      }
      initialize(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { onChange, spaceId } = options;
          if (!this.signer) {
            throw new Error("Signer is required for push space");
          }
          if (!this.decryptedPgpPvtKey) {
            throw new Error("PushSDK was initialized in readonly mode. Space functionality is not available.");
          }
          const chainId = yield new helpers_2.Signer(this.signer).getChainId();
          if (!chainId) {
            throw new Error("Chain Id not retrievable from signer");
          }
          const spaceV1Instance = new Space_1.Space({
            signer: this.signer,
            chainId,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            setSpaceData: onChange,
            address: this.account,
            env: this.env
          });
          yield spaceV1Instance.initialize({ spaceId });
          const spaceInfo = yield this.info(spaceId);
          return new SpaceV2_1.SpaceV2({
            spaceV1Instance,
            spaceInfo
          });
        });
      }
    };
    exports.Space = Space;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/helpers/validatePeerInfo.js
var require_validatePeerInfo = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/helpers/validatePeerInfo.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePeerInfo = void 0;
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var validatePeerInfo = (peerInfo) => {
      const { signal, address, meta } = peerInfo;
      if (!signal) {
        throw new Error("Invalid signal data received");
      }
      if (!(0, helpers_1.isValidPushCAIP)(address)) {
        throw new Error("Invalid address received");
      }
      if (meta.rules.access.type === constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT && !meta.rules.access.data.chatId) {
        throw new Error("ChatId not found in meta.rules");
      }
    };
    exports.validatePeerInfo = validatePeerInfo;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/video/VideoV2.js
var require_VideoV2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/video/VideoV2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VideoV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var immer_1 = require_cjs2();
    var chat_1 = require_chat2();
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var types_1 = require_types();
    var validatePeerInfo_1 = require_validatePeerInfo();
    var VideoV2 = class {
      /**
       * VideoV2 constructor
       * @param {object} params - The constructor parameters
       * @param {VideoV1} params.videoV1Instance - The VideoV1 instance
       * @param {string} params.account - The account
       * @param {string} params.decryptedPgpPvtKey - The decrypted PGP private key
       * @param {ENV} params.env - The environment
       */
      constructor({ videoV1Instance, account, decryptedPgpPvtKey, env, peerInfos }) {
        this.videoInstance = videoV1Instance;
        this.account = account;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.env = env;
        this.peerInfos = peerInfos;
      }
      /**
       * Request a video call
       * @param {string[]} recipients - The recipients of the video call
       * @param {object} options - The options for the video call
       * @param {object} options.rules - The rules for the video call
       * @param {object} options.rules.access - The access rules for the video call
       * @param {string} options.rules.access.type - The type of the video call
       * @param {object} options.rules.access.data - The data for the video call
       * @param {string} options.rules.access.data.chatId - The chat ID for the video call
       */
      request(recipients, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { rules } = options || {};
          for (const recipient of recipients) {
            if (!(0, helpers_1.isValidPushCAIP)(recipient)) {
              throw new Error("Invalid recipient address found");
            }
          }
          if (recipients.length === 0) {
            throw new Error("Alteast one recipient address is required for a video call");
          }
          if (recipients.length > 1 && (rules === null || rules === void 0 ? void 0 : rules.access.type) === constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT && !rules.access.data.chatId) {
            throw new Error("For multiple recipient addresses, chatId is required for a video call");
          }
          let retrievedChatId = "";
          if (!(rules === null || rules === void 0 ? void 0 : rules.access.data.chatId)) {
            let page = 1;
            const limit = 30;
            while (!retrievedChatId) {
              const response = yield (0, chat_1.chats)({
                account: this.account,
                toDecrypt: true,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                env: this.env,
                page,
                limit
              });
              if (response.length === 0)
                break;
              response.forEach((chat) => {
                if (chat.did === (0, helpers_1.walletToPCAIP10)(recipients[0]) && chat.chatId) {
                  retrievedChatId = chat.chatId;
                }
              });
              page++;
            }
            if (!retrievedChatId) {
              throw new Error(`ChatId not found between local user (${this.account}) and recipient (${recipients[0]}).`);
            }
          }
          this.videoInstance.setData((oldData) => {
            return (0, immer_1.produce)(oldData, (draft) => {
              var _a;
              draft.local.address = this.account;
              draft.incoming = recipients.map((recipient) => ({
                address: (0, helpers_1.pCAIP10ToWallet)(recipient),
                status: types_1.VideoCallStatus.INITIALIZED
              }));
              draft.meta.chatId = (_a = rules === null || rules === void 0 ? void 0 : rules.access.data.chatId) !== null && _a !== void 0 ? _a : retrievedChatId;
            });
          });
          yield this.videoInstance.request({
            senderAddress: (0, helpers_1.pCAIP10ToWallet)(this.account),
            recipientAddress: recipients.map((recipient) => (0, helpers_1.pCAIP10ToWallet)(recipient)),
            rules: rules !== null && rules !== void 0 ? rules : {
              access: {
                type: constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT,
                data: {
                  chatId: retrievedChatId
                }
              }
            }
          });
        });
      }
      /**
       * Approve a video call
       * @param {string} [address] - The address of the peer from which the video call is to be approved
       */
      approve(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!address) {
            const peerInfoAddresses = Object.keys(this.peerInfos);
            if (peerInfoAddresses.length !== 1) {
              throw new Error("Either no request exists or more than one request found. Please pass an address.");
            }
            address = peerInfoAddresses[0];
          }
          const peerInfo = this.peerInfos[(0, helpers_1.walletToPCAIP10)(address)];
          (0, validatePeerInfo_1.validatePeerInfo)(peerInfo);
          yield this.videoInstance.acceptRequest({
            senderAddress: (0, helpers_1.pCAIP10ToWallet)(this.account),
            recipientAddress: (0, helpers_1.pCAIP10ToWallet)(address),
            signalData: peerInfo.signal,
            rules: peerInfo.meta.rules
          });
        });
      }
      /**
       * Deny a video call
       * @param {string} [address] - The address of the peer from which the video call is to be denied
       */
      deny(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (!address) {
            const peerInfoAddresses = Object.keys(this.peerInfos);
            if (peerInfoAddresses.length !== 1) {
              throw new Error("Either no request exists or more than one request found. Please pass an address.");
            }
            address = peerInfoAddresses[0];
          }
          const peerInfo = this.peerInfos[(0, helpers_1.walletToPCAIP10)(address)];
          (0, validatePeerInfo_1.validatePeerInfo)(peerInfo);
          yield this.videoInstance.disconnect({
            peerAddress: (0, helpers_1.pCAIP10ToWallet)(address)
          });
        });
      }
      /**
       * Disconnect from a video call
       */
      disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.videoInstance.disconnect();
        });
      }
      /**
       * Enable or disable config properties (video, audio)
       * @param {object} params - The parameters
       * @param {boolean} params.video - The video state
       * @param {boolean} params.audio - The audio state
       */
      config({ video, audio }) {
        if (typeof video === "boolean") {
          this.videoInstance.enableVideo({ state: video });
        }
        if (typeof audio === "boolean") {
          this.videoInstance.enableAudio({ state: audio });
        }
      }
    };
    exports.VideoV2 = VideoV2;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/video.js
var require_video2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/video.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Video = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constantsV2_1 = require_constantsV2();
    var types_1 = require_types();
    var helpers_1 = require_helpers2();
    var Video_1 = require_Video();
    var VideoV2_1 = require_VideoV2();
    var immer_1 = require_cjs2();
    var mediaToggle_1 = require_mediaToggle();
    var Video = class {
      constructor(account, env, decryptedPgpPvtKey, signer) {
        this.account = account;
        this.env = env;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.signer = signer;
        this.peerInfos = {};
      }
      initialize(onChange, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { stream, config, media } = options;
          if (!this.signer) {
            throw new Error("Signer is required for push video");
          }
          if (!this.decryptedPgpPvtKey) {
            throw new Error("PushSDK was initialized in readonly mode. Video functionality is not available.");
          }
          const chainId = yield new helpers_1.Signer(this.signer).getChainId();
          if (!chainId) {
            throw new Error("Chain Id not retrievable from signer");
          }
          const videoV1Instance = new Video_1.Video({
            signer: this.signer,
            chainId,
            pgpPrivateKey: this.decryptedPgpPvtKey,
            env: this.env,
            setData: onChange
          });
          yield videoV1Instance.create(Object.assign(Object.assign(Object.assign({}, media && {
            stream: media
          }), (config === null || config === void 0 ? void 0 : config.audio) && {
            audio: config.audio
          }), (config === null || config === void 0 ? void 0 : config.video) && {
            video: config.video
          }));
          stream.on(constantsV2_1.default.STREAM.VIDEO, (data) => {
            const { address, signal, meta: { rules } } = data.peerInfo;
            const chatId = rules.access.data.chatId;
            if (data.event === constantsV2_1.default.VIDEO.EVENT.REQUEST) {
              this.peerInfos[(0, helpers_1.walletToPCAIP10)(data.peerInfo.address)] = data.peerInfo;
              videoV1Instance.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                  draft.local.address = this.account;
                  draft.incoming[0].address = address;
                  draft.incoming[0].status = types_1.VideoCallStatus.RECEIVED;
                  draft.meta.chatId = chatId;
                  draft.meta.initiator.address = address;
                  draft.meta.initiator.signal = signal;
                });
              });
            }
            if (chatId && chatId === videoV1Instance.data.meta.chatId) {
              if (data.event === constantsV2_1.default.VIDEO.EVENT.DENY) {
                if (videoV1Instance.data.local.stream) {
                  (0, mediaToggle_1.endStream)(videoV1Instance.data.local.stream);
                }
                videoV1Instance.setData(() => Video_1.initVideoCallData);
              }
              if (data.event === constantsV2_1.default.VIDEO.EVENT.APPROVE || data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_APPROVE) {
                videoV1Instance.connect({ peerAddress: address, signalData: signal });
              }
              if (data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_REQUEST && videoV1Instance.isInitiator()) {
                videoV1Instance.request({
                  senderAddress: this.account,
                  recipientAddress: address,
                  rules,
                  retry: true
                });
              }
              if (data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_REQUEST && !videoV1Instance.isInitiator()) {
                videoV1Instance.acceptRequest({
                  signalData: signal,
                  senderAddress: this.account,
                  recipientAddress: address,
                  rules,
                  retry: true
                });
              }
            }
          });
          return new VideoV2_1.VideoV2({
            videoV1Instance,
            account: this.account,
            decryptedPgpPvtKey: this.decryptedPgpPvtKey,
            env: this.env,
            peerInfos: this.peerInfos
          });
        });
      }
    };
    exports.Video = Video;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/PushAPI.js
var require_PushAPI = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/PushAPI.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PushAPI = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants();
    var PUSH_USER = require_user();
    var PUSH_CHAT = require_chat2();
    var helpers_1 = require_helpers();
    var chat_1 = require_chat3();
    var profile_1 = require_profile();
    var encryption_1 = require_encryption();
    var user_1 = require_user2();
    var PushStream_1 = require_PushStream();
    var channel_1 = require_channel();
    var notification_1 = require_notification();
    var config_1 = require_config();
    var space_1 = require_space2();
    var video_1 = require_video2();
    var helpers_2 = require_helpers2();
    var cache_1 = require_cache();
    var uuid_1 = require_commonjs_browser();
    var PushAPI = class _PushAPI {
      constructor(env, account, readMode, alpha, decryptedPgpPvtKey, pgpPublicKey, signer, progressHook, initializationErrors) {
        this.signer = signer;
        this.readMode = readMode;
        this.alpha = alpha;
        this.env = env;
        this.account = account;
        this.chainWiseAccount = (0, helpers_2.walletToPCAIP10)(account);
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.pgpPublicKey = pgpPublicKey;
        this.progressHook = progressHook;
        this.channel = new channel_1.Channel(this.signer, this.env, this.account);
        this.notification = new notification_1.Notification(this.signer, this.env, this.account);
        this.uid = (0, uuid_1.v4)();
        this.cache = cache_1.cache;
        this.chat = new chat_1.Chat(this.account, this.env, this.alpha, this.decryptedPgpPvtKey, this.signer, this.progressHook);
        this.space = new space_1.Space(this.account, this.env, this.decryptedPgpPvtKey, this.signer, this.progressHook);
        this.profile = new profile_1.Profile(this.account, this.env, this.cache, this.decryptedPgpPvtKey, this.progressHook);
        this.encryption = new encryption_1.Encryption(this.account, this.env, this.decryptedPgpPvtKey, this.pgpPublicKey, this.signer, this.progressHook);
        this.user = new user_1.User(this.account, this.env);
        this.video = new video_1.Video(this.account, this.env, this.decryptedPgpPvtKey, this.signer);
        this.errors = initializationErrors || [];
      }
      static initialize(...args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            let signer;
            let options;
            let decryptedPGPPrivateKey;
            if (args.length === 1 && typeof args[0] === "object") {
              if ("account" in args[0] && typeof args[0].account === "string") {
                options = args[0];
              } else {
                [signer] = args;
              }
            } else if (args.length === 2) {
              [signer, options] = args;
            } else {
              throw new Error("Invalid arguments provided to initialize method.");
            }
            if (options && "decryptedPGPPrivateKey" in options && typeof options.decryptedPGPPrivateKey === "string") {
              decryptedPGPPrivateKey = options.decryptedPGPPrivateKey;
            }
            if (!signer && !(options === null || options === void 0 ? void 0 : options.account)) {
              throw new Error("Either 'signer' or 'account' must be provided.");
            }
            let readMode = !signer && !decryptedPGPPrivateKey;
            const defaultOptions = {
              env: constants_1.ENV.STAGING,
              version: constants_1.default.ENC_TYPE_V3,
              autoUpgrade: true,
              account: null
            };
            const settings = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), { version: (options === null || options === void 0 ? void 0 : options.version) || defaultOptions.version, versionMeta: (options === null || options === void 0 ? void 0 : options.versionMeta) || defaultOptions.versionMeta, autoUpgrade: (options === null || options === void 0 ? void 0 : options.autoUpgrade) !== void 0 ? options === null || options === void 0 ? void 0 : options.autoUpgrade : defaultOptions.autoUpgrade, alpha: (options === null || options === void 0 ? void 0 : options.alpha) && options.alpha.feature ? options.alpha : config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD] });
            const initializationErrors = [];
            let derivedAccount;
            if (signer) {
              derivedAccount = yield (0, helpers_1.getAccountAddress)((0, helpers_1.getWallet)({
                account: settings.account,
                signer
              }));
            } else {
              derivedAccount = options === null || options === void 0 ? void 0 : options.account;
            }
            if (!derivedAccount) {
              throw new Error("Account could not be derived.");
            }
            let pgpPublicKey;
            const user = yield PUSH_USER.get({
              account: derivedAccount,
              env: settings.env
            });
            if (user && user.publicKey) {
              pgpPublicKey = user.publicKey;
            }
            if (!readMode) {
              try {
                if (user && user.encryptedPrivateKey) {
                  if (!decryptedPGPPrivateKey) {
                    decryptedPGPPrivateKey = yield PUSH_CHAT.decryptPGPKey({
                      encryptedPGPPrivateKey: user.encryptedPrivateKey,
                      signer,
                      toUpgrade: settings.autoUpgrade,
                      additionalMeta: settings.versionMeta,
                      progressHook: settings.progressHook,
                      env: settings.env
                    });
                  }
                } else {
                  const newUser = yield PUSH_USER.create({
                    env: settings.env,
                    account: derivedAccount,
                    signer,
                    version: settings.version,
                    additionalMeta: settings.versionMeta,
                    origin: settings.origin,
                    progressHook: settings.progressHook
                  });
                  decryptedPGPPrivateKey = newUser.decryptedPrivateKey;
                  pgpPublicKey = newUser.publicKey;
                }
              } catch (error) {
                const decryptionError = "Error decrypting PGP private key ...swiching to Guest mode";
                initializationErrors.push({
                  type: "ERROR",
                  message: decryptionError
                });
                console.error(decryptionError);
                if ((0, helpers_2.isValidNFTCAIP)(derivedAccount)) {
                  const nftDecryptionError = "NFT Account Detected. If this NFT was recently transferred to you, please ensure you have received the correct password from the previous owner. Alternatively, you can reinitialize for a fresh start. Please be aware that reinitialization will result in the loss of all previous account data.";
                  initializationErrors.push({
                    type: "WARN",
                    message: nftDecryptionError
                  });
                  console.warn(nftDecryptionError);
                }
                readMode = true;
              }
            }
            const api = new _PushAPI(settings.env, derivedAccount, readMode, settings.alpha, decryptedPGPPrivateKey, pgpPublicKey, signer, settings.progressHook, initializationErrors);
            return api;
          } catch (error) {
            console.error("Error initializing PushAPI:", error);
            throw error;
          }
        });
      }
      /**
       * This method is used to reinitialize the PushAPI instance
       * @notice - This method should only be used for fresh start of NFT accounts
       * @notice - All data will be lost after reinitialization
       */
      reinitialize(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const newUser = yield PUSH_USER.create({
            env: this.env,
            account: this.account,
            signer: this.signer,
            additionalMeta: options.versionMeta,
            progressHook: this.progressHook
          });
          this.decryptedPgpPvtKey = newUser.decryptedPrivateKey;
          this.pgpPublicKey = newUser.publicKey;
          this.readMode = false;
          this.errors = [];
          this.uid = (0, uuid_1.v4)();
          this.chat = new chat_1.Chat(this.account, this.env, this.alpha, this.decryptedPgpPvtKey, this.signer, this.progressHook);
          this.profile = new profile_1.Profile(this.account, this.env, this.cache, this.decryptedPgpPvtKey, this.progressHook);
          this.encryption = new encryption_1.Encryption(this.account, this.env, this.decryptedPgpPvtKey, this.pgpPublicKey, this.signer, this.progressHook);
        });
      }
      initStream(listen, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.stream) {
            throw new Error("Stream is already initialized.");
          }
          this.stream = yield PushStream_1.PushStream.initialize(this.account, listen, this.env, this.decryptedPgpPvtKey, this.progressHook, this.signer, options);
          return this.stream;
        });
      }
      info(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const accountToUse = (options === null || options === void 0 ? void 0 : options.overrideAccount) || this.account;
          return yield PUSH_USER.get({
            account: accountToUse,
            env: this.env
          });
        });
      }
      readmode() {
        return this.readMode;
      }
      static ensureSignerMessage() {
        return "Operation not allowed in read-only mode. Signer is required.";
      }
    };
    exports.PushAPI = PushAPI;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/index.js
var require_lib = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.video = exports.space = exports.chat = exports.payloads = exports.utils = exports.user = exports.channels = exports.alias = exports.PushAPI = exports.CONSTANTS = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var alias = require_alias();
    exports.alias = alias;
    var channels = require_channels();
    exports.channels = channels;
    var user = require_user();
    exports.user = user;
    var utils = require_utils();
    exports.utils = utils;
    var payloads = require_payloads();
    exports.payloads = payloads;
    var chat = require_chat2();
    exports.chat = chat;
    var space = require_space();
    exports.space = space;
    var video = require_video();
    exports.video = video;
    var constantsV2_1 = require_constantsV2();
    exports.CONSTANTS = constantsV2_1.default;
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_PushNotificationTypes(), exports);
    tslib_1.__exportStar(require_pushStreamTypes(), exports);
    tslib_1.__exportStar(require_pushAPITypes(), exports);
    var PushAPI_1 = require_PushAPI();
    Object.defineProperty(exports, "PushAPI", { enumerable: true, get: function() {
      return PushAPI_1.PushAPI;
    } });
  }
});

// node_modules/@pushprotocol/restapi/src/index.js
var require_src = __commonJS({
  "node_modules/@pushprotocol/restapi/src/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_lib(), exports);
  }
});

export {
  require_src
};
//# sourceMappingURL=chunk-UWU3ET5H.js.map

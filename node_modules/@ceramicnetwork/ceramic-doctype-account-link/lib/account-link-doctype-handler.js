"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountLinkDoctypeHandler = void 0;
const _3id_blockchain_utils_1 = require("3id-blockchain-utils");
const account_link_doctype_1 = require("./account-link-doctype");
const ceramic_common_1 = require("@ceramicnetwork/ceramic-common");
const DOCTYPE = 'account-link';
class AccountLinkDoctypeHandler {
    get name() {
        return DOCTYPE;
    }
    get doctype() {
        return account_link_doctype_1.AccountLinkDoctype;
    }
    async create(params, context, opts) {
        return account_link_doctype_1.AccountLinkDoctype.create(params, context, opts);
    }
    async applyRecord(record, cid, context, state) {
        if (state == null) {
            return this._applyGenesis(record, cid);
        }
        if (record.proof) {
            const proofRecord = (await context.ipfs.dag.get(record.proof)).value;
            return this._applyAnchor(record, proofRecord, cid, state);
        }
        return this._applySigned(record, cid, state);
    }
    async _applyGenesis(record, cid) {
        return {
            doctype: DOCTYPE,
            content: null,
            next: {
                content: null
            },
            metadata: record.header,
            signature: ceramic_common_1.SignatureStatus.GENESIS,
            anchorStatus: ceramic_common_1.AnchorStatus.NOT_REQUESTED,
            log: [cid]
        };
    }
    async _applySigned(record, cid, state) {
        const validProof = await _3id_blockchain_utils_1.validateLink(record.content);
        if (!validProof) {
            throw new Error('Invalid proof for signed record');
        }
        const account = validProof.account || validProof.address;
        let [address, chainId] = account.split('@');
        if (!chainId) {
            chainId = 'eip155:1';
        }
        const addressCaip10 = [address, chainId].join('@');
        if (addressCaip10.toLowerCase() !== state.metadata.controllers[0].toLowerCase()) {
            throw new Error("Address doesn't match document controller");
        }
        state.log.push(cid);
        return {
            ...state,
            signature: ceramic_common_1.SignatureStatus.SIGNED,
            anchorStatus: ceramic_common_1.AnchorStatus.NOT_REQUESTED,
            next: {
                content: validProof.did
            }
        };
    }
    async _applyAnchor(record, proof, cid, state) {
        var _a;
        state.log.push(cid);
        let content = state.content;
        if ((_a = state.next) === null || _a === void 0 ? void 0 : _a.content) {
            content = state.next.content;
            delete state.next.content;
        }
        return {
            ...state,
            content,
            anchorStatus: ceramic_common_1.AnchorStatus.ANCHORED,
            anchorProof: proof,
        };
    }
}
exports.AccountLinkDoctypeHandler = AccountLinkDoctypeHandler;
//# sourceMappingURL=account-link-doctype-handler.js.map
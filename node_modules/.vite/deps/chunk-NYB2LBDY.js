import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  init_url,
  require_https_browserify,
  require_stream_http,
  url_exports
} from "./chunk-LNHASNIF.js";
import {
  init_openpgp_min,
  openpgp_min_exports
} from "./chunk-WHD56NQX.js";
import {
  require_axios
} from "./chunk-P4BO54TR.js";
import {
  require_constants
} from "./chunk-R52GSNMP.js";
import {
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-FOVVVYF4.js";
import {
  require_nacl_fast,
  require_nacl_util
} from "./chunk-WQ42LN3A.js";
import {
  require_lib
} from "./chunk-XTGAQBSB.js";
import {
  require_assert
} from "./chunk-D4NVBJN6.js";
import {
  require_bn,
  require_crypto_browserify,
  require_stream_browserify
} from "./chunk-7LYDIDA4.js";
import {
  require_util
} from "./chunk-D2UFQSSP.js";
import {
  require_events
} from "./chunk-LPS2SYRB.js";
import {
  dist_exports,
  init_dist
} from "./chunk-644CRGRM.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@pushprotocol/restapi/package.json
var require_package = __commonJS({
  "node_modules/@pushprotocol/restapi/package.json"(exports, module) {
    module.exports = {
      name: "@pushprotocol/restapi",
      version: "1.7.25",
      type: "commonjs",
      publishConfig: {
        registry: "https://registry.npmjs.org/"
      },
      peerDependencies: {
        ethers: "^5.0.0 || ^6.0.0"
      },
      peerDependenciesMeta: {
        ethers: {
          optional: true
        }
      },
      dependencies: {
        "@metamask/eth-sig-util": "^5.0.2",
        buffer: "^6.0.3",
        "crypto-js": "^4.1.1",
        immer: "^10.0.2",
        joi: "^17.9.2",
        livepeer: "^2.5.8",
        "lru-cache": "^10.1.0",
        openpgp: "^5.5.0",
        "simple-peer": "^9.11.1",
        "socket.io-client": "^4.7.2",
        "video-stream-merger": "^4.0.1",
        viem: "^1.20.3",
        axios: "^0.27.2",
        uuid: "^9.0.0",
        "unique-names-generator": "^4.7.1",
        tslib: "^2.3.0"
      },
      scripts: {
        test: "TS_NODE_PROJECT='./tsconfig.mocha.json' NODE_OPTIONS='--loader ts-node/esm' DOTENV_CONFIG_PATH='./tests/.env' mocha -r ts-node/register -r dotenv/config 'tests/**/*.test.ts' --timeout 1200000 --require tests/root.ts --serial"
      },
      devDependencies: {
        "@types/chai": "^4.3.4",
        "@types/chai-as-promised": "^7.1.5",
        "@types/crypto-js": "^4.1.1",
        "@types/mocha": "^10.0.1",
        chai: "^4.3.7",
        "chai-as-promised": "^7.1.1",
        envfile: "^7.1.0",
        mocha: "^10.2.0",
        "mocha-typescript": "^1.1.17",
        "ts-node": "^10.9.1",
        typescript: "^5.0.2"
      },
      main: "./src/index.js",
      typings: "./src/index.d.ts"
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PACKAGE_BUILD = exports.ALPHA_FEATURES = exports.MessageType = exports.ENCRYPTION_TYPE = exports.ENV = void 0;
    var packageJson = require_package();
    var ENV;
    (function(ENV2) {
      ENV2["PROD"] = "prod";
      ENV2["STAGING"] = "staging";
      ENV2["DEV"] = "dev";
      ENV2["LOCAL"] = "local";
    })(ENV = exports.ENV || (exports.ENV = {}));
    var ENCRYPTION_TYPE;
    (function(ENCRYPTION_TYPE2) {
      ENCRYPTION_TYPE2["PGP_V1"] = "x25519-xsalsa20-poly1305";
      ENCRYPTION_TYPE2["PGP_V2"] = "aes256GcmHkdfSha256";
      ENCRYPTION_TYPE2["PGP_V3"] = "eip191-aes256-gcm-hkdf-sha256";
      ENCRYPTION_TYPE2["NFTPGP_V1"] = "pgpv1:nft";
    })(ENCRYPTION_TYPE = exports.ENCRYPTION_TYPE || (exports.ENCRYPTION_TYPE = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2["TEXT"] = "Text";
      MessageType2["IMAGE"] = "Image";
      MessageType2["VIDEO"] = "Video";
      MessageType2["AUDIO"] = "Audio";
      MessageType2["FILE"] = "File";
      MessageType2["GIF"] = "GIF";
      MessageType2["MEDIA_EMBED"] = "MediaEmbed";
      MessageType2["META"] = "Meta";
      MessageType2["REACTION"] = "Reaction";
      MessageType2["RECEIPT"] = "Receipt";
      MessageType2["USER_ACTIVITY"] = "UserActivity";
      MessageType2["INTENT"] = "Intent";
      MessageType2["REPLY"] = "Reply";
      MessageType2["COMPOSITE"] = "Composite";
      MessageType2["PAYMENT"] = "Payment";
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    exports.ALPHA_FEATURES = {
      SCALABILITY_V2: "SCALABILITY_V2"
    };
    exports.PACKAGE_BUILD = packageJson.version.includes("alpha") ? "ALPHA" : "STABLE";
    var Constants = {
      ENV,
      ENCRYPTION_TYPE,
      PAGINATION: {
        INITIAL_PAGE: 1,
        LIMIT: 10,
        LIMIT_MIN: 1,
        LIMIT_MAX: 50
      },
      DEFAULT_CHAIN_ID: 11155111,
      DEV_CHAIN_ID: 99999,
      NON_ETH_CHAINS: [
        137,
        80002,
        56,
        97,
        10,
        11155420,
        2442,
        1101,
        421614,
        42161,
        122,
        123,
        80085,
        59141,
        59144,
        111557560,
        7560,
        84532,
        8453
      ],
      ETH_CHAINS: [1, 11155111],
      ENC_TYPE_V1: "x25519-xsalsa20-poly1305",
      ENC_TYPE_V2: "aes256GcmHkdfSha256",
      ENC_TYPE_V3: "eip191-aes256-gcm-hkdf-sha256",
      ENC_TYPE_V4: "pgpv1:nft",
      ALPHA_FEATURES: exports.ALPHA_FEATURES
    };
    exports.default = Constants;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/abis/core.js
var require_core = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/abis/core.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coreABI = void 0;
    exports.coreABI = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "enum EPNSCoreStorageV1_5.ChannelType",
            name: "channelType",
            type: "uint8"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "identity",
            type: "bytes"
          }
        ],
        name: "AddChannel",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "_subGraphData",
            type: "bytes"
          }
        ],
        name: "AddSubGraph",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          }
        ],
        name: "ChannelBlocked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "_channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "totalNotifOptions",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "_notifSettings",
            type: "string"
          },
          {
            indexed: false,
            internalType: "string",
            name: "_notifDescription",
            type: "string"
          }
        ],
        name: "ChannelNotifcationSettingsAdded",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "ChannelOwnershipTransfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "revoker",
            type: "address"
          }
        ],
        name: "ChannelVerificationRevoked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "verifier",
            type: "address"
          }
        ],
        name: "ChannelVerified",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: "address", name: "user", type: "address" },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountClaimed",
            type: "uint256"
          }
        ],
        name: "ChatIncentiveClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountRefunded",
            type: "uint256"
          }
        ],
        name: "DeactivateChannel",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "requestSender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "requestReceiver",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amountForReqReceiver",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "feePoolAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          }
        ],
        name: "IncentivizeChatReqReceived",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Paused",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountDeposited",
            type: "uint256"
          }
        ],
        name: "ReactivateChannel",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: "address", name: "user", type: "address" },
          {
            indexed: false,
            internalType: "uint256",
            name: "rewardAmount",
            type: "uint256"
          }
        ],
        name: "RewardsClaimed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: "address", name: "user", type: "address" },
          {
            indexed: true,
            internalType: "uint256",
            name: "rewardAmount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "fromEpoch",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "tillEpoch",
            type: "uint256"
          }
        ],
        name: "RewardsHarvested",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: "address", name: "user", type: "address" },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountStaked",
            type: "uint256"
          }
        ],
        name: "Staked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountRefunded",
            type: "uint256"
          }
        ],
        name: "TimeBoundChannelDestroyed",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Unpaused",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: "address", name: "user", type: "address" },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountUnstaked",
            type: "uint256"
          }
        ],
        name: "Unstaked",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "identity",
            type: "bytes"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "amountDeposited",
            type: "uint256"
          }
        ],
        name: "UpdateChannel",
        type: "event"
      },
      {
        inputs: [],
        name: "ADD_CHANNEL_MIN_FEES",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "CHANNEL_POOL_FUNDS",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "CREATE_CHANNEL_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "FEE_AMOUNT",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "MIN_POOL_CONTRIBUTION",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PROTOCOL_POOL_FEES",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PUSH_TOKEN_ADDRESS",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "REFERRAL_CODE",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "UNISWAP_V2_ROUTER",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "WETH_ADDRESS",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "aDaiAddress",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "_rewardAmount", type: "uint256" }
        ],
        name: "addPoolFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes", name: "_subGraphData", type: "bytes" }],
        name: "addSubGraph",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "_startIndex", type: "uint256" },
          { internalType: "uint256", name: "_endIndex", type: "uint256" },
          { internalType: "address[]", name: "_channelList", type: "address[]" }
        ],
        name: "batchVerification",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channelAddress", type: "address" }
        ],
        name: "blockChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_user", type: "address" },
          { internalType: "uint256", name: "_epochId", type: "uint256" }
        ],
        name: "calculateEpochRewards",
        outputs: [{ internalType: "uint256", name: "rewards", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "celebUserFunds",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        name: "channelById",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "channelNotifSettings",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "channelUpdateCounter",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "channels",
        outputs: [
          {
            internalType: "enum EPNSCoreStorageV1_5.ChannelType",
            name: "channelType",
            type: "uint8"
          },
          { internalType: "uint8", name: "channelState", type: "uint8" },
          { internalType: "address", name: "verifiedBy", type: "address" },
          { internalType: "uint256", name: "poolContribution", type: "uint256" },
          { internalType: "uint256", name: "channelHistoricalZ", type: "uint256" },
          {
            internalType: "uint256",
            name: "channelFairShareCount",
            type: "uint256"
          },
          { internalType: "uint256", name: "channelLastUpdate", type: "uint256" },
          { internalType: "uint256", name: "channelStartBlock", type: "uint256" },
          { internalType: "uint256", name: "channelUpdateBlock", type: "uint256" },
          { internalType: "uint256", name: "channelWeight", type: "uint256" },
          { internalType: "uint256", name: "expiryTime", type: "uint256" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "channelsCount",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
        name: "claimChatIncentives",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "_notifOptions", type: "uint256" },
          { internalType: "string", name: "_notifSettings", type: "string" },
          { internalType: "string", name: "_notifDescription", type: "string" },
          { internalType: "uint256", name: "_amountDeposited", type: "uint256" }
        ],
        name: "createChannelSettings",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum EPNSCoreStorageV1_5.ChannelType",
            name: "_channelType",
            type: "uint8"
          },
          { internalType: "bytes", name: "_identity", type: "bytes" },
          { internalType: "uint256", name: "_amount", type: "uint256" },
          { internalType: "uint256", name: "_channelExpiryTime", type: "uint256" }
        ],
        name: "createChannelWithPUSH",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "daiAddress",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_tillEpoch", type: "uint256" }],
        name: "daoHarvestPaginated",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "deactivateChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channelAddress", type: "address" }
        ],
        name: "destroyTimeBoundChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "epnsCommunicator",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "epochDuration",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        name: "epochRewards",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        name: "epochToTotalStakedWeight",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "genesisEpoch",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_channel", type: "address" }],
        name: "getChannelVerfication",
        outputs: [
          { internalType: "uint8", name: "verificationStatus", type: "uint8" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "governance",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "groupFairShareCount",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "groupHistoricalZ",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "groupLastUpdate",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "groupNormalizedWeight",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "requestSender", type: "address" },
          { internalType: "address", name: "requestReceiver", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        name: "handleChatRequestData",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "harvestAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_tillEpoch", type: "uint256" }],
        name: "harvestPaginated",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_pushChannelAdmin", type: "address" },
          { internalType: "address", name: "_pushTokenAddress", type: "address" },
          { internalType: "address", name: "_wethAddress", type: "address" },
          {
            internalType: "address",
            name: "_uniswapRouterAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "_lendingPoolProviderAddress",
            type: "address"
          },
          { internalType: "address", name: "_daiAddress", type: "address" },
          { internalType: "address", name: "_aDaiAddress", type: "address" },
          { internalType: "uint256", name: "_referralCode", type: "uint256" }
        ],
        name: "initialize",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "initializeStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "isMigrationComplete",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "_from", type: "uint256" },
          { internalType: "uint256", name: "_to", type: "uint256" }
        ],
        name: "lastEpochRelative",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lendingPoolProviderAddress",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "nonces",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pauseContract",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "paused",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "previouslySetEpochRewards",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pushChannelAdmin",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
        name: "reactivateChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_commAddress", type: "address" }
        ],
        name: "setEpnsCommunicatorAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_newFees", type: "uint256" }],
        name: "setFeeAmount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_governanceAddress", type: "address" }
        ],
        name: "setGovernanceAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_newFees", type: "uint256" }],
        name: "setMinChannelCreationFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_newAmount", type: "uint256" }],
        name: "setMinPoolContribution",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
        name: "stake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "totalStakedAmount",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_newAdmin", type: "address" }],
        name: "transferPushChannelAdminControl",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unPauseContract",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unstake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_channel", type: "address" }],
        name: "unverifyChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "bytes", name: "_newIdentity", type: "bytes" },
          { internalType: "uint256", name: "_amount", type: "uint256" }
        ],
        name: "updateChannelMeta",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "userFeesInfo",
        outputs: [
          { internalType: "uint256", name: "stakedAmount", type: "uint256" },
          { internalType: "uint256", name: "stakedWeight", type: "uint256" },
          { internalType: "uint256", name: "lastStakedBlock", type: "uint256" },
          { internalType: "uint256", name: "lastClaimedBlock", type: "uint256" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "usersRewardsClaimed",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_channel", type: "address" }],
        name: "verifyChannel",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/@pushprotocol/restapi/src/lib/abis/comm.js
var require_comm = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/abis/comm.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commABI = void 0;
    exports.commABI = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "delegate",
            type: "address"
          }
        ],
        name: "AddDelegate",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "string",
            name: "_chainName",
            type: "string"
          },
          {
            indexed: true,
            internalType: "uint256",
            name: "_chainID",
            type: "uint256"
          },
          {
            indexed: true,
            internalType: "address",
            name: "_channelOwnerAddress",
            type: "address"
          },
          {
            indexed: false,
            internalType: "string",
            name: "_ethereumChannelAddress",
            type: "string"
          }
        ],
        name: "ChannelAlias",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "publickey",
            type: "bytes"
          }
        ],
        name: "PublicKeyRegistered",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "delegate",
            type: "address"
          }
        ],
        name: "RemoveDelegate",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "identity",
            type: "bytes"
          }
        ],
        name: "SendNotification",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          { indexed: true, internalType: "address", name: "user", type: "address" }
        ],
        name: "Subscribe",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "channel",
            type: "address"
          },
          { indexed: true, internalType: "address", name: "user", type: "address" }
        ],
        name: "Unsubscribe",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: false,
            internalType: "address",
            name: "_channel",
            type: "address"
          },
          {
            indexed: false,
            internalType: "address",
            name: "_user",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "_notifID",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "string",
            name: "_notifSettings",
            type: "string"
          }
        ],
        name: "UserNotifcationSettingsAdded",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EPNSCoreAddress",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "NAME_HASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "SEND_NOTIFICATION_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "SUBSCRIBE_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "UNSUBSCRIBE_TYPEHASH",
        outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_delegate", type: "address" }],
        name: "addDelegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address[]", name: "_channelList", type: "address[]" }
        ],
        name: "batchSubscribe",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address[]", name: "_channelList", type: "address[]" }
        ],
        name: "batchUnsubscribe",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes", name: "_publicKey", type: "bytes" }],
        name: "broadcastUserPublicKey",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "chainID",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "chainName",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "uint256", name: "_notifID", type: "uint256" },
          { internalType: "string", name: "_notifSettings", type: "string" }
        ],
        name: "changeUserChannelSettings",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "completeMigration",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "", type: "address" },
          { internalType: "address", name: "", type: "address" }
        ],
        name: "delegatedNotificationSenders",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes", name: "_publicKey", type: "bytes" }],
        name: "getWalletFromPublicKey",
        outputs: [{ internalType: "address", name: "wallet", type: "address" }],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "governance",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_pushChannelAdmin", type: "address" },
          { internalType: "string", name: "_chainName", type: "string" }
        ],
        name: "initialize",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "isMigrationComplete",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "address", name: "_user", type: "address" }
        ],
        name: "isUserSubscribed",
        outputs: [{ internalType: "bool", name: "isSubscriber", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        name: "mapAddressUsers",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "uint256", name: "_startIndex", type: "uint256" },
          { internalType: "uint256", name: "_endIndex", type: "uint256" },
          { internalType: "address[]", name: "_channelList", type: "address[]" },
          { internalType: "address[]", name: "_usersList", type: "address[]" }
        ],
        name: "migrateSubscribeData",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "nonces",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pushChannelAdmin",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_delegate", type: "address" }],
        name: "removeDelegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "address", name: "_recipient", type: "address" },
          { internalType: "bytes", name: "_identity", type: "bytes" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "uint256", name: "expiry", type: "uint256" },
          { internalType: "uint8", name: "v", type: "uint8" },
          { internalType: "bytes32", name: "r", type: "bytes32" },
          { internalType: "bytes32", name: "s", type: "bytes32" }
        ],
        name: "sendNotifBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "address", name: "_recipient", type: "address" },
          { internalType: "bytes", name: "_identity", type: "bytes" }
        ],
        name: "sendNotification",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_coreAddress", type: "address" }
        ],
        name: "setEPNSCoreAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_governanceAddress", type: "address" }
        ],
        name: "setGovernanceAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_channel", type: "address" }],
        name: "subscribe",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "channel", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "uint256", name: "expiry", type: "uint256" },
          { internalType: "uint8", name: "v", type: "uint8" },
          { internalType: "bytes32", name: "r", type: "bytes32" },
          { internalType: "bytes32", name: "s", type: "bytes32" }
        ],
        name: "subscribeBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "_channel", type: "address" },
          { internalType: "address", name: "_user", type: "address" }
        ],
        name: "subscribeViaCore",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_newAdmin", type: "address" }],
        name: "transferPushChannelAdminControl",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "_channel", type: "address" }],
        name: "unsubscribe",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "channel", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "uint256", name: "expiry", type: "uint256" },
          { internalType: "uint8", name: "v", type: "uint8" },
          { internalType: "bytes32", name: "r", type: "bytes32" },
          { internalType: "bytes32", name: "s", type: "bytes32" }
        ],
        name: "unsubscribeBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          { internalType: "address", name: "", type: "address" },
          { internalType: "address", name: "", type: "address" }
        ],
        name: "userToChannelNotifs",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [{ internalType: "address", name: "", type: "address" }],
        name: "users",
        outputs: [
          { internalType: "bool", name: "userActivated", type: "bool" },
          { internalType: "bool", name: "publicKeyRegistered", type: "bool" },
          { internalType: "uint256", name: "userStartBlock", type: "uint256" },
          { internalType: "uint256", name: "subscribedCount", type: "uint256" }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "usersCount",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          { internalType: "string", name: "_channelAddress", type: "string" }
        ],
        name: "verifyChannelAlias",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/@pushprotocol/restapi/src/lib/abis/token.js
var require_token = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/abis/token.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenABI = void 0;
    exports.tokenABI = [
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "fromDelegate",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "toDelegate",
            type: "address"
          }
        ],
        name: "DelegateChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "delegate",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "previousBalance",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "newBalance",
            type: "uint256"
          }
        ],
        name: "DelegateVotesChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "holder",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "weight",
            type: "uint256"
          }
        ],
        name: "HolderWeightChanged",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DELEGATION_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "DOMAIN_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "rawAmount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "born",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rawAmount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint32",
            name: "",
            type: "uint32"
          }
        ],
        name: "checkpoints",
        outputs: [
          {
            internalType: "uint32",
            name: "fromBlock",
            type: "uint32"
          },
          {
            internalType: "uint96",
            name: "votes",
            type: "uint96"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          }
        ],
        name: "delegate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegatee",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "delegateBySig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "delegates",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "getCurrentVotes",
        outputs: [
          {
            internalType: "uint96",
            name: "",
            type: "uint96"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getPriorVotes",
        outputs: [
          {
            internalType: "uint96",
            name: "",
            type: "uint96"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "holderDelegation",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "holderWeight",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "numCheckpoints",
        outputs: [
          {
            internalType: "uint32",
            name: "",
            type: "uint32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "rawAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "holder",
            type: "address"
          }
        ],
        name: "resetHolderWeight",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "delegate",
            type: "address"
          }
        ],
        name: "returnHolderDelegation",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "returnHolderRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "delegate",
            type: "address"
          },
          {
            internalType: "bool",
            name: "value",
            type: "bool"
          }
        ],
        name: "setHolderDelegation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "dst",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "rawAmount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "src",
            type: "address"
          },
          {
            internalType: "address",
            name: "dst",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "rawAmount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/defineChain.js
var require_defineChain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/defineChain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineChain = void 0;
    function defineChain(chain, config = {}) {
      const { fees = chain.fees, formatters = chain.formatters, serializers = chain.serializers } = config;
      return {
        ...chain,
        fees,
        formatters,
        serializers
      };
    }
    exports.defineChain = defineChain;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/acala.js
var require_acala = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/acala.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.acala = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.acala = (0, defineChain_js_1.defineChain)({
      id: 787,
      name: "Acala",
      network: "acala",
      nativeCurrency: {
        name: "Acala",
        symbol: "ACA",
        decimals: 18
      },
      rpcUrls: {
        public: {
          http: ["https://eth-rpc-acala.aca-api.network"],
          webSocket: ["wss://eth-rpc-acala.aca-api.network"]
        },
        default: {
          http: ["https://eth-rpc-acala.aca-api.network"],
          webSocket: ["wss://eth-rpc-acala.aca-api.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Acala Blockscout",
          url: "https://blockscout.acala.network"
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrum.js
var require_arbitrum = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrum.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrum = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.arbitrum = (0, defineChain_js_1.defineChain)({
      id: 42161,
      name: "Arbitrum One",
      network: "arbitrum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-mainnet.infura.io/v3"],
          webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://arb1.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://arb1.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
        default: { name: "Arbiscan", url: "https://arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7654707
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js
var require_arbitrumGoerli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrumGoerli = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.arbitrumGoerli = (0, defineChain_js_1.defineChain)({
      id: 421613,
      name: "Arbitrum Goerli",
      network: "arbitrum-goerli",
      nativeCurrency: {
        name: "Arbitrum Goerli Ether",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-goerli.infura.io/v3"],
          webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io" },
        default: { name: "Arbiscan", url: "https://goerli.arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 88114
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumNova.js
var require_arbitrumNova = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumNova.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrumNova = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.arbitrumNova = (0, defineChain_js_1.defineChain)({
      id: 42170,
      name: "Arbitrum Nova",
      network: "arbitrum-nova",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        blast: {
          http: ["https://arbitrum-nova.public.blastapi.io"],
          webSocket: ["wss://arbitrum-nova.public.blastapi.io"]
        },
        default: {
          http: ["https://nova.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://nova.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://nova.arbiscan.io" },
        blockScout: {
          name: "BlockScout",
          url: "https://nova-explorer.arbitrum.io/"
        },
        default: { name: "Arbiscan", url: "https://nova.arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1746963
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/astar.js
var require_astar = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/astar.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.astar = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.astar = (0, defineChain_js_1.defineChain)({
      id: 592,
      name: "Astar",
      network: "astar-mainnet",
      nativeCurrency: {
        name: "Astar",
        symbol: "ASTR",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://astar.api.onfinality.io/public"] },
        default: { http: ["https://astar.api.onfinality.io/public"] }
      },
      blockExplorers: {
        default: { name: "Astar Subscan", url: "https://astar.subscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 761794
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js
var require_arbitrumSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/arbitrumSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrumSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.arbitrumSepolia = (0, defineChain_js_1.defineChain)({
      id: 421614,
      name: "Arbitrum Sepolia",
      network: "arbitrum-sepolia",
      nativeCurrency: {
        name: "Arbitrum Sepolia Ether",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://arb-sepolia.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://sepolia-rollup.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://sepolia-rollup.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://sepolia.arbiscan.io" },
        default: { name: "Arbiscan", url: "https://sepolia.arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 81930
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/astarZkatana.js
var require_astarZkatana = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/astarZkatana.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.astarZkatana = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.astarZkatana = (0, defineChain_js_1.defineChain)({
      id: 1261120,
      name: "Astar zkEVM Testnet zKatana",
      network: "zKatana",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://rpc.zkatana.gelato.digital",
            "https://rpc.startale.com/zkatana"
          ]
        },
        public: {
          http: [
            "https://rpc.zkatana.gelato.digital",
            "https://rpc.startale.com/zkatana"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout zKatana chain explorer",
          url: "https://zkatana.blockscout.com"
        },
        default: {
          name: "zKatana Explorer",
          url: "https://zkatana.explorer.startale.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 31317
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/aurora.js
var require_aurora = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/aurora.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aurora = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.aurora = (0, defineChain_js_1.defineChain)({
      id: 1313161554,
      name: "Aurora",
      network: "aurora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
        default: { http: ["https://mainnet.aurora.dev"] },
        public: { http: ["https://mainnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://aurorascan.dev" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 62907816
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/auroraTestnet.js
var require_auroraTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/auroraTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auroraTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.auroraTestnet = (0, defineChain_js_1.defineChain)({
      id: 1313161555,
      name: "Aurora Testnet",
      network: "aurora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-testnet.infura.io/v3"] },
        default: { http: ["https://testnet.aurora.dev"] },
        public: { http: ["https://testnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/avalanche.js
var require_avalanche = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/avalanche.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avalanche = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.avalanche = (0, defineChain_js_1.defineChain)({
      id: 43114,
      name: "Avalanche",
      network: "avalanche",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
        default: { name: "SnowTrace", url: "https://snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 11907934
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/avalancheFuji.js
var require_avalancheFuji = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/avalancheFuji.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avalancheFuji = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.avalancheFuji = (0, defineChain_js_1.defineChain)({
      id: 43113,
      name: "Avalanche Fuji",
      network: "avalanche-fuji",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
        default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7096959
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bahamut.js
var require_bahamut = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bahamut.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bahamut = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bahamut = (0, defineChain_js_1.defineChain)({
      id: 5165,
      network: "bahamut",
      name: "Bahamut",
      nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://rpc1.bahamut.io",
            "https://bahamut.publicnode.com",
            "https://rpc2.bahamut.io"
          ],
          webSocket: [
            "wss://ws1.sahara.bahamutchain.com",
            "wss://bahamut.publicnode.com",
            "wss://ws2.sahara.bahamutchain.com"
          ]
        },
        public: {
          http: [
            "https://rpc1.bahamut.io",
            "https://bahamut.publicnode.com",
            "https://rpc2.bahamut.io"
          ],
          webSocket: [
            "wss://ws1.sahara.bahamutchain.com",
            "wss://bahamut.publicnode.com",
            "wss://ws2.sahara.bahamutchain.com"
          ]
        }
      },
      blockExplorers: {
        default: {
          name: "Ftnscan",
          url: "https://www.ftnscan.com"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/version.js
var require_version2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/version.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.21.3";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/utils.js
var require_utils = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getVersion = exports.getUrl = exports.getContractAddress = void 0;
    var version_js_1 = require_version2();
    var getContractAddress = (address) => address;
    exports.getContractAddress = getContractAddress;
    var getUrl = (url) => url;
    exports.getUrl = getUrl;
    var getVersion = () => `viem@${version_js_1.version}`;
    exports.getVersion = getVersion;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/base.js
var require_base = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/base.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var utils_js_1 = require_utils();
    var BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, utils_js_1.getVersion)()
        });
        const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [
            `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    };
    exports.BaseError = BaseError;
    function walk(err, fn) {
      if (fn?.(err))
        return err;
      if (err && typeof err === "object" && "cause" in err)
        return walk(err.cause, fn);
      return fn ? null : err;
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/encoding.js
var require_encoding = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/encoding.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = void 0;
    var base_js_1 = require_base();
    var DataLengthTooLongError = class extends base_js_1.BaseError {
      constructor({ consumed, length }) {
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooLongError"
        });
      }
    };
    exports.DataLengthTooLongError = DataLengthTooLongError;
    var DataLengthTooShortError = class extends base_js_1.BaseError {
      constructor({ length, dataLength }) {
        super(`Data length (${dataLength - 1}) is shorter than consumed bytes length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooShortError"
        });
      }
    };
    exports.DataLengthTooShortError = DataLengthTooShortError;
    var IntegerOutOfRangeError = class extends base_js_1.BaseError {
      constructor({ max, min, signed, size, value }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    exports.IntegerOutOfRangeError = IntegerOutOfRangeError;
    var InvalidBytesBooleanError = class extends base_js_1.BaseError {
      constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidBytesBooleanError"
        });
      }
    };
    exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
    var InvalidHexBooleanError = class extends base_js_1.BaseError {
      constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexBooleanError"
        });
      }
    };
    exports.InvalidHexBooleanError = InvalidHexBooleanError;
    var InvalidHexValueError = class extends base_js_1.BaseError {
      constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexValueError"
        });
      }
    };
    exports.InvalidHexValueError = InvalidHexValueError;
    var OffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ nextOffset, offset }) {
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffsetOutOfBoundsError"
        });
      }
    };
    exports.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
    var SizeOverflowError = class extends base_js_1.BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
    exports.SizeOverflowError = SizeOverflowError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isHex.js
var require_isHex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isHex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHex = void 0;
    function isHex(value, { strict = true } = {}) {
      if (!value)
        return false;
      if (typeof value !== "string")
        return false;
      return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
    }
    exports.isHex = isHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/size.js
var require_size = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/size.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.size = void 0;
    var isHex_js_1 = require_isHex();
    function size(value) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
      return value.length;
    }
    exports.size = size;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/trim.js
var require_trim = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/trim.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trim = void 0;
    function trim(hexOrBytes, { dir = "left" } = {}) {
      let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
      let sliceLength = 0;
      for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
          sliceLength++;
        else
          break;
      }
      data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
      if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right")
          data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
      }
      return data;
    }
    exports.trim = trim;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/data.js
var require_data = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/data.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = void 0;
    var base_js_1 = require_base();
    var SliceOffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ offset, position, size }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
    var SizeExceedsPaddingSizeError = class extends base_js_1.BaseError {
      constructor({ size, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
    exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/pad.js
var require_pad = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/pad.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.padBytes = exports.padHex = exports.pad = void 0;
    var data_js_1 = require_data();
    function pad(hexOrBytes, { dir, size = 32 } = {}) {
      if (typeof hexOrBytes === "string")
        return padHex(hexOrBytes, { dir, size });
      return padBytes(hexOrBytes, { dir, size });
    }
    exports.pad = pad;
    function padHex(hex_, { dir, size = 32 } = {}) {
      if (size === null)
        return hex_;
      const hex = hex_.replace("0x", "");
      if (hex.length > size * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: Math.ceil(hex.length / 2),
          targetSize: size,
          type: "hex"
        });
      return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
    }
    exports.padHex = padHex;
    function padBytes(bytes, { dir, size = 32 } = {}) {
      if (size === null)
        return bytes;
      if (bytes.length > size)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: bytes.length,
          targetSize: size,
          type: "bytes"
        });
      const paddedBytes = new Uint8Array(size);
      for (let i = 0; i < size; i++) {
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
      }
      return paddedBytes;
    }
    exports.padBytes = padBytes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toHex.js
var require_toHex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toHex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;
    var encoding_js_1 = require_encoding();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function toHex(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToHex(value, opts);
      if (typeof value === "string") {
        return stringToHex(value, opts);
      }
      if (typeof value === "boolean")
        return boolToHex(value, opts);
      return bytesToHex(value, opts);
    }
    exports.toHex = toHex;
    function boolToHex(value, opts = {}) {
      const hex = `0x${Number(value)}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
      }
      return hex;
    }
    exports.boolToHex = boolToHex;
    function bytesToHex(value, opts = {}) {
      let string = "";
      for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
      }
      const hex = `0x${string}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHex(value_, opts = {}) {
      const { signed, size } = opts;
      const value = BigInt(value_);
      let maxValue;
      if (size) {
        if (signed)
          maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else
          maxValue = 2n ** (BigInt(size) * 8n) - 1n;
      } else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
      }
      const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
      if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new encoding_js_1.IntegerOutOfRangeError({
          max: maxValue ? `${maxValue}${suffix}` : void 0,
          min: `${minValue}${suffix}`,
          signed,
          size,
          value: `${value_}${suffix}`
        });
      }
      const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
      if (size)
        return (0, pad_js_1.pad)(hex, { size });
      return hex;
    }
    exports.numberToHex = numberToHex;
    var encoder = new TextEncoder();
    function stringToHex(value_, opts = {}) {
      const value = encoder.encode(value_);
      return bytesToHex(value, opts);
    }
    exports.stringToHex = stringToHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toBytes.js
var require_toBytes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toBytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;
    var base_js_1 = require_base();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var encoder = new TextEncoder();
    function toBytes(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToBytes(value, opts);
      if (typeof value === "boolean")
        return boolToBytes(value, opts);
      if ((0, isHex_js_1.isHex)(value))
        return hexToBytes(value, opts);
      return stringToBytes(value, opts);
    }
    exports.toBytes = toBytes;
    function boolToBytes(value, opts = {}) {
      const bytes = new Uint8Array(1);
      bytes[0] = Number(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { size: opts.size });
      }
      return bytes;
    }
    exports.boolToBytes = boolToBytes;
    var charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
    function charCodeToBase16(char) {
      if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
      if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
      if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
      return void 0;
    }
    function hexToBytes(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      let hexString = hex.slice(2);
      if (hexString.length % 2)
        hexString = `0${hexString}`;
      const length = hexString.length / 2;
      const bytes = new Uint8Array(length);
      for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === void 0 || nibbleRight === void 0) {
          throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
      }
      return bytes;
    }
    exports.hexToBytes = hexToBytes;
    function numberToBytes(value, opts) {
      const hex = (0, toHex_js_1.numberToHex)(value, opts);
      return hexToBytes(hex);
    }
    exports.numberToBytes = numberToBytes;
    function stringToBytes(value, opts = {}) {
      const bytes = encoder.encode(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { dir: "right", size: opts.size });
      }
      return bytes;
    }
    exports.stringToBytes = stringToBytes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromHex.js
var require_fromHex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromHex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = void 0;
    var encoding_js_1 = require_encoding();
    var size_js_1 = require_size();
    var trim_js_1 = require_trim();
    var toBytes_js_1 = require_toBytes();
    function assertSize(hexOrBytes, { size }) {
      if ((0, size_js_1.size)(hexOrBytes) > size)
        throw new encoding_js_1.SizeOverflowError({
          givenSize: (0, size_js_1.size)(hexOrBytes),
          maxSize: size
        });
    }
    exports.assertSize = assertSize;
    function fromHex(hex, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return hexToNumber(hex, opts);
      if (to === "bigint")
        return hexToBigInt(hex, opts);
      if (to === "string")
        return hexToString(hex, opts);
      if (to === "boolean")
        return hexToBool(hex, opts);
      return (0, toBytes_js_1.hexToBytes)(hex, opts);
    }
    exports.fromHex = fromHex;
    function hexToBigInt(hex, opts = {}) {
      const { signed } = opts;
      if (opts.size)
        assertSize(hex, { size: opts.size });
      const value = BigInt(hex);
      if (!signed)
        return value;
      const size = (hex.length - 2) / 2;
      const max = (1n << BigInt(size) * 8n - 1n) - 1n;
      if (value <= max)
        return value;
      return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
    }
    exports.hexToBigInt = hexToBigInt;
    function hexToBool(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
      }
      if ((0, trim_js_1.trim)(hex) === "0x00")
        return false;
      if ((0, trim_js_1.trim)(hex) === "0x01")
        return true;
      throw new encoding_js_1.InvalidHexBooleanError(hex);
    }
    exports.hexToBool = hexToBool;
    function hexToNumber(hex, opts = {}) {
      return Number(hexToBigInt(hex, opts));
    }
    exports.hexToNumber = hexToNumber;
    function hexToString(hex, opts = {}) {
      let bytes = (0, toBytes_js_1.hexToBytes)(hex);
      if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports.hexToString = hexToString;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/formatter.js
var require_formatter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/formatter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineFormatter = void 0;
    function defineFormatter(type, format) {
      return ({ exclude, format: overrides }) => {
        return {
          exclude,
          format: (args) => {
            const formatted = format(args);
            if (exclude) {
              for (const key of exclude) {
                delete formatted[key];
              }
            }
            return {
              ...formatted,
              ...overrides(args)
            };
          },
          type
        };
      };
    }
    exports.defineFormatter = defineFormatter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transaction.js
var require_transaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    exports.transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction(transaction) {
      const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : void 0,
        gas: transaction.gas ? BigInt(transaction.gas) : void 0,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : void 0,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? exports.transactionType[transaction.type] : void 0,
        typeHex: transaction.type ? transaction.type : void 0,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        v: transaction.v ? BigInt(transaction.v) : void 0
      };
      transaction_.yParity = (() => {
        if (transaction.yParity)
          return Number(transaction.yParity);
        if (typeof transaction_.v === "bigint") {
          if (transaction_.v === 0n || transaction_.v === 27n)
            return 0;
          if (transaction_.v === 1n || transaction_.v === 28n)
            return 1;
          if (transaction_.v >= 35n)
            return transaction_.v % 2n === 0n ? 1 : 0;
        }
        return void 0;
      })();
      if (transaction_.type === "legacy") {
        delete transaction_.accessList;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
        delete transaction_.yParity;
      }
      if (transaction_.type === "eip2930") {
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
      }
      return transaction_;
    }
    exports.formatTransaction = formatTransaction;
    exports.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/block.js
var require_block = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/block.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineBlock = exports.formatBlock = void 0;
    var formatter_js_1 = require_formatter();
    var transaction_js_1 = require_transaction();
    function formatBlock(block) {
      const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
      });
      return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : void 0,
        timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
      };
    }
    exports.formatBlock = formatBlock;
    exports.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/log.js
var require_log = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/log.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLog = void 0;
    function formatLog(log, { args, eventName } = {}) {
      return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? { args, eventName } : {}
      };
    }
    exports.formatLog = formatLog;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transactionReceipt.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionReceipt = exports.formatTransactionReceipt = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    var log_js_1 = require_log();
    var transaction_js_1 = require_transaction();
    var statuses = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt(transactionReceipt) {
      return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
      };
    }
    exports.formatTransactionReceipt = formatTransactionReceipt;
    exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/optimism/formatters.js
var require_formatters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/optimism/formatters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formattersOptimism = void 0;
    var fromHex_js_1 = require_fromHex();
    var block_js_1 = require_block();
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    exports.formattersOptimism = {
      block: (0, block_js_1.defineBlock)({
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            const formatted = (0, transaction_js_1.formatTransaction)(transaction);
            if (formatted.typeHex === "0x7e") {
              formatted.isSystemTx = transaction.isSystemTx;
              formatted.mint = transaction.mint ? (0, fromHex_js_1.hexToBigInt)(transaction.mint) : void 0;
              formatted.sourceHash = transaction.sourceHash;
              formatted.type = "deposit";
            }
            return formatted;
          });
          return {
            transactions,
            stateRoot: args.stateRoot
          };
        }
      }),
      transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
          const transaction = {};
          if (args.type === "0x7e") {
            transaction.isSystemTx = args.isSystemTx;
            transaction.mint = args.mint ? (0, fromHex_js_1.hexToBigInt)(args.mint) : void 0;
            transaction.sourceHash = args.sourceHash;
            transaction.type = "deposit";
          }
          return transaction;
        }
      }),
      transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
          return {
            l1GasPrice: args.l1GasPrice ? (0, fromHex_js_1.hexToBigInt)(args.l1GasPrice) : null,
            l1GasUsed: args.l1GasUsed ? (0, fromHex_js_1.hexToBigInt)(args.l1GasUsed) : null,
            l1Fee: args.l1Fee ? (0, fromHex_js_1.hexToBigInt)(args.l1Fee) : null,
            l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
          };
        }
      })
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/base.js
var require_base2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/base.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.base = (0, defineChain_js_1.defineChain)({
      id: 8453,
      network: "base",
      name: "Base",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://base-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://base-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://base-mainnet.infura.io/v3"],
          webSocket: ["wss://base-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://mainnet.base.org"]
        },
        public: {
          http: ["https://mainnet.base.org"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Basescout",
          url: "https://base.blockscout.com"
        },
        default: {
          name: "Basescan",
          url: "https://basescan.org"
        },
        etherscan: {
          name: "Basescan",
          url: "https://basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 5022
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/baseGoerli.js
var require_baseGoerli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/baseGoerli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baseGoerli = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.baseGoerli = (0, defineChain_js_1.defineChain)({
      id: 84531,
      network: "base-goerli",
      name: "Base Goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://base-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://base-goerli.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://goerli.base.org"]
        },
        public: {
          http: ["https://goerli.base.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        },
        default: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1376988
        }
      },
      testnet: true,
      sourceId: 5
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/baseSepolia.js
var require_baseSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/baseSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baseSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.baseSepolia = (0, defineChain_js_1.defineChain)({
      id: 84532,
      network: "base-sepolia",
      name: "Base Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://base-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://base-sepolia.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://sepolia.base.org"]
        },
        public: {
          http: ["https://sepolia.base.org"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout",
          url: "https://base-sepolia.blockscout.com"
        },
        default: {
          name: "Blockscout",
          url: "https://base-sepolia.blockscout.com"
        }
      },
      testnet: true,
      sourceId: 11155111
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js
var require_bearNetworkChainMainnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearNetworkChainMainnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bearNetworkChainMainnet = (0, defineChain_js_1.defineChain)({
      id: 641230,
      name: "Bear Network Chain Mainnet",
      network: "BearNetworkChainMainnet",
      nativeCurrency: {
        decimals: 18,
        name: "BearNetworkChain",
        symbol: "BRNKC"
      },
      rpcUrls: {
        public: { http: ["https://brnkc-mainnet.bearnetwork.net"] },
        default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
      },
      blockExplorers: {
        default: { name: "BrnkScan", url: "https://brnkscan.bearnetwork.net" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js
var require_bearNetworkChainTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearNetworkChainTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bearNetworkChainTestnet = (0, defineChain_js_1.defineChain)({
      id: 751230,
      name: "Bear Network Chain Testnet",
      network: "BearNetworkChainTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "tBRNKC",
        symbol: "tBRNKC"
      },
      rpcUrls: {
        public: { http: ["https://brnkc-test.bearnetwork.net"] },
        default: { http: ["https://brnkc-test.bearnetwork.net"] }
      },
      blockExplorers: {
        default: {
          name: "BrnkTestScan",
          url: "https://brnktest-scan.bearnetwork.net"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bitTorrent.js
var require_bitTorrent = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bitTorrent.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitTorrent = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bitTorrent = (0, defineChain_js_1.defineChain)({
      id: 199,
      name: "BitTorrent",
      network: "bittorrent-chain-mainnet",
      nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc.bittorrentchain.io"] },
        public: { http: ["https://rpc.bittorrentchain.io"] }
      },
      blockExplorers: {
        etherscan: { name: "Bttcscan", url: "https://bttcscan.com" },
        default: { name: "Bttcscan", url: "https://bttcscan.com" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js
var require_bitTorrentTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bitTorrentTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitTorrentTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bitTorrentTestnet = (0, defineChain_js_1.defineChain)({
      id: 1028,
      name: "BitTorrent Chain Testnet",
      network: "bittorrent-chain-testnet",
      nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://testrpc.bittorrentchain.io"] },
        public: { http: ["https://testrpc.bittorrentchain.io"] }
      },
      blockExplorers: {
        etherscan: { name: "Bttcscan", url: "https://testnet.bttcscan.com" },
        default: { name: "Bttcscan", url: "https://testnet.bttcscan.com" }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/boba.js
var require_boba = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/boba.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boba = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.boba = (0, defineChain_js_1.defineChain)({
      id: 288,
      name: "Boba Network",
      network: "boba",
      nativeCurrency: {
        decimals: 18,
        name: "Boba",
        symbol: "BOBA"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.boba.network"] },
        public: { http: ["https://mainnet.boba.network"] }
      },
      blockExplorers: {
        etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
        default: { name: "BOBAScan", url: "https://bobascan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 446859
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bronos.js
var require_bronos = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bronos.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bronos = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bronos = (0, defineChain_js_1.defineChain)({
      id: 1039,
      name: "Bronos",
      network: "bronos",
      nativeCurrency: {
        decimals: 18,
        name: "BRO",
        symbol: "BRO"
      },
      rpcUrls: {
        default: { http: ["https://evm.bronos.org"] },
        public: { http: ["https://evm.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://broscan.bronos.org" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bronosTestnet.js
var require_bronosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bronosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bronosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bronosTestnet = (0, defineChain_js_1.defineChain)({
      id: 1038,
      name: "Bronos Testnet",
      network: "bronos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Bronos Coin",
        symbol: "tBRO"
      },
      rpcUrls: {
        default: { http: ["https://evm-testnet.bronos.org"] },
        public: { http: ["https://evm-testnet.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bsc.js
var require_bsc = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bsc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bsc = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bsc = (0, defineChain_js_1.defineChain)({
      id: 56,
      name: "BNB Smart Chain",
      network: "bsc",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/bsc"] },
        public: { http: ["https://rpc.ankr.com/bsc"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://bscscan.com" },
        default: { name: "BscScan", url: "https://bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 15921452
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bscTestnet.js
var require_bscTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bscTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bscTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bscTestnet = (0, defineChain_js_1.defineChain)({
      id: 97,
      name: "Binance Smart Chain Testnet",
      network: "bsc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "tBNB"
      },
      rpcUrls: {
        default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] },
        public: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
        default: { name: "BscScan", url: "https://testnet.bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 17422483
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bxn.js
var require_bxn = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bxn.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bxn = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bxn = (0, defineChain_js_1.defineChain)({
      id: 4999,
      name: "BlackFort Exchange Network",
      network: "bxn",
      nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.blackfort.network/rpc"]
        },
        public: {
          http: ["https://mainnet.blackfort.network/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://explorer.blackfort.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bxnTestnet.js
var require_bxnTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/bxnTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bxnTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.bxnTestnet = (0, defineChain_js_1.defineChain)({
      id: 4777,
      name: "BlackFort Exchange Network Testnet",
      network: "bxnTestnet",
      nativeCurrency: {
        name: "BlackFort Testnet Token",
        symbol: "TBXN",
        decimals: 18
      },
      rpcUrls: {
        default: {
          http: ["https://testnet.blackfort.network/rpc"]
        },
        public: {
          http: ["https://testnet.blackfort.network/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://testnet-explorer.blackfort.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/canto.js
var require_canto = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/canto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canto = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.canto = (0, defineChain_js_1.defineChain)({
      id: 7700,
      name: "Canto",
      network: "canto",
      nativeCurrency: {
        decimals: 18,
        name: "Canto",
        symbol: "CANTO"
      },
      rpcUrls: {
        default: { http: ["https://canto.gravitychain.io"] },
        public: { http: ["https://canto.gravitychain.io"] }
      },
      blockExplorers: {
        default: {
          name: "Tuber.Build (Blockscout)",
          url: "https://tuber.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2905789
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transactionRequest.js
var require_transactionRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/transactionRequest.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionRequest = exports.formatTransactionRequest = exports.rpcTransactionType = void 0;
    var toHex_js_1 = require_toHex();
    var formatter_js_1 = require_formatter();
    exports.rpcTransactionType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2"
    };
    function formatTransactionRequest(transactionRequest) {
      return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gas) : void 0,
        gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gasPrice) : void 0,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxPriorityFeePerGas) : void 0,
        nonce: typeof transactionRequest.nonce !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.nonce) : void 0,
        type: typeof transactionRequest.type !== "undefined" ? exports.rpcTransactionType[transactionRequest.type] : void 0,
        value: typeof transactionRequest.value !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.value) : void 0
      };
    }
    exports.formatTransactionRequest = formatTransactionRequest;
    exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)("transactionRequest", formatTransactionRequest);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/utils.js
var require_utils2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCIP64 = exports.isCIP42 = exports.isEIP1559 = exports.isPresent = exports.isEmpty = void 0;
    var trim_js_1 = require_trim();
    function isEmpty(value) {
      return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && ((0, trim_js_1.trim)(value).toLowerCase() === "0x" || (0, trim_js_1.trim)(value).toLowerCase() === "0x00");
    }
    exports.isEmpty = isEmpty;
    function isPresent(value) {
      return !isEmpty(value);
    }
    exports.isPresent = isPresent;
    function isEIP1559(transaction) {
      return isPresent(transaction.maxFeePerGas) && isPresent(transaction.maxPriorityFeePerGas);
    }
    exports.isEIP1559 = isEIP1559;
    function isCIP42(transaction) {
      if (transaction.type === "cip42") {
        return true;
      }
      return isEIP1559(transaction) && (isPresent(transaction.feeCurrency) || isPresent(transaction.gatewayFeeRecipient) || isPresent(transaction.gatewayFee));
    }
    exports.isCIP42 = isCIP42;
    function isCIP64(transaction) {
      if (transaction.type === "cip64") {
        return true;
      }
      return isEIP1559(transaction) && isPresent(transaction.feeCurrency) && isEmpty(transaction.gatewayFee) && isEmpty(transaction.gatewayFeeRecipient);
    }
    exports.isCIP64 = isCIP64;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/formatters.js
var require_formatters2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/formatters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formattersCelo = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var block_js_1 = require_block();
    var transaction_js_1 = require_transaction();
    var transactionRequest_js_1 = require_transactionRequest();
    var utils_js_1 = require_utils2();
    exports.formattersCelo = {
      block: (0, block_js_1.defineBlock)({
        exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            return {
              ...(0, transaction_js_1.formatTransaction)(transaction),
              feeCurrency: transaction.feeCurrency,
              ...transaction.type !== "0x7b" ? {
                gatewayFee: transaction.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(transaction.gatewayFee) : null,
                gatewayFeeRecipient: transaction.gatewayFeeRecipient || null
              } : {}
            };
          });
          return {
            randomness: args.randomness,
            transactions
          };
        }
      }),
      transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
          const transaction = { feeCurrency: args.feeCurrency };
          if (args.type === "0x7b")
            transaction.type = "cip64";
          else {
            if (args.type === "0x7c")
              transaction.type = "cip42";
            transaction.gatewayFee = args.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(args.gatewayFee) : null;
            transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
          }
          return transaction;
        }
      }),
      transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
        format(args) {
          const request = {
            feeCurrency: args.feeCurrency
          };
          if ((0, utils_js_1.isCIP64)(args))
            request.type = "0x7b";
          else {
            if ((0, utils_js_1.isCIP42)(args))
              request.type = "0x7c";
            request.gatewayFee = typeof args.gatewayFee !== "undefined" ? (0, toHex_js_1.numberToHex)(args.gatewayFee) : void 0;
            request.gatewayFeeRecipient = args.gatewayFeeRecipient;
          }
          return request;
        }
      })
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/address.js
var require_address = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAddressError = void 0;
    var base_js_1 = require_base();
    var InvalidAddressError = class extends base_js_1.BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
    exports.InvalidAddressError = InvalidAddressError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/chain.js
var require_chain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/chain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = void 0;
    var base_js_1 = require_base();
    var ChainDoesNotSupportContract = class extends base_js_1.BaseError {
      constructor({ blockNumber, chain, contract }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
          metaMessages: [
            "This could be due to any of the following:",
            ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
              `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
            ] : [
              `- The chain does not have the contract "${contract.name}" configured.`
            ]
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDoesNotSupportContract"
        });
      }
    };
    exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
    var ChainMismatchError = class extends base_js_1.BaseError {
      constructor({ chain, currentChainId }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
          metaMessages: [
            `Current Chain ID:  ${currentChainId}`,
            `Expected Chain ID: ${chain.id} – ${chain.name}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainMismatchError"
        });
      }
    };
    exports.ChainMismatchError = ChainMismatchError;
    var ChainNotFoundError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "No chain was provided to the request.",
          "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainNotFoundError"
        });
      }
    };
    exports.ChainNotFoundError = ChainNotFoundError;
    var ClientChainNotConfiguredError = class extends base_js_1.BaseError {
      constructor() {
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ClientChainNotConfiguredError"
        });
      }
    };
    exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
    var InvalidChainIdError = class extends base_js_1.BaseError {
      constructor({ chainId }) {
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidChainIdError"
        });
      }
    };
    exports.InvalidChainIdError = InvalidChainIdError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/unit.js
var require_unit = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/unit.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.weiUnits = exports.gweiUnits = exports.etherUnits = void 0;
    exports.etherUnits = {
      gwei: 9,
      wei: 18
    };
    exports.gweiUnits = {
      ether: -9,
      wei: 9
    };
    exports.weiUnits = {
      ether: -18,
      gwei: -9
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatUnits.js
var require_formatUnits = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatUnits.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatUnits = void 0;
    function formatUnits(value, decimals) {
      let display = value.toString();
      const negative = display.startsWith("-");
      if (negative)
        display = display.slice(1);
      display = display.padStart(decimals, "0");
      let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
      ];
      fraction = fraction.replace(/(0+)$/, "");
      return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
    }
    exports.formatUnits = formatUnits;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatGwei.js
var require_formatGwei = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatGwei.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatGwei = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatGwei(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
    }
    exports.formatGwei = formatGwei;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/node.js
var require_node = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/node.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var ExecutionRevertedError = class extends base_js_1.BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    exports.ExecutionRevertedError = ExecutionRevertedError;
    var FeeCapTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooHigh"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    exports.FeeCapTooHighError = FeeCapTooHighError;
    var FeeCapTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooLow"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    exports.FeeCapTooLowError = FeeCapTooLowError;
    var NonceTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooHighError"
        });
      }
    };
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    exports.NonceTooHighError = NonceTooHighError;
    var NonceTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooLowError"
        });
      }
    };
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    exports.NonceTooLowError = NonceTooLowError;
    var NonceMaxValueError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceMaxValueError"
        });
      }
    };
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    exports.NonceMaxValueError = NonceMaxValueError;
    var InsufficientFundsError = class extends base_js_1.BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds/
    });
    exports.InsufficientFundsError = InsufficientFundsError;
    var IntrinsicGasTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
    var IntrinsicGasTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
    var TransactionTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
    var TipAboveFeeCapError = class extends base_js_1.BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    exports.TipAboveFeeCapError = TipAboveFeeCapError;
    var UnknownNodeError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownNodeError"
        });
      }
    };
    exports.UnknownNodeError = UnknownNodeError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/isAddress.js
var require_isAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/isAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddress = void 0;
    var addressRegex = /^0x[a-fA-F0-9]{40}$/;
    function isAddress(address) {
      return addressRegex.test(address);
    }
    exports.isAddress = isAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/concat.js
var require_concat = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/concat.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = void 0;
    function concat(values) {
      if (typeof values[0] === "string")
        return concatHex(values);
      return concatBytes(values);
    }
    exports.concat = concat;
    function concatBytes(values) {
      let length = 0;
      for (const arr of values) {
        length += arr.length;
      }
      const result = new Uint8Array(length);
      let offset = 0;
      for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    function concatHex(values) {
      return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
    }
    exports.concatHex = concatHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/version.js
var require_version3 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/version.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.9.8";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/errors.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var version_js_1 = require_version3();
    var BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version_js_1.version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    };
    exports.BaseError = BaseError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/narrow.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.narrow = void 0;
    function narrow(value) {
      return value;
    }
    exports.narrow = narrow;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/regex.js
var require_regex2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/regex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = void 0;
    function execTyped(regex, string) {
      const match = regex.exec(string);
      return match?.groups;
    }
    exports.execTyped = execTyped;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    exports.isTupleRegex = /^\(.+?\).*?$/;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js
var require_formatAbiParameter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameter = void 0;
    var regex_js_1 = require_regex2();
    var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    function formatAbiParameter(abiParameter) {
      let type = abiParameter.type;
      if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
        type = "(";
        const length = abiParameter.components.length;
        for (let i = 0; i < length; i++) {
          const component = abiParameter.components[i];
          type += formatAbiParameter(component);
          if (i < length - 1)
            type += ", ";
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ""}`;
        return formatAbiParameter({
          ...abiParameter,
          type
        });
      }
      if ("indexed" in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
      if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
      return type;
    }
    exports.formatAbiParameter = formatAbiParameter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js
var require_formatAbiParameters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameters = void 0;
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    function formatAbiParameters(abiParameters) {
      let params = "";
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i !== length - 1)
          params += ", ";
      }
      return params;
    }
    exports.formatAbiParameters = formatAbiParameters;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js
var require_formatAbiItem = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItem = void 0;
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    function formatAbiItem(abiItem) {
      if (abiItem.type === "function")
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})` : ""}`;
      else if (abiItem.type === "event")
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "error")
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "constructor")
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
      else if (abiItem.type === "fallback")
        return "fallback()";
      return "receive() external payable";
    }
    exports.formatAbiItem = formatAbiItem;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbi.js
var require_formatAbi = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/formatAbi.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbi = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem();
    function formatAbi(abi) {
      const signatures = [];
      const length = abi.length;
      for (let i = 0; i < length; i++) {
        const abiItem = abi[i];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
      }
      return signatures;
    }
    exports.formatAbi = formatAbi;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = void 0;
    var regex_js_1 = require_regex2();
    var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isErrorSignature(signature) {
      return errorSignatureRegex.test(signature);
    }
    exports.isErrorSignature = isErrorSignature;
    function execErrorSignature(signature) {
      return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
    }
    exports.execErrorSignature = execErrorSignature;
    var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isEventSignature(signature) {
      return eventSignatureRegex.test(signature);
    }
    exports.isEventSignature = isEventSignature;
    function execEventSignature(signature) {
      return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
    }
    exports.execEventSignature = execEventSignature;
    var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    function isFunctionSignature(signature) {
      return functionSignatureRegex.test(signature);
    }
    exports.isFunctionSignature = isFunctionSignature;
    function execFunctionSignature(signature) {
      return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
    }
    exports.execFunctionSignature = execFunctionSignature;
    var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
    function isStructSignature(signature) {
      return structSignatureRegex.test(signature);
    }
    exports.isStructSignature = isStructSignature;
    function execStructSignature(signature) {
      return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
    }
    exports.execStructSignature = execStructSignature;
    var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    function isConstructorSignature(signature) {
      return constructorSignatureRegex.test(signature);
    }
    exports.isConstructorSignature = isConstructorSignature;
    function execConstructorSignature(signature) {
      return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
    }
    exports.execConstructorSignature = execConstructorSignature;
    var fallbackSignatureRegex = /^fallback\(\)$/;
    function isFallbackSignature(signature) {
      return fallbackSignatureRegex.test(signature);
    }
    exports.isFallbackSignature = isFallbackSignature;
    var receiveSignatureRegex = /^receive\(\) external payable$/;
    function isReceiveSignature(signature) {
      return receiveSignatureRegex.test(signature);
    }
    exports.isReceiveSignature = isReceiveSignature;
    exports.modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    exports.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    exports.functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiItemError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human.html#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    };
    exports.InvalidAbiItemError = InvalidAbiItemError;
    var UnknownTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    };
    exports.UnknownTypeError = UnknownTypeError;
    var UnknownSolidityTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    };
    exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Failed to parse ABI parameter.", {
          details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameter-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParameterError"
        });
      }
    };
    exports.InvalidAbiParameterError = InvalidAbiParameterError;
    var InvalidAbiParametersError = class extends errors_js_1.BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    };
    exports.InvalidAbiParametersError = InvalidAbiParametersError;
    var InvalidParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    };
    exports.InvalidParameterError = InvalidParameterError;
    var SolidityProtectedKeywordError = class extends errors_js_1.BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    };
    exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
    var InvalidModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    };
    exports.InvalidModifierError = InvalidModifierError;
    var InvalidFunctionModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    };
    exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
    var InvalidAbiTypeParameterError = class extends errors_js_1.BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    };
    exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/signature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
    var errors_js_1 = require_errors();
    var InvalidSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature, type }) {
        super(`Invalid ${type} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    };
    exports.InvalidSignatureError = InvalidSignatureError;
    var UnknownSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    };
    exports.UnknownSignatureError = UnknownSignatureError;
    var InvalidStructSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    };
    exports.InvalidStructSignatureError = InvalidStructSignatureError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/struct.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = void 0;
    var errors_js_1 = require_errors();
    var CircularReferenceError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    };
    exports.CircularReferenceError = CircularReferenceError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidParenthesisError = void 0;
    var errors_js_1 = require_errors();
    var InvalidParenthesisError = class extends errors_js_1.BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    };
    exports.InvalidParenthesisError = InvalidParenthesisError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parameterCache = exports.getParameterCacheKey = void 0;
    function getParameterCacheKey(param, type) {
      if (type)
        return `${type}:${param}`;
      return param;
    }
    exports.getParameterCacheKey = getParameterCacheKey;
    exports.parameterCache = /* @__PURE__ */ new Map([
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils3 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;
    var regex_js_1 = require_regex2();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var splitParameters_js_1 = require_splitParameters();
    var cache_js_1 = require_cache();
    var signatures_js_1 = require_signatures();
    function parseSignature(signature, structs = {}) {
      if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "function" });
        const inputParams = splitParameters(match.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i = 0; i < inputLength; i++) {
          inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
        const outputs = [];
        if (match.returns) {
          const outputParams = splitParameters(match.returns);
          const outputLength = outputParams.length;
          for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
              modifiers: signatures_js_1.functionModifiers,
              structs,
              type: "function"
            }));
          }
        }
        return {
          name: match.name,
          type: "function",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs,
          outputs
        };
      }
      if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match = (0, signatures_js_1.execEventSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "event" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: "event"
          }));
        }
        return { name: match.name, type: "event", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "error" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
        }
        return { name: match.name, type: "error", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "constructor" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
        }
        return {
          type: "constructor",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs: abiParameters
        };
      }
      if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: "fallback" };
      if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
          type: "receive",
          stateMutability: "payable"
        };
      throw new signature_js_1.UnknownSignatureError({ signature });
    }
    exports.parseSignature = parseSignature;
    var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var dynamicIntegerRegex = /^u?int$/;
    function parseAbiParameter(param, options) {
      const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
      if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
      const isTuple = regex_js_1.isTupleRegex.test(param);
      const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
      if (!match)
        throw new abiParameter_js_1.InvalidParameterError({ param });
      if (match.name && isSolidityKeyword(match.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
      const name = match.name ? { name: match.name } : {};
      const indexed = match.modifier === "indexed" ? { indexed: true } : {};
      const structs = options?.structs ?? {};
      let type;
      let components = {};
      if (isTuple) {
        type = "tuple";
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
      } else if (match.type in structs) {
        type = "tuple";
        components = { components: structs[match.type] };
      } else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
      } else {
        type = match.type;
        if (!(options?.type === "struct") && !isSolidityType(type))
          throw new abiItem_js_1.UnknownSolidityTypeError({ type });
      }
      if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
          throw new abiParameter_js_1.InvalidModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
        if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
          throw new abiParameter_js_1.InvalidFunctionModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
      }
      const abiParameter = {
        type: `${type}${match.array ?? ""}`,
        ...name,
        ...indexed,
        ...components
      };
      cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
    function splitParameters(params, result = [], current = "", depth = 0) {
      if (params === "") {
        if (current === "")
          return result;
        if (depth !== 0)
          throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
      }
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
          case ",":
            return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
          case "(":
            return splitParameters(tail, result, `${current}${char}`, depth + 1);
          case ")":
            return splitParameters(tail, result, `${current}${char}`, depth - 1);
          default:
            return splitParameters(tail, result, `${current}${char}`, depth);
        }
      }
      return [];
    }
    exports.splitParameters = splitParameters;
    function isSolidityType(type) {
      return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
    }
    exports.isSolidityType = isSolidityType;
    var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    function isSolidityKeyword(name) {
      return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
    }
    exports.isSolidityKeyword = isSolidityKeyword;
    function isValidDataLocation(type, isArray) {
      return isArray || type === "bytes" || type === "string" || type === "tuple";
    }
    exports.isValidDataLocation = isValidDataLocation;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStructs = void 0;
    var regex_js_1 = require_regex2();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var struct_js_1 = require_struct();
    var signatures_js_1 = require_signatures();
    var utils_js_1 = require_utils3();
    function parseStructs(signatures) {
      const shallowStructs = {};
      const signaturesLength = signatures.length;
      for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
          continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "struct" });
        const properties = match.properties.split(";");
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
          const property = properties[k];
          const trimmed = property.trim();
          if (!trimmed)
            continue;
          const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
            type: "struct"
          });
          components.push(abiParameter);
        }
        if (!components.length)
          throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
      }
      const resolvedStructs = {};
      const entries = Object.entries(shallowStructs);
      const entriesLength = entries.length;
      for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
      }
      return resolvedStructs;
    }
    exports.parseStructs = parseStructs;
    var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
      const components = [];
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
          components.push(abiParameter);
        else {
          const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
          if (!match?.type)
            throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
          const { array, type } = match;
          if (type in structs) {
            if (ancestors.has(type))
              throw new struct_js_1.CircularReferenceError({ type });
            components.push({
              ...abiParameter,
              type: `tuple${array ?? ""}`,
              components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
            });
          } else {
            if ((0, utils_js_1.isSolidityType)(type))
              components.push(abiParameter);
            else
              throw new abiItem_js_1.UnknownTypeError({ type });
          }
        }
      }
      return components;
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbi.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbi = void 0;
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils3();
    function parseAbi(signatures) {
      const structs = (0, structs_js_1.parseStructs)(signatures);
      const abi = [];
      const length = signatures.length;
      for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
      }
      return abi;
    }
    exports.parseAbi = parseAbi;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiItem = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils3();
    function parseAbiItem(signature) {
      let abiItem;
      if (typeof signature === "string")
        abiItem = (0, utils_js_1.parseSignature)(signature);
      else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
          const signature_ = signature[i];
          if ((0, signatures_js_1.isStructSignature)(signature_))
            continue;
          abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
          break;
        }
      }
      if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
      return abiItem;
    }
    exports.parseAbiItem = parseAbiItem;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameter = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils3();
    function parseAbiParameter(param) {
      let abiParameter;
      if (typeof param === "string")
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
          modifiers: signatures_js_1.modifiers
        });
      else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
          const signature = param[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
          break;
        }
      }
      if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameters = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils3();
    var utils_js_2 = require_utils3();
    function parseAbiParameters(params) {
      const abiParameters = [];
      if (typeof params === "string") {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
        }
      } else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
          const signature = params[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          const parameters = (0, utils_js_1.splitParameters)(signature);
          const length2 = parameters.length;
          for (let k = 0; k < length2; k++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
          }
        }
      }
      if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
      return abiParameters;
    }
    exports.parseAbiParameters = parseAbiParameters;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/abitype/dist/cjs/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
    var errors_js_1 = require_errors();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return errors_js_1.BaseError;
    } });
    var narrow_js_1 = require_narrow();
    Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var formatAbi_js_1 = require_formatAbi();
    Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function() {
      return formatAbi_js_1.formatAbi;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function() {
      return formatAbiParameter_js_1.formatAbiParameter;
    } });
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function() {
      return formatAbiParameters_js_1.formatAbiParameters;
    } });
    var parseAbi_js_1 = require_parseAbi();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = require_parseAbiItem();
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = require_parseAbiParameter();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = require_parseAbiParameters();
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
    var abiItem_js_1 = require_abiItem();
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownSolidityTypeError;
    } });
    var abiParameter_js_1 = require_abiParameter();
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParameterError;
    } });
    var signature_js_1 = require_signature();
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_1.UnknownSignatureError;
    } });
    var splitParameters_js_1 = require_splitParameters();
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_1.InvalidParenthesisError;
    } });
    var struct_js_1 = require_struct();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_1.CircularReferenceError;
    } });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/getAction.js
var require_getAction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/getAction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAction = void 0;
    function getAction(client, action, name) {
      return (params) => client[action.name || name]?.(params) ?? action(client, params);
    }
    exports.getAction = getAction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/formatAbiItem.js
var require_formatAbiItem2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/formatAbiItem.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParams = exports.formatAbiItem = void 0;
    var abi_js_1 = require_abi();
    function formatAbiItem(abiItem, { includeName = false } = {}) {
      if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
      return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
    }
    exports.formatAbiItem = formatAbiItem;
    function formatAbiParams(params, { includeName = false } = {}) {
      if (!params)
        return "";
      return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
    }
    exports.formatAbiParams = formatAbiParams;
    function formatAbiParam(param, { includeName }) {
      if (param.type.startsWith("tuple")) {
        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
      }
      return param.type + (includeName && param.name ? ` ${param.name}` : "");
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/abi.js
var require_abi = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/abi.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiItemAmbiguityError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var size_js_1 = require_size();
    var base_js_1 = require_base();
    var AbiConstructorNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "A constructor was not found on the ABI.",
          "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorNotFoundError"
        });
      }
    };
    exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
    var AbiConstructorParamsNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
          "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorParamsNotFoundError"
        });
      }
    };
    exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
    var AbiDecodingDataSizeInvalidError = class extends base_js_1.BaseError {
      constructor({ data, size }) {
        super([
          `Data size of ${size} bytes is invalid.`,
          "Size must be in increments of 32 bytes (size % 32 === 0)."
        ].join("\n"), { metaMessages: [`Data: ${data} (${size} bytes)`] });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeInvalidError"
        });
      }
    };
    exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
    var AbiDecodingDataSizeTooSmallError = class extends base_js_1.BaseError {
      constructor({ data, params, size }) {
        super([`Data size of ${size} bytes is too small for given parameters.`].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
    var AbiDecodingZeroDataError = class extends base_js_1.BaseError {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingZeroDataError"
        });
      }
    };
    exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
    var AbiEncodingArrayLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
    var AbiEncodingBytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
    var AbiEncodingLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
    var AbiErrorInputsNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath }) {
        super([
          `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
          "Cannot encode error result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the inputs exist on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorInputsNotFoundError"
        });
      }
    };
    exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
    var AbiErrorNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath } = {}) {
        super([
          `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorNotFoundError"
        });
      }
    };
    exports.AbiErrorNotFoundError = AbiErrorNotFoundError;
    var AbiErrorSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded error signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorSignatureNotFoundError"
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.signature = signature;
      }
    };
    exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
    var AbiEventSignatureEmptyTopicsError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super("Cannot extract event signature from empty topics.", {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureEmptyTopicsError"
        });
      }
    };
    exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
    var AbiEventSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded event signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureNotFoundError"
        });
      }
    };
    exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
    var AbiEventNotFoundError = class extends base_js_1.BaseError {
      constructor(eventName, { docsPath } = {}) {
        super([
          `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventNotFoundError"
        });
      }
    };
    exports.AbiEventNotFoundError = AbiEventNotFoundError;
    var AbiFunctionNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
    var AbiFunctionOutputsNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath }) {
        super([
          `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
          "Cannot decode function result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionOutputsNotFoundError"
        });
      }
    };
    exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
    var AbiFunctionSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded function signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionSignatureNotFoundError"
        });
      }
    };
    exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
    var AbiItemAmbiguityError = class extends base_js_1.BaseError {
      constructor(x, y) {
        super("Found ambiguous types in overloaded ABI items.", {
          metaMessages: [
            `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
            `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
            "",
            "These types encode differently and cannot be distinguished at runtime.",
            "Remove one of the ambiguous items in the ABI."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiItemAmbiguityError"
        });
      }
    };
    exports.AbiItemAmbiguityError = AbiItemAmbiguityError;
    var BytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BytesSizeMismatchError"
        });
      }
    };
    exports.BytesSizeMismatchError = BytesSizeMismatchError;
    var DecodeLogDataMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, data, params, size }) {
        super([
          `Data size of ${size} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports.DecodeLogDataMismatch = DecodeLogDataMismatch;
    var DecodeLogTopicsMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
      }
    };
    exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
    var InvalidAbiEncodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
    var InvalidAbiDecodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid decoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiDecodingType"
        });
      }
    };
    exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
    var InvalidArrayError = class extends base_js_1.BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    exports.InvalidArrayError = InvalidArrayError;
    var InvalidDefinitionTypeError = class extends base_js_1.BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
    exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
    var UnsupportedPackedAbiType = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedPackedAbiType"
        });
      }
    };
    exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/log.js
var require_log2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/log.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterTypeNotSupportedError = void 0;
    var base_js_1 = require_base();
    var FilterTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
    exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/normalizeSignature.js
var require_normalizeSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/normalizeSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeSignature = void 0;
    var base_js_1 = require_base();
    function normalizeSignature(signature) {
      let active = true;
      let current = "";
      let level = 0;
      let result = "";
      let valid = false;
      for (let i = 0; i < signature.length; i++) {
        const char = signature[i];
        if (["(", ")", ","].includes(char))
          active = true;
        if (char === "(")
          level++;
        if (char === ")")
          level--;
        if (!active)
          continue;
        if (level === 0) {
          if (char === " " && ["event", "function", ""].includes(result))
            result = "";
          else {
            result += char;
            if (char === ")") {
              valid = true;
              break;
            }
          }
          continue;
        }
        if (char === " ") {
          if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
            current = "";
            active = false;
          }
          continue;
        }
        result += char;
        current += char;
      }
      if (!valid)
        throw new base_js_1.BaseError("Unable to normalize signature.");
      return result;
    }
    exports.normalizeSignature = normalizeSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getFunctionSignature.js
var require_getFunctionSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getFunctionSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionSignature = void 0;
    var abitype_1 = require_cjs();
    var normalizeSignature_js_1 = require_normalizeSignature();
    var getFunctionSignature = (fn_) => {
      const fn = (() => {
        if (typeof fn_ === "string")
          return fn_;
        return (0, abitype_1.formatAbiItem)(fn_);
      })();
      return (0, normalizeSignature_js_1.normalizeSignature)(fn);
    };
    exports.getFunctionSignature = getFunctionSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getEventSignature.js
var require_getEventSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getEventSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventSignature = void 0;
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    var getEventSignature = (fn) => {
      return (0, getFunctionSignature_js_1.getFunctionSignature)(fn);
    };
    exports.getEventSignature = getEventSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/utils.js
var require_utils4 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils4();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/keccak256.js
var require_keccak256 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/keccak256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var sha3_1 = require_sha3();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function keccak256(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports.keccak256 = keccak256;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getEventSelector.js
var require_getEventSelector = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getEventSelector.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventSelector = void 0;
    var toBytes_js_1 = require_toBytes();
    var getEventSignature_js_1 = require_getEventSignature();
    var keccak256_js_1 = require_keccak256();
    var hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    var getEventSelector = (fn) => hash((0, getEventSignature_js_1.getEventSignature)(fn));
    exports.getEventSelector = getEventSelector;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/slice.js
var require_slice = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/slice.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sliceHex = exports.sliceBytes = exports.slice = void 0;
    var data_js_1 = require_data();
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function slice(value, start, end, { strict } = {}) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex(value, start, end, {
          strict
        });
      return sliceBytes(value, start, end, {
        strict
      });
    }
    exports.slice = slice;
    function assertStartOffset(value, start) {
      if (typeof start === "number" && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: start,
          position: "start",
          size: (0, size_js_1.size)(value)
        });
    }
    function assertEndOffset(value, start, end) {
      if (typeof start === "number" && typeof end === "number" && (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: end,
          position: "end",
          size: (0, size_js_1.size)(value)
        });
      }
    }
    function sliceBytes(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = value_.slice(start, end);
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports.sliceBytes = sliceBytes;
    function sliceHex(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports.sliceHex = sliceHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js
var require_encodeAbiParameters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayComponents = exports.encodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var toHex_js_1 = require_toHex();
    function encodeAbiParameters(params, values) {
      if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: params.length,
          givenLength: values.length
        });
      const preparedParams = prepareParams({
        params,
        values
      });
      const data = encodeParams(preparedParams);
      if (data.length === 0)
        return "0x";
      return data;
    }
    exports.encodeAbiParameters = encodeAbiParameters;
    function prepareParams({ params, values }) {
      const preparedParams = [];
      for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
      }
      return preparedParams;
    }
    function prepareParam({ param, value }) {
      const arrayComponents = getArrayComponents(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, { length, param: { ...param, type } });
      }
      if (param.type === "tuple") {
        return encodeTuple(value, {
          param
        });
      }
      if (param.type === "address") {
        return encodeAddress(value);
      }
      if (param.type === "bool") {
        return encodeBool(value);
      }
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber(value, { signed });
      }
      if (param.type.startsWith("bytes")) {
        return encodeBytes(value, { param });
      }
      if (param.type === "string") {
        return encodeString(value);
      }
      throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
      });
    }
    function encodeParams(preparedParams) {
      let staticSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
          staticSize += 32;
        else
          staticSize += (0, size_js_1.size)(encoded);
      }
      const staticParams = [];
      const dynamicParams = [];
      let dynamicSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
          staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
          dynamicParams.push(encoded);
          dynamicSize += (0, size_js_1.size)(encoded);
        } else {
          staticParams.push(encoded);
        }
      }
      return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
    }
    function encodeAddress(value) {
      if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
    }
    function encodeArray(value, { length, param }) {
      const dynamic = length === null;
      if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
      if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
          expectedLength: length,
          givenLength: value.length,
          type: `${param.type}[${length}]`
        });
      let dynamicChild = false;
      const preparedParams = [];
      for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam({ param, value: value[i] });
        if (preparedParam.dynamic)
          dynamicChild = true;
        preparedParams.push(preparedParam);
      }
      if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
          const length2 = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
          return {
            dynamic: true,
            encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length2, data]) : length2
          };
        }
        if (dynamicChild)
          return { dynamic: true, encoded: data };
      }
      return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function encodeBytes(value, { param }) {
      const [, paramSize] = param.type.split("bytes");
      const bytesSize = (0, size_js_1.size)(value);
      if (!paramSize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
          value_ = (0, pad_js_1.padHex)(value_, {
            dir: "right",
            size: Math.ceil((value.length - 2) / 2 / 32) * 32
          });
        return {
          dynamic: true,
          encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_])
        };
      }
      if (bytesSize !== parseInt(paramSize))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
          expectedSize: parseInt(paramSize),
          value
        });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: "right" }) };
    }
    function encodeBool(value) {
      return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
    }
    function encodeNumber(value, { signed }) {
      return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
          size: 32,
          signed
        })
      };
    }
    function encodeString(value) {
      const hexValue = (0, toHex_js_1.stringToHex)(value);
      const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
      const parts = [];
      for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
          (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
          ...parts
        ])
      };
    }
    function encodeTuple(value, { param }) {
      let dynamic = false;
      const preparedParams = [];
      for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
          param: param_,
          value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
          dynamic = true;
      }
      return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function getArrayComponents(type) {
      const matches = type.match(/^(.*)\[(\d+)?\]$/);
      return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
    }
    exports.getArrayComponents = getArrayComponents;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getFunctionSelector.js
var require_getFunctionSelector = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/getFunctionSelector.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionSelector = void 0;
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    var keccak256_js_1 = require_keccak256();
    var hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    var getFunctionSelector = (fn) => (0, slice_js_1.slice)(hash((0, getFunctionSignature_js_1.getFunctionSignature)(fn)), 0, 4);
    exports.getFunctionSelector = getFunctionSelector;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/getAbiItem.js
var require_getAbiItem = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/getAbiItem.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAmbiguousTypes = exports.isArgOfType = exports.getAbiItem = void 0;
    var abi_js_1 = require_abi();
    var isHex_js_1 = require_isHex();
    var getEventSelector_js_1 = require_getEventSelector();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var isAddress_js_1 = require_isAddress();
    function getAbiItem({ abi, args = [], name }) {
      const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
      const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
          if (abiItem.type === "function")
            return (0, getFunctionSelector_js_1.getFunctionSelector)(abiItem) === name;
          if (abiItem.type === "event")
            return (0, getEventSelector_js_1.getEventSelector)(abiItem) === name;
          return false;
        }
        return "name" in abiItem && abiItem.name === name;
      });
      if (abiItems.length === 0)
        return void 0;
      if (abiItems.length === 1)
        return abiItems[0];
      let matchedAbiItem = void 0;
      for (const abiItem of abiItems) {
        if (!("inputs" in abiItem))
          continue;
        if (!args || args.length === 0) {
          if (!abiItem.inputs || abiItem.inputs.length === 0)
            return abiItem;
          continue;
        }
        if (!abiItem.inputs)
          continue;
        if (abiItem.inputs.length === 0)
          continue;
        if (abiItem.inputs.length !== args.length)
          continue;
        const matched = args.every((arg, index) => {
          const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
          if (!abiParameter)
            return false;
          return isArgOfType(arg, abiParameter);
        });
        if (matched) {
          if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
            const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
            if (ambiguousTypes)
              throw new abi_js_1.AbiItemAmbiguityError({
                abiItem,
                type: ambiguousTypes[0]
              }, {
                abiItem: matchedAbiItem,
                type: ambiguousTypes[1]
              });
          }
          matchedAbiItem = abiItem;
        }
      }
      if (matchedAbiItem)
        return matchedAbiItem;
      return abiItems[0];
    }
    exports.getAbiItem = getAbiItem;
    function isArgOfType(arg, abiParameter) {
      const argType = typeof arg;
      const abiParameterType = abiParameter.type;
      switch (abiParameterType) {
        case "address":
          return (0, isAddress_js_1.isAddress)(arg);
        case "bool":
          return argType === "boolean";
        case "function":
          return argType === "string";
        case "string":
          return argType === "string";
        default: {
          if (abiParameterType === "tuple" && "components" in abiParameter)
            return Object.values(abiParameter.components).every((component, index) => {
              return isArgOfType(Object.values(arg)[index], component);
            });
          if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
            return argType === "number" || argType === "bigint";
          if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
            return argType === "string" || arg instanceof Uint8Array;
          if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
            return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
              ...abiParameter,
              type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
            }));
          }
          return false;
        }
      }
    }
    exports.isArgOfType = isArgOfType;
    function getAmbiguousTypes(sourceParameters, targetParameters, args) {
      for (const parameterIndex in sourceParameters) {
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
          return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [sourceParameter.type, targetParameter.type];
        const ambiguous = (() => {
          if (types.includes("address") && types.includes("bytes20"))
            return true;
          if (types.includes("address") && types.includes("string"))
            return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
          if (types.includes("address") && types.includes("bytes"))
            return (0, isAddress_js_1.isAddress)(args[parameterIndex]);
          return false;
        })();
        if (ambiguous)
          return types;
      }
      return;
    }
    exports.getAmbiguousTypes = getAmbiguousTypes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeEventTopics.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeEventTopics = void 0;
    var abi_js_1 = require_abi();
    var log_js_1 = require_log2();
    var toBytes_js_1 = require_toBytes();
    var getEventSelector_js_1 = require_getEventSelector();
    var keccak256_js_1 = require_keccak256();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeEventTopics({ abi, eventName, args }) {
      let abiItem = abi[0];
      if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: eventName
        });
        if (!abiItem)
          throw new abi_js_1.AbiEventNotFoundError(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
          });
      }
      if (abiItem.type !== "event")
        throw new abi_js_1.AbiEventNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
      let topics = [];
      if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
        if (args_.length > 0) {
          topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
        }
      }
      return [signature, ...topics];
    }
    exports.encodeEventTopics = encodeEventTopics;
    function encodeArg({ param, value }) {
      if (param.type === "string" || param.type === "bytes")
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
      if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFilterRequestScope = void 0;
    function createFilterRequestScope(client, { method }) {
      const requestMap = {};
      if (client.transport.type === "fallback")
        client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
          if (status === "success" && method === method_)
            requestMap[id] = transport.request;
        });
      return (id) => requestMap[id] || client.request;
    }
    exports.createFilterRequestScope = createFilterRequestScope;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createContractEventFilter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createContractEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi,
        args,
        eventName
      }) : void 0;
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            topics
          }
        ]
      });
      return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: "event"
      };
    }
    exports.createContractEventFilter = createContractEventFilter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/accounts/utils/parseAccount.js
var require_parseAccount = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/accounts/utils/parseAccount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccount = void 0;
    function parseAccount(account) {
      if (typeof account === "string")
        return { address: account, type: "json-rpc" };
      return account;
    }
    exports.parseAccount = parseAccount;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeFunctionData.js
var require_encodeFunctionData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeFunctionData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeFunctionData({ abi, args, functionName }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionData"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      const data = "inputs" in abiItem && abiItem.inputs ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? []) : void 0;
      return (0, concat_js_1.concatHex)([signature, data ?? "0x"]);
    }
    exports.encodeFunctionData = encodeFunctionData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/solidity.js
var require_solidity = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/solidity.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.solidityPanic = exports.solidityError = exports.panicReasons = void 0;
    exports.panicReasons = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    };
    exports.solidityError = {
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    };
    exports.solidityPanic = {
      inputs: [
        {
          name: "reason",
          type: "uint256"
        }
      ],
      name: "Panic",
      type: "error"
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/getAddress.js
var require_getAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/getAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = exports.checksumAddress = void 0;
    var address_js_1 = require_address();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var isAddress_js_1 = require_isAddress();
    function checksumAddress(address_, chainId) {
      const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
      const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), "bytes");
      const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
      for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
          address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
          address[i + 1] = address[i + 1].toUpperCase();
        }
      }
      return `0x${address.join("")}`;
    }
    exports.checksumAddress = checksumAddress;
    function getAddress(address, chainId) {
      if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
      return checksumAddress(address, chainId);
    }
    exports.getAddress = getAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js
var require_decodeAbiParameters = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var getAddress_js_1 = require_getAddress();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    function decodeAbiParameters(params, data) {
      if (data === "0x" && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
      if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
          data,
          params,
          size: (0, size_js_1.size)(data)
        });
      return decodeParams({
        data,
        params
      });
    }
    exports.decodeAbiParameters = decodeAbiParameters;
    function decodeParams({ data, params }) {
      const decodedValues = [];
      let position = 0;
      for (let i = 0; i < params.length; i++) {
        if (position >= (0, size_js_1.size)(data))
          throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data,
            params,
            size: (0, size_js_1.size)(data)
          });
        const param = params[i];
        const { consumed, value } = decodeParam({ data, param, position });
        decodedValues.push(value);
        position += consumed;
      }
      return decodedValues;
    }
    function decodeParam({ data, param, position }) {
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
          length,
          param: { ...param, type },
          position
        });
      }
      if (param.type === "tuple") {
        return decodeTuple(data, { param, position });
      }
      if (param.type === "string") {
        return decodeString(data, { position });
      }
      if (param.type.startsWith("bytes")) {
        return decodeBytes(data, { param, position });
      }
      const value = (0, slice_js_1.slice)(data, position, position + 32, { strict: true });
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        return decodeNumber(value, { param });
      }
      if (param.type === "address") {
        return decodeAddress(value);
      }
      if (param.type === "bool") {
        return decodeBool(value);
      }
      throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
      });
    }
    function decodeAddress(value) {
      return { consumed: 32, value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20)) };
    }
    function decodeArray(data, { param, length, position }) {
      if (!length) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length2 = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length2; ++i) {
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset + 32),
            param,
            position: consumed2
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      if (hasDynamicChild(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length; ++i) {
          const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param,
            position: dynamicChild ? consumed2 : i * 32
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      let consumed = 0;
      const value = [];
      for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam({
          data,
          param,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
      }
      return { value, consumed };
    }
    function decodeBool(value) {
      return { consumed: 32, value: (0, fromHex_js_1.hexToBool)(value) };
    }
    function decodeBytes(data, { param, position }) {
      const [_, size] = param.type.split("bytes");
      if (!size) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        if (length === 0)
          return { consumed: 32, value: "0x" };
        const value2 = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {
          strict: true
        });
        return { consumed: 32, value: value2 };
      }
      const value = (0, slice_js_1.slice)(data, position, position + parseInt(size), {
        strict: true
      });
      return { consumed: 32, value };
    }
    function decodeNumber(value, { param }) {
      const signed = param.type.startsWith("int");
      const size = parseInt(param.type.split("int")[1] || "256");
      return {
        consumed: 32,
        value: size > 48 ? (0, fromHex_js_1.hexToBigInt)(value, { signed }) : (0, fromHex_js_1.hexToNumber)(value, { signed })
      };
    }
    function decodeString(data, { position }) {
      const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
      const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "" };
      const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, { strict: true })));
      return { consumed: 32, value };
    }
    function decodeTuple(data, { param, position }) {
      const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
      const value = hasUnnamedChild ? [] : {};
      let consumed = 0;
      if (hasDynamicChild(param)) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        for (let i = 0; i < param.components.length; ++i) {
          const component = param.components[i];
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param: component,
            position: consumed
          });
          consumed += decodedChild.consumed;
          value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
      }
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
          data,
          param: component,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
      }
      return { consumed, value };
    }
    function hasDynamicChild(param) {
      const { type } = param;
      if (type === "string")
        return true;
      if (type === "bytes")
        return true;
      if (type.endsWith("[]"))
        return true;
      if (type === "tuple")
        return param.components?.some(hasDynamicChild);
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
      return false;
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeErrorResult.js
var require_decodeErrorResult = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeErrorResult.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeErrorResult = void 0;
    var solidity_js_1 = require_solidity();
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeErrorResult({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      if (signature === "0x")
        throw new abi_js_1.AbiDecodingZeroDataError();
      const abi_ = [...abi || [], solidity_js_1.solidityError, solidity_js_1.solidityPanic];
      const abiItem = abi_.find((x) => x.type === "error" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeErrorResult"
        });
      return {
        abiItem,
        args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : void 0,
        errorName: abiItem.name
      };
    }
    exports.decodeErrorResult = decodeErrorResult;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/stringify.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
    exports.stringify = stringify;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js
var require_formatAbiItemWithArgs = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItemWithArgs = void 0;
    var stringify_js_1 = require_stringify2();
    function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
      if (!("name" in abiItem))
        return;
      if (!("inputs" in abiItem))
        return;
      if (!abiItem.inputs)
        return;
      return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`).join(", ")})`;
    }
    exports.formatAbiItemWithArgs = formatAbiItemWithArgs;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatEther.js
var require_formatEther = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/formatEther.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatEther = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatEther(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
    }
    exports.formatEther = formatEther;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/transaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.prettyPrint = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    function prettyPrint(args) {
      const entries = Object.entries(args).map(([key, value]) => {
        if (value === void 0 || value === false)
          return null;
        return [key, value];
      }).filter(Boolean);
      const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
      return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
    }
    exports.prettyPrint = prettyPrint;
    var FeeConflictError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeConflictError"
        });
      }
    };
    exports.FeeConflictError = FeeConflictError;
    var InvalidLegacyVError = class extends base_js_1.BaseError {
      constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidLegacyVError"
        });
      }
    };
    exports.InvalidLegacyVError = InvalidLegacyVError;
    var InvalidSerializableTransactionError = class extends base_js_1.BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializableTransactionError"
        });
      }
    };
    exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
    var InvalidSerializedTransactionTypeError = class extends base_js_1.BaseError {
      constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionType"
        });
        Object.defineProperty(this, "serializedType", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedType = serializedType;
      }
    };
    exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
    var InvalidSerializedTransactionError = class extends base_js_1.BaseError {
      constructor({ attributes, serializedTransaction, type }) {
        const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
          metaMessages: [
            `Serialized Transaction: "${serializedTransaction}"`,
            missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionError"
        });
        Object.defineProperty(this, "serializedTransaction", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
      }
    };
    exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
    var InvalidStorageKeySizeError = class extends base_js_1.BaseError {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStorageKeySizeError"
        });
      }
    };
    exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
    var TransactionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint({
          chain: chain && `${chain?.name} (id: ${chain?.id})`,
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Request Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.TransactionExecutionError = TransactionExecutionError;
    var TransactionNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber, blockTag, hash, index }) {
        let identifier = "Transaction";
        if (blockTag && index !== void 0)
          identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== void 0)
          identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== void 0)
          identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
          identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionNotFoundError"
        });
      }
    };
    exports.TransactionNotFoundError = TransactionNotFoundError;
    var TransactionReceiptNotFoundError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionReceiptNotFoundError"
        });
      }
    };
    exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
    var WaitForTransactionReceiptTimeoutError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WaitForTransactionReceiptTimeoutError"
        });
      }
    };
    exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/contract.js
var require_contract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/contract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var solidity_js_1 = require_solidity();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    var getAbiItem_js_1 = require_getAbiItem();
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction2();
    var utils_js_1 = require_utils();
    var CallExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CallExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.CallExecutionError = CallExecutionError;
    var ContractFunctionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        const functionWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
          function: functionWithParams,
          args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
          sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Contract Call:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "args", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "functionName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sender", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
      }
    };
    exports.ContractFunctionExecutionError = ContractFunctionExecutionError;
    var ContractFunctionRevertedError = class extends base_js_1.BaseError {
      constructor({ abi, data, functionName, message }) {
        let cause;
        let decodedData = void 0;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
          try {
            decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = solidity_js_1.panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } catch (err) {
            cause = err;
          }
        } else if (message)
          reason = message;
        let signature;
        if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
          signature = cause.signature;
          metaMessages = [
            `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ];
        }
        super(reason && reason !== "execution reverted" || signature ? [
          `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
          reason || signature
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
          cause,
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reason", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
      }
    };
    exports.ContractFunctionRevertedError = ContractFunctionRevertedError;
    var ContractFunctionZeroDataError = class extends base_js_1.BaseError {
      constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
          metaMessages: [
            "This could be due to any of the following:",
            `  - The contract does not have the function "${functionName}",`,
            "  - The parameters passed to the contract function may be invalid, or",
            "  - The address is not a contract."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionZeroDataError"
        });
      }
    };
    exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
    var RawContractError = class extends base_js_1.BaseError {
      constructor({ data, message }) {
        super(message || "");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
      }
    };
    exports.RawContractError = RawContractError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/request.js
var require_request = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/request.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = void 0;
    var stringify_js_1 = require_stringify2();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils();
    var HttpRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, headers, status, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${(0, utils_js_1.getUrl)(url)}`,
            body && `Request body: ${(0, stringify_js_1.stringify)(body)}`
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    exports.HttpRequestError = HttpRequestError;
    var WebSocketRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, url }) {
        super("WebSocket request failed.", {
          details,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebSocketRequestError"
        });
      }
    };
    exports.WebSocketRequestError = WebSocketRequestError;
    var RpcRequestError = class extends base_js_1.BaseError {
      constructor({ body, error, url }) {
        super("RPC Request failed.", {
          cause: error,
          details: error.message,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error.code;
      }
    };
    exports.RpcRequestError = RpcRequestError;
    var TimeoutError = class extends base_js_1.BaseError {
      constructor({ body, url }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TimeoutError"
        });
      }
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/rpc.js
var require_rpc = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/rpc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownRpcError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var unknownErrorCode = -1;
    var RpcError = class extends base_js_1.BaseError {
      constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath,
          metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode;
      }
    };
    exports.RpcError = RpcError;
    var ProviderRpcError = class extends RpcError {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    exports.ProviderRpcError = ProviderRpcError;
    var ParseRpcError = class _ParseRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ParseRpcError.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ParseRpcError"
        });
      }
    };
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    exports.ParseRpcError = ParseRpcError;
    var InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidRequestRpcError.code,
          shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidRequestRpcError"
        });
      }
    };
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    exports.InvalidRequestRpcError = InvalidRequestRpcError;
    var MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _MethodNotFoundRpcError.code,
          shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    exports.MethodNotFoundRpcError = MethodNotFoundRpcError;
    var InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidParamsRpcError.code,
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParamsRpcError"
        });
      }
    };
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    exports.InvalidParamsRpcError = InvalidParamsRpcError;
    var InternalRpcError = class _InternalRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InternalRpcError.code,
          shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InternalRpcError"
        });
      }
    };
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    exports.InternalRpcError = InternalRpcError;
    var InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidInputRpcError.code,
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidInputRpcError"
        });
      }
    };
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    exports.InvalidInputRpcError = InvalidInputRpcError;
    var ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceNotFoundRpcError.code,
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
    var ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceUnavailableRpcError.code,
          shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceUnavailableRpcError"
        });
      }
    };
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
    var TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _TransactionRejectedRpcError.code,
          shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionRejectedRpcError"
        });
      }
    };
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    exports.TransactionRejectedRpcError = TransactionRejectedRpcError;
    var MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _MethodNotSupportedRpcError.code,
          shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotSupportedRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
    var LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _LimitExceededRpcError.code,
          shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "LimitExceededRpcError"
        });
      }
    };
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    exports.LimitExceededRpcError = LimitExceededRpcError;
    var JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _JsonRpcVersionUnsupportedError.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "JsonRpcVersionUnsupportedError"
        });
      }
    };
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
    var UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UserRejectedRequestError.code,
          shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UserRejectedRequestError"
        });
      }
    };
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    exports.UserRejectedRequestError = UserRejectedRequestError;
    var UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnauthorizedProviderError.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnauthorizedProviderError"
        });
      }
    };
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    exports.UnauthorizedProviderError = UnauthorizedProviderError;
    var UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnsupportedProviderMethodError.code,
          shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedProviderMethodError"
        });
      }
    };
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
    var ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ProviderDisconnectedError.code,
          shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderDisconnectedError"
        });
      }
    };
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    exports.ProviderDisconnectedError = ProviderDisconnectedError;
    var ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ChainDisconnectedError.code,
          shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDisconnectedError"
        });
      }
    };
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    exports.ChainDisconnectedError = ChainDisconnectedError;
    var SwitchChainError = class _SwitchChainError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _SwitchChainError.code,
          shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SwitchChainError"
        });
      }
    };
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    exports.SwitchChainError = SwitchChainError;
    var UnknownRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          shortMessage: "An unknown RPC error occurred."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownRpcError"
        });
      }
    };
    exports.UnknownRpcError = UnknownRpcError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getContractError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContractError = void 0;
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var rpc_js_1 = require_rpc();
    var EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
      const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
      const cause = (() => {
        if (err instanceof abi_js_1.AbiDecodingZeroDataError)
          return new contract_js_1.ContractFunctionZeroDataError({ functionName });
        if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1.InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
          return new contract_js_1.ContractFunctionRevertedError({
            abi,
            data: typeof data === "object" ? data.data : data,
            functionName,
            message: shortMessage ?? message
          });
        }
        return err;
      })();
      return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
      });
    }
    exports.getContractError = getContractError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/account.js
var require_account = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/account.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNotFoundError = void 0;
    var base_js_1 = require_base();
    var AccountNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
    exports.AccountNotFoundError = AccountNotFoundError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/estimateGas.js
var require_estimateGas = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/estimateGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EstimateGasExecutionError = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction2();
    var EstimateGasExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.EstimateGasExecutionError = EstimateGasExecutionError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getNodeError.js
var require_getNodeError = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getNodeError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNodeError = exports.containsNodeError = void 0;
    var base_js_1 = require_base();
    var node_js_1 = require_node();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    function containsNodeError(err) {
      return err instanceof rpc_js_1.TransactionRejectedRpcError || err instanceof rpc_js_1.InvalidInputRpcError || err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code;
    }
    exports.containsNodeError = containsNodeError;
    function getNodeError(err, args) {
      const message = (err.details || "").toLowerCase();
      const executionRevertedError = err.walk((e) => e.code === node_js_1.ExecutionRevertedError.code);
      if (executionRevertedError instanceof base_js_1.BaseError) {
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: executionRevertedError.details
        });
      }
      if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: err.details
        });
      if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
      if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
      if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
      if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
      if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
      if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
      if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
      if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas,
          maxPriorityFeePerGas: args?.maxPriorityFeePerGas
        });
      return new node_js_1.UnknownNodeError({
        cause: err
      });
    }
    exports.getNodeError = getNodeError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getEstimateGasError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEstimateGasError = void 0;
    var estimateGas_js_1 = require_estimateGas();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getEstimateGasError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getEstimateGasError = getEstimateGasError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/extract.js
var require_extract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/extract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extract = void 0;
    function extract(value_, { format }) {
      if (!format)
        return {};
      const value = {};
      function extract_(formatted2) {
        const keys = Object.keys(formatted2);
        for (const key of keys) {
          if (key in value_)
            value[key] = value_[key];
          if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
            extract_(formatted2[key]);
        }
      }
      const formatted = format(value_ || {});
      extract_(formatted);
      return value;
    }
    exports.extract = extract;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/assertRequest.js
var require_assertRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/assertRequest.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var address_js_1 = require_address();
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    function assertRequest(args) {
      const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
        throw new transaction_js_1.FeeConflictError();
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertRequest = assertRequest;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/fee.js
var require_fee = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/fee.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var BaseFeeScalarError = class extends base_js_1.BaseError {
      constructor() {
        super("`baseFeeMultiplier` must be greater than 1.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseFeeScalarError"
        });
      }
    };
    exports.BaseFeeScalarError = BaseFeeScalarError;
    var Eip1559FeesNotSupportedError = class extends base_js_1.BaseError {
      constructor() {
        super("Chain does not support EIP-1559 fees.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Eip1559FeesNotSupportedError"
        });
      }
    };
    exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
    var MaxFeePerGasTooLowError = class extends base_js_1.BaseError {
      constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MaxFeePerGasTooLowError"
        });
      }
    };
    exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/block.js
var require_block2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/block.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockNotFoundError = void 0;
    var base_js_1 = require_base();
    var BlockNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
    exports.BlockNotFoundError = BlockNotFoundError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlock.js
var require_getBlock = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlock.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlock = void 0;
    var block_js_1 = require_block2();
    var toHex_js_1 = require_toHex();
    var block_js_2 = require_block();
    async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
      const blockTag = blockTag_ ?? "latest";
      const includeTransactions = includeTransactions_ ?? false;
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let block = null;
      if (blockHash) {
        block = await client.request({
          method: "eth_getBlockByHash",
          params: [blockHash, includeTransactions]
        });
      } else {
        block = await client.request({
          method: "eth_getBlockByNumber",
          params: [blockNumberHex || blockTag, includeTransactions]
        });
      }
      if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
      const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
      return format(block);
    }
    exports.getBlock = getBlock;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getGasPrice.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGasPrice = void 0;
    async function getGasPrice(client) {
      const gasPrice = await client.request({
        method: "eth_gasPrice"
      });
      return BigInt(gasPrice);
    }
    exports.getGasPrice = getGasPrice;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js
var require_estimateMaxPriorityFeePerGas = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal_estimateMaxPriorityFeePerGas = exports.estimateMaxPriorityFeePerGas = void 0;
    var fee_js_1 = require_fee();
    var fromHex_js_1 = require_fromHex();
    var getAction_js_1 = require_getAction();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateMaxPriorityFeePerGas(client, args) {
      return internal_estimateMaxPriorityFeePerGas(client, args);
    }
    exports.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
    async function internal_estimateMaxPriorityFeePerGas(client, args) {
      const { block: block_, chain = client.chain, request } = args || {};
      if (typeof chain?.fees?.defaultPriorityFee === "function") {
        const block = block_ || await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
        return chain.fees.defaultPriorityFee({
          block,
          client,
          request
        });
      }
      if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
        return chain?.fees?.defaultPriorityFee;
      try {
        const maxPriorityFeePerGasHex = await client.request({
          method: "eth_maxPriorityFeePerGas"
        });
        return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
      } catch {
        const [block, gasPrice] = await Promise.all([
          block_ ? Promise.resolve(block_) : (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({}),
          (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({})
        ]);
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n)
          return 0n;
        return maxPriorityFeePerGas;
      }
    }
    exports.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js
var require_estimateFeesPerGas = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal_estimateFeesPerGas = exports.estimateFeesPerGas = void 0;
    var fee_js_1 = require_fee();
    var getAction_js_1 = require_getAction();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateFeesPerGas(client, args) {
      return internal_estimateFeesPerGas(client, args);
    }
    exports.estimateFeesPerGas = estimateFeesPerGas;
    async function internal_estimateFeesPerGas(client, args) {
      const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
      const baseFeeMultiplier = await (async () => {
        if (typeof chain?.fees?.baseFeeMultiplier === "function")
          return chain.fees.baseFeeMultiplier({
            block: block_,
            client,
            request
          });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
      })();
      if (baseFeeMultiplier < 1)
        throw new fee_js_1.BaseFeeScalarError();
      const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
      const denominator = 10 ** decimals;
      const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
      const block = block_ ? block_ : await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({});
      if (typeof chain?.fees?.estimateFeesPerGas === "function")
        return chain.fees.estimateFeesPerGas({
          block: block_,
          client,
          multiply,
          request,
          type
        });
      if (type === "eip1559") {
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = request?.maxPriorityFeePerGas ? request.maxPriorityFeePerGas : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
          block,
          chain,
          request
        });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
          maxFeePerGas,
          maxPriorityFeePerGas
        };
      }
      const gasPrice = request?.gasPrice ?? multiply(await (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, "getGasPrice")({}));
      return {
        gasPrice
      };
    }
    exports.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionCount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
      const count = await client.request({
        method: "eth_getTransactionCount",
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
      });
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getTransactionCount = getTransactionCount;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/getTransactionType.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionType = void 0;
    var transaction_js_1 = require_transaction2();
    function getTransactionType(transaction) {
      if (transaction.type)
        return transaction.type;
      if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
        return "eip1559";
      if (typeof transaction.gasPrice !== "undefined") {
        if (typeof transaction.accessList !== "undefined")
          return "eip2930";
        return "legacy";
      }
      throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
    }
    exports.getTransactionType = getTransactionType;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js
var require_prepareTransactionRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareTransactionRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var getBlock_js_1 = require_getBlock();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var account_js_1 = require_account();
    var fee_js_1 = require_fee();
    var getAction_js_1 = require_getAction();
    var assertRequest_js_1 = require_assertRequest();
    var getTransactionType_js_1 = require_getTransactionType();
    async function prepareTransactionRequest(client, args) {
      const { account: account_ = client.account, chain, gas, nonce, type } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError();
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({ blockTag: "latest" });
      const request = { ...args, from: account.address };
      if (typeof nonce === "undefined")
        request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, "getTransactionCount")({
          address: account.address,
          blockTag: "pending"
        });
      if (typeof type === "undefined") {
        try {
          request.type = (0, getTransactionType_js_1.getTransactionType)(request);
        } catch {
          request.type = typeof block.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
        }
      }
      if (request.type === "eip1559") {
        const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new fee_js_1.MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
      if (typeof gas === "undefined")
        request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
          ...request,
          account: { address: account.address, type: "json-rpc" }
        });
      (0, assertRequest_js_1.assertRequest)(request);
      return request;
    }
    exports.prepareTransactionRequest = prepareTransactionRequest;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    async function estimateGas(client, args) {
      const account_ = args.account ?? client.account;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/public/estimateGas"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          from: account.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        const balance = await client.request({
          method: "eth_estimateGas",
          params: block ? [request, block] : [request]
        });
        return BigInt(balance);
      } catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.estimateGas = estimateGas;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/estimateContractGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateContractGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var estimateGas_js_1 = require_estimateGas2();
    async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, "estimateGas")({
          data,
          to: address,
          ...request
        });
        return gas;
      } catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : void 0;
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/estimateContractGas",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.estimateContractGas = estimateContractGas;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeEventLog.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeEventLog = void 0;
    var abi_js_1 = require_abi();
    var getEventSelector_js_1 = require_getEventSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var docsPath = "/docs/contract/decodeEventLog";
    function decodeEventLog({ abi, data, strict: strict_, topics }) {
      const strict = strict_ ?? true;
      const [signature, ...argTopics] = topics;
      if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
          docsPath
        });
      const abiItem = abi.find((x) => x.type === "event" && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
          docsPath
        });
      const { name, inputs } = abiItem;
      const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
      let args = isUnnamed ? [] : {};
      const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
      for (let i = 0; i < indexedInputs.length; i++) {
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic)
          throw new abi_js_1.DecodeLogTopicsMismatch({
            abiItem,
            param
          });
        args[param.name || i] = decodeTopic({ param, value: topic });
      }
      const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
      if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") {
          try {
            const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
              if (isUnnamed)
                args = [...args, ...decodedData];
              else {
                for (let i = 0; i < nonIndexedInputs.length; i++) {
                  args[nonIndexedInputs[i].name] = decodedData[i];
                }
              }
            }
          } catch (err) {
            if (strict) {
              if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                throw new abi_js_1.DecodeLogDataMismatch({
                  abiItem,
                  data: err.data,
                  params: err.params,
                  size: err.size
                });
              throw err;
            }
          }
        } else if (strict) {
          throw new abi_js_1.DecodeLogDataMismatch({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
          });
        }
      }
      return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : void 0
      };
    }
    exports.decodeEventLog = decodeEventLog;
    function decodeTopic({ param, value }) {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
      const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
      return decodedArg[0];
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getLogs.js
var require_getLogs = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getLogs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var log_js_1 = require_log();
    async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
      const strict = strict_ ?? false;
      const events = events_ ?? (event ? [event] : void 0);
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      let logs;
      if (blockHash) {
        logs = await client.request({
          method: "eth_getLogs",
          params: [{ address, topics, blockHash }]
        });
      } else {
        logs = await client.request({
          method: "eth_getLogs",
          params: [
            {
              address,
              topics,
              fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
              toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
            }
          ]
        });
      }
      return logs.map((log) => {
        try {
          const { eventName, args: args2 } = events ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: events,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args: args2, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if (strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getLogs = getLogs;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getContractEvents.js
var require_getContractEvents = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getContractEvents.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContractEvents = void 0;
    var getAbiItem_js_1 = require_getAbiItem();
    var getAction_js_1 = require_getAction();
    var getLogs_js_1 = require_getLogs();
    async function getContractEvents(client, { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict }) {
      const event = eventName ? (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName }) : void 0;
      const events = !event ? abi.filter((x) => x.type === "event") : void 0;
      return (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict
      });
    }
    exports.getContractEvents = getContractEvents;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js
var require_decodeFunctionResult = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/decodeFunctionResult";
    function decodeFunctionResult({ abi, args, functionName, data }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, { docsPath });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
      if (values && values.length > 1)
        return values;
      if (values && values.length === 1)
        return values[0];
      return void 0;
    }
    exports.decodeFunctionResult = decodeFunctionResult;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/abis.js
var require_abis = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/abis.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.addressResolverAbi = exports.textResolverAbi = exports.universalResolverReverseAbi = exports.universalResolverResolveAbi = exports.multicall3Abi = void 0;
    exports.multicall3Abi = [
      {
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "allowFailure",
                type: "bool"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        name: "aggregate3",
        outputs: [
          {
            components: [
              {
                name: "success",
                type: "bool"
              },
              {
                name: "returnData",
                type: "bytes"
              }
            ],
            name: "returnData",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var universalResolverErrors = [
      {
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
      },
      {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
      }
    ];
    exports.universalResolverResolveAbi = [
      ...universalResolverErrors,
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ];
    exports.universalResolverReverseAbi = [
      ...universalResolverErrors,
      {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{ type: "bytes", name: "reverseName" }],
        outputs: [
          { type: "string", name: "resolvedName" },
          { type: "address", name: "resolvedAddress" },
          { type: "address", name: "reverseResolver" },
          { type: "address", name: "resolver" }
        ]
      }
    ];
    exports.textResolverAbi = [
      {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "key", type: "string" }
        ],
        outputs: [{ name: "", type: "string" }]
      }
    ];
    exports.addressResolverAbi = [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "name", type: "bytes32" }],
        outputs: [{ name: "", type: "address" }]
      },
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "coinType", type: "uint256" }
        ],
        outputs: [{ name: "", type: "bytes" }]
      }
    ];
    exports.smartAccountAbi = [
      {
        name: "isValidSignature",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "hash", type: "bytes32" },
          { name: "signature", type: "bytes" }
        ],
        outputs: [{ name: "", type: "bytes4" }]
      }
    ];
    exports.universalSignatureValidatorAbi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_signer",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_hash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      }
    ];
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/contract.js
var require_contract2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/contract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aggregate3Signature = void 0;
    exports.aggregate3Signature = "0x82ad56cb";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/getChainContractAddress.js
var require_getChainContractAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/getChainContractAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainContractAddress = void 0;
    var chain_js_1 = require_chain();
    function getChainContractAddress({ blockNumber, chain, contract: name }) {
      const contract = chain?.contracts?.[name];
      if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
          chain,
          contract: { name }
        });
      if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
          blockNumber,
          chain,
          contract: {
            name,
            blockCreated: contract.blockCreated
          }
        });
      return contract.address;
    }
    exports.getChainContractAddress = getChainContractAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getCallError.js
var require_getCallError = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getCallError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCallError = void 0;
    var contract_js_1 = require_contract();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getCallError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new contract_js_1.CallExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getCallError = getCallError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/createBatchScheduler.js
var require_createBatchScheduler = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/createBatchScheduler.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBatchScheduler = void 0;
    var schedulerCache = /* @__PURE__ */ new Map();
    function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
      const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args: args2 }) => args2);
        if (args.length === 0)
          return;
        fn(args).then((data) => {
          if (sort && Array.isArray(data))
            data.sort(sort);
          for (let i = 0; i < scheduler.length; i++) {
            const { pendingPromise } = scheduler[i];
            pendingPromise.resolve?.([data[i], data]);
          }
        }).catch((err) => {
          for (let i = 0; i < scheduler.length; i++) {
            const { pendingPromise } = scheduler[i];
            pendingPromise.reject?.(err);
          }
        });
      };
      const flush = () => schedulerCache.delete(id);
      const getBatchedArgs = () => getScheduler().map(({ args }) => args);
      const getScheduler = () => schedulerCache.get(id) || [];
      const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
      return {
        flush,
        async schedule(args) {
          const pendingPromise = {};
          const promise = new Promise((resolve, reject) => {
            pendingPromise.resolve = resolve;
            pendingPromise.reject = reject;
          });
          const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
          if (split)
            exec();
          const hasActiveScheduler = getScheduler().length > 0;
          if (hasActiveScheduler) {
            setScheduler({ args, pendingPromise });
            return promise;
          }
          setScheduler({ args, pendingPromise });
          setTimeout(exec, wait);
          return promise;
        }
      };
    }
    exports.createBatchScheduler = createBatchScheduler;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/ccip.js
var require_ccip = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/ccip.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = void 0;
    var stringify_js_1 = require_stringify2();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils();
    var OffchainLookupError = class extends base_js_1.BaseError {
      constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
        super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
          cause,
          metaMessages: [
            ...cause.metaMessages || [],
            cause.metaMessages?.length ? "" : [],
            "Offchain Gateway Call:",
            urls && [
              "  Gateway URL(s):",
              ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`)
            ],
            `  Sender: ${sender}`,
            `  Data: ${data}`,
            `  Callback selector: ${callbackSelector}`,
            `  Extra data: ${extraData}`
          ].flat()
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupError"
        });
      }
    };
    exports.OffchainLookupError = OffchainLookupError;
    var OffchainLookupResponseMalformedError = class extends base_js_1.BaseError {
      constructor({ result, url }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
          metaMessages: [
            `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
            `Response: ${(0, stringify_js_1.stringify)(result)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupResponseMalformedError"
        });
      }
    };
    exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
    var OffchainLookupSenderMismatchError = class extends base_js_1.BaseError {
      constructor({ sender, to }) {
        super("Reverted sender address does not match target contract address (`to`).", {
          metaMessages: [
            `Contract address: ${to}`,
            `OffchainLookup sender address: ${sender}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupSenderMismatchError"
        });
      }
    };
    exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/isAddressEqual.js
var require_isAddressEqual = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/isAddressEqual.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddressEqual = void 0;
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    function isAddressEqual(a, b) {
      if (!(0, isAddress_js_1.isAddress)(a))
        throw new address_js_1.InvalidAddressError({ address: a });
      if (!(0, isAddress_js_1.isAddress)(b))
        throw new address_js_1.InvalidAddressError({ address: b });
      return a.toLowerCase() === b.toLowerCase();
    }
    exports.isAddressEqual = isAddressEqual;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ccip.js
var require_ccip2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ccip.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ccipFetch = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
    var call_js_1 = require_call();
    var ccip_js_1 = require_ccip();
    var request_js_1 = require_request();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var concat_js_1 = require_concat();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify2();
    exports.offchainLookupSignature = "0x556f1830";
    exports.offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
    async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
      const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports.offchainLookupAbiItem]
      });
      const [sender, urls, callData, callbackSelector, extraData] = args;
      try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
          throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
          blockNumber,
          blockTag,
          data: (0, concat_js_1.concat)([
            callbackSelector,
            (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
          ]),
          to
        });
        return data_;
      } catch (err) {
        throw new ccip_js_1.OffchainLookupError({
          callbackSelector,
          cause: err,
          data,
          extraData,
          sender,
          urls
        });
      }
    }
    exports.offchainLookup = offchainLookup;
    async function ccipFetch({ data, sender, urls }) {
      let error = new Error("An unknown error occurred.");
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes("{data}") ? "GET" : "POST";
        const body = method === "POST" ? { data, sender } : void 0;
        try {
          const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
            body: JSON.stringify(body),
            method
          });
          let result;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            result = (await response.json()).data;
          } else {
            result = await response.text();
          }
          if (!response.ok) {
            error = new request_js_1.HttpRequestError({
              body,
              details: result?.error ? (0, stringify_js_1.stringify)(result.error) : response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
            continue;
          }
          if (!(0, isHex_js_1.isHex)(result)) {
            error = new ccip_js_1.OffchainLookupResponseMalformedError({
              result,
              url
            });
            continue;
          }
          return result;
        } catch (err) {
          error = new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
      throw error;
    }
    exports.ccipFetch = ccipFetch;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/call.js
var require_call = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/call.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRevertErrorData = exports.call = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var abis_js_1 = require_abis();
    var contract_js_1 = require_contract2();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var contract_js_2 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var getCallError_js_1 = require_getCallError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var assertRequest_js_1 = require_assertRequest();
    async function call(client, args) {
      const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          from: account?.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        if (batch && shouldPerformMulticall({ request })) {
          try {
            return await scheduleMulticall(client, {
              ...request,
              blockNumber,
              blockTag
            });
          } catch (err) {
            if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract))
              throw err;
          }
        }
        const response = await client.request({
          method: "eth_call",
          params: block ? [request, block] : [request]
        });
        if (response === "0x")
          return { data: void 0 };
        return { data: response };
      } catch (err) {
        const data2 = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => require_ccip2());
        if (data2?.slice(0, 10) === offchainLookupSignature && to) {
          return { data: await offchainLookup(client, { data: data2, to }) };
        }
        throw (0, getCallError_js_1.getCallError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.call = call;
    function shouldPerformMulticall({ request }) {
      const { data, to, ...request_ } = request;
      if (!data)
        return false;
      if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
      if (!to)
        return false;
      if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
        return false;
      return true;
    }
    async function scheduleMulticall(client, args) {
      const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
      const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new chain_js_1.ClientChainNotConfiguredError();
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args2) {
          const size = args2.reduce((size2, { data: data2 }) => size2 + (data2.length - 2), 0);
          return size > batchSize * 2;
        },
        fn: async (requests) => {
          const calls = requests.map((request) => ({
            allowFailure: true,
            callData: request.data,
            target: request.to
          }));
          const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3"
          });
          const data2 = await client.request({
            method: "eth_call",
            params: [
              {
                data: calldata,
                to: multicallAddress
              },
              block
            ]
          });
          return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3",
            data: data2 || "0x"
          });
        }
      });
      const [{ returnData, success }] = await schedule({ data, to });
      if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
      if (returnData === "0x")
        return { data: void 0 };
      return { data: returnData };
    }
    function getRevertErrorData(err) {
      if (!(err instanceof base_js_1.BaseError))
        return void 0;
      const error = err.walk();
      return typeof error.data === "object" ? error.data.data : error.data;
    }
    exports.getRevertErrorData = getRevertErrorData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/readContract.js
var require_readContract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/readContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readContract = void 0;
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var call_js_1 = require_call();
    async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          data: calldata,
          to: address,
          ...callRequest
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/readContract",
          functionName
        });
      }
    }
    exports.readContract = readContract;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/simulateContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simulateContract = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var call_js_1 = require_call();
    async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
      const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : void 0;
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          batch: false,
          data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
          to: address,
          ...callRequest
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
        return {
          result,
          request: {
            abi,
            address,
            args,
            dataSuffix,
            functionName,
            ...callRequest
          }
        };
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.simulateContract = simulateContract;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/observe.js
var require_observe = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/observe.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
    exports.listenersCache = /* @__PURE__ */ new Map();
    exports.cleanupCache = /* @__PURE__ */ new Map();
    var callbackCount = 0;
    function observe(observerId, callbacks, fn) {
      const callbackId = ++callbackCount;
      const getListeners = () => exports.listenersCache.get(observerId) || [];
      const unsubscribe = () => {
        const listeners2 = getListeners();
        exports.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
      };
      const unwatch = () => {
        const cleanup2 = exports.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup2)
          cleanup2();
        unsubscribe();
      };
      const listeners = getListeners();
      exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks }
      ]);
      if (listeners && listeners.length > 0)
        return unwatch;
      const emit = {};
      for (const key in callbacks) {
        emit[key] = (...args) => {
          const listeners2 = getListeners();
          if (listeners2.length === 0)
            return;
          for (const listener of listeners2)
            listener.fns[key]?.(...args);
        };
      }
      const cleanup = fn(emit);
      if (typeof cleanup === "function")
        exports.cleanupCache.set(observerId, cleanup);
      return unwatch;
    }
    exports.observe = observe;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/wait.js
var require_wait = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/wait.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wait = void 0;
    async function wait(time) {
      return new Promise((res) => setTimeout(res, time));
    }
    exports.wait = wait;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/poll.js
var require_poll = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/poll.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = void 0;
    var wait_js_1 = require_wait();
    function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
      let active = true;
      const unwatch = () => active = false;
      const watch = async () => {
        let data = void 0;
        if (emitOnBegin)
          data = await fn({ unpoll: unwatch });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll2 = async () => {
          if (!active)
            return;
          await fn({ unpoll: unwatch });
          await (0, wait_js_1.wait)(interval);
          poll2();
        };
        poll2();
      };
      watch();
      return unwatch;
    }
    exports.poll = poll;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withCache.js
var require_withCache = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withCache.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
    exports.promiseCache = /* @__PURE__ */ new Map();
    exports.responseCache = /* @__PURE__ */ new Map();
    function getCache(cacheKey) {
      const buildCache = (cacheKey2, cache) => ({
        clear: () => cache.delete(cacheKey2),
        get: () => cache.get(cacheKey2),
        set: (data) => cache.set(cacheKey2, data)
      });
      const promise = buildCache(cacheKey, exports.promiseCache);
      const response = buildCache(cacheKey, exports.responseCache);
      return {
        clear: () => {
          promise.clear();
          response.clear();
        },
        promise,
        response
      };
    }
    exports.getCache = getCache;
    async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
      const cache = getCache(cacheKey);
      const response = cache.response.get();
      if (response && cacheTime > 0) {
        const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
        if (age < cacheTime)
          return response.data;
      }
      let promise = cache.promise.get();
      if (!promise) {
        promise = fn();
        cache.promise.set(promise);
      }
      try {
        const data = await promise;
        cache.response.set({ created: /* @__PURE__ */ new Date(), data });
        return data;
      } finally {
        cache.promise.clear();
      }
    }
    exports.withCache = withCache;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlockNumber.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockNumber = exports.getBlockNumberCache = void 0;
    var withCache_js_1 = require_withCache();
    var cacheKey = (id) => `blockNumber.${id}`;
    function getBlockNumberCache(id) {
      return (0, withCache_js_1.getCache)(cacheKey(id));
    }
    exports.getBlockNumberCache = getBlockNumberCache;
    async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
      const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: "eth_blockNumber"
      }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
      return BigInt(blockNumberHex);
    }
    exports.getBlockNumber = getBlockNumber;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFilterChanges.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterChanges = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log();
    async function getFilterChanges(_client, { filter }) {
      const strict = "strict" in filter && filter.strict;
      const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [filter.id]
      });
      return logs.map((log) => {
        if (typeof log === "string")
          return log;
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterChanges = getFilterChanges;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/uninstallFilter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uninstallFilter = void 0;
    async function uninstallFilter(_client, { filter }) {
      return filter.request({
        method: "eth_uninstallFilter",
        params: [filter.id]
      });
    }
    exports.uninstallFilter = uninstallFilter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchContractEvent.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchContractEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify2();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var log_js_1 = require_log();
    var getAction_js_1 = require_getAction();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getContractEvents_js_1 = require_getContractEvents();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollContractEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchContractEvent",
          address,
          args,
          batch,
          client.uid,
          eventName,
          pollingInterval
        ]);
        const strict = strict_ ?? false;
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                  abi,
                  address,
                  args,
                  eventName,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              } else {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                    abi,
                    address,
                    args,
                    eventName,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber,
                    strict
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                for (const log of logs)
                  emit.onLogs([log]);
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribeContractEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
              abi,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = (0, decodeEventLog_js_1.decodeEventLog)({
                    abi,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollContractEvent() : subscribeContractEvent();
    }
    exports.watchContractEvent = watchContractEvent;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/assertCurrentChain.js
var require_assertCurrentChain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/assertCurrentChain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertCurrentChain = void 0;
    var chain_js_1 = require_chain();
    function assertCurrentChain({ chain, currentChainId }) {
      if (!chain)
        throw new chain_js_1.ChainNotFoundError();
      if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
    }
    exports.assertCurrentChain = assertCurrentChain;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/errors/getTransactionError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionError = void 0;
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction2();
    var getNodeError_js_1 = require_getNodeError();
    function getTransactionError(err, { docsPath, ...args }) {
      const cause = (() => {
        const cause2 = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause2 instanceof node_js_1.UnknownNodeError)
          return err;
        return cause2;
      })();
      return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getTransactionError = getTransactionError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getChainId.js
var require_getChainId = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getChainId.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainId = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getChainId(client) {
      const chainIdHex = await client.request({
        method: "eth_chainId"
      });
      return (0, fromHex_js_1.hexToNumber)(chainIdHex);
    }
    exports.getChainId = getChainId;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js
var require_sendRawTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendRawTransaction = void 0;
    async function sendRawTransaction(client, { serializedTransaction }) {
      return client.request({
        method: "eth_sendRawTransaction",
        params: [serializedTransaction]
      });
    }
    exports.sendRawTransaction = sendRawTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/sendTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    var getTransactionError_js_1 = require_getTransactionError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var getAction_js_1 = require_getAction();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    async function sendTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
          chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
          (0, assertCurrentChain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain
          });
        }
        if (account.type === "local") {
          const request2 = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, "prepareTransactionRequest")({
            account,
            accessList,
            chain,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...rest
          });
          if (!chainId)
            chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
          const serializer = chain?.serializers?.transaction;
          const serializedTransaction = await account.signTransaction({
            ...request2,
            chainId
          }, { serializer });
          return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, "sendRawTransaction")({
            serializedTransaction
          });
        }
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
          accessList,
          data,
          from: account.address,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        return await client.request({
          method: "eth_sendTransaction",
          params: [request]
        });
      } catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
          ...args,
          account,
          chain: args.chain || void 0
        });
      }
    }
    exports.sendTransaction = sendTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/writeContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeContract = void 0;
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getAction_js_1 = require_getAction();
    var sendTransaction_js_1 = require_sendTransaction();
    async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      const hash = await (0, getAction_js_1.getAction)(client, sendTransaction_js_1.sendTransaction, "sendTransaction")({
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return hash;
    }
    exports.writeContract = writeContract;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/getContract.js
var require_getContract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/getContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventParameters = exports.getFunctionParameters = exports.getContract = void 0;
    var getAction_js_1 = require_getAction();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var getContractEvents_js_1 = require_getContractEvents();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var writeContract_js_1 = require_writeContract();
    function getContract({ abi, address, publicClient, walletClient }) {
      const hasPublicClient = publicClient !== void 0 && publicClient !== null;
      const hasWalletClient = walletClient !== void 0 && walletClient !== null;
      const contract = {};
      let hasReadFunction = false;
      let hasWriteFunction = false;
      let hasEvent = false;
      for (const item of abi) {
        if (item.type === "function")
          if (item.stateMutability === "view" || item.stateMutability === "pure")
            hasReadFunction = true;
          else
            hasWriteFunction = true;
        else if (item.type === "event")
          hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
          break;
      }
      if (hasPublicClient) {
        if (hasReadFunction)
          contract.read = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(publicClient, readContract_js_1.readContract, "readContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasWriteFunction)
          contract.simulate = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(publicClient, simulateContract_js_1.simulateContract, "simulateContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasEvent) {
          contract.createEventFilter = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, "createContractEventFilter")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.getEvents = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, getContractEvents_js_1.getContractEvents, "getContractEvents")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.watchEvent = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, getAction_js_1.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, "watchContractEvent")({
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
        }
      }
      if (hasWalletClient) {
        if (hasWriteFunction)
          contract.write = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, getAction_js_1.getAction)(walletClient, writeContract_js_1.writeContract, "writeContract")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
      }
      if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction)
          contract.estimateGas = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                const client = publicClient ?? walletClient;
                return (0, getAction_js_1.getAction)(client, estimateContractGas_js_1.estimateContractGas, "estimateContractGas")({
                  abi,
                  address,
                  functionName,
                  args,
                  ...options,
                  account: options.account ?? walletClient.account
                });
              };
            }
          });
      }
      contract.address = address;
      contract.abi = abi;
      return contract;
    }
    exports.getContract = getContract;
    function getFunctionParameters(values) {
      const hasArgs = values.length && Array.isArray(values[0]);
      const args = hasArgs ? values[0] : [];
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getFunctionParameters = getFunctionParameters;
    function getEventParameters(values, abiEvent) {
      let hasArgs = false;
      if (Array.isArray(values[0]))
        hasArgs = true;
      else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
      } else if (values.length === 2) {
        hasArgs = true;
      }
      const args = hasArgs ? values[0] : void 0;
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getEventParameters = getEventParameters;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = void 0;
    var getAddress_js_1 = require_getAddress();
    var keccak256_js_1 = require_keccak256();
    function publicKeyToAddress(publicKey) {
      const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
      return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
    }
    exports.publicKeyToAddress = publicKeyToAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/accounts.js
var require_accounts = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/accounts.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = exports.parseAccount = void 0;
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/uid.js
var require_uid = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/uid.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uid = void 0;
    var size = 256;
    var index = size;
    var buffer;
    function uid(length = 11) {
      if (!buffer || index + length > size * 2) {
        buffer = "";
        index = 0;
        for (let i = 0; i < size; i++) {
          buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
        }
      }
      return buffer.substring(index, index++ + length);
    }
    exports.uid = uid;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createClient.js
var require_createClient = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createClient.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createClient = void 0;
    var accounts_js_1 = require_accounts();
    var uid_js_1 = require_uid();
    function createClient(parameters) {
      const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
      const chain = parameters.chain;
      const account = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : void 0;
      const { config, request, value } = parameters.transport({
        chain,
        pollingInterval
      });
      const transport = { ...config, ...value };
      const client = {
        account,
        batch,
        cacheTime,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)()
      };
      function extend(base) {
        return (extendFn) => {
          const extended = extendFn(base);
          for (const key2 in client)
            delete extended[key2];
          const combined = { ...base, ...extended };
          return Object.assign(combined, { extend: extend(combined) });
        };
      }
      return Object.assign(client, { extend: extend(client) });
    }
    exports.createClient = createClient;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withRetry.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withRetry = void 0;
    var wait_js_1 = require_wait();
    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
      return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
          const retry = async ({ error }) => {
            const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
            if (delay)
              await (0, wait_js_1.wait)(delay);
            attemptRetry({ count: count + 1 });
          };
          try {
            const data = await fn();
            resolve(data);
          } catch (err) {
            if (count < retryCount && await shouldRetry({ count, error: err }))
              return retry({ error: err });
            reject(err);
          }
        };
        attemptRetry();
      });
    }
    exports.withRetry = withRetry;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/buildRequest.js
var require_buildRequest = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/buildRequest.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildRequest = exports.isDeterministicError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    var withRetry_js_1 = require_withRetry();
    var isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof request_js_1.HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
    exports.isDeterministicError = isDeterministicError;
    function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
      return async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            case 5e3:
              throw new rpc_js_1.UserRejectedRequestError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error)
      });
    }
    exports.buildRequest = buildRequest;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/createTransport.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransport = void 0;
    var buildRequest_js_1 = require_buildRequest();
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
      return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value
      };
    }
    exports.createTransport = createTransport;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/custom.js
var require_custom = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/custom.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.custom = void 0;
    var createTransport_js_1 = require_createTransport();
    function custom(provider, config = {}) {
      const { key = "custom", name = "Custom Provider", retryDelay } = config;
      return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config.retryCount ?? defaultRetryCount,
        retryDelay,
        type: "custom"
      });
    }
    exports.custom = custom;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/fallback.js
var require_fallback = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/fallback.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rankTransports = exports.fallback = void 0;
    var buildRequest_js_1 = require_buildRequest();
    var wait_js_1 = require_wait();
    var createTransport_js_1 = require_createTransport();
    function fallback(transports_, config = {}) {
      const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
      return ({ chain, pollingInterval = 4e3, timeout }) => {
        let transports = transports_;
        let onResponse = () => {
        };
        const transport = (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const fetch2 = async (i = 0) => {
              const transport2 = transports[i]({ chain, retryCount: 0, timeout });
              try {
                const response = await transport2.request({
                  method,
                  params
                });
                onResponse({
                  method,
                  params,
                  response,
                  transport: transport2,
                  status: "success"
                });
                return response;
              } catch (err) {
                onResponse({
                  error: err,
                  method,
                  params,
                  transport: transport2,
                  status: "error"
                });
                if ((0, buildRequest_js_1.isDeterministicError)(err))
                  throw err;
                if (i === transports.length - 1)
                  throw err;
                return fetch2(i + 1);
              }
            };
            return fetch2();
          },
          retryCount,
          retryDelay,
          type: "fallback"
        }, {
          onResponse: (fn) => onResponse = fn,
          transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
        });
        if (rank) {
          const rankOptions = typeof rank === "object" ? rank : {};
          rankTransports({
            chain,
            interval: rankOptions.interval ?? pollingInterval,
            onTransports: (transports_2) => transports = transports_2,
            sampleCount: rankOptions.sampleCount,
            timeout: rankOptions.timeout,
            transports,
            weights: rankOptions.weights
          });
        }
        return transport;
      };
    }
    exports.fallback = fallback;
    function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
      const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
      const samples = [];
      const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
          const transport_ = transport({ chain, retryCount: 0, timeout });
          const start = Date.now();
          let end;
          let success;
          try {
            await transport_.request({ method: "net_listening" });
            success = 1;
          } catch {
            success = 0;
          } finally {
            end = Date.now();
          }
          const latency = end - start;
          return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
          samples.shift();
        const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
        const scores = transports.map((_, i) => {
          const latencies = samples.map((sample2) => sample2[i].latency);
          const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
          const latencyScore = 1 - meanLatency / maxLatency;
          const successes = samples.map((sample2) => sample2[i].success);
          const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
          if (stabilityScore === 0)
            return [0, i];
          return [
            latencyWeight * latencyScore + stabilityWeight * stabilityScore,
            i
          ];
        }).sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
      };
      rankTransports_();
    }
    exports.rankTransports = rankTransports;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/transport.js
var require_transport = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/transport.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlRequiredError = void 0;
    var base_js_1 = require_base();
    var UrlRequiredError = class extends base_js_1.BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
    exports.UrlRequiredError = UrlRequiredError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/isows/_esm/utils.js
function getNativeWebSocket() {
  if (typeof WebSocket !== "undefined")
    return WebSocket;
  if (typeof global.WebSocket !== "undefined")
    return global.WebSocket;
  if (typeof window.WebSocket !== "undefined")
    return window.WebSocket;
  if (typeof self.WebSocket !== "undefined")
    return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}
var import_dist, import_dist2, import_dist3;
var init_utils = __esm({
  "node_modules/@pushprotocol/restapi/node_modules/isows/_esm/utils.js"() {
    import_dist = __toESM(require_dist(), 1);
    import_dist2 = __toESM(require_dist2(), 1);
    import_dist3 = __toESM(require_dist3(), 1);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/isows/_esm/native.js
var native_exports = {};
__export(native_exports, {
  WebSocket: () => WebSocket2
});
var import_dist4, import_dist5, import_dist6, WebSocket2;
var init_native = __esm({
  "node_modules/@pushprotocol/restapi/node_modules/isows/_esm/native.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
    init_utils();
    WebSocket2 = getNativeWebSocket();
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/promise/withTimeout.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
      return new Promise((resolve, reject) => {
        ;
        (async () => {
          let timeoutId;
          try {
            const controller = new AbortController();
            if (timeout > 0) {
              timeoutId = setTimeout(() => {
                if (signal) {
                  controller.abort();
                } else {
                  reject(errorInstance);
                }
              }, timeout);
            }
            resolve(await fn({ signal: controller?.signal }));
          } catch (err) {
            if (err.name === "AbortError")
              reject(errorInstance);
            reject(err);
          } finally {
            clearTimeout(timeoutId);
          }
        })();
      });
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/rpc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpc = exports.getSocket = exports.socketsCache = void 0;
    var isows_1 = (init_native(), __toCommonJS(native_exports));
    var request_js_1 = require_request();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var withTimeout_js_1 = require_withTimeout();
    var stringify_js_1 = require_stringify2();
    var id = 0;
    async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
          const response2 = await fetch(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? id++,
              ...body2
            }))) : (0, stringify_js_1.stringify)({ jsonrpc: "2.0", id: body.id ?? id++, ...body }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : void 0)
          });
          return response2;
        }, {
          errorInstance: new request_js_1.TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new request_js_1.HttpRequestError({
            body,
            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
          throw err;
        if (err instanceof request_js_1.TimeoutError)
          throw err;
        throw new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    exports.socketsCache = /* @__PURE__ */ new Map();
    async function getSocket(url) {
      let socket = exports.socketsCache.get(url);
      if (socket)
        return socket;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: url,
        fn: async () => {
          const webSocket2 = new isows_1.WebSocket(url);
          const requests = /* @__PURE__ */ new Map();
          const subscriptions = /* @__PURE__ */ new Map();
          const onMessage = ({ data }) => {
            const message = JSON.parse(data);
            const isSubscription = message.method === "eth_subscription";
            const id2 = isSubscription ? message.params.subscription : message.id;
            const cache = isSubscription ? subscriptions : requests;
            const callback = cache.get(id2);
            if (callback)
              callback({ data });
            if (!isSubscription)
              cache.delete(id2);
          };
          const onClose = () => {
            exports.socketsCache.delete(url);
            webSocket2.removeEventListener("close", onClose);
            webSocket2.removeEventListener("message", onMessage);
          };
          webSocket2.addEventListener("close", onClose);
          webSocket2.addEventListener("message", onMessage);
          if (webSocket2.readyState === isows_1.WebSocket.CONNECTING) {
            await new Promise((resolve, reject) => {
              if (!webSocket2)
                return;
              webSocket2.onopen = resolve;
              webSocket2.onerror = reject;
            });
          }
          socket = Object.assign(webSocket2, {
            requests,
            subscriptions
          });
          exports.socketsCache.set(url, socket);
          return [socket];
        }
      });
      const [_, [socket_]] = await schedule();
      return socket_;
    }
    exports.getSocket = getSocket;
    function webSocket(socket, { body, onResponse }) {
      if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
          body,
          url: socket.url,
          details: "Socket is closed."
        });
      const id_ = id++;
      const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id)
          return;
        onResponse?.(message);
        if (body.method === "eth_subscribe" && typeof message.result === "string") {
          socket.subscriptions.set(message.result, callback);
        }
        if (body.method === "eth_unsubscribe") {
          socket.subscriptions.delete(body.params?.[0]);
        }
      };
      socket.requests.set(id_, callback);
      socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
      return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 1e4 }) {
      return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
        body,
        onResponse
      })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout
      });
    }
    exports.rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/http.js
var require_http = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/http.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function http(url, config = {}) {
      const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1e3, wait = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
              id: `${url}`,
              wait,
              shouldSplitBatch(requests) {
                return requests.length > batchSize;
              },
              fn: (body2) => rpc_js_1.rpc.http(url_, {
                body: body2,
                fetchOptions,
                timeout
              }),
              sort: (a, b) => a.id - b.id
            });
            const fn = async (body2) => batch ? schedule(body2) : [await rpc_js_1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
            const [{ error, result }] = await fn(body);
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "http"
        }, {
          fetchOptions,
          url
        });
      };
    }
    exports.http = http;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/errors.js
var require_errors2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/errors.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNullUniversalResolverError = void 0;
    var solidity_js_1 = require_solidity();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    function isNullUniversalResolverError(err, callType) {
      if (!(err instanceof base_js_1.BaseError))
        return false;
      const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
      if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
      if (cause.data?.errorName === "ResolverNotFound")
        return true;
      if (cause.data?.errorName === "ResolverWildcardNotSupported")
        return true;
      if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
        return true;
      if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
        return true;
      return false;
    }
    exports.isNullUniversalResolverError = isNullUniversalResolverError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodedLabelToLabelhash = void 0;
    var isHex_js_1 = require_isHex();
    function encodedLabelToLabelhash(label) {
      if (label.length !== 66)
        return null;
      if (label.indexOf("[") !== 0)
        return null;
      if (label.indexOf("]") !== 65)
        return null;
      const hash = `0x${label.slice(1, 65)}`;
      if (!(0, isHex_js_1.isHex)(hash))
        return null;
      return hash;
    }
    exports.encodedLabelToLabelhash = encodedLabelToLabelhash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/namehash.js
var require_namehash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/namehash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namehash = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function namehash(name) {
      let result = new Uint8Array(32).fill(0);
      if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
      const labels = name.split(".");
      for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), "bytes");
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
      }
      return (0, toHex_js_1.bytesToHex)(result);
    }
    exports.namehash = namehash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/encodeLabelhash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeLabelhash = void 0;
    function encodeLabelhash(hash) {
      return `[${hash.slice(2)}]`;
    }
    exports.encodeLabelhash = encodeLabelhash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/labelhash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.labelhash = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function labelhash(label) {
      const result = new Uint8Array(32).fill(0);
      if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
      return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
    }
    exports.labelhash = labelhash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/packetToBytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packetToBytes = void 0;
    var toBytes_js_1 = require_toBytes();
    var encodeLabelhash_js_1 = require_encodeLabelhash();
    var labelhash_js_1 = require_labelhash();
    function packetToBytes(packet) {
      const value = packet.replace(/^\.|\.$/gm, "");
      if (value.length === 0)
        return new Uint8Array(1);
      const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
      let offset = 0;
      const list = value.split(".");
      for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
          encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
      }
      if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
      return bytes;
    }
    exports.packetToBytes = packetToBytes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAddress = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
          abi: abis_js_1.addressResolverAbi,
          functionName: "addr",
          ...coinType != null ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] } : { args: [(0, namehash_js_1.namehash)(name)] }
        });
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.addressResolverAbi,
          args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : void 0,
          functionName: "addr",
          data: res[0]
        });
        if (address === "0x")
          return null;
        if ((0, trim_js_1.trim)(address) === "0x00")
          return null;
        return address;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsAddress = getEnsAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/ens.js
var require_ens = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/ens.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
    var base_js_1 = require_base();
    var EnsAvatarInvalidMetadataError = class extends base_js_1.BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
    var EnsAvatarInvalidNftUriError = class extends base_js_1.BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
    var EnsAvatarUriResolutionError = class extends base_js_1.BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
    var EnsAvatarUnsupportedNamespaceError = class extends base_js_1.BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
    exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/avatar/utils.js
var require_utils5 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/avatar/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;
    var readContract_js_1 = require_readContract();
    var ens_js_1 = require_ens();
    var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
      try {
        const res = await fetch(uri, { method: "HEAD" });
        if (res.status === 200) {
          const contentType = res.headers.get("content-type");
          return contentType?.startsWith("image/");
        }
        return false;
      } catch (error) {
        if (typeof error === "object" && typeof error.response !== "undefined") {
          return false;
        }
        if (!globalThis.hasOwnProperty("Image"))
          return false;
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(true);
          };
          img.onerror = () => {
            resolve(false);
          };
          img.src = uri;
        });
      }
    }
    exports.isImageUri = isImageUri;
    function getGateway(custom, defaultGateway) {
      if (!custom)
        return defaultGateway;
      if (custom.endsWith("/"))
        return custom.slice(0, -1);
      return custom;
    }
    exports.getGateway = getGateway;
    function resolveAvatarUri({ uri, gatewayUrls }) {
      const isEncoded = base64Regex.test(uri);
      if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
      const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
      const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
      const networkRegexMatch = uri.match(networkRegex);
      const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
      const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
      const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
      if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
          replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
      }
      if ((isIPNS || isIPFS) && target) {
        return {
          uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      if (protocol === "ar:/" && target) {
        return {
          uri: `${arweaveGateway}/${target}${subtarget || ""}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      let parsedUri = uri.replace(dataURIRegex, "");
      if (parsedUri.startsWith("<svg")) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
      }
      if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
        return {
          uri: parsedUri,
          isOnChain: true,
          isEncoded: false
        };
      }
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.resolveAvatarUri = resolveAvatarUri;
    function getJsonImage(data) {
      if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
      }
      return data.image || data.image_url || data.image_data;
    }
    exports.getJsonImage = getJsonImage;
    async function getMetadataAvatarUri({ gatewayUrls, uri }) {
      try {
        const res = await fetch(uri).then((res2) => res2.json());
        const image = await parseAvatarUri({
          gatewayUrls,
          uri: getJsonImage(res)
        });
        return image;
      } catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
      }
    }
    exports.getMetadataAvatarUri = getMetadataAvatarUri;
    async function parseAvatarUri({ gatewayUrls, uri }) {
      const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
      if (isOnChain)
        return resolvedURI;
      const isImage = await isImageUri(resolvedURI);
      if (isImage)
        return resolvedURI;
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.parseAvatarUri = parseAvatarUri;
    function parseNftUri(uri_) {
      let uri = uri_;
      if (uri.startsWith("did:nft:")) {
        uri = uri.replace("did:nft:", "").replace(/_/g, "/");
      }
      const [reference, asset_namespace, tokenID] = uri.split("/");
      const [eip_namespace, chainID] = reference.split(":");
      const [erc_namespace, contractAddress] = asset_namespace.split(":");
      if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
      if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
      if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
          reason: "Contract address not found"
        });
      if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
      if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
      return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress,
        tokenID
      };
    }
    exports.parseNftUri = parseNftUri;
    async function getNftTokenUri(client, { nft }) {
      if (nft.namespace === "erc721") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "tokenId", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "tokenURI",
          args: [BigInt(nft.tokenID)]
        });
      }
      if (nft.namespace === "erc1155") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "_id", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "uri",
          args: [BigInt(nft.tokenID)]
        });
      }
      throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }
    exports.getNftTokenUri = getNftTokenUri;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAvatarRecord = void 0;
    var utils_js_1 = require_utils5();
    async function parseAvatarRecord(client, { gatewayUrls, record }) {
      if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
      return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
    }
    exports.parseAvatarRecord = parseAvatarRecord;
    async function parseNftAvatarUri(client, { gatewayUrls, record }) {
      const nft = (0, utils_js_1.parseNftUri)(record);
      const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
      const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
      if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
      }
      let uriTokenId = nft.tokenID;
      if (nft.namespace === "erc1155")
        uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
      return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
      });
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsText.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsText = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [
            (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
            (0, encodeFunctionData_js_1.encodeFunctionData)({
              abi: abis_js_1.textResolverAbi,
              functionName: "text",
              args: [(0, namehash_js_1.namehash)(name), key]
            })
          ],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.textResolverAbi,
          functionName: "text",
          data: res[0]
        });
        return record === "" ? null : record;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsText = getEnsText;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsAvatar.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAvatar = void 0;
    var parseAvatarRecord_js_1 = require_parseAvatarRecord();
    var getAction_js_1 = require_getAction();
    var getEnsText_js_1 = require_getEnsText();
    async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
      const record = await (0, getAction_js_1.getAction)(client, getEnsText_js_1.getEnsText, "getEnsText")({
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
      });
      if (!record)
        return null;
      try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
      } catch {
        return null;
      }
    }
    exports.getEnsAvatar = getEnsAvatar;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsName.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsName = void 0;
    var abis_js_1 = require_abis();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
      try {
        const [name, resolvedAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverReverseAbi,
          functionName: "reverse",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
          blockNumber,
          blockTag
        });
        if (address.toLowerCase() !== resolvedAddress.toLowerCase())
          return null;
        return name;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
          return null;
        throw err;
      }
    }
    exports.getEnsName = getEnsName;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/ens/getEnsResolver.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsResolver = void 0;
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
        address: universalResolverAddress,
        abi: [
          {
            inputs: [{ type: "bytes" }],
            name: "findResolver",
            outputs: [{ type: "address" }, { type: "bytes32" }],
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "findResolver",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag
      });
      return resolverAddress;
    }
    exports.getEnsResolver = getEnsResolver;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createBlockFilter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBlockFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createBlockFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
      });
      const id = await client.request({
        method: "eth_newBlockFilter"
      });
      return { id, request: getRequest(id), type: "block" };
    }
    exports.createBlockFilter = createBlockFilter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createEventFilter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
      const events = events_ ?? (event ? [event] : void 0);
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            ...topics.length ? { topics } : {}
          }
        ]
      });
      return {
        abi: events,
        args,
        eventName: event ? event.name : void 0,
        fromBlock,
        id,
        request: getRequest(id),
        strict,
        toBlock,
        type: "event"
      };
    }
    exports.createEventFilter = createEventFilter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPendingTransactionFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createPendingTransactionFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
      });
      const id = await client.request({
        method: "eth_newPendingTransactionFilter"
      });
      return { id, request: getRequest(id), type: "transaction" };
    }
    exports.createPendingTransactionFilter = createPendingTransactionFilter;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBalance.js
var require_getBalance = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBalance.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const balance = await client.request({
        method: "eth_getBalance",
        params: [address, blockNumberHex || blockTag]
      });
      return BigInt(balance);
    }
    exports.getBalance = getBalance;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let count;
      if (blockHash) {
        count = await client.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [blockHash]
        });
      } else {
        count = await client.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [blockNumberHex || blockTag]
        });
      }
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getBlockTransactionCount = getBlockTransactionCount;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getBytecode.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBytecode = void 0;
    var toHex_js_1 = require_toHex();
    async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const hex = await client.request({
        method: "eth_getCode",
        params: [address, blockNumberHex || blockTag]
      });
      if (hex === "0x")
        return void 0;
      return hex;
    }
    exports.getBytecode = getBytecode;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/feeHistory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatFeeHistory = void 0;
    function formatFeeHistory(feeHistory) {
      return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
      };
    }
    exports.formatFeeHistory = formatFeeHistory;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFeeHistory.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeeHistory = void 0;
    var toHex_js_1 = require_toHex();
    var feeHistory_js_1 = require_feeHistory();
    async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
          (0, toHex_js_1.numberToHex)(blockCount),
          blockNumberHex || blockTag,
          rewardPercentiles
        ]
      });
      return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
    }
    exports.getFeeHistory = getFeeHistory;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getFilterLogs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log();
    async function getFilterLogs(_client, { filter }) {
      const strict = filter.strict ?? false;
      const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [filter.id]
      });
      return logs.map((log) => {
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterLogs = getFilterLogs;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/extractChain.js
var require_extractChain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/chain/extractChain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractChain = void 0;
    function extractChain({ chains, id }) {
      return chains.find((chain) => chain.id === id);
    }
    exports.extractChain = extractChain;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/regex.js
var require_regex3 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/regex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
    exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hashTypedData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashDomain = exports.hashTypedData = void 0;
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var typedData_js_1 = require_typedData();
    function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
      const domain = typeof domain_ === "undefined" ? {} : domain_;
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      const parts = ["0x1901"];
      if (domain)
        parts.push(hashDomain({
          domain,
          types
        }));
      if (primaryType !== "EIP712Domain") {
        parts.push(hashStruct({
          data: message,
          primaryType,
          types
        }));
      }
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
    }
    exports.hashTypedData = hashTypedData;
    function hashDomain({ domain, types }) {
      return hashStruct({
        data: domain,
        primaryType: "EIP712Domain",
        types
      });
    }
    exports.hashDomain = hashDomain;
    function hashStruct({ data, primaryType, types }) {
      const encoded = encodeData({
        data,
        primaryType,
        types
      });
      return (0, keccak256_js_1.keccak256)(encoded);
    }
    function encodeData({ data, primaryType, types }) {
      const encodedTypes = [{ type: "bytes32" }];
      const encodedValues = [hashType({ primaryType, types })];
      for (const field of types[primaryType]) {
        const [type, value] = encodeField({
          types,
          name: field.name,
          type: field.type,
          value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
    }
    function hashType({ primaryType, types }) {
      const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
      return (0, keccak256_js_1.keccak256)(encodedHashType);
    }
    function encodeType({ primaryType, types }) {
      let result = "";
      const unsortedDeps = findTypeDependencies({ primaryType, types });
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
      const match = primaryType_.match(/^\w*/u);
      const primaryType = match?.[0];
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
      }
      return results;
    }
    function encodeField({ types, name, type, value }) {
      if (types[type] !== void 0) {
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types }))
        ];
      }
      if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
      }
      if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
      if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField({
          name,
          type: parsedType,
          types,
          value: item
        }));
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [{ type }, value];
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/typedData.js
var require_typedData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/typedData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var size_js_1 = require_size();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex3();
    var hashTypedData_js_1 = require_hashTypedData();
    function validateTypedData({ domain, message, primaryType, types: types_ }) {
      const types = types_;
      const validateData = (struct, value_) => {
        for (const param of struct) {
          const { name, type: type_ } = param;
          const type = type_;
          const value = value_[name];
          const integerMatch = type.match(regex_js_1.integerRegex);
          if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
            const [_type, base, size_] = integerMatch;
            (0, toHex_js_1.numberToHex)(value, {
              signed: base === "int",
              size: parseInt(size_) / 8
            });
          }
          if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
            throw new address_js_1.InvalidAddressError({ address: value });
          const bytesMatch = type.match(regex_js_1.bytesRegex);
          if (bytesMatch) {
            const [_type, size_] = bytesMatch;
            if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
              throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size_),
                givenSize: (0, size_js_1.size)(value)
              });
          }
          const struct2 = types[type];
          if (struct2)
            validateData(struct2, value);
        }
      };
      if (types.EIP712Domain && domain)
        validateData(types.EIP712Domain, domain);
      if (primaryType !== "EIP712Domain") {
        const type = types[primaryType];
        validateData(type, message);
      }
    }
    exports.validateTypedData = validateTypedData;
    function getTypesForEIP712Domain({ domain }) {
      return [
        typeof domain?.name === "string" && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        typeof domain?.chainId === "number" && {
          name: "chainId",
          type: "uint256"
        },
        domain?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean);
    }
    exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
    function domainSeparator({ domain }) {
      return (0, hashTypedData_js_1.hashDomain)({
        domain,
        types: {
          EIP712Domain: getTypesForEIP712Domain({ domain })
        }
      });
    }
    exports.domainSeparator = domainSeparator;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeFunctionData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeFunctionData({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      const description = abi.find((x) => x.type === "function" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeFunctionData"
        });
      return {
        functionName: description.name,
        args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : void 0
      };
    }
    exports.decodeFunctionData = decodeFunctionData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeDeployData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var docsPath = "/docs/contract/encodeDeployData";
    function encodeDeployData({ abi, args, bytecode }) {
      if (!args || args.length === 0)
        return bytecode;
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
      return (0, concat_js_1.concatHex)([bytecode, data]);
    }
    exports.encodeDeployData = encodeDeployData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeErrorResult.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeErrorResult = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeErrorResult";
    function encodeErrorResult({ abi, errorName, args }) {
      let abiItem = abi[0];
      if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: errorName
        });
        if (!abiItem)
          throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
      }
      if (abiItem.type !== "error")
        throw new abi_js_1.AbiErrorNotFoundError(void 0, { docsPath });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      let data = "0x";
      if (args && args.length > 0) {
        if (!abiItem.inputs)
          throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
      }
      return (0, concat_js_1.concatHex)([signature, data]);
    }
    exports.encodeErrorResult = encodeErrorResult;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeFunctionResult";
    function encodeFunctionResult({ abi, functionName, result }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionResult"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionResult"
        });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      let values = Array.isArray(result) ? result : [result];
      if (abiItem.outputs.length === 0 && !values[0])
        values = [];
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
    }
    exports.encodeFunctionResult = encodeFunctionResult;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/encodePacked.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePacked = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex3();
    function encodePacked(types, values) {
      if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: types.length,
          givenLength: values.length
        });
      const data = [];
      for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
      }
      return (0, concat_js_1.concatHex)(data);
    }
    exports.encodePacked = encodePacked;
    function encode(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
          size: isArray ? 32 : null
        });
      }
      if (type === "string")
        return (0, toHex_js_1.stringToHex)(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
      const intMatch = type.match(regex_js_1.integerRegex);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
          size: isArray ? 32 : size,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(regex_js_1.bytesRegex);
      if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (parseInt(size) !== (value.length - 2) / 2)
          throw new abi_js_1.BytesSizeMismatchError({
            expectedSize: parseInt(size),
            givenSize: (value.length - 2) / 2
          });
        return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
      }
      const arrayMatch = type.match(regex_js_1.arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
          data.push(encode(childType, value[i], true));
        }
        if (data.length === 0)
          return "0x";
        return (0, concat_js_1.concatHex)(data);
      }
      throw new abi_js_1.UnsupportedPackedAbiType(type);
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isBytes.js
var require_isBytes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isBytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = void 0;
    function isBytes(value) {
      if (!value)
        return false;
      if (typeof value !== "object")
        return false;
      if (!("BYTES_PER_ELEMENT" in value))
        return false;
      return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/address/getContractAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = void 0;
    var concat_js_1 = require_concat();
    var isBytes_js_1 = require_isBytes();
    var pad_js_1 = require_pad();
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var toRlp_js_1 = require_toRlp();
    var keccak256_js_1 = require_keccak256();
    var getAddress_js_1 = require_getAddress();
    function getContractAddress(opts) {
      if (opts.opcode === "CREATE2")
        return getCreate2Address(opts);
      return getCreateAddress(opts);
    }
    exports.getContractAddress = getContractAddress;
    function getCreateAddress(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
      if (nonce[0] === 0)
        nonce = new Uint8Array([]);
      return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
    }
    exports.getCreateAddress = getCreateAddress;
    function getCreate2Address(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32
      });
      const bytecodeHash = (() => {
        if ("bytecodeHash" in opts) {
          if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
            return opts.bytecodeHash;
          return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);
        }
        return (0, keccak256_js_1.keccak256)(opts.bytecode, "bytes");
      })();
      return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/contract/extractFunctionParts.js
var require_extractFunctionParts = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/contract/extractFunctionParts.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.extractFunctionParts = void 0;
    var paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    function extractFunctionParts(def) {
      const parts = def.match(paramsRegex);
      const type = parts?.[2] || void 0;
      const name = parts?.[3];
      const params = parts?.[5] || void 0;
      return { type, name, params };
    }
    exports.extractFunctionParts = extractFunctionParts;
    function extractFunctionName(def) {
      return extractFunctionParts(def).name;
    }
    exports.extractFunctionName = extractFunctionName;
    function extractFunctionParams(def) {
      const params = extractFunctionParts(def).params;
      const splitParams = params?.split(",").map((x) => x.trim().split(" "));
      return splitParams?.map((param) => ({
        type: param[0],
        name: param[1] === "indexed" ? param[2] : param[1],
        ...param[1] === "indexed" ? { indexed: true } : {}
      }));
    }
    exports.extractFunctionParams = extractFunctionParams;
    function extractFunctionType(def) {
      return extractFunctionParts(def).type;
    }
    exports.extractFunctionType = extractFunctionType;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromBytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.fromBytes = void 0;
    var encoding_js_1 = require_encoding();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function fromBytes(bytes, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return bytesToNumber(bytes, opts);
      if (to === "bigint")
        return bytesToBigInt(bytes, opts);
      if (to === "boolean")
        return bytesToBool(bytes, opts);
      if (to === "string")
        return bytesToString(bytes, opts);
      return (0, toHex_js_1.bytesToHex)(bytes, opts);
    }
    exports.fromBytes = fromBytes;
    function bytesToBigInt(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToBigInt)(hex);
    }
    exports.bytesToBigInt = bytesToBigInt;
    function bytesToBool(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
      }
      if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
      return Boolean(bytes[0]);
    }
    exports.bytesToBool = bytesToBool;
    function bytesToNumber(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToNumber)(hex);
    }
    exports.bytesToNumber = bytesToNumber;
    function bytesToString(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/cursor.js
var require_cursor = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/errors/cursor.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;
    var base_js_1 = require_base();
    var NegativeOffsetError = class extends base_js_1.BaseError {
      constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NegativeOffsetError"
        });
      }
    };
    exports.NegativeOffsetError = NegativeOffsetError;
    var PositionOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "PositionOutOfBoundsError"
        });
      }
    };
    exports.PositionOutOfBoundsError = PositionOutOfBoundsError;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/cursor.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCursor = void 0;
    var cursor_js_1 = require_cursor();
    var staticCursor = {
      bytes: new Uint8Array(),
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
          throw new cursor_js_1.PositionOutOfBoundsError({
            length: this.bytes.length,
            position
          });
      },
      decrementPosition(offset) {
        if (offset < 0)
          throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
      },
      incrementPosition(offset) {
        if (offset < 0)
          throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
      },
      inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
      },
      inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
      },
      inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
      },
      inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
      },
      pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
      },
      pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
      },
      pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
      },
      pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
      },
      pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
      },
      pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
      },
      readByte() {
        const value = this.inspectByte();
        this.position++;
        return value;
      },
      readBytes(length) {
        const value = this.inspectBytes(length);
        this.position += length;
        return value;
      },
      readUint8() {
        const value = this.inspectUint8();
        this.position += 1;
        return value;
      },
      readUint16() {
        const value = this.inspectUint16();
        this.position += 2;
        return value;
      },
      readUint24() {
        const value = this.inspectUint24();
        this.position += 3;
        return value;
      },
      readUint32() {
        const value = this.inspectUint32();
        this.position += 4;
        return value;
      },
      setPosition(position) {
        this.assertPosition(position);
        this.position = position;
      }
    };
    function createCursor(bytes) {
      const cursor = Object.create(staticCursor);
      cursor.bytes = bytes;
      cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      return cursor;
    }
    exports.createCursor = createCursor;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/fromRlp.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlpToHex = exports.rlpToBytes = exports.fromRlp = void 0;
    var base_js_1 = require_base();
    var encoding_js_1 = require_encoding();
    var cursor_js_1 = require_cursor2();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function fromRlp(value, to = "hex") {
      const bytes = (() => {
        if (typeof value === "string") {
          if (value.length > 3 && value.length % 2 !== 0)
            throw new encoding_js_1.InvalidHexValueError(value);
          return (0, toBytes_js_1.hexToBytes)(value);
        }
        return value;
      })();
      const cursor = (0, cursor_js_1.createCursor)(bytes);
      const result = fromRlpCursor(cursor, to);
      return result;
    }
    exports.fromRlp = fromRlp;
    function rlpToBytes(bytes, to = "bytes") {
      return fromRlp(bytes, to);
    }
    exports.rlpToBytes = rlpToBytes;
    function rlpToHex(hex, to = "hex") {
      return fromRlp(hex, to);
    }
    exports.rlpToHex = rlpToHex;
    function fromRlpCursor(cursor, to = "hex") {
      if (cursor.bytes.length === 0)
        return to === "hex" ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes;
      const prefix = cursor.readByte();
      if (prefix < 128)
        cursor.decrementPosition(1);
      if (prefix < 192) {
        const length2 = readLength(cursor, prefix, 128);
        const bytes = cursor.readBytes(length2);
        return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
      }
      const length = readLength(cursor, prefix, 192);
      return readList(cursor, length, to);
    }
    function readLength(cursor, prefix, offset) {
      if (offset === 128 && prefix < 128)
        return 1;
      if (prefix <= offset + 55)
        return prefix - offset;
      if (prefix === offset + 55 + 1)
        return cursor.readUint8();
      if (prefix === offset + 55 + 2)
        return cursor.readUint16();
      if (prefix === offset + 55 + 3)
        return cursor.readUint24();
      if (prefix === offset + 55 + 4)
        return cursor.readUint32();
      throw new base_js_1.BaseError("Invalid RLP prefix");
    }
    function readList(cursor, length, to) {
      const position = cursor.position;
      const value = [];
      while (cursor.position - position < length)
        value.push(fromRlpCursor(cursor, to));
      return value;
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/isHash.js
var require_isHash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/isHash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHash = void 0;
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function isHash(hash) {
      return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
    }
    exports.isHash = isHash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils4();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils4();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/sha256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var sha256_1 = require_sha256();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function sha256(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, sha256_1.sha256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports.sha256 = sha256;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils4();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
    var Pi = Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    var rotl = (word, shift) => word << shift | word >>> 32 - shift;
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/ripemd160.js
var require_ripemd1602 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/hash/ripemd160.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function ripemd160(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, ripemd160_1.ripemd160)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports.ripemd160 = ripemd160;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
var require_assert3 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
var require_utils6 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
var require_sha22 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils6();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js
var require_sha2563 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha22();
    var utils_js_1 = require_utils6();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils7 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils7();
    var utils_js_1 = require_utils7();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils6();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils6();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha2563();
    var utils_1 = require_utils6();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils7();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverPublicKey.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverPublicKey = void 0;
    var isHex_js_1 = require_isHex();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function recoverPublicKey({ hash, signature }) {
      const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
      const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
      let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
      if (v === 0 || v === 1)
        v += 27;
      const { secp256k1 } = await Promise.resolve().then(() => require_secp256k1());
      const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
      return `0x${publicKey}`;
    }
    exports.recoverPublicKey = recoverPublicKey;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverAddress = void 0;
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    async function recoverAddress({ hash, signature }) {
      return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash, signature }));
    }
    exports.recoverAddress = recoverAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/strings.js
var require_strings = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/strings.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.presignMessagePrefix = void 0;
    exports.presignMessagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hashMessage.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = void 0;
    var strings_js_1 = require_strings();
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    function hashMessage(message, to_) {
      const messageBytes = (() => {
        if (typeof message === "string")
          return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
          return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
      })();
      const prefixBytes = (0, toBytes_js_1.stringToBytes)(`${strings_js_1.presignMessagePrefix}${messageBytes.length}`);
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
    }
    exports.hashMessage = hashMessage;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverMessageAddress = void 0;
    var hashMessage_js_1 = require_hashMessage();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverMessageAddress({ message, signature }) {
      return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
    }
    exports.recoverMessageAddress = recoverMessageAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedDataAddress = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverTypedDataAddress({ domain, message, primaryType, signature, types }) {
      return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        }),
        signature
      });
    }
    exports.recoverTypedDataAddress = recoverTypedDataAddress;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/verifyMessage.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    async function verifyMessage({ address, message, signature }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/verifyTypedData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    async function verifyTypedData({ address, domain, message, primaryType, signature, types }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
      }));
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializedTransactionType = void 0;
    var transaction_js_1 = require_transaction2();
    var slice_js_1 = require_slice();
    var fromHex_js_1 = require_fromHex();
    function getSerializedTransactionType(serializedTransaction) {
      const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
      if (serializedType === "0x02")
        return "eip1559";
      if (serializedType === "0x01")
        return "eip2930";
      if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
        return "legacy";
      throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
    }
    exports.getSerializedTransactionType = getSerializedTransactionType;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/assertTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    function assertTransactionEIP1559(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertTransactionEIP1559 = assertTransactionEIP1559;
    function assertTransactionEIP2930(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    }
    exports.assertTransactionEIP2930 = assertTransactionEIP2930;
    function assertTransactionLegacy(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof chainId !== "undefined" && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
      if (accessList)
        throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
    }
    exports.assertTransactionLegacy = assertTransactionLegacy;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/parseTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccessList = exports.toTransactionArray = exports.parseTransaction = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var fromRlp_js_1 = require_fromRlp();
    var isHash_js_1 = require_isHash();
    var assertTransaction_js_1 = require_assertTransaction();
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    function parseTransaction(serializedTransaction) {
      const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
      if (type === "eip1559")
        return parseTransactionEIP1559(serializedTransaction);
      if (type === "eip2930")
        return parseTransactionEIP2930(serializedTransaction);
      return parseTransactionLegacy(serializedTransaction);
    }
    exports.parseTransaction = parseTransaction;
    function parseTransactionEIP1559(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip1559"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip1559"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
      if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionEIP2930(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip2930"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip2930"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionLegacy(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
      const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
      if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
              v: chainIdOrV_,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "legacy"
        });
      const transaction = {
        type: "legacy"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      if (transactionArray.length === 6)
        return transaction;
      const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
      if (s === "0x" && r === "0x") {
        if (chainIdOrV > 0)
          transaction.chainId = Number(chainIdOrV);
        return transaction;
      }
      const v = chainIdOrV;
      const chainId = Number((v - 35n) / 2n);
      if (chainId > 0)
        transaction.chainId = chainId;
      else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
      transaction.v = v;
      transaction.s = s;
      transaction.r = r;
      return transaction;
    }
    function toTransactionArray(serializedTransaction) {
      return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
    }
    exports.toTransactionArray = toTransactionArray;
    function parseAccessList(accessList_) {
      const accessList = [];
      for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
          address,
          storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
        });
      }
      return accessList;
    }
    exports.parseAccessList = parseAccessList;
    function parseEIP155Signature(transactionArray) {
      const signature = transactionArray.slice(-3);
      const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
      return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1
      };
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/serializeAccessList.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeAccessList = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    function serializeAccessList(accessList) {
      if (!accessList || accessList.length === 0)
        return [];
      const serializedAccessList = [];
      for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
          if (storageKeys[j].length - 2 !== 64) {
            throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
          }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
          throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
      }
      return serializedAccessList;
    }
    exports.serializeAccessList = serializeAccessList;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/transaction/serializeTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeTransaction = void 0;
    var transaction_js_1 = require_transaction2();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var assertTransaction_js_1 = require_assertTransaction();
    var getTransactionType_js_1 = require_getTransactionType();
    var serializeAccessList_js_1 = require_serializeAccessList();
    function serializeTransaction(transaction, signature) {
      const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
      if (type === "eip1559")
        return serializeTransactionEIP1559(transaction, signature);
      if (type === "eip2930")
        return serializeTransactionEIP2930(transaction, signature);
      return serializeTransactionLegacy(transaction, signature);
    }
    exports.serializeTransaction = serializeTransaction;
    function serializeTransactionEIP1559(transaction, signature) {
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature) {
        const yParity = (() => {
          if (signature.v === 0n)
            return "0x";
          if (signature.v === 1n)
            return (0, toHex_js_1.toHex)(1);
          return signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x02",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionEIP2930(transaction, signature) {
      const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature) {
        const yParity = (() => {
          if (signature.v === 0n)
            return "0x";
          if (signature.v === 1n)
            return (0, toHex_js_1.toHex)(1);
          return signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1);
        })();
        serializedTransaction.push(yParity, (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x01",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionLegacy(transaction, signature) {
      const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x"
      ];
      if (signature) {
        const v = (() => {
          if (chainId > 0)
            return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
          if (signature.v >= 35n) {
            const inferredChainId = (signature.v - 35n) / 2n;
            if (inferredChainId > 0)
              return signature.v;
            return 27n + (signature.v === 35n ? 0n : 1n);
          }
          const v2 = 27n + (signature.v === 27n ? 0n : 1n);
          if (signature.v !== v2)
            throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
          return v2;
        })();
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(v),
          signature.r,
          signature.s
        ];
      } else if (chainId > 0) {
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(chainId),
          "0x",
          "0x"
        ];
      }
      return (0, toRlp_js_1.toRlp)(serializedTransaction);
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseUnits.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnits = void 0;
    function parseUnits(value, decimals) {
      let [integer, fraction = "0"] = value.split(".");
      const negative = integer.startsWith("-");
      if (negative)
        integer = integer.slice(1);
      fraction = fraction.replace(/(0+)$/, "");
      if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
          integer = `${BigInt(integer) + 1n}`;
        fraction = "";
      } else if (fraction.length > decimals) {
        const [left, unit, right] = [
          fraction.slice(0, decimals - 1),
          fraction.slice(decimals - 1, decimals),
          fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
          fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else
          fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
          fraction = fraction.slice(1);
          integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
      } else {
        fraction = fraction.padEnd(decimals, "0");
      }
      return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
    }
    exports.parseUnits = parseUnits;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseEther.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseEther(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
    }
    exports.parseEther = parseEther;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/unit/parseGwei.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGwei = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseGwei(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
    }
    exports.parseGwei = parseGwei;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/index.js
var require_utils8 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = exports.isDeterministicError = void 0;
    exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = void 0;
    exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareTransactionRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHash = exports.getFunctionSelector = exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = void 0;
    var buildRequest_js_1 = require_buildRequest();
    Object.defineProperty(exports, "isDeterministicError", { enumerable: true, get: function() {
      return buildRequest_js_1.isDeterministicError;
    } });
    Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_1.buildRequest;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_1.assertCurrentChain;
    } });
    var defineChain_js_1 = require_defineChain();
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require_extractChain();
    Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_1.getChainContractAddress;
    } });
    var regex_js_1 = require_regex3();
    Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_1.arrayRegex;
    } });
    Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_1.bytesRegex;
    } });
    Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
      return regex_js_1.integerRegex;
    } });
    var rpc_js_1 = require_rpc2();
    Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
      return rpc_js_1.getSocket;
    } });
    Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
      return rpc_js_1.rpc;
    } });
    var stringify_js_1 = require_stringify2();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem2();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiParams;
    } });
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    Object.defineProperty(exports, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var block_js_1 = require_block();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_1.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_1.formatBlock;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_1.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_1.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_1.transactionType;
    } });
    var log_js_1 = require_log();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_1.formatLog;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var extract_js_1 = require_extract();
    Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
      return extract_js_1.extract;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getNodeError_js_1 = require_getNodeError();
    Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.containsNodeError;
    } });
    Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.getNodeError;
    } });
    var getCallError_js_1 = require_getCallError();
    Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_1 = require_getTransactionError();
    Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_1.getTransactionError;
    } });
    var formatter_js_1 = require_formatter();
    Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_1.defineFormatter;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var sha256_js_1 = require_sha2562();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require_ripemd1602();
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    Object.defineProperty(exports, "prepareTransactionRequest", { enumerable: true, get: function() {
      return prepareTransactionRequest_js_1.prepareTransactionRequest;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/proof.js
var require_proof = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/formatters/proof.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatProof = void 0;
    var index_js_1 = require_utils8();
    function formatStorageProof(storageProof) {
      return storageProof.map((proof) => ({
        ...proof,
        value: BigInt(proof.value)
      }));
    }
    function formatProof(proof) {
      return {
        ...proof,
        balance: proof.balance ? BigInt(proof.balance) : void 0,
        nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : void 0,
        storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
      };
    }
    exports.formatProof = formatProof;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getProof.js
var require_getProof = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getProof.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProof = void 0;
    var toHex_js_1 = require_toHex();
    var proof_js_1 = require_proof();
    async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
      const blockTag = blockTag_ ?? "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const proof = await client.request({
        method: "eth_getProof",
        params: [address, storageKeys, blockNumberHex || blockTag]
      });
      return (0, proof_js_1.formatProof)(proof);
    }
    exports.getProof = getProof;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getStorageAt.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const data = await client.request({
        method: "eth_getStorageAt",
        params: [address, slot, blockNumberHex || blockTag]
      });
      return data;
    }
    exports.getStorageAt = getStorageAt;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransaction = void 0;
    var transaction_js_1 = require_transaction2();
    var toHex_js_1 = require_toHex();
    var transaction_js_2 = require_transaction();
    async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index }) {
      const blockTag = blockTag_ || "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let transaction = null;
      if (hash) {
        transaction = await client.request({
          method: "eth_getTransactionByHash",
          params: [hash]
        });
      } else if (blockHash) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [blockHash, (0, toHex_js_1.numberToHex)(index)]
        });
      } else if (blockNumberHex || blockTag) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)]
        });
      }
      if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
          blockHash,
          blockNumber,
          blockTag,
          hash,
          index
        });
      const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
      return format(transaction);
    }
    exports.getTransaction = getTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionConfirmations = void 0;
    var getAction_js_1 = require_getAction();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getTransaction_js_1 = require_getTransaction();
    async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
      const [blockNumber, transaction] = await Promise.all([
        (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({}),
        hash ? (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getBlockNumber")({ hash }) : void 0
      ]);
      const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
      if (!transactionBlockNumber)
        return 0n;
      return blockNumber - transactionBlockNumber + 1n;
    }
    exports.getTransactionConfirmations = getTransactionConfirmations;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/getTransactionReceipt.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction2();
    var transactionReceipt_js_1 = require_transactionReceipt();
    async function getTransactionReceipt(client, { hash }) {
      const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [hash]
      });
      if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
      const format = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
      return format(receipt);
    }
    exports.getTransactionReceipt = getTransactionReceipt;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/multicall.js
var require_multicall = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/multicall.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicall = void 0;
    var abis_js_1 = require_abis();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    var getContractError_js_1 = require_getContractError();
    var getAction_js_1 = require_getAction();
    var readContract_js_1 = require_readContract();
    async function multicall(client, args) {
      const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
      const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const chunkedCalls = [[]];
      let currentChunk = 0;
      let currentChunkSize = 0;
      for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args: args2, functionName } = contracts[i];
        try {
          const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi,
            args: args2,
            functionName
          });
          currentChunkSize += (callData.length - 2) / 2;
          if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
            currentChunk++;
            currentChunkSize = (callData.length - 2) / 2;
            chunkedCalls[currentChunk] = [];
          }
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData,
              target: address
            }
          ];
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData: "0x",
              target: address
            }
          ];
        }
      }
      const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, "readContract")({
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: "aggregate3"
      })));
      const results = [];
      for (let i = 0; i < aggregate3Results.length; i++) {
        const result = aggregate3Results[i];
        if (result.status === "rejected") {
          if (!allowFailure)
            throw result.reason;
          for (let j = 0; j < chunkedCalls[i].length; j++) {
            results.push({
              status: "failure",
              error: result.reason,
              result: void 0
            });
          }
          continue;
        }
        const aggregate3Result = result.value;
        for (let j = 0; j < aggregate3Result.length; j++) {
          const { returnData, success } = aggregate3Result[j];
          const { callData } = chunkedCalls[i][j];
          const { abi, address, functionName, args: args2 } = contracts[results.length];
          try {
            if (callData === "0x")
              throw new abi_js_1.AbiDecodingZeroDataError();
            if (!success)
              throw new contract_js_1.RawContractError({ data: returnData });
            const result2 = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
              abi,
              args: args2,
              data: returnData,
              functionName
            });
            results.push(allowFailure ? { result: result2, status: "success" } : result2);
          } catch (err) {
            const error = (0, getContractError_js_1.getContractError)(err, {
              abi,
              address,
              args: args2,
              docsPath: "/docs/contract/multicall",
              functionName
            });
            if (!allowFailure)
              throw error;
            results.push({ error, result: void 0, status: "failure" });
          }
        }
      }
      if (results.length !== contracts.length)
        throw new base_js_1.BaseError("multicall results mismatch");
      return results;
    }
    exports.multicall = multicall;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/contracts.js
var require_contracts = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/contracts.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorByteCode = void 0;
    exports.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/data/isBytesEqual.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytesEqual = void 0;
    var utils_1 = require_utils7();
    var toBytes_js_1 = require_toBytes();
    var isHex_js_1 = require_isHex();
    function isBytesEqual(a_, b_) {
      const a = (0, isHex_js_1.isHex)(a_) ? (0, toBytes_js_1.toBytes)(a_) : a_;
      const b = (0, isHex_js_1.isHex)(b_) ? (0, toBytes_js_1.toBytes)(b_) : b_;
      return (0, utils_1.equalBytes)(a, b);
    }
    exports.isBytesEqual = isBytesEqual;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyHash.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyHash = void 0;
    var abis_js_1 = require_abis();
    var contracts_js_1 = require_contracts();
    var contract_js_1 = require_contract();
    var isBytesEqual_js_1 = require_isBytesEqual();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils8();
    var call_js_1 = require_call();
    async function verifyHash(client, { address, hash, signature, ...callRequest }) {
      const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
      try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, "call")({
          data: (0, index_js_1.encodeDeployData)({
            abi: abis_js_1.universalSignatureValidatorAbi,
            args: [address, hash, signatureHex],
            bytecode: contracts_js_1.universalSignatureValidatorByteCode
          }),
          ...callRequest
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
      } catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
          return false;
        }
        throw error;
      }
    }
    exports.verifyHash = verifyHash;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyMessage.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var index_js_1 = require_utils8();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyMessage(client, { address, message, signature, ...callRequest }) {
      const hash = (0, index_js_1.hashMessage)(message);
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/verifyTypedData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
      const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchBlockNumber.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlockNumber = void 0;
    var fromHex_js_1 = require_fromHex();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify2();
    var getBlockNumber_js_1 = require_getBlockNumber();
    function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlockNumber;
      const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlockNumber",
          client.uid,
          emitOnBegin,
          emitMissed,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
            if (prevBlockNumber) {
              if (blockNumber === prevBlockNumber)
                return;
              if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                  emit.onBlockNumber(i, prevBlockNumber);
                  prevBlockNumber = i;
                }
              }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }
    exports.watchBlockNumber = watchBlockNumber;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTransactionReceipt = void 0;
    var block_js_1 = require_block2();
    var transaction_js_1 = require_transaction2();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var withRetry_js_1 = require_withRetry();
    var stringify_js_1 = require_stringify2();
    var getBlock_js_1 = require_getBlock();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
      const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash]);
      let transaction;
      let replacedTransaction;
      let receipt;
      let retrying = false;
      return new Promise((resolve, reject) => {
        if (timeout)
          setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
          const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, "watchBlockNumber")({
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
              if (retrying)
                return;
              let blockNumber = blockNumber_;
              const done = (fn) => {
                _unwatch();
                fn();
                _unobserve();
              };
              try {
                if (receipt) {
                  if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                    return;
                  done(() => emit.resolve(receipt));
                  return;
                }
                if (!transaction) {
                  retrying = true;
                  await (0, withRetry_js_1.withRetry)(async () => {
                    transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, "getTransaction")({ hash });
                    if (transaction.blockNumber)
                      blockNumber = transaction.blockNumber;
                  }, {
                    delay: ({ count }) => ~~(1 << count) * 200,
                    retryCount: 6
                  });
                  retrying = false;
                }
                receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({ hash });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                done(() => emit.resolve(receipt));
              } catch (err) {
                if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                  try {
                    replacedTransaction = transaction;
                    retrying = true;
                    const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                      blockNumber,
                      includeTransactions: true
                    }), {
                      delay: ({ count }) => ~~(1 << count) * 200,
                      retryCount: 6,
                      shouldRetry: ({ error }) => error instanceof block_js_1.BlockNotFoundError
                    });
                    retrying = false;
                    const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                    if (!replacementTransaction)
                      return;
                    receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, "getTransactionReceipt")({
                      hash: replacementTransaction.hash
                    });
                    if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                      return;
                    let reason = "replaced";
                    if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                      reason = "repriced";
                    } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                      reason = "cancelled";
                    }
                    done(() => {
                      emit.onReplaced?.({
                        reason,
                        replacedTransaction,
                        transaction: replacementTransaction,
                        transactionReceipt: receipt
                      });
                      emit.resolve(receipt);
                    });
                  } catch (err_) {
                    done(() => emit.reject(err_));
                  }
                } else {
                  done(() => emit.reject(err));
                }
              }
            }
          });
        });
      });
    }
    exports.waitForTransactionReceipt = waitForTransactionReceipt;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchBlocks.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlocks = void 0;
    var block_js_1 = require_block();
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify2();
    var getBlock_js_1 = require_getBlock();
    function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const includeTransactions = includeTransactions_ ?? false;
      let prevBlock;
      const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlocks",
          client.uid,
          emitMissed,
          emitOnBegin,
          includeTransactions,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
              blockTag,
              includeTransactions
            });
            if (block.number && prevBlock?.number) {
              if (block.number === prevBlock.number)
                return;
              if (block.number - prevBlock.number > 1 && emitMissed) {
                for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                  const block2 = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, "getBlock")({
                    blockNumber: i,
                    includeTransactions
                  });
                  emit.onBlock(block2, prevBlock);
                  prevBlock = block2;
                }
              }
            }
            if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
              emit.onBlock(block, prevBlock);
              prevBlock = block;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                const block = format(data.result);
                onBlock(block, prevBlock);
                prevBlock = block;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlocks() : subscribeBlocks();
    }
    exports.watchBlocks = watchBlocks;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchEvent.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify2();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils8();
    var createEventFilter_js_1 = require_createEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const strict = strict_ ?? false;
      const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchEvent",
          address,
          args,
          batch,
          client.uid,
          event,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, "createEventFilter")({
                  address,
                  args,
                  event,
                  events,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              } else {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, "getBlockNumber")({});
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, "getLogs")({
                    address,
                    args,
                    event,
                    events,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                for (const log of logs)
                  emit.onLogs([log]);
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const events_ = events ?? (event ? [event] : void 0);
            let topics = [];
            if (events_) {
              topics = [
                events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                  abi: [event2],
                  eventName: event2.name,
                  args
                }))
              ];
              if (event)
                topics = topics[0];
            }
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                    abi: events_,
                    data: log.data,
                    topics: log.topics,
                    strict
                  });
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: args2,
                    eventName
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollEvent() : subscribeEvent();
    }
    exports.watchEvent = watchEvent;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/public/watchPendingTransactions.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchPendingTransactions = void 0;
    var getAction_js_1 = require_getAction();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify2();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchPendingTransactions",
          client.uid,
          batch,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
          let filter;
          const unwatch = (0, poll_js_1.poll)(async () => {
            try {
              if (!filter) {
                try {
                  filter = await (0, getAction_js_1.getAction)(client, createPendingTransactionFilter_js_1.createPendingTransactionFilter, "createPendingTransactionFilter")({});
                  return;
                } catch (err) {
                  unwatch();
                  throw err;
                }
              }
              const hashes = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, "getFilterChanges")({ filter });
              if (hashes.length === 0)
                return;
              if (batch)
                emit.onTransactions(hashes);
              else
                for (const hash of hashes)
                  emit.onTransactions([hash]);
            } catch (err) {
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, "uninstallFilter")({ filter });
            unwatch();
          };
        });
      };
      const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newPendingTransactions"],
              onData(data) {
                if (!active)
                  return;
                const transaction = data.result;
                onTransactions([transaction]);
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
    }
    exports.watchPendingTransactions = watchPendingTransactions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/public.js
var require_public = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/public.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicActions = void 0;
    var getEnsAddress_js_1 = require_getEnsAddress();
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    var getEnsName_js_1 = require_getEnsName();
    var getEnsResolver_js_1 = require_getEnsResolver();
    var getEnsText_js_1 = require_getEnsText();
    var call_js_1 = require_call();
    var createBlockFilter_js_1 = require_createBlockFilter();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var createEventFilter_js_1 = require_createEventFilter();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBalance_js_1 = require_getBalance();
    var getBlock_js_1 = require_getBlock();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
    var getBytecode_js_1 = require_getBytecode();
    var getChainId_js_1 = require_getChainId();
    var getContractEvents_js_1 = require_getContractEvents();
    var getFeeHistory_js_1 = require_getFeeHistory();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getFilterLogs_js_1 = require_getFilterLogs();
    var getGasPrice_js_1 = require_getGasPrice();
    var getLogs_js_1 = require_getLogs();
    var getProof_js_1 = require_getProof();
    var getStorageAt_js_1 = require_getStorageAt();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var multicall_js_1 = require_multicall();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var uninstallFilter_js_1 = require_uninstallFilter();
    var verifyMessage_js_1 = require_verifyMessage2();
    var verifyTypedData_js_1 = require_verifyTypedData2();
    var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    var watchBlocks_js_1 = require_watchBlocks();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var watchEvent_js_1 = require_watchEvent();
    var watchPendingTransactions_js_1 = require_watchPendingTransactions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    function publicActions(client) {
      return {
        call: (args) => (0, call_js_1.call)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        getProof: (args) => (0, getProof_js_1.getProof)(client, args),
        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
      };
    }
    exports.publicActions = publicActions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createPublicClient.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPublicClient = void 0;
    var createClient_js_1 = require_createClient();
    var public_js_1 = require_public();
    function createPublicClient(parameters) {
      const { key = "public", name = "Public Client" } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "publicClient"
      });
      return client.extend(public_js_1.publicActions);
    }
    exports.createPublicClient = createPublicClient;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/dropTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropTransaction = void 0;
    async function dropTransaction(client, { hash }) {
      await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash]
      });
    }
    exports.dropTransaction = dropTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/dumpState.js
var require_dumpState = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/dumpState.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dumpState = void 0;
    async function dumpState(client) {
      return client.request({
        method: `${client.mode}_dumpState`
      });
    }
    exports.dumpState = dumpState;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getAutomine.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAutomine = void 0;
    async function getAutomine(client) {
      if (client.mode === "ganache")
        return await client.request({
          method: "eth_mining"
        });
      return await client.request({
        method: `${client.mode}_getAutomine`
      });
    }
    exports.getAutomine = getAutomine;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getTxpoolContent.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolContent = void 0;
    async function getTxpoolContent(client) {
      return await client.request({
        method: "txpool_content"
      });
    }
    exports.getTxpoolContent = getTxpoolContent;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/getTxpoolStatus.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolStatus = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getTxpoolStatus(client) {
      const { pending, queued } = await client.request({
        method: "txpool_status"
      });
      return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued)
      };
    }
    exports.getTxpoolStatus = getTxpoolStatus;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/impersonateAccount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.impersonateAccount = void 0;
    async function impersonateAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address]
      });
    }
    exports.impersonateAccount = impersonateAccount;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/increaseTime.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.increaseTime = void 0;
    var toHex_js_1 = require_toHex();
    async function increaseTime(client, { seconds }) {
      return await client.request({
        method: "evm_increaseTime",
        params: [(0, toHex_js_1.numberToHex)(seconds)]
      });
    }
    exports.increaseTime = increaseTime;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/inspectTxpool.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inspectTxpool = void 0;
    async function inspectTxpool(client) {
      return await client.request({
        method: "txpool_inspect"
      });
    }
    exports.inspectTxpool = inspectTxpool;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/loadState.js
var require_loadState = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/loadState.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadState = void 0;
    async function loadState(client, { state }) {
      await client.request({
        method: `${client.mode}_loadState`,
        params: [state]
      });
    }
    exports.loadState = loadState;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/mine.js
var require_mine = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/mine.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mine = void 0;
    var toHex_js_1 = require_toHex();
    async function mine(client, { blocks, interval }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_mine",
          params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
        });
      else
        await client.request({
          method: `${client.mode}_mine`,
          params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
        });
    }
    exports.mine = mine;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeBlockTimestampInterval = void 0;
    async function removeBlockTimestampInterval(client) {
      await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
      });
    }
    exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/reset.js
var require_reset = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/reset.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reset = void 0;
    async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
      await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
      });
    }
    exports.reset = reset;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/revert.js
var require_revert = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/revert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revert = void 0;
    async function revert(client, { id }) {
      await client.request({
        method: "evm_revert",
        params: [id]
      });
    }
    exports.revert = revert;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendUnsignedTransaction = void 0;
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    async function sendUnsignedTransaction(client, args) {
      const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const hash = await client.request({
        method: "eth_sendUnsignedTransaction",
        params: [request]
      });
      return hash;
    }
    exports.sendUnsignedTransaction = sendUnsignedTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setAutomine.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAutomine = void 0;
    async function setAutomine(client, enabled) {
      if (client.mode === "ganache") {
        if (enabled)
          await client.request({ method: "miner_start" });
        else
          await client.request({ method: "miner_stop" });
      } else
        await client.request({
          method: "evm_setAutomine",
          params: [enabled]
        });
    }
    exports.setAutomine = setAutomine;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBalance.js
var require_setBalance = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBalance.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function setBalance(client, { address, value }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_setAccountBalance",
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
      else
        await client.request({
          method: `${client.mode}_setBalance`,
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
    }
    exports.setBalance = setBalance;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBlockGasLimit.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockGasLimit = void 0;
    var toHex_js_1 = require_toHex();
    async function setBlockGasLimit(client, { gasLimit }) {
      await client.request({
        method: "evm_setBlockGasLimit",
        params: [(0, toHex_js_1.numberToHex)(gasLimit)]
      });
    }
    exports.setBlockGasLimit = setBlockGasLimit;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockTimestampInterval = void 0;
    async function setBlockTimestampInterval(client, { interval }) {
      const interval_ = (() => {
        if (client.mode === "hardhat")
          return interval * 1e3;
        return interval;
      })();
      await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval_]
      });
    }
    exports.setBlockTimestampInterval = setBlockTimestampInterval;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setCode.js
var require_setCode = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setCode.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCode = void 0;
    async function setCode(client, { address, bytecode }) {
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
    }
    exports.setCode = setCode;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setCoinbase.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCoinbase = void 0;
    async function setCoinbase(client, { address }) {
      await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address]
      });
    }
    exports.setCoinbase = setCoinbase;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setIntervalMining.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setIntervalMining = void 0;
    async function setIntervalMining(client, { interval }) {
      const interval_ = (() => {
        if (client.mode === "hardhat")
          return interval * 1e3;
        return interval;
      })();
      await client.request({
        method: "evm_setIntervalMining",
        params: [interval_]
      });
    }
    exports.setIntervalMining = setIntervalMining;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setLoggingEnabled.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setLoggingEnabled = void 0;
    async function setLoggingEnabled(client, enabled) {
      await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled]
      });
    }
    exports.setLoggingEnabled = setLoggingEnabled;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setMinGasPrice.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setMinGasPrice = void 0;
    var toHex_js_1 = require_toHex();
    async function setMinGasPrice(client, { gasPrice }) {
      await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)]
      });
    }
    exports.setMinGasPrice = setMinGasPrice;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockBaseFeePerGas = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
      await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
      });
    }
    exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockTimestamp = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockTimestamp(client, { timestamp }) {
      await client.request({
        method: "evm_setNextBlockTimestamp",
        params: [(0, toHex_js_1.numberToHex)(timestamp)]
      });
    }
    exports.setNextBlockTimestamp = setNextBlockTimestamp;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNonce.js
var require_setNonce = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setNonce.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNonce = void 0;
    var toHex_js_1 = require_toHex();
    async function setNonce(client, { address, nonce }) {
      await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)]
      });
    }
    exports.setNonce = setNonce;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setRpcUrl.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setRpcUrl = void 0;
    async function setRpcUrl(client, jsonRpcUrl) {
      await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl]
      });
    }
    exports.setRpcUrl = setRpcUrl;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/setStorageAt.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function setStorageAt(client, { address, index, value }) {
      await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
          address,
          typeof index === "number" ? (0, toHex_js_1.numberToHex)(index) : index,
          value
        ]
      });
    }
    exports.setStorageAt = setStorageAt;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/snapshot.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snapshot = void 0;
    async function snapshot(client) {
      return await client.request({
        method: "evm_snapshot"
      });
    }
    exports.snapshot = snapshot;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stopImpersonatingAccount = void 0;
    async function stopImpersonatingAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address]
      });
    }
    exports.stopImpersonatingAccount = stopImpersonatingAccount;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/test.js
var require_test = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/test.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testActions = void 0;
    var dropTransaction_js_1 = require_dropTransaction();
    var dumpState_js_1 = require_dumpState();
    var getAutomine_js_1 = require_getAutomine();
    var getTxpoolContent_js_1 = require_getTxpoolContent();
    var getTxpoolStatus_js_1 = require_getTxpoolStatus();
    var impersonateAccount_js_1 = require_impersonateAccount();
    var increaseTime_js_1 = require_increaseTime();
    var inspectTxpool_js_1 = require_inspectTxpool();
    var loadState_js_1 = require_loadState();
    var mine_js_1 = require_mine();
    var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
    var reset_js_1 = require_reset();
    var revert_js_1 = require_revert();
    var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
    var setAutomine_js_1 = require_setAutomine();
    var setBalance_js_1 = require_setBalance();
    var setBlockGasLimit_js_1 = require_setBlockGasLimit();
    var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
    var setCode_js_1 = require_setCode();
    var setCoinbase_js_1 = require_setCoinbase();
    var setIntervalMining_js_1 = require_setIntervalMining();
    var setLoggingEnabled_js_1 = require_setLoggingEnabled();
    var setMinGasPrice_js_1 = require_setMinGasPrice();
    var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
    var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
    var setNonce_js_1 = require_setNonce();
    var setRpcUrl_js_1 = require_setRpcUrl();
    var setStorageAt_js_1 = require_setStorageAt();
    var snapshot_js_1 = require_snapshot();
    var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
    function testActions({ mode }) {
      return (client_) => {
        const client = client_.extend(() => ({
          mode
        }));
        return {
          dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
          dumpState: () => (0, dumpState_js_1.dumpState)(client),
          getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
          getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
          getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
          impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
          increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
          inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
          loadState: (args) => (0, loadState_js_1.loadState)(client, args),
          mine: (args) => (0, mine_js_1.mine)(client, args),
          removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
          reset: (args) => (0, reset_js_1.reset)(client, args),
          revert: (args) => (0, revert_js_1.revert)(client, args),
          sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
          setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
          setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
          setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
          setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
          setCode: (args) => (0, setCode_js_1.setCode)(client, args),
          setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
          setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
          setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
          setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
          setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
          setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
          setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
          setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
          setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
          snapshot: () => (0, snapshot_js_1.snapshot)(client),
          stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
        };
      };
    }
    exports.testActions = testActions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createTestClient.js
var require_createTestClient = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createTestClient.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTestClient = void 0;
    var createClient_js_1 = require_createClient();
    var test_js_1 = require_test();
    function createTestClient(parameters) {
      const { key = "test", name = "Test Client", mode } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "testClient"
      });
      return client.extend((config) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config)
      }));
    }
    exports.createTestClient = createTestClient;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/addChain.js
var require_addChain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/addChain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addChain = void 0;
    var toHex_js_1 = require_toHex();
    async function addChain(client, { chain }) {
      const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
      await client.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id),
            chainName: name,
            nativeCurrency,
            rpcUrls: rpcUrls.default.http,
            blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
          }
        ]
      });
    }
    exports.addChain = addChain;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/deployContract.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deployContract = void 0;
    var encodeDeployData_js_1 = require_encodeDeployData();
    var sendTransaction_js_1 = require_sendTransaction();
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
      const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode
      });
      return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata
      });
    }
    exports.deployContract = deployContract;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/getAddresses.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function getAddresses(client) {
      if (client.account?.type === "local")
        return [client.account.address];
      const addresses = await client.request({ method: "eth_accounts" });
      return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
    }
    exports.getAddresses = getAddresses;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/getPermissions.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPermissions = void 0;
    async function getPermissions(client) {
      const permissions = await client.request({ method: "wallet_getPermissions" });
      return permissions;
    }
    exports.getPermissions = getPermissions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/requestAddresses.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function requestAddresses(client) {
      const addresses = await client.request({ method: "eth_requestAccounts" });
      return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
    }
    exports.requestAddresses = requestAddresses;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/requestPermissions.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPermissions = void 0;
    async function requestPermissions(client, permissions) {
      return client.request({
        method: "wallet_requestPermissions",
        params: [permissions]
      });
    }
    exports.requestPermissions = requestPermissions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signMessage.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMessage = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    async function signMessage(client, { account: account_ = client.account, message }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      if (account.type === "local")
        return account.signMessage({ message });
      const message_ = (() => {
        if (typeof message === "string")
          return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
          return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
      })();
      return client.request({
        method: "personal_sign",
        params: [message_, account.address]
      });
    }
    exports.signMessage = signMessage;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signTransaction.js
var require_signTransaction = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signTransaction.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    var transactionRequest_js_1 = require_transactionRequest();
    var getAction_js_1 = require_getAction();
    var index_js_1 = require_utils8();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    async function signTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, ...transaction } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      (0, assertRequest_js_1.assertRequest)({
        account,
        ...args
      });
      const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, "getChainId")({});
      if (chain !== null)
        (0, assertCurrentChain_js_1.assertCurrentChain)({
          currentChainId: chainId,
          chain
        });
      const formatters = chain?.formatters || client.chain?.formatters;
      const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      if (account.type === "local")
        return account.signTransaction({
          ...transaction,
          chainId
        }, { serializer: client.chain?.serializers?.transaction });
      return await client.request({
        method: "eth_signTransaction",
        params: [
          {
            ...format(transaction),
            chainId: (0, index_js_1.numberToHex)(chainId),
            from: account.address
          }
        ]
      });
    }
    exports.signTransaction = signTransaction;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/signTypedData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTypedData = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify2();
    var typedData_js_1 = require_typedData();
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTypedData"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      if (account.type === "local")
        return account.signTypedData({
          domain,
          primaryType,
          types,
          message
        });
      const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
      return client.request({
        method: "eth_signTypedData_v4",
        params: [account.address, typedData]
      });
    }
    exports.signTypedData = signTypedData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/switchChain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchChain = void 0;
    var toHex_js_1 = require_toHex();
    async function switchChain(client, { id }) {
      await client.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id)
          }
        ]
      });
    }
    exports.switchChain = switchChain;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/actions/wallet/watchAsset.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchAsset = void 0;
    async function watchAsset(client, params) {
      const added = await client.request({
        method: "wallet_watchAsset",
        params
      });
      return added;
    }
    exports.watchAsset = watchAsset;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/wallet.js
var require_wallet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/decorators/wallet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletActions = void 0;
    var getChainId_js_1 = require_getChainId();
    var addChain_js_1 = require_addChain();
    var deployContract_js_1 = require_deployContract();
    var getAddresses_js_1 = require_getAddresses();
    var getPermissions_js_1 = require_getPermissions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var requestAddresses_js_1 = require_requestAddresses();
    var requestPermissions_js_1 = require_requestPermissions();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    var sendTransaction_js_1 = require_sendTransaction();
    var signMessage_js_1 = require_signMessage();
    var signTransaction_js_1 = require_signTransaction();
    var signTypedData_js_1 = require_signTypedData();
    var switchChain_js_1 = require_switchChain();
    var watchAsset_js_1 = require_watchAsset();
    var writeContract_js_1 = require_writeContract();
    function walletActions(client) {
      return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
      };
    }
    exports.walletActions = walletActions;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/createWalletClient.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletClient = void 0;
    var createClient_js_1 = require_createClient();
    var wallet_js_1 = require_wallet();
    function createWalletClient(parameters) {
      const { key = "wallet", name = "Wallet Client", transport } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      });
      return client.extend(wallet_js_1.walletActions);
    }
    exports.createWalletClient = createWalletClient;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/webSocket.js
var require_webSocket = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/clients/transports/webSocket.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webSocket = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function webSocket(url, config = {}) {
      const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
              body,
              timeout
            });
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "webSocket"
        }, {
          getSocket() {
            return (0, rpc_js_1.getSocket)(url_);
          },
          async subscribe({ params, onData, onError }) {
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onResponse(response) {
                if (response.error) {
                  reject(response.error);
                  onError?.(response.error);
                  return;
                }
                if (typeof response.id === "number") {
                  resolve(response);
                  return;
                }
                if (response.method !== "eth_subscription")
                  return;
                onData(response.params);
              }
            }));
            return {
              subscriptionId,
              async unsubscribe() {
                return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onResponse: resolve
                }));
              }
            };
          }
        });
      };
    }
    exports.webSocket = webSocket;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/address.js
var require_address2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroAddress = void 0;
    exports.zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/number.js
var require_number = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/number.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = void 0;
    exports.maxInt8 = 2n ** (8n - 1n) - 1n;
    exports.maxInt16 = 2n ** (16n - 1n) - 1n;
    exports.maxInt24 = 2n ** (24n - 1n) - 1n;
    exports.maxInt32 = 2n ** (32n - 1n) - 1n;
    exports.maxInt40 = 2n ** (40n - 1n) - 1n;
    exports.maxInt48 = 2n ** (48n - 1n) - 1n;
    exports.maxInt56 = 2n ** (56n - 1n) - 1n;
    exports.maxInt64 = 2n ** (64n - 1n) - 1n;
    exports.maxInt72 = 2n ** (72n - 1n) - 1n;
    exports.maxInt80 = 2n ** (80n - 1n) - 1n;
    exports.maxInt88 = 2n ** (88n - 1n) - 1n;
    exports.maxInt96 = 2n ** (96n - 1n) - 1n;
    exports.maxInt104 = 2n ** (104n - 1n) - 1n;
    exports.maxInt112 = 2n ** (112n - 1n) - 1n;
    exports.maxInt120 = 2n ** (120n - 1n) - 1n;
    exports.maxInt128 = 2n ** (128n - 1n) - 1n;
    exports.maxInt136 = 2n ** (136n - 1n) - 1n;
    exports.maxInt144 = 2n ** (144n - 1n) - 1n;
    exports.maxInt152 = 2n ** (152n - 1n) - 1n;
    exports.maxInt160 = 2n ** (160n - 1n) - 1n;
    exports.maxInt168 = 2n ** (168n - 1n) - 1n;
    exports.maxInt176 = 2n ** (176n - 1n) - 1n;
    exports.maxInt184 = 2n ** (184n - 1n) - 1n;
    exports.maxInt192 = 2n ** (192n - 1n) - 1n;
    exports.maxInt200 = 2n ** (200n - 1n) - 1n;
    exports.maxInt208 = 2n ** (208n - 1n) - 1n;
    exports.maxInt216 = 2n ** (216n - 1n) - 1n;
    exports.maxInt224 = 2n ** (224n - 1n) - 1n;
    exports.maxInt232 = 2n ** (232n - 1n) - 1n;
    exports.maxInt240 = 2n ** (240n - 1n) - 1n;
    exports.maxInt248 = 2n ** (248n - 1n) - 1n;
    exports.maxInt256 = 2n ** (256n - 1n) - 1n;
    exports.minInt8 = -(2n ** (8n - 1n));
    exports.minInt16 = -(2n ** (16n - 1n));
    exports.minInt24 = -(2n ** (24n - 1n));
    exports.minInt32 = -(2n ** (32n - 1n));
    exports.minInt40 = -(2n ** (40n - 1n));
    exports.minInt48 = -(2n ** (48n - 1n));
    exports.minInt56 = -(2n ** (56n - 1n));
    exports.minInt64 = -(2n ** (64n - 1n));
    exports.minInt72 = -(2n ** (72n - 1n));
    exports.minInt80 = -(2n ** (80n - 1n));
    exports.minInt88 = -(2n ** (88n - 1n));
    exports.minInt96 = -(2n ** (96n - 1n));
    exports.minInt104 = -(2n ** (104n - 1n));
    exports.minInt112 = -(2n ** (112n - 1n));
    exports.minInt120 = -(2n ** (120n - 1n));
    exports.minInt128 = -(2n ** (128n - 1n));
    exports.minInt136 = -(2n ** (136n - 1n));
    exports.minInt144 = -(2n ** (144n - 1n));
    exports.minInt152 = -(2n ** (152n - 1n));
    exports.minInt160 = -(2n ** (160n - 1n));
    exports.minInt168 = -(2n ** (168n - 1n));
    exports.minInt176 = -(2n ** (176n - 1n));
    exports.minInt184 = -(2n ** (184n - 1n));
    exports.minInt192 = -(2n ** (192n - 1n));
    exports.minInt200 = -(2n ** (200n - 1n));
    exports.minInt208 = -(2n ** (208n - 1n));
    exports.minInt216 = -(2n ** (216n - 1n));
    exports.minInt224 = -(2n ** (224n - 1n));
    exports.minInt232 = -(2n ** (232n - 1n));
    exports.minInt240 = -(2n ** (240n - 1n));
    exports.minInt248 = -(2n ** (248n - 1n));
    exports.minInt256 = -(2n ** (256n - 1n));
    exports.maxUint8 = 2n ** 8n - 1n;
    exports.maxUint16 = 2n ** 16n - 1n;
    exports.maxUint24 = 2n ** 24n - 1n;
    exports.maxUint32 = 2n ** 32n - 1n;
    exports.maxUint40 = 2n ** 40n - 1n;
    exports.maxUint48 = 2n ** 48n - 1n;
    exports.maxUint56 = 2n ** 56n - 1n;
    exports.maxUint64 = 2n ** 64n - 1n;
    exports.maxUint72 = 2n ** 72n - 1n;
    exports.maxUint80 = 2n ** 80n - 1n;
    exports.maxUint88 = 2n ** 88n - 1n;
    exports.maxUint96 = 2n ** 96n - 1n;
    exports.maxUint104 = 2n ** 104n - 1n;
    exports.maxUint112 = 2n ** 112n - 1n;
    exports.maxUint120 = 2n ** 120n - 1n;
    exports.maxUint128 = 2n ** 128n - 1n;
    exports.maxUint136 = 2n ** 136n - 1n;
    exports.maxUint144 = 2n ** 144n - 1n;
    exports.maxUint152 = 2n ** 152n - 1n;
    exports.maxUint160 = 2n ** 160n - 1n;
    exports.maxUint168 = 2n ** 168n - 1n;
    exports.maxUint176 = 2n ** 176n - 1n;
    exports.maxUint184 = 2n ** 184n - 1n;
    exports.maxUint192 = 2n ** 192n - 1n;
    exports.maxUint200 = 2n ** 200n - 1n;
    exports.maxUint208 = 2n ** 208n - 1n;
    exports.maxUint216 = 2n ** 216n - 1n;
    exports.maxUint224 = 2n ** 224n - 1n;
    exports.maxUint232 = 2n ** 232n - 1n;
    exports.maxUint240 = 2n ** 240n - 1n;
    exports.maxUint248 = 2n ** 248n - 1n;
    exports.maxUint256 = 2n ** 256n - 1n;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/bytes.js
var require_bytes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/constants/bytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroHash = void 0;
    exports.zeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/abi/decodeDeployData.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var docsPath = "/docs/contract/decodeDeployData";
    function decodeDeployData({ abi, bytecode, data }) {
      if (data === bytecode)
        return { bytecode };
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
      return { args, bytecode };
    }
    exports.decodeDeployData = decodeDeployData;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js
var require_compactSignatureToSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactSignatureToSignature = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function compactSignatureToSignature({ r, yParityAndS }) {
      const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
      const v = yParityAndS_bytes[0] & 128 ? 28n : 27n;
      const s = yParityAndS_bytes;
      if (v === 28n)
        s[0] &= 127;
      return { r, s: (0, toHex_js_1.bytesToHex)(s), v };
    }
    exports.compactSignatureToSignature = compactSignatureToSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js
var require_hexToCompactSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hexToCompactSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToCompactSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToCompactSignature(signatureHex) {
      const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      return {
        r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
        yParityAndS: (0, toHex_js_1.numberToHex)(s, { size: 32 })
      };
    }
    exports.hexToCompactSignature = hexToCompactSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hexToSignature.js
var require_hexToSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/hexToSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToSignature(signatureHex) {
      const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      const v = BigInt(`0x${signatureHex.slice(130)}`);
      return { r: (0, toHex_js_1.numberToHex)(r, { size: 32 }), s: (0, toHex_js_1.numberToHex)(s, { size: 32 }), v };
    }
    exports.hexToSignature = hexToSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js
var require_signatureToCompactSignature = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToCompactSignature = void 0;
    var index_js_1 = require_utils8();
    function signatureToCompactSignature(signature) {
      const { r, s, v } = signature;
      const yParity = v - 27n;
      let yParityAndS = s;
      if (yParity === 1n) {
        const bytes = (0, index_js_1.hexToBytes)(s);
        bytes[0] |= 128;
        yParityAndS = (0, index_js_1.bytesToHex)(bytes);
      }
      return { r, yParityAndS };
    }
    exports.signatureToCompactSignature = signatureToCompactSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js
var require_compactSignatureToHex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/compactSignatureToHex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactSignatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    function compactSignatureToHex({ r, yParityAndS }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
    }
    exports.compactSignatureToHex = compactSignatureToHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/signatureToHex.js
var require_signatureToHex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/signature/signatureToHex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function signatureToHex({ r, s, v }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${(0, toHex_js_1.toHex)(v).slice(2)}`;
    }
    exports.signatureToHex = signatureToHex;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = void 0;
    exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.presignMessagePrefix = exports.zeroHash = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = void 0;
    exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = void 0;
    exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarUriResolutionError = exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = void 0;
    exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = exports.signatureToHex = exports.compactSignatureToHex = exports.signatureToCompactSignature = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = exports.hexToCompactSignature = exports.compactSignatureToSignature = exports.hashTypedData = exports.hashDomain = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = void 0;
    exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.getFunctionSignature = exports.getFunctionSelector = exports.getEventSignature = exports.getEventSelector = exports.getContractError = exports.getAddress = exports.checksumAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = void 0;
    exports.getTypesForEIP712Domain = exports.domainSeparator = exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = void 0;
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var getContract_js_1 = require_getContract();
    Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_1 = require_createClient();
    Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
      return createClient_js_1.createClient;
    } });
    var custom_js_1 = require_custom();
    Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require_fallback();
    Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require_http();
    Object.defineProperty(exports, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = require_createPublicClient();
    Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require_createTestClient();
    Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_1 = require_test();
    Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
      return test_js_1.testActions;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_1 = require_createTransport();
    Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_1.createTransport;
    } });
    var createWalletClient_js_1 = require_createWalletClient();
    Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require_webSocket();
    Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_1 = require_abis();
    Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_1.multicall3Abi;
    } });
    var address_js_1 = require_address2();
    Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
      return address_js_1.zeroAddress;
    } });
    var unit_js_1 = require_unit();
    Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
      return unit_js_1.etherUnits;
    } });
    Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_1.gweiUnits;
    } });
    Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
      return unit_js_1.weiUnits;
    } });
    var number_js_1 = require_number();
    Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function() {
      return number_js_1.maxInt8;
    } });
    Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function() {
      return number_js_1.maxInt16;
    } });
    Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function() {
      return number_js_1.maxInt24;
    } });
    Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function() {
      return number_js_1.maxInt32;
    } });
    Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function() {
      return number_js_1.maxInt40;
    } });
    Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function() {
      return number_js_1.maxInt48;
    } });
    Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function() {
      return number_js_1.maxInt56;
    } });
    Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function() {
      return number_js_1.maxInt64;
    } });
    Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function() {
      return number_js_1.maxInt72;
    } });
    Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function() {
      return number_js_1.maxInt80;
    } });
    Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function() {
      return number_js_1.maxInt88;
    } });
    Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function() {
      return number_js_1.maxInt96;
    } });
    Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function() {
      return number_js_1.maxInt104;
    } });
    Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function() {
      return number_js_1.maxInt112;
    } });
    Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function() {
      return number_js_1.maxInt120;
    } });
    Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function() {
      return number_js_1.maxInt128;
    } });
    Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function() {
      return number_js_1.maxInt136;
    } });
    Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function() {
      return number_js_1.maxInt144;
    } });
    Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function() {
      return number_js_1.maxInt152;
    } });
    Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function() {
      return number_js_1.maxInt160;
    } });
    Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function() {
      return number_js_1.maxInt168;
    } });
    Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function() {
      return number_js_1.maxInt176;
    } });
    Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function() {
      return number_js_1.maxInt184;
    } });
    Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function() {
      return number_js_1.maxInt192;
    } });
    Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function() {
      return number_js_1.maxInt200;
    } });
    Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function() {
      return number_js_1.maxInt208;
    } });
    Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function() {
      return number_js_1.maxInt216;
    } });
    Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function() {
      return number_js_1.maxInt224;
    } });
    Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function() {
      return number_js_1.maxInt232;
    } });
    Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function() {
      return number_js_1.maxInt240;
    } });
    Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function() {
      return number_js_1.maxInt248;
    } });
    Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function() {
      return number_js_1.maxInt256;
    } });
    Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function() {
      return number_js_1.maxUint8;
    } });
    Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function() {
      return number_js_1.maxUint16;
    } });
    Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function() {
      return number_js_1.maxUint24;
    } });
    Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function() {
      return number_js_1.maxUint32;
    } });
    Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function() {
      return number_js_1.maxUint40;
    } });
    Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function() {
      return number_js_1.maxUint48;
    } });
    Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function() {
      return number_js_1.maxUint56;
    } });
    Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function() {
      return number_js_1.maxUint64;
    } });
    Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function() {
      return number_js_1.maxUint72;
    } });
    Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function() {
      return number_js_1.maxUint80;
    } });
    Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function() {
      return number_js_1.maxUint88;
    } });
    Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function() {
      return number_js_1.maxUint96;
    } });
    Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function() {
      return number_js_1.maxUint104;
    } });
    Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function() {
      return number_js_1.maxUint112;
    } });
    Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function() {
      return number_js_1.maxUint120;
    } });
    Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function() {
      return number_js_1.maxUint128;
    } });
    Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function() {
      return number_js_1.maxUint136;
    } });
    Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function() {
      return number_js_1.maxUint144;
    } });
    Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function() {
      return number_js_1.maxUint152;
    } });
    Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function() {
      return number_js_1.maxUint160;
    } });
    Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function() {
      return number_js_1.maxUint168;
    } });
    Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function() {
      return number_js_1.maxUint176;
    } });
    Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function() {
      return number_js_1.maxUint184;
    } });
    Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function() {
      return number_js_1.maxUint192;
    } });
    Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function() {
      return number_js_1.maxUint200;
    } });
    Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function() {
      return number_js_1.maxUint208;
    } });
    Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function() {
      return number_js_1.maxUint216;
    } });
    Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function() {
      return number_js_1.maxUint224;
    } });
    Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function() {
      return number_js_1.maxUint232;
    } });
    Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function() {
      return number_js_1.maxUint240;
    } });
    Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function() {
      return number_js_1.maxUint248;
    } });
    Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function() {
      return number_js_1.maxUint256;
    } });
    Object.defineProperty(exports, "minInt8", { enumerable: true, get: function() {
      return number_js_1.minInt8;
    } });
    Object.defineProperty(exports, "minInt16", { enumerable: true, get: function() {
      return number_js_1.minInt16;
    } });
    Object.defineProperty(exports, "minInt24", { enumerable: true, get: function() {
      return number_js_1.minInt24;
    } });
    Object.defineProperty(exports, "minInt32", { enumerable: true, get: function() {
      return number_js_1.minInt32;
    } });
    Object.defineProperty(exports, "minInt40", { enumerable: true, get: function() {
      return number_js_1.minInt40;
    } });
    Object.defineProperty(exports, "minInt48", { enumerable: true, get: function() {
      return number_js_1.minInt48;
    } });
    Object.defineProperty(exports, "minInt56", { enumerable: true, get: function() {
      return number_js_1.minInt56;
    } });
    Object.defineProperty(exports, "minInt64", { enumerable: true, get: function() {
      return number_js_1.minInt64;
    } });
    Object.defineProperty(exports, "minInt72", { enumerable: true, get: function() {
      return number_js_1.minInt72;
    } });
    Object.defineProperty(exports, "minInt80", { enumerable: true, get: function() {
      return number_js_1.minInt80;
    } });
    Object.defineProperty(exports, "minInt88", { enumerable: true, get: function() {
      return number_js_1.minInt88;
    } });
    Object.defineProperty(exports, "minInt96", { enumerable: true, get: function() {
      return number_js_1.minInt96;
    } });
    Object.defineProperty(exports, "minInt104", { enumerable: true, get: function() {
      return number_js_1.minInt104;
    } });
    Object.defineProperty(exports, "minInt112", { enumerable: true, get: function() {
      return number_js_1.minInt112;
    } });
    Object.defineProperty(exports, "minInt120", { enumerable: true, get: function() {
      return number_js_1.minInt120;
    } });
    Object.defineProperty(exports, "minInt128", { enumerable: true, get: function() {
      return number_js_1.minInt128;
    } });
    Object.defineProperty(exports, "minInt136", { enumerable: true, get: function() {
      return number_js_1.minInt136;
    } });
    Object.defineProperty(exports, "minInt144", { enumerable: true, get: function() {
      return number_js_1.minInt144;
    } });
    Object.defineProperty(exports, "minInt152", { enumerable: true, get: function() {
      return number_js_1.minInt152;
    } });
    Object.defineProperty(exports, "minInt160", { enumerable: true, get: function() {
      return number_js_1.minInt160;
    } });
    Object.defineProperty(exports, "minInt168", { enumerable: true, get: function() {
      return number_js_1.minInt168;
    } });
    Object.defineProperty(exports, "minInt176", { enumerable: true, get: function() {
      return number_js_1.minInt176;
    } });
    Object.defineProperty(exports, "minInt184", { enumerable: true, get: function() {
      return number_js_1.minInt184;
    } });
    Object.defineProperty(exports, "minInt192", { enumerable: true, get: function() {
      return number_js_1.minInt192;
    } });
    Object.defineProperty(exports, "minInt200", { enumerable: true, get: function() {
      return number_js_1.minInt200;
    } });
    Object.defineProperty(exports, "minInt208", { enumerable: true, get: function() {
      return number_js_1.minInt208;
    } });
    Object.defineProperty(exports, "minInt216", { enumerable: true, get: function() {
      return number_js_1.minInt216;
    } });
    Object.defineProperty(exports, "minInt224", { enumerable: true, get: function() {
      return number_js_1.minInt224;
    } });
    Object.defineProperty(exports, "minInt232", { enumerable: true, get: function() {
      return number_js_1.minInt232;
    } });
    Object.defineProperty(exports, "minInt240", { enumerable: true, get: function() {
      return number_js_1.minInt240;
    } });
    Object.defineProperty(exports, "minInt248", { enumerable: true, get: function() {
      return number_js_1.minInt248;
    } });
    Object.defineProperty(exports, "minInt256", { enumerable: true, get: function() {
      return number_js_1.minInt256;
    } });
    var bytes_js_1 = require_bytes();
    Object.defineProperty(exports, "zeroHash", { enumerable: true, get: function() {
      return bytes_js_1.zeroHash;
    } });
    var strings_js_1 = require_strings();
    Object.defineProperty(exports, "presignMessagePrefix", { enumerable: true, get: function() {
      return strings_js_1.presignMessagePrefix;
    } });
    var abi_js_1 = require_abi();
    Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeTooSmallError;
    } });
    Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingBytesSizeMismatchError;
    } });
    Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "BytesSizeMismatchError", { enumerable: true, get: function() {
      return abi_js_1.BytesSizeMismatchError;
    } });
    Object.defineProperty(exports, "DecodeLogDataMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogDataMismatch;
    } });
    Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_1.InvalidArrayError;
    } });
    Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidDefinitionTypeError;
    } });
    Object.defineProperty(exports, "UnsupportedPackedAbiType", { enumerable: true, get: function() {
      return abi_js_1.UnsupportedPackedAbiType;
    } });
    var base_js_1 = require_base();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return base_js_1.BaseError;
    } });
    var block_js_1 = require_block2();
    Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_1.BlockNotFoundError;
    } });
    var contract_js_1 = require_contract();
    Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_1.CallExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
      return contract_js_1.RawContractError;
    } });
    var fee_js_1 = require_fee();
    Object.defineProperty(exports, "BaseFeeScalarError", { enumerable: true, get: function() {
      return fee_js_1.BaseFeeScalarError;
    } });
    Object.defineProperty(exports, "Eip1559FeesNotSupportedError", { enumerable: true, get: function() {
      return fee_js_1.Eip1559FeesNotSupportedError;
    } });
    Object.defineProperty(exports, "MaxFeePerGasTooLowError", { enumerable: true, get: function() {
      return fee_js_1.MaxFeePerGasTooLowError;
    } });
    var rpc_js_1 = require_rpc();
    Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ChainDisconnectedError;
    } });
    Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InternalRpcError;
    } });
    Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidInputRpcError;
    } });
    Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_1.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_1.LimitExceededRpcError;
    } });
    Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ParseRpcError;
    } });
    Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderRpcError;
    } });
    Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return rpc_js_1.RpcError;
    } });
    Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_1.SwitchChainError;
    } });
    Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_1.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_1.UnknownRpcError;
    } });
    Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_1.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_1.UserRejectedRequestError;
    } });
    var chain_js_1 = require_chain();
    Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_1.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports, "ChainMismatchError", { enumerable: true, get: function() {
      return chain_js_1.ChainMismatchError;
    } });
    Object.defineProperty(exports, "ChainNotFoundError", { enumerable: true, get: function() {
      return chain_js_1.ChainNotFoundError;
    } });
    Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_1.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_1.InvalidChainIdError;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooLongError;
    } });
    Object.defineProperty(exports, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooShortError;
    } });
    Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports, "IntegerOutOfRangeError", { enumerable: true, get: function() {
      return encoding_js_1.IntegerOutOfRangeError;
    } });
    Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexValueError;
    } });
    Object.defineProperty(exports, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_1.OffsetOutOfBoundsError;
    } });
    Object.defineProperty(exports, "SizeOverflowError", { enumerable: true, get: function() {
      return encoding_js_1.SizeOverflowError;
    } });
    var ens_js_1 = require_ens();
    Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUriResolutionError;
    } });
    Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarInvalidNftUriError;
    } });
    Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUnsupportedNamespaceError;
    } });
    var estimateGas_js_1 = require_estimateGas();
    Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_1.EstimateGasExecutionError;
    } });
    var node_js_1 = require_node();
    Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_1.ExecutionRevertedError;
    } });
    Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooHighError;
    } });
    Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooLowError;
    } });
    Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_1.InsufficientFundsError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_1.NonceMaxValueError;
    } });
    Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_1.NonceTooHighError;
    } });
    Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_1.NonceTooLowError;
    } });
    Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_1.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_1.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_1.UnknownNodeError;
    } });
    var log_js_1 = require_log2();
    Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_1.FilterTypeNotSupportedError;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_1.HttpRequestError;
    } });
    Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_1.RpcRequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return request_js_1.TimeoutError;
    } });
    Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_1.WebSocketRequestError;
    } });
    var address_js_2 = require_address();
    Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_1 = require_transaction2();
    Object.defineProperty(exports, "FeeConflictError", { enumerable: true, get: function() {
      return transaction_js_1.FeeConflictError;
    } });
    Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidLegacyVError;
    } });
    Object.defineProperty(exports, "InvalidSerializableTransactionError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializableTransactionError;
    } });
    Object.defineProperty(exports, "InvalidSerializedTransactionError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializedTransactionError;
    } });
    Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidSerializedTransactionTypeError;
    } });
    Object.defineProperty(exports, "InvalidStorageKeySizeError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidStorageKeySizeError;
    } });
    Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionExecutionError;
    } });
    Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionNotFoundError;
    } });
    Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_1.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_1.SizeExceedsPaddingSizeError;
    } });
    Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", { enumerable: true, get: function() {
      return data_js_1.SliceOffsetOutOfBoundsError;
    } });
    var transport_js_1 = require_transport();
    Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_1.UrlRequiredError;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    var block_js_2 = require_block();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_2.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_2.formatBlock;
    } });
    var log_js_2 = require_log();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require_decodeDeployData();
    Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_2 = require_transaction();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_2.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_2.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_2.transactionType;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    Object.defineProperty(exports, "formatTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.formatTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    Object.defineProperty(exports, "rpcTransactionType", { enumerable: true, get: function() {
      return transactionRequest_js_1.rpcTransactionType;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashDomain", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashDomain;
    } });
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var compactSignatureToSignature_js_1 = require_compactSignatureToSignature();
    Object.defineProperty(exports, "compactSignatureToSignature", { enumerable: true, get: function() {
      return compactSignatureToSignature_js_1.compactSignatureToSignature;
    } });
    var hexToCompactSignature_js_1 = require_hexToCompactSignature();
    Object.defineProperty(exports, "hexToCompactSignature", { enumerable: true, get: function() {
      return hexToCompactSignature_js_1.hexToCompactSignature;
    } });
    var hexToSignature_js_1 = require_hexToSignature();
    Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function() {
      return hexToSignature_js_1.hexToSignature;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var signatureToCompactSignature_js_1 = require_signatureToCompactSignature();
    Object.defineProperty(exports, "signatureToCompactSignature", { enumerable: true, get: function() {
      return signatureToCompactSignature_js_1.signatureToCompactSignature;
    } });
    var compactSignatureToHex_js_1 = require_compactSignatureToHex();
    Object.defineProperty(exports, "compactSignatureToHex", { enumerable: true, get: function() {
      return compactSignatureToHex_js_1.compactSignatureToHex;
    } });
    var signatureToHex_js_1 = require_signatureToHex();
    Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function() {
      return signatureToHex_js_1.signatureToHex;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "bytesToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.bytesToRlp;
    } });
    Object.defineProperty(exports, "hexToRlp", { enumerable: true, get: function() {
      return toRlp_js_1.hexToRlp;
    } });
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigInt", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigInt;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var assertCurrentChain_js_1 = require_assertCurrentChain();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return assertCurrentChain_js_1.assertCurrentChain;
    } });
    var defineChain_js_1 = require_defineChain();
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return defineChain_js_1.defineChain;
    } });
    var extractChain_js_1 = require_extractChain();
    Object.defineProperty(exports, "extractChain", { enumerable: true, get: function() {
      return extractChain_js_1.extractChain;
    } });
    var getChainContractAddress_js_1 = require_getChainContractAddress();
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return getChainContractAddress_js_1.getChainContractAddress;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "checksumAddress", { enumerable: true, get: function() {
      return getAddress_js_1.checksumAddress;
    } });
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getEventSignature_js_1 = require_getEventSignature();
    Object.defineProperty(exports, "getEventSignature", { enumerable: true, get: function() {
      return getEventSignature_js_1.getEventSignature;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var getFunctionSignature_js_1 = require_getFunctionSignature();
    Object.defineProperty(exports, "getFunctionSignature", { enumerable: true, get: function() {
      return getFunctionSignature_js_1.getFunctionSignature;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var sha256_js_1 = require_sha2562();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha256_js_1.sha256;
    } });
    var ripemd160_js_1 = require_ripemd1602();
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var stringify_js_1 = require_stringify2();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    Object.defineProperty(exports, "domainSeparator", { enumerable: true, get: function() {
      return typedData_js_1.domainSeparator;
    } });
    Object.defineProperty(exports, "getTypesForEIP712Domain", { enumerable: true, get: function() {
      return typedData_js_1.getTypesForEIP712Domain;
    } });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/utils/encoding/toRlp.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToRlp = exports.bytesToRlp = exports.toRlp = void 0;
    var index_js_1 = require_cjs2();
    var cursor_js_1 = require_cursor2();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function toRlp(bytes, to = "hex") {
      const encodable = getEncodable(bytes);
      const cursor = (0, cursor_js_1.createCursor)(new Uint8Array(encodable.length));
      encodable.encode(cursor);
      if (to === "hex")
        return (0, toHex_js_1.bytesToHex)(cursor.bytes);
      return cursor.bytes;
    }
    exports.toRlp = toRlp;
    function bytesToRlp(bytes, to = "bytes") {
      return toRlp(bytes, to);
    }
    exports.bytesToRlp = bytesToRlp;
    function hexToRlp(hex, to = "hex") {
      return toRlp(hex, to);
    }
    exports.hexToRlp = hexToRlp;
    function getEncodable(bytes) {
      if (Array.isArray(bytes))
        return getEncodableList(bytes.map((x) => getEncodable(x)));
      return getEncodableBytes(bytes);
    }
    function getEncodableList(list) {
      const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
      const sizeOfBodyLength = getSizeOfLength(bodyLength);
      const length = (() => {
        if (bodyLength <= 55)
          return 1 + bodyLength;
        return 1 + sizeOfBodyLength + bodyLength;
      })();
      return {
        length,
        encode(cursor) {
          if (bodyLength <= 55) {
            cursor.pushByte(192 + bodyLength);
          } else {
            cursor.pushByte(192 + 55 + sizeOfBodyLength);
            if (sizeOfBodyLength === 1)
              cursor.pushUint8(bodyLength);
            else if (sizeOfBodyLength === 2)
              cursor.pushUint16(bodyLength);
            else if (sizeOfBodyLength === 3)
              cursor.pushUint24(bodyLength);
            else
              cursor.pushUint32(bodyLength);
          }
          for (const { encode } of list) {
            encode(cursor);
          }
        }
      };
    }
    function getEncodableBytes(bytesOrHex) {
      const bytes = typeof bytesOrHex === "string" ? (0, toBytes_js_1.hexToBytes)(bytesOrHex) : bytesOrHex;
      const sizeOfBytesLength = getSizeOfLength(bytes.length);
      const length = (() => {
        if (bytes.length === 1 && bytes[0] < 128)
          return 1;
        if (bytes.length <= 55)
          return 1 + bytes.length;
        return 1 + sizeOfBytesLength + bytes.length;
      })();
      return {
        length,
        encode(cursor) {
          if (bytes.length === 1 && bytes[0] < 128) {
            cursor.pushBytes(bytes);
          } else if (bytes.length <= 55) {
            cursor.pushByte(128 + bytes.length);
            cursor.pushBytes(bytes);
          } else {
            cursor.pushByte(128 + 55 + sizeOfBytesLength);
            if (sizeOfBytesLength === 1)
              cursor.pushUint8(bytes.length);
            else if (sizeOfBytesLength === 2)
              cursor.pushUint16(bytes.length);
            else if (sizeOfBytesLength === 3)
              cursor.pushUint24(bytes.length);
            else
              cursor.pushUint32(bytes.length);
            cursor.pushBytes(bytes);
          }
        }
      };
    }
    function getSizeOfLength(length) {
      if (length < 2 ** 8)
        return 1;
      if (length < 2 ** 16)
        return 2;
      if (length < 2 ** 24)
        return 3;
      if (length < 2 ** 32)
        return 4;
      throw new index_js_1.BaseError("Length is too large.");
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/serializers.js
var require_serializers = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/celo/serializers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionCIP64 = exports.assertTransactionCIP42 = exports.serializersCelo = exports.serializeTransactionCelo = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var serializeAccessList_js_1 = require_serializeAccessList();
    var serializeTransaction_js_1 = require_serializeTransaction();
    var utils_js_1 = require_utils2();
    var serializeTransactionCelo = (tx, signature) => {
      if ((0, utils_js_1.isCIP64)(tx))
        return serializeTransactionCIP64(tx, signature);
      if ((0, utils_js_1.isCIP42)(tx))
        return serializeTransactionCIP42(tx, signature);
      return (0, serializeTransaction_js_1.serializeTransaction)(tx, signature);
    };
    exports.serializeTransactionCelo = serializeTransactionCelo;
    exports.serializersCelo = {
      transaction: exports.serializeTransactionCelo
    };
    function serializeTransactionCIP42(transaction, signature) {
      assertTransactionCIP42(transaction);
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data } = transaction;
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        feeCurrency ?? "0x",
        gatewayFeeRecipient ?? "0x",
        gatewayFee ? (0, toHex_js_1.toHex)(gatewayFee) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        (0, serializeAccessList_js_1.serializeAccessList)(accessList)
      ];
      if (signature) {
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x7c",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionCIP64(transaction, signature) {
      assertTransactionCIP64(transaction);
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        (0, serializeAccessList_js_1.serializeAccessList)(accessList),
        feeCurrency
      ];
      if (signature) {
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x7b",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    var MAX_MAX_FEE_PER_GAS = 2n ** 256n - 1n;
    function assertTransactionCIP42(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
      if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) && (0, utils_js_1.isPresent)(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
      if ((0, utils_js_1.isPresent)(gatewayFee) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient) || (0, utils_js_1.isPresent)(gatewayFeeRecipient) && (0, utils_js_1.isEmpty)(gatewayFee)) {
        throw new base_js_1.BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
      }
      if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
        throw new base_js_1.BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
      }
      if ((0, utils_js_1.isPresent)(gatewayFeeRecipient) && !(0, isAddress_js_1.isAddress)(gatewayFeeRecipient)) {
        throw new address_js_1.InvalidAddressError(gatewayFeeRecipient);
      }
      if ((0, utils_js_1.isEmpty)(feeCurrency) && (0, utils_js_1.isEmpty)(gatewayFeeRecipient)) {
        throw new base_js_1.BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
      }
    }
    exports.assertTransactionCIP42 = assertTransactionCIP42;
    function assertTransactionCIP64(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
      if ((0, utils_js_1.isPresent)(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if ((0, utils_js_1.isPresent)(maxPriorityFeePerGas) && (0, utils_js_1.isPresent)(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
      if ((0, utils_js_1.isPresent)(feeCurrency) && !(0, isAddress_js_1.isAddress)(feeCurrency)) {
        throw new base_js_1.BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
      }
      if ((0, utils_js_1.isEmpty)(feeCurrency)) {
        throw new base_js_1.BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
      }
    }
    exports.assertTransactionCIP64 = assertTransactionCIP64;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celo.js
var require_celo = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celo.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celo = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celo = (0, defineChain_js_1.defineChain)({
      id: 42220,
      name: "Celo",
      network: "celo",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
      },
      rpcUrls: {
        default: { http: ["https://forno.celo.org"] },
        infura: {
          http: ["https://celo-mainnet.infura.io/v3"]
        },
        public: {
          http: ["https://forno.celo.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/mainnet"
        },
        etherscan: { name: "CeloScan", url: "https://celoscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 13112599
        }
      },
      testnet: false
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celoAlfajores.js
var require_celoAlfajores = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celoAlfajores.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celoAlfajores = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celoAlfajores = (0, defineChain_js_1.defineChain)({
      id: 44787,
      name: "Alfajores",
      network: "celo-alfajores",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "A-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        },
        infura: {
          http: ["https://celo-alfajores.infura.io/v3"]
        },
        public: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/alfajores"
        },
        etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 14569001
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/chiliz.js
var require_chiliz = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/chiliz.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chiliz = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.chiliz = (0, defineChain_js_1.defineChain)({
      id: 88888,
      name: "Chiliz Chain",
      network: "chiliz-chain",
      nativeCurrency: {
        decimals: 18,
        name: "CHZ",
        symbol: "CHZ"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.ankr.com/chiliz", "https://chiliz.publicnode.com"]
        },
        public: {
          http: ["https://rpc.ankr.com/chiliz", "https://chiliz.publicnode.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "Chiliz Explorer",
          url: "https://scan.chiliz.com"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celoCannoli.js
var require_celoCannoli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/celoCannoli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celoCannoli = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celoCannoli = (0, defineChain_js_1.defineChain)({
      id: 17323,
      name: "Cannoli",
      network: "celo-cannoli",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "C-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        },
        public: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/cannoli"
        }
      },
      contracts: {
        multicall3: {
          address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
          blockCreated: 87429
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/classic.js
var require_classic = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/classic.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classic = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.classic = (0, defineChain_js_1.defineChain)({
      id: 61,
      name: "Ethereum Classic",
      network: "classic",
      nativeCurrency: {
        decimals: 18,
        name: "ETC",
        symbol: "ETC"
      },
      rpcUrls: {
        default: { http: ["https://etc.rivet.link"] },
        public: { http: ["https://etc.rivet.link"] }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.com/etc/mainnet"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/confluxESpace.js
var require_confluxESpace = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/confluxESpace.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.confluxESpace = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.confluxESpace = (0, defineChain_js_1.defineChain)({
      id: 1030,
      name: "Conflux eSpace",
      network: "cfx-espace",
      nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://evm.confluxrpc.org"],
          webSocket: ["wss://evm.confluxrpc.org/ws"]
        },
        public: {
          http: ["https://evm.confluxrpc.org"],
          webSocket: ["wss://evm.confluxrpc.org/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "ConfluxScan",
          url: "https://evm.confluxscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
          blockCreated: 68602935
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js
var require_confluxESpaceTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/confluxESpaceTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.confluxESpaceTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.confluxESpaceTestnet = (0, defineChain_js_1.defineChain)({
      id: 71,
      name: "Conflux eSpace Testnet",
      network: "cfx-espace-testnet",
      testnet: true,
      nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://evmtestnet.confluxrpc.org"],
          webSocket: ["wss://evmtestnet.confluxrpc.org/ws"]
        },
        public: {
          http: ["https://evmtestnet.confluxrpc.org"],
          webSocket: ["wss://evmtestnet.confluxrpc.org/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "ConfluxScan",
          url: "https://evmtestnet.confluxscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
          blockCreated: 117499050
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/coreDao.js
var require_coreDao = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/coreDao.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coreDao = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.coreDao = (0, defineChain_js_1.defineChain)({
      id: 1116,
      name: "Core Dao",
      network: "coreDao",
      nativeCurrency: {
        decimals: 18,
        name: "Core",
        symbol: "CORE"
      },
      rpcUrls: {
        public: { http: ["https://rpc.coredao.org"] },
        default: { http: ["https://rpc.coredao.org"] }
      },
      blockExplorers: {
        default: { name: "CoreDao", url: "https://scan.coredao.org" },
        etherscan: { name: "CoreDao", url: "https://scan.coredao.org" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 11907934
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/cronos.js
var require_cronos = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/cronos.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cronos = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.cronos = (0, defineChain_js_1.defineChain)({
      id: 25,
      name: "Cronos Mainnet",
      network: "cronos",
      nativeCurrency: {
        decimals: 18,
        name: "Cronos",
        symbol: "CRO"
      },
      rpcUrls: {
        default: { http: ["https://evm.cronos.org"] },
        public: { http: ["https://evm.cronos.org"] }
      },
      blockExplorers: {
        default: { name: "Cronoscan", url: "https://cronoscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1963112
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/cronosTestnet.js
var require_cronosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/cronosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cronosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.cronosTestnet = (0, defineChain_js_1.defineChain)({
      id: 338,
      name: "Cronos Testnet",
      network: "cronos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "CRO",
        symbol: "tCRO"
      },
      rpcUrls: {
        default: { http: ["https://evm-t3.cronos.org"] },
        public: { http: ["https://evm-t3.cronos.org"] }
      },
      blockExplorers: {
        default: {
          name: "Cronos Explorer",
          url: "https://cronos.org/explorer/testnet3"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 10191251
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/crossbell.js
var require_crossbell = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/crossbell.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crossbell = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.crossbell = (0, defineChain_js_1.defineChain)({
      id: 3737,
      network: "crossbell",
      name: "Crossbell",
      nativeCurrency: {
        decimals: 18,
        name: "CSB",
        symbol: "CSB"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.crossbell.io"]
        },
        public: {
          http: ["https://rpc.crossbell.io"]
        }
      },
      blockExplorers: {
        default: { name: "CrossScan", url: "https://scan.crossbell.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 38246031
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/dfk.js
var require_dfk = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/dfk.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dfk = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.dfk = (0, defineChain_js_1.defineChain)({
      id: 53935,
      name: "DFK Chain",
      network: "dfk",
      nativeCurrency: {
        decimals: 18,
        name: "Jewel",
        symbol: "JEWEL"
      },
      rpcUrls: {
        default: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        },
        public: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        },
        default: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/dogechain.js
var require_dogechain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/dogechain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dogechain = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.dogechain = (0, defineChain_js_1.defineChain)({
      id: 2e3,
      name: "Dogechain",
      network: "dogechain",
      nativeCurrency: {
        decimals: 18,
        name: "Dogechain",
        symbol: "DC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.dogechain.dog"] },
        public: { http: ["https://rpc.dogechain.dog"] }
      },
      blockExplorers: {
        etherscan: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        },
        default: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/edgeware.js
var require_edgeware = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/edgeware.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edgeware = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.edgeware = (0, defineChain_js_1.defineChain)({
      id: 2021,
      name: "Edgeware EdgeEVM Mainnet",
      network: "edgeware",
      nativeCurrency: {
        decimals: 18,
        name: "Edgeware",
        symbol: "EDG"
      },
      rpcUrls: {
        default: { http: ["https://edgeware-evm.jelliedowl.net"] },
        public: { http: ["https://edgeware-evm.jelliedowl.net"] }
      },
      blockExplorers: {
        etherscan: { name: "Edgscan by Bharathcoorg", url: "https://edgscan.live" },
        default: { name: "Edgscan by Bharathcoorg", url: "https://edgscan.live" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 18117872
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js
var require_edgewareTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edgewareTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.edgewareTestnet = (0, defineChain_js_1.defineChain)({
      id: 2022,
      name: "Beresheet BereEVM Testnet",
      network: "edgewareTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "Testnet EDG",
        symbol: "tEDG"
      },
      rpcUrls: {
        default: { http: ["https://beresheet-evm.jelliedowl.net"] },
        public: { http: ["https://beresheet-evm.jelliedowl.net"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Edgscan by Bharathcoorg",
          url: "https://testnet.edgscan.live"
        },
        default: {
          name: "Edgscan by Bharathcoorg",
          url: "https://testnet.edgscan.live"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/eos.js
var require_eos = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/eos.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eos = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.eos = (0, defineChain_js_1.defineChain)({
      id: 17777,
      name: "EOS EVM",
      network: "eos",
      nativeCurrency: {
        decimals: 18,
        name: "EOS",
        symbol: "EOS"
      },
      rpcUrls: {
        default: { http: ["https://api.evm.eosnetwork.com"] },
        public: { http: ["https://api.evm.eosnetwork.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "EOS EVM Explorer",
          url: "https://explorer.evm.eosnetwork.com"
        },
        default: {
          name: "EOS EVM Explorer",
          url: "https://explorer.evm.eosnetwork.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7943933
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/eosTestnet.js
var require_eosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/eosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.eosTestnet = (0, defineChain_js_1.defineChain)({
      id: 15557,
      name: "EOS EVM Testnet",
      network: "eos",
      nativeCurrency: {
        decimals: 18,
        name: "EOS",
        symbol: "EOS"
      },
      rpcUrls: {
        default: { http: ["https://api.testnet.evm.eosnetwork.com"] },
        public: { http: ["https://api.testnet.evm.eosnetwork.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "EOS EVM Testnet Explorer",
          url: "https://explorer.testnet.evm.eosnetwork.com"
        },
        default: {
          name: "EOS EVM Testnet Explorer",
          url: "https://explorer.testnet.evm.eosnetwork.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 9067940
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/evmos.js
var require_evmos = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/evmos.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evmos = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.evmos = (0, defineChain_js_1.defineChain)({
      id: 9001,
      name: "Evmos",
      network: "evmos",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.org:8545"] },
        public: { http: ["https://eth.bd.evmos.org:8545"] }
      },
      blockExplorers: {
        default: { name: "Evmos Block Explorer", url: "https://escan.live" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/evmosTestnet.js
var require_evmosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/evmosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evmosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.evmosTestnet = (0, defineChain_js_1.defineChain)({
      id: 9e3,
      name: "Evmos Testnet",
      network: "evmos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.dev:8545"] },
        public: { http: ["https://eth.bd.evmos.dev:8545"] }
      },
      blockExplorers: {
        default: {
          name: "Evmos Testnet Block Explorer",
          url: "https://evm.evmos.dev/"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ekta.js
var require_ekta = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ekta.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ekta = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.ekta = (0, defineChain_js_1.defineChain)({
      id: 1994,
      name: "Ekta",
      network: "ekta",
      nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
      },
      rpcUrls: {
        public: { http: ["https://main.ekta.io"] },
        default: { http: ["https://main.ekta.io"] }
      },
      blockExplorers: {
        default: { name: "Ektascan", url: "https://ektascan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ektaTestnet.js
var require_ektaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ektaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ektaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.ektaTestnet = (0, defineChain_js_1.defineChain)({
      id: 1004,
      name: "Ekta Testnet",
      network: "ekta-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
      },
      rpcUrls: {
        public: { http: ["https://test.ekta.io:8545"] },
        default: { http: ["https://test.ekta.io:8545"] }
      },
      blockExplorers: {
        default: { name: "Test Ektascan", url: "https://test.ektascan.io" }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantom.js
var require_fantom = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantom.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantom = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fantom = (0, defineChain_js_1.defineChain)({
      id: 250,
      name: "Fantom",
      network: "fantom",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/fantom"] },
        public: { http: ["https://rpc.ankr.com/fantom"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
        default: { name: "FTMScan", url: "https://ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 33001987
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js
var require_fantomSonicTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantomSonicTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantomSonicTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fantomSonicTestnet = (0, defineChain_js_1.defineChain)({
      id: 64240,
      name: "Fantom Sonic Open Testnet",
      network: "fantom-sonic-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpcapi.sonic.fantom.network"] },
        public: { http: ["https://rpcapi.sonic.fantom.network"] }
      },
      blockExplorers: {
        default: {
          name: "Fantom Sonic Open Testnet Explorer",
          url: "https://public-sonic.fantom.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantomTestnet.js
var require_fantomTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fantomTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantomTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fantomTestnet = (0, defineChain_js_1.defineChain)({
      id: 4002,
      name: "Fantom Testnet",
      network: "fantom-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.testnet.fantom.network"] },
        public: { http: ["https://rpc.testnet.fantom.network"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
        default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 8328688
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fibo.js
var require_fibo = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fibo.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fibo = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fibo = (0, defineChain_js_1.defineChain)({
      id: 12306,
      name: "Fibo Chain",
      network: "fibochain",
      nativeCurrency: {
        decimals: 18,
        name: "fibo",
        symbol: "FIBO"
      },
      rpcUrls: {
        default: { http: ["https://network.hzroc.art"] },
        public: { http: ["https://network.hzroc.art"] }
      },
      blockExplorers: {
        default: { name: "FiboScan", url: "https://scan.fibochain.org" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoin.js
var require_filecoin = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoin.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoin = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.filecoin = (0, defineChain_js_1.defineChain)({
      id: 314,
      name: "Filecoin Mainnet",
      network: "filecoin-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
      },
      rpcUrls: {
        default: { http: ["https://api.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://filfox.info/en" },
        filscan: { name: "Filscan", url: "https://filscan.io" },
        filscout: { name: "Filscout", url: "https://filscout.io/en" },
        glif: { name: "Glif", url: "https://explorer.glif.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3328594
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js
var require_filecoinCalibration = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoinCalibration = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.filecoinCalibration = (0, defineChain_js_1.defineChain)({
      id: 314159,
      name: "Filecoin Calibration",
      network: "filecoin-calibration",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filscan", url: "https://calibration.filscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js
var require_filecoinHyperspace = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoinHyperspace = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.filecoinHyperspace = (0, defineChain_js_1.defineChain)({
      id: 3141,
      name: "Filecoin Hyperspace",
      network: "filecoin-hyperspace",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
        filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/flare.js
var require_flare = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/flare.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flare = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.flare = (0, defineChain_js_1.defineChain)({
      id: 14,
      name: "Flare Mainnet",
      network: "flare-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "flare",
        symbol: "FLR"
      },
      rpcUrls: {
        default: { http: ["https://flare-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Flare Explorer",
          url: "https://flare-explorer.flare.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/flareTestnet.js
var require_flareTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/flareTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flareTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.flareTestnet = (0, defineChain_js_1.defineChain)({
      id: 114,
      name: "Coston2",
      network: "coston2",
      nativeCurrency: {
        decimals: 18,
        name: "coston2flare",
        symbol: "C2FLR"
      },
      rpcUrls: {
        default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston2 Explorer",
          url: "https://coston2-explorer.flare.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/foundry.js
var require_foundry = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/foundry.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.foundry = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.foundry = (0, defineChain_js_1.defineChain)({
      id: 31337,
      name: "Foundry",
      network: "foundry",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        },
        public: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fuse.js
var require_fuse = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fuse.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fuse = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fuse = (0, defineChain_js_1.defineChain)({
      id: 122,
      name: "Fuse",
      network: "fuse",
      nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc.fuse.io"] },
        public: { http: ["https://rpc.fuse.io"] }
      },
      blockExplorers: {
        default: { name: "Fuse Explorer", url: "https://explorer.fuse.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 16146628
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fuseSparknet.js
var require_fuseSparknet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/fuseSparknet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fuseSparknet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.fuseSparknet = (0, defineChain_js_1.defineChain)({
      id: 123,
      name: "Fuse Sparknet",
      network: "fuse",
      nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc.fusespark.io"] },
        public: { http: ["https://rpc.fusespark.io"] }
      },
      blockExplorers: {
        default: {
          name: "Sparkent Explorer",
          url: "https://explorer.fusespark.io"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/iotex.js
var require_iotex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/iotex.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iotex = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.iotex = (0, defineChain_js_1.defineChain)({
      id: 4689,
      name: "IoTeX",
      network: "iotex",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://iotexscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/iotexTestnet.js
var require_iotexTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/iotexTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iotexTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.iotexTestnet = (0, defineChain_js_1.defineChain)({
      id: 4690,
      name: "IoTeX Testnet",
      network: "iotex-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/jbc.js
var require_jbc = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/jbc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jbc = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.jbc = (0, defineChain_js_1.defineChain)({
      id: 8899,
      name: "JIBCHAIN L1",
      network: "jbc",
      nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc-l1.jibchain.net"]
        },
        public: {
          http: ["https://rpc-l1.jibchain.net"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://exp-l1.jibchain.net"
        }
      },
      contracts: {
        multicall3: {
          address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
          blockCreated: 2299048
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/karura.js
var require_karura = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/karura.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.karura = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.karura = (0, defineChain_js_1.defineChain)({
      id: 686,
      name: "Karura",
      network: "karura",
      nativeCurrency: {
        name: "Karura",
        symbol: "KAR",
        decimals: 18
      },
      rpcUrls: {
        public: {
          http: ["https://eth-rpc-karura.aca-api.network"],
          webSocket: ["wss://eth-rpc-karura.aca-api.network"]
        },
        default: {
          http: ["https://eth-rpc-karura.aca-api.network"],
          webSocket: ["wss://eth-rpc-karura.aca-api.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Karura Blockscout",
          url: "https://blockscout.karura.network"
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gobi.js
var require_gobi = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gobi.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gobi = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.gobi = (0, defineChain_js_1.defineChain)({
      id: 1663,
      name: "Horizen Gobi Testnet",
      network: "gobi",
      nativeCurrency: {
        decimals: 18,
        name: "Test ZEN",
        symbol: "tZEN"
      },
      rpcUrls: {
        public: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] },
        default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
      },
      blockExplorers: {
        default: { name: "Gobi Explorer", url: "https://gobi-explorer.horizen.io" }
      },
      contracts: {},
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/goerli.js
var require_goerli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/goerli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.goerli = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.goerli = (0, defineChain_js_1.defineChain)({
      id: 5,
      network: "goerli",
      name: "Goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://goerli.infura.io/v3"],
          webSocket: ["wss://goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        },
        public: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0x56522D00C410a43BFfDF00a9A569489297385790",
          blockCreated: 8765204
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gnosis.js
var require_gnosis = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gnosis.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gnosis = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.gnosis = (0, defineChain_js_1.defineChain)({
      id: 100,
      name: "Gnosis",
      network: "gnosis",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.gnosischain.com"],
          webSocket: ["wss://rpc.gnosischain.com/wss"]
        },
        public: {
          http: ["https://rpc.gnosischain.com"],
          webSocket: ["wss://rpc.gnosischain.com/wss"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Gnosisscan",
          url: "https://gnosisscan.io"
        },
        default: {
          name: "Gnosis Chain Explorer",
          url: "https://blockscout.com/xdai/mainnet"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 21022491
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gnosisChiado.js
var require_gnosisChiado = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/gnosisChiado.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gnosisChiado = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.gnosisChiado = (0, defineChain_js_1.defineChain)({
      id: 10200,
      name: "Gnosis Chiado",
      network: "chiado",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.chiadochain.net"],
          webSocket: ["wss://rpc.chiadochain.net/wss"]
        },
        public: {
          http: ["https://rpc.chiadochain.net"],
          webSocket: ["wss://rpc.chiadochain.net/wss"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.chiadochain.net"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 4967313
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/hardhat.js
var require_hardhat = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/hardhat.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hardhat = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.hardhat = (0, defineChain_js_1.defineChain)({
      id: 31337,
      name: "Hardhat",
      network: "hardhat",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/harmonyOne.js
var require_harmonyOne = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/harmonyOne.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.harmonyOne = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.harmonyOne = (0, defineChain_js_1.defineChain)({
      id: 16666e5,
      name: "Harmony One",
      network: "harmony",
      nativeCurrency: {
        name: "Harmony",
        symbol: "ONE",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://rpc.ankr.com/harmony"] },
        default: { http: ["https://rpc.ankr.com/harmony"] }
      },
      blockExplorers: {
        default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 24185753
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/haqqMainnet.js
var require_haqqMainnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/haqqMainnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.haqqMainnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.haqqMainnet = (0, defineChain_js_1.defineChain)({
      id: 11235,
      name: "HAQQ Mainnet",
      network: "haqq-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLM"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.haqq.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js
var require_haqqTestedge2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.haqqTestedge2 = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.haqqTestedge2 = (0, defineChain_js_1.defineChain)({
      id: 54211,
      name: "HAQQ Testedge 2",
      network: "haqq-testedge-2",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLMT"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.testedge2.haqq.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/holesky.js
var require_holesky = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/holesky.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.holesky = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.holesky = (0, defineChain_js_1.defineChain)({
      id: 17e3,
      network: "holesky",
      name: "Holesky",
      nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://ethereum-holesky.publicnode.com"]
        },
        public: {
          http: ["https://ethereum-holesky.publicnode.com"]
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 77
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kava.js
var require_kava = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kava.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kava = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.kava = (0, defineChain_js_1.defineChain)({
      id: 2222,
      name: "Kava EVM",
      network: "kava-mainnet",
      nativeCurrency: {
        name: "Kava",
        symbol: "KAVA",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://evm.kava.io"] },
        default: { http: ["https://evm.kava.io"] }
      },
      blockExplorers: {
        default: { name: "Kava EVM Explorer", url: "https://kavascan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 3661165
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kavaTestnet.js
var require_kavaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kavaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kavaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.kavaTestnet = (0, defineChain_js_1.defineChain)({
      id: 2221,
      name: "Kava EVM Testnet",
      network: "kava-testnet",
      nativeCurrency: {
        name: "Kava",
        symbol: "KAVA",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://evm.testnet.kava.io"] },
        default: { http: ["https://evm.testnet.kava.io"] }
      },
      blockExplorers: {
        default: {
          name: "Kava EVM Testnet Explorer",
          url: "https://testnet.kavascan.com/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
          blockCreated: 7242179
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/klaytn.js
var require_klaytn = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/klaytn.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.klaytn = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.klaytn = (0, defineChain_js_1.defineChain)({
      id: 8217,
      name: "Klaytn",
      network: "klaytn",
      nativeCurrency: {
        decimals: 18,
        name: "Klaytn",
        symbol: "KLAY"
      },
      rpcUrls: {
        default: { http: ["https://public-en-cypress.klaytn.net"] },
        public: { http: ["https://public-en-cypress.klaytn.net"] }
      },
      blockExplorers: {
        etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
        default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 96002415
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js
var require_klaytnBaobab = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/klaytnBaobab.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.klaytnBaobab = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.klaytnBaobab = (0, defineChain_js_1.defineChain)({
      id: 1001,
      name: "Klaytn Baobab Testnet",
      network: "klaytn-baobab",
      nativeCurrency: {
        decimals: 18,
        name: "Baobab Klaytn",
        symbol: "KLAY"
      },
      rpcUrls: {
        default: { http: ["https://public-en-baobab.klaytn.net"] },
        public: { http: ["https://public-en-baobab.klaytn.net"] }
      },
      blockExplorers: {
        etherscan: { name: "KlaytnScope", url: "https://baobab.klaytnscope.com" },
        default: { name: "KlaytnScope", url: "https://baobab.klaytnscope.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 123390593
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kroma.js
var require_kroma = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kroma.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kroma = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.kroma = (0, defineChain_js_1.defineChain)({
      id: 255,
      network: "kroma",
      name: "Kroma",
      nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.kroma.network"]
        },
        public: {
          http: ["https://api.kroma.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Kroma Explorer",
          url: "https://blockscout.kroma.network"
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kromaSepolia.js
var require_kromaSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/kromaSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kromaSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.kromaSepolia = (0, defineChain_js_1.defineChain)({
      id: 2358,
      network: "kroma-sepolia",
      name: "Kroma Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.sepolia.kroma.network"]
        },
        public: {
          http: ["https://api.sepolia.kroma.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Kroma Sepolia Explorer",
          url: "https://blockscout.sepolia.kroma.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/linea.js
var require_linea = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/linea.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.linea = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.linea = (0, defineChain_js_1.defineChain)({
      id: 59144,
      name: "Linea Mainnet",
      network: "linea-mainnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        infura: {
          http: ["https://linea-mainnet.infura.io/v3"],
          webSocket: ["wss://linea-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.linea.build"],
          webSocket: ["wss://rpc.linea.build"]
        },
        public: {
          http: ["https://rpc.linea.build"],
          webSocket: ["wss://rpc.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "Etherscan",
          url: "https://lineascan.build"
        },
        etherscan: {
          name: "Etherscan",
          url: "https://lineascan.build"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.linea.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 42
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/lineaTestnet.js
var require_lineaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/lineaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lineaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.lineaTestnet = (0, defineChain_js_1.defineChain)({
      id: 59140,
      name: "Linea Goerli Testnet",
      network: "linea-testnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        infura: {
          http: ["https://linea-goerli.infura.io/v3"],
          webSocket: ["wss://linea-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        },
        public: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "Etherscan",
          url: "https://goerli.lineascan.build"
        },
        etherscan: {
          name: "Etherscan",
          url: "https://goerli.lineascan.build"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.goerli.linea.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 498623
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/localhost.js
var require_localhost = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/localhost.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.localhost = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.localhost = (0, defineChain_js_1.defineChain)({
      id: 1337,
      name: "Localhost",
      network: "localhost",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/lukso.js
var require_lukso = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/lukso.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lukso = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.lukso = (0, defineChain_js_1.defineChain)({
      id: 42,
      network: "lukso",
      name: "LUKSO",
      nativeCurrency: {
        name: "LUKSO",
        symbol: "LYX",
        decimals: 18
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.lukso.network"],
          webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
        },
        public: {
          http: ["https://rpc.mainnet.lukso.network"],
          webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "LUKSO Mainnet Explorer",
          url: "https://explorer.execution.mainnet.lukso.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mainnet.js
var require_mainnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mainnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mainnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mainnet = (0, defineChain_js_1.defineChain)({
      id: 1,
      network: "homestead",
      name: "Ethereum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://mainnet.infura.io/v3"],
          webSocket: ["wss://mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://cloudflare-eth.com"]
        },
        public: {
          http: ["https://cloudflare-eth.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
          blockCreated: 16966585
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mandala.js
var require_mandala = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mandala.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mandala = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mandala = (0, defineChain_js_1.defineChain)({
      id: 595,
      name: "Mandala TC9",
      network: "mandala",
      nativeCurrency: {
        name: "Mandala",
        symbol: "mACA",
        decimals: 18
      },
      rpcUrls: {
        public: {
          http: ["https://eth-rpc-tc9.aca-staging.network"],
          webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
        },
        default: {
          http: ["https://eth-rpc-tc9.aca-staging.network"],
          webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Mandala Blockscout",
          url: "https://blockscout.mandala.aca-staging.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/manta.js
var require_manta = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/manta.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.manta = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.manta = (0, defineChain_js_1.defineChain)({
      id: 169,
      name: "Manta Pacific Mainnet",
      network: "manta",
      nativeCurrency: {
        decimals: 18,
        name: "ETH",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["https://pacific-rpc.manta.network/http"] },
        public: { http: ["https://pacific-rpc.manta.network/http"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Manta Explorer",
          url: "https://pacific-explorer.manta.network"
        },
        default: {
          name: "Manta Explorer",
          url: "https://pacific-explorer.manta.network"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 332890
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantaTestnet.js
var require_mantaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mantaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mantaTestnet = (0, defineChain_js_1.defineChain)({
      id: 3441005,
      name: "Manta Pacific Testnet",
      network: "manta-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "ETH",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["https://manta-testnet.calderachain.xyz/http"] },
        public: { http: ["https://manta-testnet.calderachain.xyz/http"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Manta Testnet Explorer",
          url: "https://pacific-explorer.testnet.manta.network"
        },
        default: {
          name: "Manta Testnet Explorer",
          url: "https://pacific-explorer.testnet.manta.network"
        }
      },
      contracts: {
        multicall3: {
          address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
          blockCreated: 419915
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantle.js
var require_mantle = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantle.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mantle = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mantle = (0, defineChain_js_1.defineChain)({
      id: 5e3,
      name: "Mantle",
      network: "mantle",
      nativeCurrency: {
        decimals: 18,
        name: "MNT",
        symbol: "MNT"
      },
      rpcUrls: {
        default: { http: ["https://rpc.mantle.xyz"] },
        public: { http: ["https://rpc.mantle.xyz"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Mantle Explorer",
          url: "https://explorer.mantle.xyz"
        },
        default: {
          name: "Mantle Explorer",
          url: "https://explorer.mantle.xyz"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 304717
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantleTestnet.js
var require_mantleTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mantleTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mantleTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mantleTestnet = (0, defineChain_js_1.defineChain)({
      id: 5001,
      name: "Mantle Testnet",
      network: "mantle",
      nativeCurrency: {
        decimals: 18,
        name: "MNT",
        symbol: "MNT"
      },
      rpcUrls: {
        default: { http: ["https://rpc.testnet.mantle.xyz"] },
        public: { http: ["https://rpc.testnet.mantle.xyz"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Mantle Testnet Explorer",
          url: "https://explorer.testnet.mantle.xyz"
        },
        default: {
          name: "Mantle Testnet Explorer",
          url: "https://explorer.testnet.mantle.xyz"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/meter.js
var require_meter = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/meter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.meter = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.meter = (0, defineChain_js_1.defineChain)({
      id: 82,
      name: "Meter",
      network: "meter",
      nativeCurrency: {
        decimals: 18,
        name: "MTR",
        symbol: "MTR"
      },
      rpcUrls: {
        default: { http: ["https://rpc.meter.io"] },
        public: { http: ["https://rpc.meter.io"] }
      },
      blockExplorers: {
        default: { name: "MeterScan", url: "https://scan.meter.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/meterTestnet.js
var require_meterTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/meterTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.meterTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.meterTestnet = (0, defineChain_js_1.defineChain)({
      id: 83,
      name: "Meter Testnet",
      network: "meter-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "MTR",
        symbol: "MTR"
      },
      rpcUrls: {
        default: { http: ["https://rpctest.meter.io"] },
        public: { http: ["https://rpctest.meter.io"] }
      },
      blockExplorers: {
        default: {
          name: "MeterTestnetScan",
          url: "https://scan-warringstakes.meter.io"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/metis.js
var require_metis = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/metis.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metis = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.metis = (0, defineChain_js_1.defineChain)({
      id: 1088,
      name: "Metis",
      network: "andromeda",
      nativeCurrency: {
        decimals: 18,
        name: "Metis",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://andromeda.metis.io/?owner=1088"] },
        public: { http: ["https://andromeda.metis.io/?owner=1088"] }
      },
      blockExplorers: {
        default: {
          name: "Andromeda Explorer",
          url: "https://andromeda-explorer.metis.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2338552
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/metisGoerli.js
var require_metisGoerli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/metisGoerli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metisGoerli = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.metisGoerli = (0, defineChain_js_1.defineChain)({
      id: 599,
      name: "Metis Goerli",
      network: "metis-goerli",
      nativeCurrency: {
        decimals: 18,
        name: "Metis Goerli",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://goerli.gateway.metisdevops.link"] },
        public: { http: ["https://goerli.gateway.metisdevops.link"] }
      },
      blockExplorers: {
        default: {
          name: "Metis Goerli Explorer",
          url: "https://goerli.explorer.metisdevops.link"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1006207
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mev.js
var require_mev = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mev.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mev = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mev = (0, defineChain_js_1.defineChain)({
      id: 7518,
      network: "MEVerse",
      name: "MEVerse Chain Mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversemainnet.io"]
        },
        public: {
          http: ["https://rpc.meversemainnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://www.meversescan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 86881340
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mevTestnet.js
var require_mevTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/mevTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mevTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.mevTestnet = (0, defineChain_js_1.defineChain)({
      id: 4759,
      network: "MEVerse Testnet",
      name: "MEVerse Chain Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversetestnet.io"]
        },
        public: {
          http: ["https://rpc.meversetestnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://testnet.meversescan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 64371115
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/modeTestnet.js
var require_modeTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/modeTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modeTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.modeTestnet = (0, defineChain_js_1.defineChain)({
      id: 919,
      name: "Mode Testnet",
      network: "mode-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia.mode.network"]
        },
        public: {
          http: ["https://sepolia.mode.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://sepolia.explorer.mode.network"
        }
      },
      contracts: {
        multicall3: {
          address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
          blockCreated: 3019007
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js
var require_moonbaseAlpha = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonbaseAlpha = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.moonbaseAlpha = (0, defineChain_js_1.defineChain)({
      id: 1287,
      name: "Moonbase Alpha",
      network: "moonbase-alpha",
      nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        },
        public: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1850686
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbeam.js
var require_moonbeam = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbeam.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonbeam = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.moonbeam = (0, defineChain_js_1.defineChain)({
      id: 1284,
      name: "Moonbeam",
      network: "moonbeam",
      nativeCurrency: {
        decimals: 18,
        name: "GLMR",
        symbol: "GLMR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        },
        default: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 609002
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbeamDev.js
var require_moonbeamDev = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonbeamDev.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonbeamDev = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.moonbeamDev = (0, defineChain_js_1.defineChain)({
      id: 1281,
      name: "Moonbeam Development Node",
      network: "development",
      nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
      },
      rpcUrls: {
        default: {
          http: ["http://127.0.0.1:9944"],
          webSocket: ["wss://127.0.0.1:9944"]
        },
        public: {
          http: ["http://127.0.0.1:9944"],
          webSocket: ["wss://127.0.0.1:9944"]
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonriver.js
var require_moonriver = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/moonriver.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonriver = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.moonriver = (0, defineChain_js_1.defineChain)({
      id: 1285,
      name: "Moonriver",
      network: "moonriver",
      nativeCurrency: {
        decimals: 18,
        name: "MOVR",
        symbol: "MOVR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        },
        default: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1597904
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/neonDevnet.js
var require_neonDevnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/neonDevnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.neonDevnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.neonDevnet = (0, defineChain_js_1.defineChain)({
      id: 245022926,
      network: "neonDevnet",
      name: "Neon EVM DevNet",
      nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://devnet.neonevm.org"]
        },
        public: {
          http: ["https://devnet.neonevm.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Neonscan",
          url: "https://devnet.neonscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 205206112
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/neonMainnet.js
var require_neonMainnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/neonMainnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.neonMainnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.neonMainnet = (0, defineChain_js_1.defineChain)({
      id: 245022934,
      network: "neonMainnet",
      name: "Neon EVM MainNet",
      nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://neon-proxy-mainnet.solana.p2p.org"]
        },
        public: {
          http: ["https://neon-proxy-mainnet.solana.p2p.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Neonscan",
          url: "https://neonscan.org"
        }
      },
      contracts: {},
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/nexi.js
var require_nexi = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/nexi.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nexi = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.nexi = (0, defineChain_js_1.defineChain)({
      id: 4242,
      name: "Nexi",
      network: "nexi",
      nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.chain.nexi.technology"]
        },
        public: {
          http: ["https://rpc.chain.nexi.technology"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        },
        default: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
          blockCreated: 25770160
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/nexilix.js
var require_nexilix = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/nexilix.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nexilix = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.nexilix = (0, defineChain_js_1.defineChain)({
      id: 240,
      name: "Nexilix Smart Chain",
      network: "nexilix",
      nativeCurrency: {
        decimals: 18,
        name: "Nexilix",
        symbol: "NEXILIX"
      },
      rpcUrls: {
        default: { http: ["https://rpcurl.pos.nexilix.com"] },
        public: { http: ["https://rpcurl.pos.nexilix.com"] }
      },
      blockExplorers: {
        etherscan: { name: "NexilixScan", url: "https://scan.nexilix.com" },
        default: { name: "NexilixScan", url: "https://scan.nexilix.com" }
      },
      contracts: {
        multicall3: {
          address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
          blockCreated: 74448
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/oasys.js
var require_oasys = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/oasys.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oasys = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.oasys = (0, defineChain_js_1.defineChain)({
      id: 248,
      name: "Oasys",
      network: "oasys",
      nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.oasys.games"]
        },
        public: {
          http: ["https://rpc.mainnet.oasys.games"]
        }
      },
      blockExplorers: {
        default: {
          name: "OasysScan",
          url: "https://scan.oasys.games"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/oasisTestnet.js
var require_oasisTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/oasisTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oasisTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.oasisTestnet = (0, defineChain_js_1.defineChain)({
      id: 4090,
      network: "oasis-testnet",
      name: "Oasis Testnet",
      nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc1.oasis.bahamutchain.com"] },
        public: { http: ["https://rpc1.oasis.bahamutchain.com"] }
      },
      blockExplorers: {
        default: {
          name: "Ftnscan",
          url: "https://oasis.ftnscan.com"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/okc.js
var require_okc = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/okc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.okc = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.okc = (0, defineChain_js_1.defineChain)({
      id: 66,
      name: "OKC",
      network: "okc",
      nativeCurrency: {
        decimals: 18,
        name: "OKT",
        symbol: "OKT"
      },
      rpcUrls: {
        default: { http: ["https://exchainrpc.okex.org"] },
        public: { http: ["https://exchainrpc.okex.org"] }
      },
      blockExplorers: {
        default: { name: "oklink", url: "https://www.oklink.com/okc" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 10364792
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimism.js
var require_optimism = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimism.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optimism = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.optimism = (0, defineChain_js_1.defineChain)({
      id: 10,
      name: "OP Mainnet",
      network: "optimism",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-mainnet.infura.io/v3"],
          webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://mainnet.optimism.io"]
        },
        public: {
          http: ["https://mainnet.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://optimistic.etherscan.io"
        },
        default: {
          name: "Optimism Explorer",
          url: "https://explorer.optimism.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 4286263
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimismGoerli.js
var require_optimismGoerli = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimismGoerli.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optimismGoerli = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.optimismGoerli = (0, defineChain_js_1.defineChain)({
      id: 420,
      name: "Optimism Goerli",
      network: "optimism-goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-goerli.infura.io/v3"],
          webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli.optimism.io"]
        },
        public: {
          http: ["https://goerli.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 49461
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimismSepolia.js
var require_optimismSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/optimismSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optimismSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.optimismSepolia = (0, defineChain_js_1.defineChain)({
      id: 11155420,
      name: "Optimism Sepolia",
      network: "optimism-sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://opt-sepolia.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://sepolia.optimism.io"]
        },
        public: {
          http: ["https://sepolia.optimism.io"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout",
          url: "https://optimism-sepolia.blockscout.com"
        },
        default: {
          name: "Blockscout",
          url: "https://optimism-sepolia.blockscout.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1620204
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/opBNB.js
var require_opBNB = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/opBNB.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opBNB = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.opBNB = (0, defineChain_js_1.defineChain)({
      id: 204,
      name: "opBNB",
      network: "opBNB Mainnet",
      nativeCurrency: {
        name: "BNB",
        symbol: "BNB",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] },
        default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
      },
      blockExplorers: {
        default: { name: "opbnbscan", url: "https://mainnet.opbnbscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 512881
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js
var require_opBNBTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opBNBTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.opBNBTestnet = (0, defineChain_js_1.defineChain)({
      id: 5611,
      name: "opBNB Testnet",
      network: "opBNB Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "tBNB",
        symbol: "tBNB"
      },
      rpcUrls: {
        public: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] },
        default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
      },
      blockExplorers: {
        default: { name: "opbnbscan", url: "https://testnet.opbnbscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3705108
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pgn.js
var require_pgn = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pgn.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pgn = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.pgn = (0, defineChain_js_1.defineChain)({
      id: 424,
      network: "pgn",
      name: "PGN",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.publicgoods.network"]
        },
        public: {
          http: ["https://rpc.publicgoods.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "PGN Explorer",
          url: "https://explorer.publicgoods.network"
        },
        blocksout: {
          name: "PGN Explorer",
          url: "https://explorer.publicgoods.network"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3380209
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pgnTestnet.js
var require_pgnTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pgnTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pgnTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.pgnTestnet = (0, defineChain_js_1.defineChain)({
      id: 58008,
      network: "pgn-testnet",
      name: "PGN ",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia.publicgoods.network"]
        },
        public: {
          http: ["https://sepolia.publicgoods.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "PGN Testnet Explorer",
          url: "https://explorer.sepolia.publicgoods.network"
        },
        blocksout: {
          name: "PGN Testnet Explorer",
          url: "https://explorer.sepolia.publicgoods.network"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3754925
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/plinga.js
var require_plinga = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/plinga.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.plinga = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.plinga = (0, defineChain_js_1.defineChain)({
      id: 242,
      name: "Plinga",
      network: "plinga",
      nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpcurl.mainnet.plgchain.com"]
        },
        public: {
          http: ["https://rpcurl.mainnet.plgchain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "Plgscan",
          url: "https://www.plgscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0x0989576160f2e7092908BB9479631b901060b6e4",
          blockCreated: 204489
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygon.js
var require_polygon = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygon.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygon = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.polygon = (0, defineChain_js_1.defineChain)({
      id: 137,
      name: "Polygon",
      network: "matic",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mainnet.infura.io/v3"],
          webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://polygon-rpc.com"]
        },
        public: {
          http: ["https://polygon-rpc.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonMumbai.js
var require_polygonMumbai = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonMumbai.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonMumbai = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.polygonMumbai = (0, defineChain_js_1.defineChain)({
      id: 80001,
      name: "Polygon Mumbai",
      network: "maticmum",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mumbai.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mumbai.infura.io/v3"],
          webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.ankr.com/polygon_mumbai"]
        },
        public: {
          http: ["https://rpc.ankr.com/polygon_mumbai"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js
var require_polygonZkEvmTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonZkEvmTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.polygonZkEvmTestnet = (0, defineChain_js_1.defineChain)({
      id: 1442,
      name: "Polygon zkEVM Testnet",
      network: "polygon-zkevm-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.public.zkevm-test.net"]
        },
        public: {
          http: ["https://rpc.public.zkevm-test.net"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.public.zkevm-test.net"
        },
        default: {
          name: "PolygonScan",
          url: "https://testnet-zkevm.polygonscan.com"
        }
      },
      testnet: true,
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 525686
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js
var require_polygonZkEvm = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonZkEvm = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.polygonZkEvm = (0, defineChain_js_1.defineChain)({
      id: 1101,
      name: "Polygon zkEVM",
      network: "polygon-zkevm",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://zkevm-rpc.com"]
        },
        public: {
          http: ["https://zkevm-rpc.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PolygonScan",
          url: "https://zkevm.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 57746
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pulsechain.js
var require_pulsechain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pulsechain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pulsechain = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.pulsechain = (0, defineChain_js_1.defineChain)({
      id: 369,
      network: "pulsechain",
      name: "PulseChain",
      nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
      testnet: false,
      rpcUrls: {
        default: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pulsechainV4.js
var require_pulsechainV4 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/pulsechainV4.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pulsechainV4 = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.pulsechainV4 = (0, defineChain_js_1.defineChain)({
      id: 943,
      network: "pulsechainV4",
      name: "PulseChain V4",
      testnet: true,
      nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.v4.testnet.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/qMainnet.js
var require_qMainnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/qMainnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.qMainnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.qMainnet = (0, defineChain_js_1.defineChain)({
      id: 35441,
      name: "Q Mainnet",
      network: "q-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "Q",
        symbol: "Q"
      },
      rpcUrls: {
        default: { http: ["https://rpc.q.org"] },
        public: { http: ["https://rpc.q.org"] }
      },
      blockExplorers: {
        default: {
          name: "Q Mainnet Explorer",
          url: "https://explorer.q.org"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/qTestnet.js
var require_qTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/qTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.qTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.qTestnet = (0, defineChain_js_1.defineChain)({
      id: 35443,
      name: "Q Testnet",
      network: "q-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Q",
        symbol: "Q"
      },
      rpcUrls: {
        default: { http: ["https://rpc.qtestnet.org"] },
        public: { http: ["https://rpc.qtestnet.org"] }
      },
      blockExplorers: {
        default: {
          name: "Q Testnet Explorer",
          url: "https://explorer.qtestnet.org"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rollux.js
var require_rollux = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rollux.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rollux = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.rollux = (0, defineChain_js_1.defineChain)({
      id: 570,
      name: "Rollux Mainnet",
      network: "rollux",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.rollux.com"],
          webSocket: ["wss://rpc.rollux.com/wss"]
        },
        public: { http: ["https://rollux.public-rpc.com"] }
      },
      blockExplorers: {
        default: { name: "RolluxExplorer", url: "https://explorer.rollux.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 119222
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js
var require_rolluxTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rolluxTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.rolluxTestnet = (0, defineChain_js_1.defineChain)({
      id: 57e3,
      name: "Rollux Testnet",
      network: "rollux-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc-tanenbaum.rollux.com/"],
          webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
        },
        public: { http: ["https://rpc-tanenbaum.rollux.com/"] }
      },
      blockExplorers: {
        default: {
          name: "RolluxTestnetExplorer",
          url: "https://rollux.tanenbaum.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1813675
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ronin.js
var require_ronin = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/ronin.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ronin = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.ronin = (0, defineChain_js_1.defineChain)({
      id: 2020,
      name: "Ronin",
      network: "ronin",
      nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.roninchain.com/rpc"]
        },
        public: {
          http: ["https://api.roninchain.com/rpc"]
        }
      },
      blockExplorers: {
        default: { name: "Ronin Explorer", url: "https://app.roninchain.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 26023535
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rootstock.js
var require_rootstock = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/rootstock.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rootstock = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.rootstock = (0, defineChain_js_1.defineChain)({
      id: 30,
      name: "Rootstock Mainnet",
      network: "rootstock",
      nativeCurrency: {
        decimals: 18,
        name: "Rootstock Bitcoin",
        symbol: "RBTC"
      },
      rpcUrls: {
        public: { http: ["https://public-node.rsk.co"] },
        default: { http: ["https://public-node.rsk.co"] }
      },
      blockExplorers: {
        blockscout: { name: "Blockscout", url: "https://rootstock.blockscout.com" },
        default: { name: "RSK Explorer", url: "https://explorer.rsk.co" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 4249540
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/saigon.js
var require_saigon = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/saigon.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saigon = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.saigon = (0, defineChain_js_1.defineChain)({
      id: 2021,
      name: "Saigon Testnet",
      network: "saigon",
      nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://saigon-testnet.roninchain.com/rpc"]
        },
        public: {
          http: ["https://saigon-testnet.roninchain.com/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Saigon Explorer",
          url: "https://saigon-explorer.roninchain.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 18736871
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sapphire.js
var require_sapphire = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sapphire.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sapphire = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.sapphire = (0, defineChain_js_1.defineChain)({
      id: 23294,
      name: "Oasis Sapphire",
      network: "sapphire",
      nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sapphire.oasis.io"],
          webSocket: ["wss://sapphire.oasis.io/ws"]
        },
        public: {
          http: ["https://sapphire.oasis.io"],
          webSocket: ["wss://sapphire.oasis.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Oasis Sapphire Explorer",
          url: "https://explorer.sapphire.oasis.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 734531
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js
var require_sapphireTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sapphireTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sapphireTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.sapphireTestnet = (0, defineChain_js_1.defineChain)({
      id: 23295,
      name: "Oasis Sapphire Testnet",
      network: "sapphire-testnet",
      nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://testnet.sapphire.oasis.dev"],
          webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
        },
        public: {
          http: ["https://testnet.sapphire.oasis.dev"],
          webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Oasis Sapphire Testnet Explorer",
          url: "https://testnet.explorer.sapphire.oasis.dev"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scroll.js
var require_scroll = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scroll.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scroll = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.scroll = (0, defineChain_js_1.defineChain)({
      id: 534352,
      name: "Scroll",
      network: "scroll",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.scroll.io"],
          webSocket: ["wss://wss-rpc.scroll.io/ws"]
        },
        public: {
          http: ["https://rpc.scroll.io"],
          webSocket: ["wss://wss-rpc.scroll.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Scrollscan",
          url: "https://scrollscan.com"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://blockscout.scroll.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scrollSepolia.js
var require_scrollSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scrollSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scrollSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.scrollSepolia = (0, defineChain_js_1.defineChain)({
      id: 534351,
      name: "Scroll Sepolia",
      network: "scroll-sepolia",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia-rpc.scroll.io"]
        },
        public: {
          http: ["https://sepolia-rpc.scroll.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://sepolia-blockscout.scroll.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 9473
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scrollTestnet.js
var require_scrollTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/scrollTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scrollTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.scrollTestnet = (0, defineChain_js_1.defineChain)({
      id: 534353,
      name: "Scroll Testnet",
      network: "scroll-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        },
        public: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.scroll.io"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sepolia.js
var require_sepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/sepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.sepolia = (0, defineChain_js_1.defineChain)({
      id: 11155111,
      network: "sepolia",
      name: "Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://sepolia.infura.io/v3"],
          webSocket: ["wss://sepolia.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.sepolia.org"]
        },
        public: {
          http: ["https://rpc.sepolia.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 751532
        },
        ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
        ensUniversalResolver: {
          address: "0x21B000Fd62a880b2125A61e36a284BB757b76025",
          blockCreated: 3914906
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shimmer.js
var require_shimmer = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shimmer.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shimmer = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.shimmer = (0, defineChain_js_1.defineChain)({
      id: 148,
      name: "Shimmer",
      network: "shimmer",
      nativeCurrency: {
        decimals: 18,
        name: "Shimmer",
        symbol: "SMR"
      },
      rpcUrls: {
        public: {
          http: ["https://json-rpc.evm.shimmer.network"]
        },
        default: {
          http: ["https://json-rpc.evm.shimmer.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Shimmer Network Explorer",
          url: "https://explorer.evm.shimmer.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js
var require_shimmerTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shimmerTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shimmerTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.shimmerTestnet = (0, defineChain_js_1.defineChain)({
      id: 1073,
      name: "Shimmer Testnet",
      network: "shimmer-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Shimmer",
        symbol: "SMR"
      },
      rpcUrls: {
        public: {
          http: ["https://json-rpc.evm.testnet.shimmer.network"]
        },
        default: {
          http: ["https://json-rpc.evm.testnet.shimmer.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Shimmer Network Explorer",
          url: "https://explorer.evm.testnet.shimmer.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/brawl.js
var require_brawl = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/brawl.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleBlockBrawlers = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleBlockBrawlers = (0, defineChain_js_1.defineChain)({
      id: 391845894,
      name: "SKALE | Block Brawlers",
      network: "skale-brawl",
      nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/calypso.js
var require_calypso = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/calypso.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCalypso = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleCalypso = (0, defineChain_js_1.defineChain)({
      id: 1564830818,
      name: "SKALE | Calypso NFT Hub",
      network: "skale-calypso",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
          ]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3107626
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js
var require_calypsoTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCalypsoTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleCalypsoTestnet = (0, defineChain_js_1.defineChain)({
      id: 344106930,
      name: "SKALE | Calypso NFT Hub Testnet",
      network: "skale-calypso-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2131424
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js
var require_chaosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleChaosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleChaosTestnet = (0, defineChain_js_1.defineChain)({
      id: 1351057110,
      name: "SKALE | Chaos Testnet",
      network: "skale-chaos-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1192202
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js
var require_cryptoBlades = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCryptoBlades = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleCryptoBlades = (0, defineChain_js_1.defineChain)({
      id: 1026062157,
      name: "SKALE | CryptoBlades",
      network: "skale-cryptoblades",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
          ]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js
var require_cryptoColosseum = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCryptoColosseum = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleCryptoColosseum = (0, defineChain_js_1.defineChain)({
      id: 2046399126,
      name: "SKALE | Crypto Colosseum",
      network: "skale-crypto-coloseeum",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/europa.js
var require_europa = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/europa.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleEuropa = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleEuropa = (0, defineChain_js_1.defineChain)({
      id: 2046399126,
      name: "SKALE | Europa Liquidity Hub",
      network: "skale-europa",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3113495
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js
var require_europaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleEuropaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleEuropaTestnet = (0, defineChain_js_1.defineChain)({
      id: 476158412,
      name: "SKALE | Europa Liquidity Hub Testnet",
      network: "skale-europa-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor"
          ]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2071911
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/exorde.js
var require_exorde = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/exorde.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleExorde = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleExorde = (0, defineChain_js_1.defineChain)({
      id: 2139927552,
      name: "SKALE | Exorde",
      network: "skale-exorde",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js
var require_humanProtocol = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleHumanProtocol = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleHumanProtocol = (0, defineChain_js_1.defineChain)({
      id: 1273227453,
      name: "SKALE | Human Protocol",
      network: "skale-human-protocol",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/nebula.js
var require_nebula = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/nebula.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleNebula = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleNebula = (0, defineChain_js_1.defineChain)({
      id: 1482601649,
      name: "SKALE | Nebula Gaming Hub",
      network: "skale-nebula",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2372986
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js
var require_nebulaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleNebulaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleNebulaTestnet = (0, defineChain_js_1.defineChain)({
      id: 503129905,
      name: "SKALE | Nebula Gaming Hub Testnet",
      network: "skale-nebula-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird"
          ]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2205882
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/razor.js
var require_razor = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/razor.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleRazor = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleRazor = (0, defineChain_js_1.defineChain)({
      id: 278611351,
      name: "SKALE | Razor Network",
      network: "skale-razor",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/titan.js
var require_titan = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/titan.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleTitan = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleTitan = (0, defineChain_js_1.defineChain)({
      id: 1350216234,
      name: "SKALE | Titan Community Hub",
      network: "skale-titan",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2076458
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js
var require_titanTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleTitanTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.skaleTitanTestnet = (0, defineChain_js_1.defineChain)({
      id: 1517929550,
      name: "SKALE | Titan Community Hub Testnet",
      network: "skale-titan-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2085155
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/songbird.js
var require_songbird = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/songbird.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.songbird = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.songbird = (0, defineChain_js_1.defineChain)({
      id: 19,
      name: "Songbird Mainnet",
      network: "songbird-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "songbird",
        symbol: "SGB"
      },
      rpcUrls: {
        default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Songbird Explorer",
          url: "https://songbird-explorer.flare.network"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js
var require_songbirdTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.songbirdTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.songbirdTestnet = (0, defineChain_js_1.defineChain)({
      id: 16,
      name: "Coston",
      network: "coston",
      nativeCurrency: {
        decimals: 18,
        name: "costonflare",
        symbol: "CFLR"
      },
      rpcUrls: {
        default: { http: ["https://coston-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston Explorer",
          url: "https://coston-explorer.flare.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/spicy.js
var require_spicy = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/spicy.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spicy = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.spicy = (0, defineChain_js_1.defineChain)({
      id: 88882,
      name: "Chiliz Spicy Testnet",
      network: "chiliz-spicy-Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "CHZ",
        symbol: "CHZ"
      },
      rpcUrls: {
        default: {
          http: [
            "https://spicy-rpc.chiliz.com",
            "https://chiliz-spicy.publicnode.com"
          ],
          webSocket: [
            "wss://spicy-rpc-ws.chiliz.com",
            "wss://chiliz-spicy.publicnode.com"
          ]
        },
        public: {
          http: [
            "https://spicy-rpc.chiliz.com",
            "https://chiliz-spicy.publicnode.com"
          ],
          webSocket: [
            "wss://spicy-rpc-ws.chiliz.com",
            "wss://chiliz-spicy.publicnode.com"
          ]
        }
      },
      blockExplorers: {
        default: {
          name: "Chiliz Explorer",
          url: "http://spicy-explorer.chiliz.com"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js
var require_shardeumSphinx = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shardeumSphinx = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.shardeumSphinx = (0, defineChain_js_1.defineChain)({
      id: 8082,
      name: "Shardeum Sphinx",
      network: "shmSphinx",
      nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sphinx.shardeum.org"]
        },
        public: {
          http: ["https://sphinx.shardeum.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Shardeum Explorer",
          url: "https://explorer-sphinx.shardeum.org"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shibarium.js
var require_shibarium = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/shibarium.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shibarium = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.shibarium = (0, defineChain_js_1.defineChain)({
      id: 109,
      name: "Shibarium",
      network: "shibarium",
      nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.shibrpc.com"]
        },
        public: {
          http: ["https://rpc.shibrpc.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Blockscout",
          url: "https://shibariumscan.io"
        },
        default: {
          name: "Blockscout",
          url: "https://shibariumscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
          blockCreated: 265900
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/syscoin.js
var require_syscoin = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/syscoin.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syscoin = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.syscoin = (0, defineChain_js_1.defineChain)({
      id: 57,
      name: "Syscoin Mainnet",
      network: "syscoin",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.syscoin.org"],
          webSocket: ["wss://rpc.syscoin.org/wss"]
        },
        public: {
          http: ["https://rpc.syscoin.org"],
          webSocket: ["wss://rpc.syscoin.org/wss"]
        }
      },
      blockExplorers: {
        default: { name: "SyscoinExplorer", url: "https://explorer.syscoin.org" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 287139
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js
var require_syscoinTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syscoinTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.syscoinTestnet = (0, defineChain_js_1.defineChain)({
      id: 5700,
      name: "Syscoin Tanenbaum Testnet",
      network: "syscoin-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.tanenbaum.io"],
          webSocket: ["wss://rpc.tanenbaum.io/wss"]
        },
        public: {
          http: ["https://rpc.tanenbaum.io"],
          webSocket: ["wss://rpc.tanenbaum.io/wss"]
        }
      },
      blockExplorers: {
        default: { name: "SyscoinTestnetExplorer", url: "https://tanenbaum.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 271288
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taraxa.js
var require_taraxa = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taraxa.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taraxa = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.taraxa = (0, defineChain_js_1.defineChain)({
      id: 841,
      name: "Taraxa Mainnet",
      network: "taraxa",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.mainnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.mainnet.taraxa.io"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taikoJolnir.js
var require_taikoJolnir = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taikoJolnir.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taikoJolnir = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.taikoJolnir = (0, defineChain_js_1.defineChain)({
      id: 167007,
      name: "Taiko Jolnir (Alpha-5 Testnet)",
      network: "tko-jolnir",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.jolnir.taiko.xyz"]
        },
        public: {
          http: ["https://rpc.jolnir.taiko.xyz"]
        }
      },
      blockExplorers: {
        default: {
          name: "blockscout",
          url: "https://explorer.jolnir.taiko.xyz"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js
var require_taikoTestnetSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taikoTestnetSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.taikoTestnetSepolia = (0, defineChain_js_1.defineChain)({
      id: 167005,
      name: "Taiko (Alpha-3 Testnet)",
      network: "taiko-sepolia",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.test.taiko.xyz"]
        },
        public: {
          http: ["https://rpc.test.taiko.xyz"]
        }
      },
      blockExplorers: {
        default: {
          name: "blockscout",
          url: "https://explorer.test.taiko.xyz"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js
var require_taraxaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taraxaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.taraxaTestnet = (0, defineChain_js_1.defineChain)({
      id: 842,
      name: "Taraxa Testnet",
      network: "taraxa-testnet",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.testnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.testnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.testnet.taraxa.io"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/telos.js
var require_telos = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/telos.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.telos = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.telos = (0, defineChain_js_1.defineChain)({
      id: 40,
      name: "Telos",
      network: "telos",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.telos.net/evm"] },
        public: { http: ["https://mainnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan",
          url: "https://www.teloscan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 246530709
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/telosTestnet.js
var require_telosTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/telosTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.telosTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.telosTestnet = (0, defineChain_js_1.defineChain)({
      id: 41,
      name: "Telos",
      network: "telosTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://testnet.telos.net/evm"] },
        public: { http: ["https://testnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan (testnet)",
          url: "https://testnet.teloscan.io/"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/tenet.js
var require_tenet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/tenet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tenet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.tenet = (0, defineChain_js_1.defineChain)({
      id: 1559,
      name: "Tenet",
      network: "tenet-mainnet",
      nativeCurrency: {
        name: "TENET",
        symbol: "TENET",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://rpc.tenet.org"] },
        default: { http: ["https://rpc.tenet.org"] }
      },
      blockExplorers: {
        default: { name: "TenetScan Mainnet", url: "https://tenetscan.io" }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/thunderTestnet.js
var require_thunderTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/thunderTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thunderTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.thunderTestnet = (0, defineChain_js_1.defineChain)({
      id: 997,
      name: "5ireChain Thunder Testnet",
      network: "5ireChain",
      nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc-testnet.5ire.network"]
        },
        public: {
          http: ["https://rpc-testnet.5ire.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "5ireChain Explorer",
          url: "https://explorer.5ire.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/vechain.js
var require_vechain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/vechain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vechain = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.vechain = (0, defineChain_js_1.defineChain)({
      id: 100009,
      name: "Vechain",
      network: "vechain",
      nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.vechain.org"]
        },
        public: {
          http: ["https://mainnet.vechain.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Vechain Explorer",
          url: "https://explore.vechain.org"
        },
        vechainStats: {
          name: "Vechain Stats",
          url: "https://vechainstats.com"
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wanchain.js
var require_wanchain = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wanchain.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wanchain = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.wanchain = (0, defineChain_js_1.defineChain)({
      id: 888,
      name: "Wanchain",
      network: "wanchain",
      nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        },
        public: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScan",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScan",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
          blockCreated: 25312390
        }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js
var require_wanchainTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wanchainTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.wanchainTestnet = (0, defineChain_js_1.defineChain)({
      id: 999,
      name: "Wanchain Testnet",
      network: "wanchainTestnet",
      nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        },
        public: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
          blockCreated: 24743448
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wemix.js
var require_wemix = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wemix.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wemix = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.wemix = (0, defineChain_js_1.defineChain)({
      id: 1111,
      name: "WEMIX",
      network: "wemix-mainnet",
      nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://api.wemix.com"] },
        public: { http: ["https://api.wemix.com"] }
      },
      blockExplorers: {
        etherscan: { name: "wemixExplorer", url: "https://explorer.wemix.com" },
        default: { name: "wemixExplorer", url: "https://explorer.wemix.com" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wemixTestnet.js
var require_wemixTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/wemixTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wemixTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.wemixTestnet = (0, defineChain_js_1.defineChain)({
      id: 1112,
      name: "WEMIX Testnet",
      network: "wemix-testnet",
      nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://api.test.wemix.com"] },
        public: { http: ["https://api.test.wemix.com"] }
      },
      blockExplorers: {
        etherscan: { name: "wemixExplorer", url: "https://testnet.wemixscan.com" },
        default: { name: "wemixExplorer", url: "https://testnet.wemixscan.com" }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/xdc.js
var require_xdc = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/xdc.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xdc = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.xdc = (0, defineChain_js_1.defineChain)({
      id: 50,
      name: "XinFin Network",
      network: "xdc",
      nativeCurrency: {
        decimals: 18,
        name: "XDC",
        symbol: "XDC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.xinfin.network"] },
        public: { http: ["https://rpc.xinfin.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.xinfin.network" },
        default: { name: "Blocksscan", url: "https://xdc.blocksscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/xdcTestnet.js
var require_xdcTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/xdcTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xdcTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.xdcTestnet = (0, defineChain_js_1.defineChain)({
      id: 51,
      name: "Apothem Network",
      network: "xdc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "TXDC",
        symbol: "TXDC"
      },
      rpcUrls: {
        default: { http: ["https://erpc.apothem.network"] },
        public: { http: ["https://erpc.apothem.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.apothem.network" },
        default: { name: "Blocksscan", url: "https://apothem.blocksscan.io" }
      }
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zhejiang.js
var require_zhejiang = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zhejiang.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhejiang = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zhejiang = (0, defineChain_js_1.defineChain)({
      id: 1337803,
      network: "zhejiang",
      name: "Zhejiang",
      nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        },
        public: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        }
      },
      blockExplorers: {
        beaconchain: {
          name: "Etherscan",
          url: "https://zhejiang.beaconcha.in"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://blockscout.com/eth/zhejiang-testnet"
        },
        default: {
          name: "Beaconchain",
          url: "https://zhejiang.beaconcha.in"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkFair.js
var require_zkFair = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkFair.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkFair = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zkFair = (0, defineChain_js_1.defineChain)({
      id: 42766,
      name: "ZKFair Mainnet",
      network: "zkfair-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "USD Coin",
        symbol: "USDC"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.zkfair.io"]
        },
        public: {
          http: ["https://rpc.zkfair.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkFair Explorer",
          url: "https://scan.zkfair.io"
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js
var require_zkFairTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkFairTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkFairTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zkFairTestnet = (0, defineChain_js_1.defineChain)({
      id: 43851,
      name: "ZKFair Testnet",
      network: "zkfair-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "USD Coin",
        symbol: "USDC"
      },
      rpcUrls: {
        default: {
          http: ["https://testnet-rpc.zkfair.io"]
        },
        public: {
          http: ["https://testnet-rpc.zkfair.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkFair Explorer",
          url: "https://testnet-scan.zkfair.io"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/zksync/formatters.js
var require_formatters3 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/zksync/formatters.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formattersZkSync = void 0;
    var fromHex_js_1 = require_fromHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var block_js_1 = require_block();
    var log_js_1 = require_log();
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    var transactionRequest_js_1 = require_transactionRequest();
    exports.formattersZkSync = {
      block: (0, block_js_1.defineBlock)({
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            const formatted = exports.formattersZkSync.transaction.format(transaction);
            if (formatted.typeHex === "0x71")
              formatted.type = "eip712";
            else if (formatted.typeHex === "0xff")
              formatted.type = "priority";
            return formatted;
          });
          return {
            l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
            l1BatchTimestamp: args.l1BatchTimestamp ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTimestamp) : null,
            transactions
          };
        }
      }),
      transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
          const transaction = {};
          if (args.type === "0x71")
            transaction.type = "eip712";
          else if (args.type === "0xff")
            transaction.type = "priority";
          return {
            ...transaction,
            l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
            l1BatchTxIndex: args.l1BatchTxIndex ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex) : null
          };
        }
      }),
      transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
          return {
            l1BatchNumber: args.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchNumber) : null,
            l1BatchTxIndex: args.l1BatchTxIndex ? (0, fromHex_js_1.hexToBigInt)(args.l1BatchTxIndex) : null,
            logs: args.logs.map((log) => {
              return {
                ...(0, log_js_1.formatLog)(log),
                l1BatchNumber: log.l1BatchNumber ? (0, fromHex_js_1.hexToBigInt)(log.l1BatchNumber) : null,
                transactionLogIndex: (0, fromHex_js_1.hexToNumber)(log.transactionLogIndex),
                logType: log.logType
              };
            }),
            l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
              return {
                blockNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.blockHash),
                blockHash: l2ToL1Log.blockHash,
                l1BatchNumber: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.l1BatchNumber),
                transactionIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.transactionIndex),
                shardId: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.shardId),
                isService: l2ToL1Log.isService,
                sender: l2ToL1Log.sender,
                key: l2ToL1Log.key,
                value: l2ToL1Log.value,
                transactionHash: l2ToL1Log.transactionHash,
                logIndex: (0, fromHex_js_1.hexToBigInt)(l2ToL1Log.logIndex)
              };
            })
          };
        }
      }),
      transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
        exclude: [
          "customSignature",
          "factoryDeps",
          "gasPerPubdata",
          "paymaster",
          "paymasterInput"
        ],
        format(args) {
          if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
            return {
              eip712Meta: {
                ...args.gasPerPubdata ? { gasPerPubdata: (0, toHex_js_1.toHex)(args.gasPerPubdata) } : {},
                ...args.paymaster && args.paymasterInput ? {
                  paymasterParams: {
                    paymaster: args.paymaster,
                    paymasterInput: Array.from((0, toBytes_js_1.hexToBytes)(args.paymasterInput))
                  }
                } : {},
                ...args.factoryDeps ? { factoryDeps: args.factoryDeps } : {},
                ...args.customSignature ? { customSignature: args.customSignature } : {}
              },
              type: args.type === "eip712" ? "0x71" : "0xff"
            };
          return {};
        }
      })
    };
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/zksync/serializers.js
var require_serializers2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/zksync/serializers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionEIP712 = exports.serializersZkSync = exports.serializeTransactionZkSync = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var serializeTransaction_js_1 = require_serializeTransaction();
    var serializeTransactionZkSync = (tx, signature) => {
      if (isEIP712(tx))
        return serializeTransactionZkSyncEIP712(tx);
      return (0, serializeTransaction_js_1.serializeTransaction)(tx, signature);
    };
    exports.serializeTransactionZkSync = serializeTransactionZkSync;
    exports.serializersZkSync = {
      transaction: exports.serializeTransactionZkSync
    };
    function serializeTransactionZkSyncEIP712(transaction) {
      const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
      assertTransactionEIP712(transaction);
      const serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        (0, toHex_js_1.toHex)(chainId),
        (0, toHex_js_1.toHex)(""),
        (0, toHex_js_1.toHex)(""),
        (0, toHex_js_1.toHex)(chainId),
        from ?? "0x",
        gasPerPubdata ? (0, toHex_js_1.toHex)(gasPerPubdata) : "0x",
        factoryDeps ?? [],
        customSignature ?? "0x",
        paymaster && paymasterInput ? [paymaster, paymasterInput] : []
      ];
      return (0, concat_js_1.concatHex)([
        "0x71",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function isEIP712(transaction) {
      if ("customSignature" in transaction || "paymaster" in transaction || "paymasterInput" in transaction || "gasPerPubdata" in transaction || "factoryDeps" in transaction)
        return true;
      return false;
    }
    function assertTransactionEIP712(transaction) {
      const { chainId, to, from, paymaster, paymasterInput } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (from && !(0, isAddress_js_1.isAddress)(from))
        throw new address_js_1.InvalidAddressError({ address: from });
      if (paymaster && !(0, isAddress_js_1.isAddress)(paymaster))
        throw new address_js_1.InvalidAddressError({ address: paymaster });
      if (paymaster && !paymasterInput) {
        throw new base_js_1.BaseError("`paymasterInput` must be provided when `paymaster` is defined");
      }
      if (!paymaster && paymasterInput) {
        throw new base_js_1.BaseError("`paymaster` must be provided when `paymasterInput` is defined");
      }
    }
    exports.assertTransactionEIP712 = assertTransactionEIP712;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSync.js
var require_zkSync = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSync.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkSync = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters3();
    var serializers_js_1 = require_serializers2();
    exports.zkSync = (0, defineChain_js_1.defineChain)({
      id: 324,
      name: "zkSync Era",
      network: "zksync-era",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        },
        public: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      }
    }, {
      serializers: serializers_js_1.serializersZkSync,
      formatters: formatters_js_1.formattersZkSync
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js
var require_zkSyncTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkSyncTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters3();
    var serializers_js_1 = require_serializers2();
    exports.zkSyncTestnet = (0, defineChain_js_1.defineChain)({
      id: 280,
      name: "zkSync Era Testnet",
      network: "zksync-era-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        },
        public: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://goerli.explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      },
      testnet: true
    }, {
      serializers: serializers_js_1.serializersZkSync,
      formatters: formatters_js_1.formattersZkSync
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js
var require_zkSyncSepoliaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zkSyncSepoliaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkSyncSepoliaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters3();
    var serializers_js_1 = require_serializers2();
    exports.zkSyncSepoliaTestnet = (0, defineChain_js_1.defineChain)({
      id: 300,
      name: "zkSync Sepolia Testnet",
      network: "zksync-sepolia-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia.era.zksync.dev"],
          webSocket: ["wss://sepolia.era.zksync.dev/ws"]
        },
        public: {
          http: ["https://sepolia.era.zksync.dev"],
          webSocket: ["wss://sepolia.era.zksync.dev/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://sepolia.explorer.zksync.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      },
      testnet: true
    }, {
      serializers: serializers_js_1.serializersZkSync,
      formatters: formatters_js_1.formattersZkSync
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js
var require_zetachainAthensTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zetachainAthensTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zetachainAthensTestnet = (0, defineChain_js_1.defineChain)({
      id: 7001,
      name: "ZetaChain Athens Testnet",
      network: "zetachain-athens-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Zeta",
        symbol: "aZETA"
      },
      rpcUrls: {
        public: {
          http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
        },
        default: {
          http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
        }
      },
      blockExplorers: {
        default: {
          name: "ZetaScan",
          url: "https://athens3.explorer.zetachain.com"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zilliqa.js
var require_zilliqa = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zilliqa.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zilliqa = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zilliqa = (0, defineChain_js_1.defineChain)({
      id: 32769,
      name: "Zilliqa",
      network: "zilliqa",
      nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.zilliqa.com"]
        },
        public: {
          http: ["https://api.zilliqa.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "Ethernal",
          url: "https://evmx.zilliqa.com"
        }
      },
      testnet: false
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js
var require_zilliqaTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zilliqaTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zilliqaTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    exports.zilliqaTestnet = (0, defineChain_js_1.defineChain)({
      id: 33101,
      name: "Zilliqa Testnet",
      network: "zilliqa-testnet",
      nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://dev-api.zilliqa.com"]
        },
        public: {
          http: ["https://dev-api.zilliqa.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "Ethernal",
          url: "https://evmx.testnet.zilliqa.com"
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zora.js
var require_zora = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zora.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zora = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.zora = (0, defineChain_js_1.defineChain)({
      id: 7777777,
      name: "Zora",
      network: "zora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        },
        public: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: { name: "Explorer", url: "https://explorer.zora.energy" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 5882
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zoraSepolia.js
var require_zoraSepolia = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zoraSepolia.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zoraSepolia = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.zoraSepolia = (0, defineChain_js_1.defineChain)({
      id: 999999999,
      name: "Zora Sepolia",
      network: "zora-sepolia",
      nativeCurrency: {
        decimals: 18,
        name: "Zora Sepolia",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://sepolia.rpc.zora.energy"],
          webSocket: ["wss://sepolia.rpc.zora.energy"]
        },
        public: {
          http: ["https://sepolia.rpc.zora.energy"],
          webSocket: ["wss://sepolia.rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: {
          name: "Zora Sepolia Explorer",
          url: "https://sepolia.explorer.zora.energy/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 83160
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zoraTestnet.js
var require_zoraTestnet = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/definitions/zoraTestnet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zoraTestnet = void 0;
    var defineChain_js_1 = require_defineChain();
    var formatters_js_1 = require_formatters();
    exports.zoraTestnet = (0, defineChain_js_1.defineChain)({
      id: 999,
      name: "Zora Goerli Testnet",
      network: "zora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Zora Goerli",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        },
        public: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://testnet.explorer.zora.energy"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 189123
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/index.js
var require_chains = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/viem/_cjs/chains/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantomSonicTestnet = exports.fantom = exports.ektaTestnet = exports.ekta = exports.evmosTestnet = exports.evmos = exports.eosTestnet = exports.eos = exports.edgewareTestnet = exports.edgeware = exports.dogechain = exports.dfk = exports.crossbell = exports.cronosTestnet = exports.cronos = exports.coreDao = exports.confluxESpaceTestnet = exports.confluxESpace = exports.classic = exports.celoCannoli = exports.chiliz = exports.celoAlfajores = exports.celo = exports.canto = exports.bxnTestnet = exports.bxn = exports.bscTestnet = exports.bsc = exports.bronosTestnet = exports.bronos = exports.boba = exports.bitTorrentTestnet = exports.bitTorrent = exports.bearNetworkChainTestnet = exports.bearNetworkChainMainnet = exports.baseSepolia = exports.baseGoerli = exports.base = exports.bahamut = exports.avalancheFuji = exports.avalanche = exports.auroraTestnet = exports.aurora = exports.astarZkatana = exports.arbitrumSepolia = exports.astar = exports.arbitrumNova = exports.arbitrumGoerli = exports.arbitrum = exports.acala = void 0;
    exports.moonriver = exports.moonbeamDev = exports.moonbeam = exports.moonbaseAlpha = exports.modeTestnet = exports.mevTestnet = exports.mev = exports.metisGoerli = exports.metis = exports.meterTestnet = exports.meter = exports.mantleTestnet = exports.mantle = exports.mantaTestnet = exports.manta = exports.mandala = exports.mainnet = exports.lukso = exports.localhost = exports.lineaTestnet = exports.linea = exports.kromaSepolia = exports.kroma = exports.klaytnBaobab = exports.klaytn = exports.kavaTestnet = exports.kava = exports.holesky = exports.haqqTestedge2 = exports.haqqMainnet = exports.harmonyOne = exports.hardhat = exports.gnosisChiado = exports.gnosis = exports.goerli = exports.gobi = exports.karura = exports.jbc = exports.iotexTestnet = exports.iotex = exports.fuseSparknet = exports.fuse = exports.foundry = exports.flareTestnet = exports.flare = exports.filecoinHyperspace = exports.filecoinCalibration = exports.filecoin = exports.fibo = exports.fantomTestnet = void 0;
    exports.skaleTitan = exports.skaleRazor = exports.skaleNebulaTestnet = exports.skaleNebula = exports.skaleHumanProtocol = exports.skaleExorde = exports.skaleEuropaTestnet = exports.skaleEuropa = exports.skaleCryptoColosseum = exports.skaleCryptoBlades = exports.skaleChaosTestnet = exports.skaleCalypsoTestnet = exports.skaleCalypso = exports.skaleBlockBrawlers = exports.shimmerTestnet = exports.shimmer = exports.sepolia = exports.scrollTestnet = exports.scrollSepolia = exports.scroll = exports.sapphireTestnet = exports.sapphire = exports.saigon = exports.rootstock = exports.ronin = exports.rolluxTestnet = exports.rollux = exports.qTestnet = exports.qMainnet = exports.pulsechainV4 = exports.pulsechain = exports.polygonZkEvm = exports.polygonZkEvmTestnet = exports.polygonMumbai = exports.polygon = exports.plinga = exports.pgnTestnet = exports.pgn = exports.opBNBTestnet = exports.opBNB = exports.optimismSepolia = exports.optimismGoerli = exports.optimism = exports.okc = exports.oasisTestnet = exports.oasys = exports.nexilix = exports.nexi = exports.neonMainnet = exports.neonDevnet = void 0;
    exports.zoraTestnet = exports.zoraSepolia = exports.zora = exports.zilliqaTestnet = exports.zilliqa = exports.zetachainAthensTestnet = exports.zkSyncSepoliaTestnet = exports.zkSyncTestnet = exports.zkSync = exports.zkFairTestnet = exports.zkFair = exports.zhejiang = exports.xdcTestnet = exports.xdc = exports.wemixTestnet = exports.wemix = exports.wanchainTestnet = exports.wanchain = exports.vechain = exports.thunderTestnet = exports.tenet = exports.telosTestnet = exports.telos = exports.taraxaTestnet = exports.taikoTestnetSepolia = exports.taikoJolnir = exports.taraxa = exports.syscoinTestnet = exports.syscoin = exports.shibarium = exports.shardeumSphinx = exports.spicy = exports.songbirdTestnet = exports.songbird = exports.skaleTitanTestnet = void 0;
    var acala_js_1 = require_acala();
    Object.defineProperty(exports, "acala", { enumerable: true, get: function() {
      return acala_js_1.acala;
    } });
    var arbitrum_js_1 = require_arbitrum();
    Object.defineProperty(exports, "arbitrum", { enumerable: true, get: function() {
      return arbitrum_js_1.arbitrum;
    } });
    var arbitrumGoerli_js_1 = require_arbitrumGoerli();
    Object.defineProperty(exports, "arbitrumGoerli", { enumerable: true, get: function() {
      return arbitrumGoerli_js_1.arbitrumGoerli;
    } });
    var arbitrumNova_js_1 = require_arbitrumNova();
    Object.defineProperty(exports, "arbitrumNova", { enumerable: true, get: function() {
      return arbitrumNova_js_1.arbitrumNova;
    } });
    var astar_js_1 = require_astar();
    Object.defineProperty(exports, "astar", { enumerable: true, get: function() {
      return astar_js_1.astar;
    } });
    var arbitrumSepolia_js_1 = require_arbitrumSepolia();
    Object.defineProperty(exports, "arbitrumSepolia", { enumerable: true, get: function() {
      return arbitrumSepolia_js_1.arbitrumSepolia;
    } });
    var astarZkatana_js_1 = require_astarZkatana();
    Object.defineProperty(exports, "astarZkatana", { enumerable: true, get: function() {
      return astarZkatana_js_1.astarZkatana;
    } });
    var aurora_js_1 = require_aurora();
    Object.defineProperty(exports, "aurora", { enumerable: true, get: function() {
      return aurora_js_1.aurora;
    } });
    var auroraTestnet_js_1 = require_auroraTestnet();
    Object.defineProperty(exports, "auroraTestnet", { enumerable: true, get: function() {
      return auroraTestnet_js_1.auroraTestnet;
    } });
    var avalanche_js_1 = require_avalanche();
    Object.defineProperty(exports, "avalanche", { enumerable: true, get: function() {
      return avalanche_js_1.avalanche;
    } });
    var avalancheFuji_js_1 = require_avalancheFuji();
    Object.defineProperty(exports, "avalancheFuji", { enumerable: true, get: function() {
      return avalancheFuji_js_1.avalancheFuji;
    } });
    var bahamut_js_1 = require_bahamut();
    Object.defineProperty(exports, "bahamut", { enumerable: true, get: function() {
      return bahamut_js_1.bahamut;
    } });
    var base_js_1 = require_base2();
    Object.defineProperty(exports, "base", { enumerable: true, get: function() {
      return base_js_1.base;
    } });
    var baseGoerli_js_1 = require_baseGoerli();
    Object.defineProperty(exports, "baseGoerli", { enumerable: true, get: function() {
      return baseGoerli_js_1.baseGoerli;
    } });
    var baseSepolia_js_1 = require_baseSepolia();
    Object.defineProperty(exports, "baseSepolia", { enumerable: true, get: function() {
      return baseSepolia_js_1.baseSepolia;
    } });
    var bearNetworkChainMainnet_js_1 = require_bearNetworkChainMainnet();
    Object.defineProperty(exports, "bearNetworkChainMainnet", { enumerable: true, get: function() {
      return bearNetworkChainMainnet_js_1.bearNetworkChainMainnet;
    } });
    var bearNetworkChainTestnet_js_1 = require_bearNetworkChainTestnet();
    Object.defineProperty(exports, "bearNetworkChainTestnet", { enumerable: true, get: function() {
      return bearNetworkChainTestnet_js_1.bearNetworkChainTestnet;
    } });
    var bitTorrent_js_1 = require_bitTorrent();
    Object.defineProperty(exports, "bitTorrent", { enumerable: true, get: function() {
      return bitTorrent_js_1.bitTorrent;
    } });
    var bitTorrentTestnet_js_1 = require_bitTorrentTestnet();
    Object.defineProperty(exports, "bitTorrentTestnet", { enumerable: true, get: function() {
      return bitTorrentTestnet_js_1.bitTorrentTestnet;
    } });
    var boba_js_1 = require_boba();
    Object.defineProperty(exports, "boba", { enumerable: true, get: function() {
      return boba_js_1.boba;
    } });
    var bronos_js_1 = require_bronos();
    Object.defineProperty(exports, "bronos", { enumerable: true, get: function() {
      return bronos_js_1.bronos;
    } });
    var bronosTestnet_js_1 = require_bronosTestnet();
    Object.defineProperty(exports, "bronosTestnet", { enumerable: true, get: function() {
      return bronosTestnet_js_1.bronosTestnet;
    } });
    var bsc_js_1 = require_bsc();
    Object.defineProperty(exports, "bsc", { enumerable: true, get: function() {
      return bsc_js_1.bsc;
    } });
    var bscTestnet_js_1 = require_bscTestnet();
    Object.defineProperty(exports, "bscTestnet", { enumerable: true, get: function() {
      return bscTestnet_js_1.bscTestnet;
    } });
    var bxn_js_1 = require_bxn();
    Object.defineProperty(exports, "bxn", { enumerable: true, get: function() {
      return bxn_js_1.bxn;
    } });
    var bxnTestnet_js_1 = require_bxnTestnet();
    Object.defineProperty(exports, "bxnTestnet", { enumerable: true, get: function() {
      return bxnTestnet_js_1.bxnTestnet;
    } });
    var canto_js_1 = require_canto();
    Object.defineProperty(exports, "canto", { enumerable: true, get: function() {
      return canto_js_1.canto;
    } });
    var celo_js_1 = require_celo();
    Object.defineProperty(exports, "celo", { enumerable: true, get: function() {
      return celo_js_1.celo;
    } });
    var celoAlfajores_js_1 = require_celoAlfajores();
    Object.defineProperty(exports, "celoAlfajores", { enumerable: true, get: function() {
      return celoAlfajores_js_1.celoAlfajores;
    } });
    var chiliz_js_1 = require_chiliz();
    Object.defineProperty(exports, "chiliz", { enumerable: true, get: function() {
      return chiliz_js_1.chiliz;
    } });
    var celoCannoli_js_1 = require_celoCannoli();
    Object.defineProperty(exports, "celoCannoli", { enumerable: true, get: function() {
      return celoCannoli_js_1.celoCannoli;
    } });
    var classic_js_1 = require_classic();
    Object.defineProperty(exports, "classic", { enumerable: true, get: function() {
      return classic_js_1.classic;
    } });
    var confluxESpace_js_1 = require_confluxESpace();
    Object.defineProperty(exports, "confluxESpace", { enumerable: true, get: function() {
      return confluxESpace_js_1.confluxESpace;
    } });
    var confluxESpaceTestnet_js_1 = require_confluxESpaceTestnet();
    Object.defineProperty(exports, "confluxESpaceTestnet", { enumerable: true, get: function() {
      return confluxESpaceTestnet_js_1.confluxESpaceTestnet;
    } });
    var coreDao_js_1 = require_coreDao();
    Object.defineProperty(exports, "coreDao", { enumerable: true, get: function() {
      return coreDao_js_1.coreDao;
    } });
    var cronos_js_1 = require_cronos();
    Object.defineProperty(exports, "cronos", { enumerable: true, get: function() {
      return cronos_js_1.cronos;
    } });
    var cronosTestnet_js_1 = require_cronosTestnet();
    Object.defineProperty(exports, "cronosTestnet", { enumerable: true, get: function() {
      return cronosTestnet_js_1.cronosTestnet;
    } });
    var crossbell_js_1 = require_crossbell();
    Object.defineProperty(exports, "crossbell", { enumerable: true, get: function() {
      return crossbell_js_1.crossbell;
    } });
    var dfk_js_1 = require_dfk();
    Object.defineProperty(exports, "dfk", { enumerable: true, get: function() {
      return dfk_js_1.dfk;
    } });
    var dogechain_js_1 = require_dogechain();
    Object.defineProperty(exports, "dogechain", { enumerable: true, get: function() {
      return dogechain_js_1.dogechain;
    } });
    var edgeware_js_1 = require_edgeware();
    Object.defineProperty(exports, "edgeware", { enumerable: true, get: function() {
      return edgeware_js_1.edgeware;
    } });
    var edgewareTestnet_js_1 = require_edgewareTestnet();
    Object.defineProperty(exports, "edgewareTestnet", { enumerable: true, get: function() {
      return edgewareTestnet_js_1.edgewareTestnet;
    } });
    var eos_js_1 = require_eos();
    Object.defineProperty(exports, "eos", { enumerable: true, get: function() {
      return eos_js_1.eos;
    } });
    var eosTestnet_js_1 = require_eosTestnet();
    Object.defineProperty(exports, "eosTestnet", { enumerable: true, get: function() {
      return eosTestnet_js_1.eosTestnet;
    } });
    var evmos_js_1 = require_evmos();
    Object.defineProperty(exports, "evmos", { enumerable: true, get: function() {
      return evmos_js_1.evmos;
    } });
    var evmosTestnet_js_1 = require_evmosTestnet();
    Object.defineProperty(exports, "evmosTestnet", { enumerable: true, get: function() {
      return evmosTestnet_js_1.evmosTestnet;
    } });
    var ekta_js_1 = require_ekta();
    Object.defineProperty(exports, "ekta", { enumerable: true, get: function() {
      return ekta_js_1.ekta;
    } });
    var ektaTestnet_js_1 = require_ektaTestnet();
    Object.defineProperty(exports, "ektaTestnet", { enumerable: true, get: function() {
      return ektaTestnet_js_1.ektaTestnet;
    } });
    var fantom_js_1 = require_fantom();
    Object.defineProperty(exports, "fantom", { enumerable: true, get: function() {
      return fantom_js_1.fantom;
    } });
    var fantomSonicTestnet_js_1 = require_fantomSonicTestnet();
    Object.defineProperty(exports, "fantomSonicTestnet", { enumerable: true, get: function() {
      return fantomSonicTestnet_js_1.fantomSonicTestnet;
    } });
    var fantomTestnet_js_1 = require_fantomTestnet();
    Object.defineProperty(exports, "fantomTestnet", { enumerable: true, get: function() {
      return fantomTestnet_js_1.fantomTestnet;
    } });
    var fibo_js_1 = require_fibo();
    Object.defineProperty(exports, "fibo", { enumerable: true, get: function() {
      return fibo_js_1.fibo;
    } });
    var filecoin_js_1 = require_filecoin();
    Object.defineProperty(exports, "filecoin", { enumerable: true, get: function() {
      return filecoin_js_1.filecoin;
    } });
    var filecoinCalibration_js_1 = require_filecoinCalibration();
    Object.defineProperty(exports, "filecoinCalibration", { enumerable: true, get: function() {
      return filecoinCalibration_js_1.filecoinCalibration;
    } });
    var filecoinHyperspace_js_1 = require_filecoinHyperspace();
    Object.defineProperty(exports, "filecoinHyperspace", { enumerable: true, get: function() {
      return filecoinHyperspace_js_1.filecoinHyperspace;
    } });
    var flare_js_1 = require_flare();
    Object.defineProperty(exports, "flare", { enumerable: true, get: function() {
      return flare_js_1.flare;
    } });
    var flareTestnet_js_1 = require_flareTestnet();
    Object.defineProperty(exports, "flareTestnet", { enumerable: true, get: function() {
      return flareTestnet_js_1.flareTestnet;
    } });
    var foundry_js_1 = require_foundry();
    Object.defineProperty(exports, "foundry", { enumerable: true, get: function() {
      return foundry_js_1.foundry;
    } });
    var fuse_js_1 = require_fuse();
    Object.defineProperty(exports, "fuse", { enumerable: true, get: function() {
      return fuse_js_1.fuse;
    } });
    var fuseSparknet_js_1 = require_fuseSparknet();
    Object.defineProperty(exports, "fuseSparknet", { enumerable: true, get: function() {
      return fuseSparknet_js_1.fuseSparknet;
    } });
    var iotex_js_1 = require_iotex();
    Object.defineProperty(exports, "iotex", { enumerable: true, get: function() {
      return iotex_js_1.iotex;
    } });
    var iotexTestnet_js_1 = require_iotexTestnet();
    Object.defineProperty(exports, "iotexTestnet", { enumerable: true, get: function() {
      return iotexTestnet_js_1.iotexTestnet;
    } });
    var jbc_js_1 = require_jbc();
    Object.defineProperty(exports, "jbc", { enumerable: true, get: function() {
      return jbc_js_1.jbc;
    } });
    var karura_js_1 = require_karura();
    Object.defineProperty(exports, "karura", { enumerable: true, get: function() {
      return karura_js_1.karura;
    } });
    var gobi_js_1 = require_gobi();
    Object.defineProperty(exports, "gobi", { enumerable: true, get: function() {
      return gobi_js_1.gobi;
    } });
    var goerli_js_1 = require_goerli();
    Object.defineProperty(exports, "goerli", { enumerable: true, get: function() {
      return goerli_js_1.goerli;
    } });
    var gnosis_js_1 = require_gnosis();
    Object.defineProperty(exports, "gnosis", { enumerable: true, get: function() {
      return gnosis_js_1.gnosis;
    } });
    var gnosisChiado_js_1 = require_gnosisChiado();
    Object.defineProperty(exports, "gnosisChiado", { enumerable: true, get: function() {
      return gnosisChiado_js_1.gnosisChiado;
    } });
    var hardhat_js_1 = require_hardhat();
    Object.defineProperty(exports, "hardhat", { enumerable: true, get: function() {
      return hardhat_js_1.hardhat;
    } });
    var harmonyOne_js_1 = require_harmonyOne();
    Object.defineProperty(exports, "harmonyOne", { enumerable: true, get: function() {
      return harmonyOne_js_1.harmonyOne;
    } });
    var haqqMainnet_js_1 = require_haqqMainnet();
    Object.defineProperty(exports, "haqqMainnet", { enumerable: true, get: function() {
      return haqqMainnet_js_1.haqqMainnet;
    } });
    var haqqTestedge2_js_1 = require_haqqTestedge2();
    Object.defineProperty(exports, "haqqTestedge2", { enumerable: true, get: function() {
      return haqqTestedge2_js_1.haqqTestedge2;
    } });
    var holesky_js_1 = require_holesky();
    Object.defineProperty(exports, "holesky", { enumerable: true, get: function() {
      return holesky_js_1.holesky;
    } });
    var kava_js_1 = require_kava();
    Object.defineProperty(exports, "kava", { enumerable: true, get: function() {
      return kava_js_1.kava;
    } });
    var kavaTestnet_js_1 = require_kavaTestnet();
    Object.defineProperty(exports, "kavaTestnet", { enumerable: true, get: function() {
      return kavaTestnet_js_1.kavaTestnet;
    } });
    var klaytn_js_1 = require_klaytn();
    Object.defineProperty(exports, "klaytn", { enumerable: true, get: function() {
      return klaytn_js_1.klaytn;
    } });
    var klaytnBaobab_js_1 = require_klaytnBaobab();
    Object.defineProperty(exports, "klaytnBaobab", { enumerable: true, get: function() {
      return klaytnBaobab_js_1.klaytnBaobab;
    } });
    var kroma_js_1 = require_kroma();
    Object.defineProperty(exports, "kroma", { enumerable: true, get: function() {
      return kroma_js_1.kroma;
    } });
    var kromaSepolia_js_1 = require_kromaSepolia();
    Object.defineProperty(exports, "kromaSepolia", { enumerable: true, get: function() {
      return kromaSepolia_js_1.kromaSepolia;
    } });
    var linea_js_1 = require_linea();
    Object.defineProperty(exports, "linea", { enumerable: true, get: function() {
      return linea_js_1.linea;
    } });
    var lineaTestnet_js_1 = require_lineaTestnet();
    Object.defineProperty(exports, "lineaTestnet", { enumerable: true, get: function() {
      return lineaTestnet_js_1.lineaTestnet;
    } });
    var localhost_js_1 = require_localhost();
    Object.defineProperty(exports, "localhost", { enumerable: true, get: function() {
      return localhost_js_1.localhost;
    } });
    var lukso_js_1 = require_lukso();
    Object.defineProperty(exports, "lukso", { enumerable: true, get: function() {
      return lukso_js_1.lukso;
    } });
    var mainnet_js_1 = require_mainnet();
    Object.defineProperty(exports, "mainnet", { enumerable: true, get: function() {
      return mainnet_js_1.mainnet;
    } });
    var mandala_js_1 = require_mandala();
    Object.defineProperty(exports, "mandala", { enumerable: true, get: function() {
      return mandala_js_1.mandala;
    } });
    var manta_js_1 = require_manta();
    Object.defineProperty(exports, "manta", { enumerable: true, get: function() {
      return manta_js_1.manta;
    } });
    var mantaTestnet_js_1 = require_mantaTestnet();
    Object.defineProperty(exports, "mantaTestnet", { enumerable: true, get: function() {
      return mantaTestnet_js_1.mantaTestnet;
    } });
    var mantle_js_1 = require_mantle();
    Object.defineProperty(exports, "mantle", { enumerable: true, get: function() {
      return mantle_js_1.mantle;
    } });
    var mantleTestnet_js_1 = require_mantleTestnet();
    Object.defineProperty(exports, "mantleTestnet", { enumerable: true, get: function() {
      return mantleTestnet_js_1.mantleTestnet;
    } });
    var meter_js_1 = require_meter();
    Object.defineProperty(exports, "meter", { enumerable: true, get: function() {
      return meter_js_1.meter;
    } });
    var meterTestnet_js_1 = require_meterTestnet();
    Object.defineProperty(exports, "meterTestnet", { enumerable: true, get: function() {
      return meterTestnet_js_1.meterTestnet;
    } });
    var metis_js_1 = require_metis();
    Object.defineProperty(exports, "metis", { enumerable: true, get: function() {
      return metis_js_1.metis;
    } });
    var metisGoerli_js_1 = require_metisGoerli();
    Object.defineProperty(exports, "metisGoerli", { enumerable: true, get: function() {
      return metisGoerli_js_1.metisGoerli;
    } });
    var mev_js_1 = require_mev();
    Object.defineProperty(exports, "mev", { enumerable: true, get: function() {
      return mev_js_1.mev;
    } });
    var mevTestnet_js_1 = require_mevTestnet();
    Object.defineProperty(exports, "mevTestnet", { enumerable: true, get: function() {
      return mevTestnet_js_1.mevTestnet;
    } });
    var modeTestnet_js_1 = require_modeTestnet();
    Object.defineProperty(exports, "modeTestnet", { enumerable: true, get: function() {
      return modeTestnet_js_1.modeTestnet;
    } });
    var moonbaseAlpha_js_1 = require_moonbaseAlpha();
    Object.defineProperty(exports, "moonbaseAlpha", { enumerable: true, get: function() {
      return moonbaseAlpha_js_1.moonbaseAlpha;
    } });
    var moonbeam_js_1 = require_moonbeam();
    Object.defineProperty(exports, "moonbeam", { enumerable: true, get: function() {
      return moonbeam_js_1.moonbeam;
    } });
    var moonbeamDev_js_1 = require_moonbeamDev();
    Object.defineProperty(exports, "moonbeamDev", { enumerable: true, get: function() {
      return moonbeamDev_js_1.moonbeamDev;
    } });
    var moonriver_js_1 = require_moonriver();
    Object.defineProperty(exports, "moonriver", { enumerable: true, get: function() {
      return moonriver_js_1.moonriver;
    } });
    var neonDevnet_js_1 = require_neonDevnet();
    Object.defineProperty(exports, "neonDevnet", { enumerable: true, get: function() {
      return neonDevnet_js_1.neonDevnet;
    } });
    var neonMainnet_js_1 = require_neonMainnet();
    Object.defineProperty(exports, "neonMainnet", { enumerable: true, get: function() {
      return neonMainnet_js_1.neonMainnet;
    } });
    var nexi_js_1 = require_nexi();
    Object.defineProperty(exports, "nexi", { enumerable: true, get: function() {
      return nexi_js_1.nexi;
    } });
    var nexilix_js_1 = require_nexilix();
    Object.defineProperty(exports, "nexilix", { enumerable: true, get: function() {
      return nexilix_js_1.nexilix;
    } });
    var oasys_js_1 = require_oasys();
    Object.defineProperty(exports, "oasys", { enumerable: true, get: function() {
      return oasys_js_1.oasys;
    } });
    var oasisTestnet_js_1 = require_oasisTestnet();
    Object.defineProperty(exports, "oasisTestnet", { enumerable: true, get: function() {
      return oasisTestnet_js_1.oasisTestnet;
    } });
    var okc_js_1 = require_okc();
    Object.defineProperty(exports, "okc", { enumerable: true, get: function() {
      return okc_js_1.okc;
    } });
    var optimism_js_1 = require_optimism();
    Object.defineProperty(exports, "optimism", { enumerable: true, get: function() {
      return optimism_js_1.optimism;
    } });
    var optimismGoerli_js_1 = require_optimismGoerli();
    Object.defineProperty(exports, "optimismGoerli", { enumerable: true, get: function() {
      return optimismGoerli_js_1.optimismGoerli;
    } });
    var optimismSepolia_js_1 = require_optimismSepolia();
    Object.defineProperty(exports, "optimismSepolia", { enumerable: true, get: function() {
      return optimismSepolia_js_1.optimismSepolia;
    } });
    var opBNB_js_1 = require_opBNB();
    Object.defineProperty(exports, "opBNB", { enumerable: true, get: function() {
      return opBNB_js_1.opBNB;
    } });
    var opBNBTestnet_js_1 = require_opBNBTestnet();
    Object.defineProperty(exports, "opBNBTestnet", { enumerable: true, get: function() {
      return opBNBTestnet_js_1.opBNBTestnet;
    } });
    var pgn_js_1 = require_pgn();
    Object.defineProperty(exports, "pgn", { enumerable: true, get: function() {
      return pgn_js_1.pgn;
    } });
    var pgnTestnet_js_1 = require_pgnTestnet();
    Object.defineProperty(exports, "pgnTestnet", { enumerable: true, get: function() {
      return pgnTestnet_js_1.pgnTestnet;
    } });
    var plinga_js_1 = require_plinga();
    Object.defineProperty(exports, "plinga", { enumerable: true, get: function() {
      return plinga_js_1.plinga;
    } });
    var polygon_js_1 = require_polygon();
    Object.defineProperty(exports, "polygon", { enumerable: true, get: function() {
      return polygon_js_1.polygon;
    } });
    var polygonMumbai_js_1 = require_polygonMumbai();
    Object.defineProperty(exports, "polygonMumbai", { enumerable: true, get: function() {
      return polygonMumbai_js_1.polygonMumbai;
    } });
    var polygonZkEvmTestnet_js_1 = require_polygonZkEvmTestnet();
    Object.defineProperty(exports, "polygonZkEvmTestnet", { enumerable: true, get: function() {
      return polygonZkEvmTestnet_js_1.polygonZkEvmTestnet;
    } });
    var polygonZkEvm_js_1 = require_polygonZkEvm();
    Object.defineProperty(exports, "polygonZkEvm", { enumerable: true, get: function() {
      return polygonZkEvm_js_1.polygonZkEvm;
    } });
    var pulsechain_js_1 = require_pulsechain();
    Object.defineProperty(exports, "pulsechain", { enumerable: true, get: function() {
      return pulsechain_js_1.pulsechain;
    } });
    var pulsechainV4_js_1 = require_pulsechainV4();
    Object.defineProperty(exports, "pulsechainV4", { enumerable: true, get: function() {
      return pulsechainV4_js_1.pulsechainV4;
    } });
    var qMainnet_js_1 = require_qMainnet();
    Object.defineProperty(exports, "qMainnet", { enumerable: true, get: function() {
      return qMainnet_js_1.qMainnet;
    } });
    var qTestnet_js_1 = require_qTestnet();
    Object.defineProperty(exports, "qTestnet", { enumerable: true, get: function() {
      return qTestnet_js_1.qTestnet;
    } });
    var rollux_js_1 = require_rollux();
    Object.defineProperty(exports, "rollux", { enumerable: true, get: function() {
      return rollux_js_1.rollux;
    } });
    var rolluxTestnet_js_1 = require_rolluxTestnet();
    Object.defineProperty(exports, "rolluxTestnet", { enumerable: true, get: function() {
      return rolluxTestnet_js_1.rolluxTestnet;
    } });
    var ronin_js_1 = require_ronin();
    Object.defineProperty(exports, "ronin", { enumerable: true, get: function() {
      return ronin_js_1.ronin;
    } });
    var rootstock_js_1 = require_rootstock();
    Object.defineProperty(exports, "rootstock", { enumerable: true, get: function() {
      return rootstock_js_1.rootstock;
    } });
    var saigon_js_1 = require_saigon();
    Object.defineProperty(exports, "saigon", { enumerable: true, get: function() {
      return saigon_js_1.saigon;
    } });
    var sapphire_js_1 = require_sapphire();
    Object.defineProperty(exports, "sapphire", { enumerable: true, get: function() {
      return sapphire_js_1.sapphire;
    } });
    var sapphireTestnet_js_1 = require_sapphireTestnet();
    Object.defineProperty(exports, "sapphireTestnet", { enumerable: true, get: function() {
      return sapphireTestnet_js_1.sapphireTestnet;
    } });
    var scroll_js_1 = require_scroll();
    Object.defineProperty(exports, "scroll", { enumerable: true, get: function() {
      return scroll_js_1.scroll;
    } });
    var scrollSepolia_js_1 = require_scrollSepolia();
    Object.defineProperty(exports, "scrollSepolia", { enumerable: true, get: function() {
      return scrollSepolia_js_1.scrollSepolia;
    } });
    var scrollTestnet_js_1 = require_scrollTestnet();
    Object.defineProperty(exports, "scrollTestnet", { enumerable: true, get: function() {
      return scrollTestnet_js_1.scrollTestnet;
    } });
    var sepolia_js_1 = require_sepolia();
    Object.defineProperty(exports, "sepolia", { enumerable: true, get: function() {
      return sepolia_js_1.sepolia;
    } });
    var shimmer_js_1 = require_shimmer();
    Object.defineProperty(exports, "shimmer", { enumerable: true, get: function() {
      return shimmer_js_1.shimmer;
    } });
    var shimmerTestnet_js_1 = require_shimmerTestnet();
    Object.defineProperty(exports, "shimmerTestnet", { enumerable: true, get: function() {
      return shimmerTestnet_js_1.shimmerTestnet;
    } });
    var brawl_js_1 = require_brawl();
    Object.defineProperty(exports, "skaleBlockBrawlers", { enumerable: true, get: function() {
      return brawl_js_1.skaleBlockBrawlers;
    } });
    var calypso_js_1 = require_calypso();
    Object.defineProperty(exports, "skaleCalypso", { enumerable: true, get: function() {
      return calypso_js_1.skaleCalypso;
    } });
    var calypsoTestnet_js_1 = require_calypsoTestnet();
    Object.defineProperty(exports, "skaleCalypsoTestnet", { enumerable: true, get: function() {
      return calypsoTestnet_js_1.skaleCalypsoTestnet;
    } });
    var chaosTestnet_js_1 = require_chaosTestnet();
    Object.defineProperty(exports, "skaleChaosTestnet", { enumerable: true, get: function() {
      return chaosTestnet_js_1.skaleChaosTestnet;
    } });
    var cryptoBlades_js_1 = require_cryptoBlades();
    Object.defineProperty(exports, "skaleCryptoBlades", { enumerable: true, get: function() {
      return cryptoBlades_js_1.skaleCryptoBlades;
    } });
    var cryptoColosseum_js_1 = require_cryptoColosseum();
    Object.defineProperty(exports, "skaleCryptoColosseum", { enumerable: true, get: function() {
      return cryptoColosseum_js_1.skaleCryptoColosseum;
    } });
    var europa_js_1 = require_europa();
    Object.defineProperty(exports, "skaleEuropa", { enumerable: true, get: function() {
      return europa_js_1.skaleEuropa;
    } });
    var europaTestnet_js_1 = require_europaTestnet();
    Object.defineProperty(exports, "skaleEuropaTestnet", { enumerable: true, get: function() {
      return europaTestnet_js_1.skaleEuropaTestnet;
    } });
    var exorde_js_1 = require_exorde();
    Object.defineProperty(exports, "skaleExorde", { enumerable: true, get: function() {
      return exorde_js_1.skaleExorde;
    } });
    var humanProtocol_js_1 = require_humanProtocol();
    Object.defineProperty(exports, "skaleHumanProtocol", { enumerable: true, get: function() {
      return humanProtocol_js_1.skaleHumanProtocol;
    } });
    var nebula_js_1 = require_nebula();
    Object.defineProperty(exports, "skaleNebula", { enumerable: true, get: function() {
      return nebula_js_1.skaleNebula;
    } });
    var nebulaTestnet_js_1 = require_nebulaTestnet();
    Object.defineProperty(exports, "skaleNebulaTestnet", { enumerable: true, get: function() {
      return nebulaTestnet_js_1.skaleNebulaTestnet;
    } });
    var razor_js_1 = require_razor();
    Object.defineProperty(exports, "skaleRazor", { enumerable: true, get: function() {
      return razor_js_1.skaleRazor;
    } });
    var titan_js_1 = require_titan();
    Object.defineProperty(exports, "skaleTitan", { enumerable: true, get: function() {
      return titan_js_1.skaleTitan;
    } });
    var titanTestnet_js_1 = require_titanTestnet();
    Object.defineProperty(exports, "skaleTitanTestnet", { enumerable: true, get: function() {
      return titanTestnet_js_1.skaleTitanTestnet;
    } });
    var songbird_js_1 = require_songbird();
    Object.defineProperty(exports, "songbird", { enumerable: true, get: function() {
      return songbird_js_1.songbird;
    } });
    var songbirdTestnet_js_1 = require_songbirdTestnet();
    Object.defineProperty(exports, "songbirdTestnet", { enumerable: true, get: function() {
      return songbirdTestnet_js_1.songbirdTestnet;
    } });
    var spicy_js_1 = require_spicy();
    Object.defineProperty(exports, "spicy", { enumerable: true, get: function() {
      return spicy_js_1.spicy;
    } });
    var shardeumSphinx_js_1 = require_shardeumSphinx();
    Object.defineProperty(exports, "shardeumSphinx", { enumerable: true, get: function() {
      return shardeumSphinx_js_1.shardeumSphinx;
    } });
    var shibarium_js_1 = require_shibarium();
    Object.defineProperty(exports, "shibarium", { enumerable: true, get: function() {
      return shibarium_js_1.shibarium;
    } });
    var syscoin_js_1 = require_syscoin();
    Object.defineProperty(exports, "syscoin", { enumerable: true, get: function() {
      return syscoin_js_1.syscoin;
    } });
    var syscoinTestnet_js_1 = require_syscoinTestnet();
    Object.defineProperty(exports, "syscoinTestnet", { enumerable: true, get: function() {
      return syscoinTestnet_js_1.syscoinTestnet;
    } });
    var taraxa_js_1 = require_taraxa();
    Object.defineProperty(exports, "taraxa", { enumerable: true, get: function() {
      return taraxa_js_1.taraxa;
    } });
    var taikoJolnir_js_1 = require_taikoJolnir();
    Object.defineProperty(exports, "taikoJolnir", { enumerable: true, get: function() {
      return taikoJolnir_js_1.taikoJolnir;
    } });
    var taikoTestnetSepolia_js_1 = require_taikoTestnetSepolia();
    Object.defineProperty(exports, "taikoTestnetSepolia", { enumerable: true, get: function() {
      return taikoTestnetSepolia_js_1.taikoTestnetSepolia;
    } });
    var taraxaTestnet_js_1 = require_taraxaTestnet();
    Object.defineProperty(exports, "taraxaTestnet", { enumerable: true, get: function() {
      return taraxaTestnet_js_1.taraxaTestnet;
    } });
    var telos_js_1 = require_telos();
    Object.defineProperty(exports, "telos", { enumerable: true, get: function() {
      return telos_js_1.telos;
    } });
    var telosTestnet_js_1 = require_telosTestnet();
    Object.defineProperty(exports, "telosTestnet", { enumerable: true, get: function() {
      return telosTestnet_js_1.telosTestnet;
    } });
    var tenet_js_1 = require_tenet();
    Object.defineProperty(exports, "tenet", { enumerable: true, get: function() {
      return tenet_js_1.tenet;
    } });
    var thunderTestnet_js_1 = require_thunderTestnet();
    Object.defineProperty(exports, "thunderTestnet", { enumerable: true, get: function() {
      return thunderTestnet_js_1.thunderTestnet;
    } });
    var vechain_js_1 = require_vechain();
    Object.defineProperty(exports, "vechain", { enumerable: true, get: function() {
      return vechain_js_1.vechain;
    } });
    var wanchain_js_1 = require_wanchain();
    Object.defineProperty(exports, "wanchain", { enumerable: true, get: function() {
      return wanchain_js_1.wanchain;
    } });
    var wanchainTestnet_js_1 = require_wanchainTestnet();
    Object.defineProperty(exports, "wanchainTestnet", { enumerable: true, get: function() {
      return wanchainTestnet_js_1.wanchainTestnet;
    } });
    var wemix_js_1 = require_wemix();
    Object.defineProperty(exports, "wemix", { enumerable: true, get: function() {
      return wemix_js_1.wemix;
    } });
    var wemixTestnet_js_1 = require_wemixTestnet();
    Object.defineProperty(exports, "wemixTestnet", { enumerable: true, get: function() {
      return wemixTestnet_js_1.wemixTestnet;
    } });
    var xdc_js_1 = require_xdc();
    Object.defineProperty(exports, "xdc", { enumerable: true, get: function() {
      return xdc_js_1.xdc;
    } });
    var xdcTestnet_js_1 = require_xdcTestnet();
    Object.defineProperty(exports, "xdcTestnet", { enumerable: true, get: function() {
      return xdcTestnet_js_1.xdcTestnet;
    } });
    var zhejiang_js_1 = require_zhejiang();
    Object.defineProperty(exports, "zhejiang", { enumerable: true, get: function() {
      return zhejiang_js_1.zhejiang;
    } });
    var zkFair_js_1 = require_zkFair();
    Object.defineProperty(exports, "zkFair", { enumerable: true, get: function() {
      return zkFair_js_1.zkFair;
    } });
    var zkFairTestnet_js_1 = require_zkFairTestnet();
    Object.defineProperty(exports, "zkFairTestnet", { enumerable: true, get: function() {
      return zkFairTestnet_js_1.zkFairTestnet;
    } });
    var zkSync_js_1 = require_zkSync();
    Object.defineProperty(exports, "zkSync", { enumerable: true, get: function() {
      return zkSync_js_1.zkSync;
    } });
    var zkSyncTestnet_js_1 = require_zkSyncTestnet();
    Object.defineProperty(exports, "zkSyncTestnet", { enumerable: true, get: function() {
      return zkSyncTestnet_js_1.zkSyncTestnet;
    } });
    var zkSyncSepoliaTestnet_js_1 = require_zkSyncSepoliaTestnet();
    Object.defineProperty(exports, "zkSyncSepoliaTestnet", { enumerable: true, get: function() {
      return zkSyncSepoliaTestnet_js_1.zkSyncSepoliaTestnet;
    } });
    var zetachainAthensTestnet_js_1 = require_zetachainAthensTestnet();
    Object.defineProperty(exports, "zetachainAthensTestnet", { enumerable: true, get: function() {
      return zetachainAthensTestnet_js_1.zetachainAthensTestnet;
    } });
    var zilliqa_js_1 = require_zilliqa();
    Object.defineProperty(exports, "zilliqa", { enumerable: true, get: function() {
      return zilliqa_js_1.zilliqa;
    } });
    var zilliqaTestnet_js_1 = require_zilliqaTestnet();
    Object.defineProperty(exports, "zilliqaTestnet", { enumerable: true, get: function() {
      return zilliqaTestnet_js_1.zilliqaTestnet;
    } });
    var zora_js_1 = require_zora();
    Object.defineProperty(exports, "zora", { enumerable: true, get: function() {
      return zora_js_1.zora;
    } });
    var zoraSepolia_js_1 = require_zoraSepolia();
    Object.defineProperty(exports, "zoraSepolia", { enumerable: true, get: function() {
      return zoraSepolia_js_1.zoraSepolia;
    } });
    var zoraTestnet_js_1 = require_zoraTestnet();
    Object.defineProperty(exports, "zoraTestnet", { enumerable: true, get: function() {
      return zoraTestnet_js_1.zoraTestnet;
    } });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/customChains.js
var require_customChains = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/customChains.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lineaSepoliaTestnet = exports.cyberConnectMainnet = exports.cyberConnectTestnet = exports.berachainTestnet = exports.polygonAmoy = exports.polygonZkEvmCordona = void 0;
    var viem_1 = require_cjs2();
    exports.polygonZkEvmCordona = (0, viem_1.defineChain)({
      id: 2442,
      name: "Polygon zkEVM Cardona Testnet",
      network: "polygon-zkevm-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "ETH",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["https://rpc.cardona.zkevm-rpc.com/"] },
        public: { http: ["https://rpc.cardona.zkevm-rpc.com/"] }
      },
      blockExplorers: {
        default: {
          name: "Polygon zkEVM Cardona",
          url: " https://cardona-zkevm.polygonscan.com/"
        }
      },
      testnet: true
    });
    exports.polygonAmoy = (0, viem_1.defineChain)({
      id: 80002,
      name: "Polygon Amoy Testnet",
      network: "polygon-amoy",
      nativeCurrency: {
        decimals: 18,
        name: "MATIC",
        symbol: "MATIC"
      },
      rpcUrls: {
        default: { http: ["https://rpc-amoy.polygon.technology/"] },
        public: { http: ["https://rpc-amoy.polygon.technology/"] }
      },
      blockExplorers: {
        default: {
          name: "Polygon Amoy",
          url: "https://www.oklink.com/amoy"
        }
      },
      testnet: true
    });
    exports.berachainTestnet = (0, viem_1.defineChain)({
      id: 80085,
      name: "Berachain Artio",
      network: "berachain-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "BERA Token",
        symbol: "BERA"
      },
      rpcUrls: {
        default: { http: ["https://artio.rpc.berachain.com"] },
        public: { http: ["https://artio.rpc.berachain.com"] }
      },
      blockExplorers: {
        default: {
          name: "Berachain",
          url: "https://artio.beratrail.io"
        }
      },
      testnet: true
    });
    exports.cyberConnectTestnet = (0, viem_1.defineChain)({
      id: 111557560,
      name: "Cyber Testnet",
      network: "cyberconnect-testent",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://cyber-testnet.alt.technology"] },
        public: { http: ["https://cyber-testnet.alt.technology"] }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://testnet.cyberscan.co"
        }
      },
      contracts: {
        multicall3: {
          address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
          blockCreated: 304545
        }
      },
      testnet: true
    });
    exports.cyberConnectMainnet = (0, viem_1.defineChain)({
      id: 7560,
      name: "Cyber",
      network: "cyberconnect-mainnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://cyber.alt.technology"]
        },
        public: {
          http: ["https://cyber.alt.technology"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://cyberscan.co",
          apiUrl: "https://cyberscan.co/api"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 0
        }
      }
    });
    exports.lineaSepoliaTestnet = (0, viem_1.defineChain)({
      id: 59141,
      name: "Linea Sepolia Testnet",
      network: "linea-sepolia-testnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.sepolia.linea.build"],
          webSocket: ["wss://rpc.sepolia.linea.build"]
        },
        public: {
          http: ["https://rpc.sepolia.linea.build"],
          webSocket: ["wss://rpc.sepolia.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "Etherscan",
          url: "https://sepolia.lineascan.build",
          apiUrl: "https://api-sepolia.lineascan.build/api"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 227427
        }
      },
      testnet: true
    });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/config.js
var require_config = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/config.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ALPHA_FEATURE_CONFIG = exports.VIEM_CONFIG = exports.CHANNEL_TYPE = exports.ABIS = exports.MIN_TOKEN_BALANCE = exports.TOKEN_VIEM_NETWORK_MAP = exports.TOKEN = exports.CORE_CONFIG = exports.VIEM_CORE_CONFIG = exports.CHAIN_NAME = exports.CHAIN_ID = exports.ALIAS_CHAIN_ID = exports.ETH_CHAIN_ID = exports.API_BASE_URL = void 0;
    var constants_1 = require_constants2();
    var core_1 = require_core();
    var comm_1 = require_comm();
    var token_1 = require_token();
    var chains_1 = require_chains();
    var customChains_1 = require_customChains();
    exports.API_BASE_URL = {
      [constants_1.ENV.PROD]: "https://backend.epns.io/apis",
      [constants_1.ENV.STAGING]: "https://backend-staging.epns.io/apis",
      [constants_1.ENV.DEV]: "https://backend-dev.epns.io/apis",
      /**
       * **This is for local development only**
       */
      [constants_1.ENV.LOCAL]: "http://localhost:4000/apis"
    };
    var BLOCKCHAIN_NETWORK = {
      ETH_MAINNET: "eip155:1",
      ETH_SEPOLIA: "eip155:11155111",
      POLYGON_MAINNET: "eip155:137",
      POLYGON_AMOY: "eip155:80002",
      BSC_MAINNET: "eip155:56",
      BSC_TESTNET: "eip155:97",
      OPTIMISM_TESTNET: "eip155:11155420",
      OPTIMISM_MAINNET: "eip155:10",
      POLYGON_ZK_EVM_TESTNET: "eip155:2442",
      POLYGON_ZK_EVM_MAINNET: "eip155:1101",
      ARBITRUM_TESTNET: "eip155:421614",
      ARBITRUMONE_MAINNET: "eip155:42161",
      FUSE_TESTNET: "eip155:123",
      FUSE_MAINNET: "eip155:122",
      BERACHAIN_TESTNET: "eip155:80085",
      LINEA_MAINNET: "eip155:59144",
      LINEA_TESTNET: "eip155:59141",
      CYBER_CONNECT_TESTNET: "eip155:111557560",
      CYBER_CONNECT_MAINNET: "eip155:7560",
      BASE_TESTNET: "eip155:84532",
      BASE_MAINNET: "eip155:8453"
    };
    exports.ETH_CHAIN_ID = {
      [constants_1.ENV.PROD]: 1,
      [constants_1.ENV.STAGING]: 11155111,
      [constants_1.ENV.DEV]: 11155111,
      [constants_1.ENV.LOCAL]: 11155111
    };
    exports.ALIAS_CHAIN_ID = {
      POLYGON: {
        [constants_1.ENV.PROD]: 137,
        [constants_1.ENV.STAGING]: 80002,
        [constants_1.ENV.DEV]: 80002,
        [constants_1.ENV.LOCAL]: 80002
      },
      BSC: {
        [constants_1.ENV.PROD]: 56,
        [constants_1.ENV.STAGING]: 97,
        [constants_1.ENV.DEV]: 97,
        [constants_1.ENV.LOCAL]: 97
      },
      OPTIMISM: {
        [constants_1.ENV.PROD]: 10,
        [constants_1.ENV.STAGING]: 11155420,
        [constants_1.ENV.DEV]: 11155420,
        [constants_1.ENV.LOCAL]: 11155420
      },
      POLYGONZKEVM: {
        [constants_1.ENV.PROD]: 1101,
        [constants_1.ENV.STAGING]: 2442,
        [constants_1.ENV.DEV]: 2442,
        [constants_1.ENV.LOCAL]: 2442
      },
      ARBITRUMONE: {
        [constants_1.ENV.PROD]: 42161,
        [constants_1.ENV.STAGING]: 421614,
        [constants_1.ENV.DEV]: 421614,
        [constants_1.ENV.LOCAL]: 421614
      },
      FUSE: {
        [constants_1.ENV.PROD]: 122,
        [constants_1.ENV.STAGING]: 123,
        [constants_1.ENV.DEV]: 123,
        [constants_1.ENV.LOCAL]: 123
      },
      BERACHAIN: {
        [constants_1.ENV.PROD]: 0,
        [constants_1.ENV.STAGING]: 80085,
        [constants_1.ENV.DEV]: 80085,
        [constants_1.ENV.LOCAL]: 80085
      },
      LINEA: {
        [constants_1.ENV.PROD]: 59144,
        [constants_1.ENV.STAGING]: 59141,
        [constants_1.ENV.DEV]: 59141,
        [constants_1.ENV.LOCAL]: 59141
      },
      CYBERCONNECT: {
        [constants_1.ENV.PROD]: 7560,
        [constants_1.ENV.STAGING]: 111557560,
        [constants_1.ENV.DEV]: 111557560,
        [constants_1.ENV.LOCAL]: 111557560
      },
      BASE: {
        [constants_1.ENV.PROD]: 8453,
        [constants_1.ENV.STAGING]: 84532,
        [constants_1.ENV.DEV]: 84532,
        [constants_1.ENV.LOCAL]: 84532
      }
    };
    exports.CHAIN_ID = Object.assign({ ETHEREUM: exports.ETH_CHAIN_ID }, exports.ALIAS_CHAIN_ID);
    exports.CHAIN_NAME = {
      // eth
      1: "ETHEREUM",
      11155111: "ETHEREUM",
      // polygon
      137: "POLYGON",
      80002: "POLYGON",
      // bsc
      56: "BSC",
      97: "BSC",
      // optimism
      10: "OPTIMISM",
      11155420: "OPTIMISM",
      // plygonzkevm
      1101: "POLYGONZKEVM",
      2442: "POLYGONZKEVM",
      // arbitrun
      421614: "ARBITRUN",
      42161: "ARBITRUM",
      // fuse
      122: "FUSE",
      123: "FUSE",
      // berachain
      80085: "BERACHAIN",
      // linea
      59144: "LINEA",
      59141: "LINEA",
      // cyberconnect
      7560: "CYBER_CONNECT_MAINNET",
      111557560: "CYBER_CONNECT_TESTNET",
      // base
      8453: "BASE_MAINNET",
      84532: "BASE_TESTNET"
    };
    exports.VIEM_CORE_CONFIG = {
      [constants_1.ENV.PROD]: {
        NETWORK: chains_1.mainnet,
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
        EPNS_CORE_CONTRACT: "0x66329Fdd4042928BfCAB60b179e1538D56eeeeeE"
      },
      [constants_1.ENV.STAGING]: {
        NETWORK: chains_1.sepolia,
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
        EPNS_CORE_CONTRACT: "0x9d65129223451fbd58fc299c635cd919baf2564c"
      },
      [constants_1.ENV.DEV]: {
        NETWORK: chains_1.sepolia,
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
        EPNS_CORE_CONTRACT: "0x5ab1520e2bd519bdab2e1347eee81c00a77f4946"
      },
      [constants_1.ENV.LOCAL]: {
        NETWORK: chains_1.sepolia,
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
        EPNS_CORE_CONTRACT: "0x5ab1520e2bd519bdab2e1347eee81c00a77f4946"
      }
    };
    exports.CORE_CONFIG = {
      [constants_1.ENV.PROD]: {
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
        EPNS_CORE_CONTRACT: "0x66329Fdd4042928BfCAB60b179e1538D56eeeeeE"
      },
      [constants_1.ENV.STAGING]: {
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
        EPNS_CORE_CONTRACT: "0x9d65129223451fbd58fc299c635cd919baf2564c"
      },
      [constants_1.ENV.DEV]: {
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
        EPNS_CORE_CONTRACT: "0x5ab1520e2bd519bdab2e1347eee81c00a77f4946"
      },
      [constants_1.ENV.LOCAL]: {
        API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
        EPNS_CORE_CONTRACT: "0x5ab1520e2bd519bdab2e1347eee81c00a77f4946"
      }
    };
    var CONFIG = {
      [constants_1.ENV.PROD]: {
        [BLOCKCHAIN_NETWORK.ETH_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BSC_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUMONE_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.FUSE_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.LINEA_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0x0d8e75CB5d8873c43c5d9Add71Fd71a09F7Ef890"
        },
        [BLOCKCHAIN_NETWORK.BASE_MAINNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        }
      },
      [constants_1.ENV.STAGING]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x0c34d54a09cfe75bccd878a469206ae77e0fe6e7"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9Dc25996ba72A2FD7E64e7a674232a683f406F1A"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489b7af21ceb969f49a90e481274966ce9d74d"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9Dc25996ba72A2FD7E64e7a674232a683f406F1A"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x7b9C405e261ba671f008c20D0321f62d08C140EC"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489B7af21cEb969f49A90E481274966ce9D74d"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489B7af21cEb969f49A90E481274966ce9D74d"
        }
      },
      [constants_1.ENV.DEV]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9dDCD7ed7151afab43044E4D694FA064742C428c"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x4132061E3349ff36cFfCadA460E10Bd4f31F7ea8"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x7eBb54D86CF928115965DB596a3E600404dD8039"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0xA1DF3E68D085aa6918bcc2506b24e499830Db0eB"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        }
      },
      [constants_1.ENV.LOCAL]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9dDCD7ed7151afab43044E4D694FA064742C428c"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x4132061E3349ff36cFfCadA460E10Bd4f31F7ea8"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x7eBb54D86CF928115965DB596a3E600404dD8039"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0xA1DF3E68D085aa6918bcc2506b24e499830Db0eB"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        }
      }
    };
    exports.default = CONFIG;
    exports.TOKEN = {
      [constants_1.ENV.PROD]: "0xf418588522d5dd018b425E472991E52EBBeEEEEE",
      [constants_1.ENV.STAGING]: "0x37c779a1564DCc0e3914aB130e0e787d93e21804",
      [constants_1.ENV.DEV]: "0x37c779a1564DCc0e3914aB130e0e787d93e21804",
      [constants_1.ENV.LOCAL]: "0x37c779a1564DCc0e3914aB130e0e787d93e21804"
    };
    exports.TOKEN_VIEM_NETWORK_MAP = {
      [constants_1.ENV.PROD]: chains_1.mainnet,
      [constants_1.ENV.STAGING]: chains_1.sepolia,
      [constants_1.ENV.DEV]: chains_1.sepolia,
      [constants_1.ENV.LOCAL]: chains_1.sepolia
    };
    exports.MIN_TOKEN_BALANCE = {
      [constants_1.ENV.PROD]: 50,
      [constants_1.ENV.STAGING]: 50,
      [constants_1.ENV.DEV]: 50,
      [constants_1.ENV.LOCAL]: 50
    };
    exports.ABIS = {
      CORE: core_1.coreABI,
      COMM: comm_1.commABI,
      TOKEN: token_1.tokenABI
    };
    exports.CHANNEL_TYPE = {
      TIMEBOUND: 4,
      GENERAL: 2
    };
    exports.VIEM_CONFIG = {
      [constants_1.ENV.PROD]: {
        [BLOCKCHAIN_NETWORK.ETH_MAINNET]: {
          NETWORK: chains_1.mainnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_MAINNET]: {
          NETWORK: chains_1.polygon,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BSC_MAINNET]: {
          NETWORK: chains_1.bsc,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_MAINNET]: {
          NETWORK: chains_1.optimism,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_MAINNET]: {
          NETWORK: chains_1.polygonZkEvm,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUMONE_MAINNET]: {
          NETWORK: chains_1.arbitrum,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.FUSE_MAINNET]: {
          NETWORK: chains_1.fuse,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.LINEA_MAINNET]: {
          NETWORK: chains_1.linea,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0x0d8e75CB5d8873c43c5d9Add71Fd71a09F7Ef890"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_MAINNET]: {
          NETWORK: customChains_1.cyberConnectMainnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BASE_MAINNET]: {
          NETWORK: chains_1.base,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.PROD],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        }
      },
      [constants_1.ENV.STAGING]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          NETWORK: chains_1.sepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x0c34d54a09cfe75bccd878a469206ae77e0fe6e7"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          NETWORK: customChains_1.polygonAmoy,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          NETWORK: chains_1.bscTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          NETWORK: chains_1.optimismSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9Dc25996ba72A2FD7E64e7a674232a683f406F1A"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          NETWORK: customChains_1.polygonZkEvmCordona,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489b7af21ceb969f49a90e481274966ce9d74d"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          NETWORK: chains_1.arbitrumSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9Dc25996ba72A2FD7E64e7a674232a683f406F1A"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          NETWORK: chains_1.fuseSparknet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0xb3971BCef2D791bc4027BbfedFb47319A4AAaaAa"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          NETWORK: customChains_1.berachainTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x7b9C405e261ba671f008c20D0321f62d08C140EC"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          NETWORK: customChains_1.lineaSepoliaTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          NETWORK: customChains_1.cyberConnectTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489B7af21cEb969f49A90E481274966ce9D74d"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          NETWORK: chains_1.baseSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.STAGING],
          EPNS_COMMUNICATOR_CONTRACT: "0x6e489B7af21cEb969f49A90E481274966ce9D74d"
        }
      },
      [constants_1.ENV.DEV]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          NETWORK: chains_1.sepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9dDCD7ed7151afab43044E4D694FA064742C428c"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          NETWORK: customChains_1.polygonAmoy,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          NETWORK: chains_1.bscTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x4132061E3349ff36cFfCadA460E10Bd4f31F7ea8"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          NETWORK: chains_1.optimismSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          NETWORK: customChains_1.polygonZkEvmCordona,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          NETWORK: chains_1.arbitrumSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          NETWORK: chains_1.fuseSparknet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x7eBb54D86CF928115965DB596a3E600404dD8039"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          NETWORK: customChains_1.berachainTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0xA1DF3E68D085aa6918bcc2506b24e499830Db0eB"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          NETWORK: customChains_1.lineaSepoliaTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          NETWORK: customChains_1.cyberConnectTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          NETWORK: chains_1.baseSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.DEV],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        }
      },
      [constants_1.ENV.LOCAL]: {
        [BLOCKCHAIN_NETWORK.ETH_SEPOLIA]: {
          NETWORK: chains_1.sepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9dDCD7ed7151afab43044E4D694FA064742C428c"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_AMOY]: {
          NETWORK: customChains_1.polygonAmoy,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.BSC_TESTNET]: {
          NETWORK: chains_1.bscTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x4132061E3349ff36cFfCadA460E10Bd4f31F7ea8"
        },
        [BLOCKCHAIN_NETWORK.OPTIMISM_TESTNET]: {
          NETWORK: chains_1.optimismSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.POLYGON_ZK_EVM_TESTNET]: {
          NETWORK: customChains_1.polygonZkEvmCordona,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550b5c92baa056fc0f08132f49508145f"
        },
        [BLOCKCHAIN_NETWORK.ARBITRUM_TESTNET]: {
          NETWORK: chains_1.arbitrumSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x754787358fac861ef904c92d54f7adb659779317"
        },
        [BLOCKCHAIN_NETWORK.FUSE_TESTNET]: {
          NETWORK: chains_1.fuseSparknet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x7eBb54D86CF928115965DB596a3E600404dD8039"
        },
        [BLOCKCHAIN_NETWORK.BERACHAIN_TESTNET]: {
          NETWORK: customChains_1.berachainTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0xA1DF3E68D085aa6918bcc2506b24e499830Db0eB"
        },
        [BLOCKCHAIN_NETWORK.LINEA_TESTNET]: {
          NETWORK: customChains_1.lineaSepoliaTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.CYBER_CONNECT_TESTNET]: {
          NETWORK: customChains_1.cyberConnectTestnet,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        },
        [BLOCKCHAIN_NETWORK.BASE_TESTNET]: {
          NETWORK: chains_1.baseSepolia,
          API_BASE_URL: exports.API_BASE_URL[constants_1.ENV.LOCAL],
          EPNS_COMMUNICATOR_CONTRACT: "0x9cb3bd7550B5c92baA056Fc0F08132f49508145F"
        }
      }
    };
    exports.ALPHA_FEATURE_CONFIG = {
      STABLE: {
        feature: []
      },
      ALPHA: {
        feature: [constants_1.default.ALPHA_FEATURES.SCALABILITY_V2]
      }
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/config.js
var require_config2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/config.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAPIBaseUrls = exports.getConfig = void 0;
    var config_1 = require_config();
    var getConfig = (env, { blockchain, networkId }) => {
      const blockchainSelector = `${blockchain}:${networkId}`;
      const configuration = config_1.default[env][blockchainSelector];
      if (!configuration) {
        throw Error(`
      [Push SDK] - cannot determine config for 
        env: ${env},
        blockchain: ${blockchain},
        networkId: ${networkId}
    `);
      }
      return configuration;
    };
    exports.getConfig = getConfig;
    function getAPIBaseUrls(env) {
      if (!env)
        throw Error("ENV not provided!");
      return config_1.API_BASE_URL[env];
    }
    exports.getAPIBaseUrls = getAPIBaseUrls;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/core.js
var require_core2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/core.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto_browserify();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/x64-core.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-utf16.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-base64.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/enc-base64url.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/md5.js
var require_md52 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/md5.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha1.js
var require_sha12 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha1.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha256.js
var require_sha2564 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha256.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha224.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha2564());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha512.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M[offset + i * 2] | 0;
                Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha384.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha3.js
var require_sha32 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/sha3.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/ripemd160.js
var require_ripemd1603 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/ripemd160.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/hmac.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pbkdf2.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha2564(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/evpkdf.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_sha12(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/cipher-core.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-cfb.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ctr.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ofb.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/mode-ecb.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/format-hex.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/aes.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/tripledes.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/rc4.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/rabbit.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/blowfish.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c = x >> 8 & 255;
          let d = x & 255;
          let y = ctx.sbox[0][a] + ctx.sbox[1][b];
          y = y ^ ctx.sbox[2][c];
          y = y + ctx.sbox[3][d];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = 0; i < N; ++i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = N + 1; i > 1; --i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i = 0; i < N + 2; i += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i] = Data1;
            ctx.pbox[i + 1] = Data2;
          }
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i][j] = Data1;
              ctx.sbox[i][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          decryptBlock: function(M, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS.Blowfish;
    });
  }
});

// node_modules/@pushprotocol/restapi/node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/crypto-js/index.js"(exports, module) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core2(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md52(), require_sha12(), require_sha2564(), require_sha224(), require_sha512(), require_sha384(), require_sha32(), require_ripemd1603(), require_hmac2(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/aes.js
var require_aes2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/aes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateRandomSecret = exports.aesDecrypt = exports.aesEncrypt = void 0;
    var CryptoJS = require_crypto_js();
    var aesEncrypt = ({ plainText, secretKey }) => {
      return CryptoJS.AES.encrypt(plainText, secretKey).toString();
    };
    exports.aesEncrypt = aesEncrypt;
    var aesDecrypt = ({ cipherText, secretKey }) => {
      const bytes = CryptoJS.AES.decrypt(cipherText, secretKey);
      return bytes.toString(CryptoJS.enc.Utf8);
    };
    exports.aesDecrypt = aesDecrypt;
    var generateRandomSecret = (length) => {
      let result = "";
      const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      const charactersLength = characters.length;
      for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
    exports.generateRandomSecret = generateRandomSecret;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/pgp.js
var require_pgp = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/pgp.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pgpDecrypt = exports.verifySignature = exports.sign = exports.pgpEncrypt = exports.generateKeyPair = exports.PGPHelper = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var openpgp = (init_openpgp_min(), __toCommonJS(openpgp_min_exports));
    var PGPHelper = {
      generateKeyPair() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const keys = yield openpgp.generateKey({
            type: "rsa",
            rsaBits: 2048,
            userIDs: [{ name: "", email: "" }]
          });
          return {
            privateKeyArmored: keys.privateKey,
            publicKeyArmored: keys.publicKey
          };
        });
      },
      sign({ message, signingKey }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const messageObject = yield openpgp.createMessage({ text: message });
          const privateKey = yield openpgp.readPrivateKey({ armoredKey: signingKey });
          return yield openpgp.sign({ message: messageObject, signingKeys: privateKey, detached: true });
        });
      },
      pgpEncrypt({ plainText, keys }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const pgpKeys = [];
          for (let i = 0; i < keys.length; i++) {
            pgpKeys.push(yield openpgp.readKey({ armoredKey: keys[i] }));
          }
          const message = yield openpgp.createMessage({ text: plainText });
          const encrypted = yield openpgp.encrypt({
            message,
            encryptionKeys: pgpKeys
          });
          return encrypted;
        });
      },
      pgpDecrypt({ cipherText, toPrivateKeyArmored }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const message = yield openpgp.readMessage({ armoredMessage: cipherText });
          const privateKey = yield openpgp.readPrivateKey({ armoredKey: toPrivateKeyArmored });
          const { data: decrypted } = yield openpgp.decrypt({
            message,
            decryptionKeys: privateKey
          });
          return decrypted;
        });
      },
      verifySignature({ messageContent, signatureArmored, publicKeyArmored }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const message = yield openpgp.createMessage({ text: messageContent });
          const signature = yield openpgp.readSignature({
            armoredSignature: signatureArmored
          });
          const publicKey = yield openpgp.readKey({ armoredKey: publicKeyArmored });
          const verificationResult = yield openpgp.verify({
            // setting date to 1 day in the future to avoid issues with clock skew
            date: new Date(Date.now() + 1e3 * 60 * 60 * 24),
            message,
            signature,
            verificationKeys: publicKey
          });
          const { verified } = verificationResult.signatures[0];
          try {
            yield verified;
          } catch (e) {
            throw new Error("Signature could not be verified: " + e);
          }
        });
      }
    };
    exports.PGPHelper = PGPHelper;
    var generateKeyPair = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const keys = yield openpgp.generateKey({
        type: "rsa",
        rsaBits: 2048,
        userIDs: [{ name: "", email: "" }]
      });
      return {
        privateKeyArmored: keys.privateKey,
        publicKeyArmored: keys.publicKey
      };
    });
    exports.generateKeyPair = generateKeyPair;
    var pgpEncrypt = ({ plainText, keys }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const pgpKeys = [];
      for (let i = 0; i < keys.length; i++) {
        pgpKeys.push(yield openpgp.readKey({ armoredKey: keys[i] }));
      }
      const message = yield openpgp.createMessage({ text: plainText });
      const encrypted = yield openpgp.encrypt({
        message,
        encryptionKeys: pgpKeys
      });
      return encrypted;
    });
    exports.pgpEncrypt = pgpEncrypt;
    var sign = ({ message, signingKey }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const messageObject = yield openpgp.createMessage({ text: message });
      const privateKey = yield openpgp.readPrivateKey({ armoredKey: signingKey });
      return yield openpgp.sign({ message: messageObject, signingKeys: privateKey, detached: true });
    });
    exports.sign = sign;
    var verifySignature = ({ messageContent, signatureArmored, publicKeyArmored }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const message = yield openpgp.createMessage({ text: messageContent });
      const signature = yield openpgp.readSignature({
        armoredSignature: signatureArmored
      });
      const publicKey = yield openpgp.readKey({ armoredKey: publicKeyArmored });
      const verificationResult = yield openpgp.verify({
        message,
        signature,
        verificationKeys: publicKey
      });
      const { verified } = verificationResult.signatures[0];
      try {
        yield verified;
      } catch (e) {
        throw new Error("Signature could not be verified: " + e);
      }
    });
    exports.verifySignature = verifySignature;
    var pgpDecrypt = ({ cipherText, toPrivateKeyArmored }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const message = yield openpgp.readMessage({ armoredMessage: cipherText });
      const privateKey = yield openpgp.readPrivateKey({ armoredKey: toPrivateKeyArmored });
      const { data: decrypted } = yield openpgp.decrypt({
        message,
        decryptionKeys: privateKey
      });
      return decrypted;
    });
    exports.pgpDecrypt = pgpDecrypt;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/wallet.js
var require_wallet2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/wallet.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAccountAddress = exports.getWallet = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var getWallet = (options) => {
      const { account, signer } = options || {};
      return {
        account: account ? (0, helpers_1.pCAIP10ToWallet)(account) : account,
        signer
      };
    };
    exports.getWallet = getWallet;
    var getAccountAddress = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, signer } = options || {};
      const pushSigner = new helpers_1.Signer(signer);
      return account || (yield pushSigner.getAddress()) || "";
    });
    exports.getAccountAddress = getAccountAddress;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/user.js
var require_user = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/user.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getConnectedUserV2Core = exports.getConnectedUserV2 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var user_1 = require_user2();
    var wallet_1 = require_wallet2();
    var _1 = require_helpers2();
    var getConnectedUserV2 = (wallet, privateKey, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.getConnectedUserV2Core)(wallet, privateKey, env, _1.PGPHelper);
    });
    exports.getConnectedUserV2 = getConnectedUserV2;
    var getConnectedUserV2Core = (wallet, privateKey, env, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const address = yield (0, wallet_1.getAccountAddress)(wallet);
      const user = yield (0, user_1.get)({ account: address, env: env || constants_1.default.ENV.PROD });
      if (user === null || user === void 0 ? void 0 : user.encryptedPrivateKey) {
        if (privateKey) {
          return Object.assign(Object.assign({}, user), { privateKey });
        } else {
          console.warn("Please note that if you don't pass the pgpPrivateKey parameter, a wallet popup will appear every time the approveRequest endpoint is called. We strongly recommend passing this parameter, and it will become mandatory in future versions of the API.");
          const decryptedPrivateKey = yield (0, _1.getDecryptedPrivateKey)(wallet, user, address, env);
          return Object.assign(Object.assign({}, user), { privateKey: decryptedPrivateKey });
        }
      } else {
        const createUserProps = {};
        if (wallet.account) {
          createUserProps.account = wallet.account;
        }
        if (user && user.did) {
          createUserProps.account = user.did;
        }
        if (wallet.signer) {
          createUserProps.signer = wallet.signer;
        }
        createUserProps.env = env;
        const newUser = yield (0, user_1.createUserCore)(createUserProps, pgpHelper);
        const decryptedPrivateKey = yield (0, _1.getDecryptedPrivateKey)(wallet, newUser, address, env);
        return Object.assign(Object.assign({}, newUser), { privateKey: decryptedPrivateKey });
      }
    });
    exports.getConnectedUserV2Core = getConnectedUserV2Core;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/populateIUser.js
var require_populateIUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/populateIUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.populateDeprecatedUser = void 0;
    var populateDeprecatedUser = (user) => {
      if (!user)
        return user;
      user.name = user.profile.name;
      user.about = user.profile.desc;
      user.profilePicture = user.profile.picture;
      user.numMsg = user.msgSent;
      user.allowedNumMsg = user.maxMsgPersisted;
      let encryptionType = "";
      let sigType = "";
      let signature = "";
      try {
        const { version } = JSON.parse(user.encryptedPrivateKey);
        encryptionType = version;
      } catch (err) {
      }
      user.encryptionType = encryptionType;
      try {
        sigType = user.verificationProof.split(":")[0];
        signature = user.verificationProof.split(":")[1];
      } catch (err) {
      }
      user.signature = signature;
      user.sigType = sigType;
      user.encryptedPassword = null;
      user.nftOwner = null;
      user.linkedListHash = null;
      user.nfts = null;
      return user;
    };
    exports.populateDeprecatedUser = populateDeprecatedUser;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/axiosUtil.js
var require_axiosUtil = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/axiosUtil.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.axiosDelete = exports.axiosPut = exports.axiosPost = exports.axiosGet = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var packageJson = require_package();
    var version = packageJson.version;
    var addSdkVersionHeader = (config) => {
      const headers = Object.assign(Object.assign({}, config === null || config === void 0 ? void 0 : config.headers), { "X-JS-SDK-VERSION": version });
      return Object.assign(Object.assign({}, config), { headers });
    };
    var checkForDeprecationHeader = (response) => {
      var _a;
      const deprecationNotice = response.headers["x-deprecation-notice"];
      if (deprecationNotice) {
        const method = (_a = response.config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        const path = response.config.url;
        console.warn(`%cDeprecation Notice%c Method: ${method}, Path: ${path}, Notice: ${deprecationNotice}`, "color: white; background-color: red; font-weight: bold; padding: 2px 4px;", "color: red; font-weight: bold;");
      }
      return response;
    };
    var axiosGet = (url, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return axios_1.default.get(url, addSdkVersionHeader(config)).then((response) => checkForDeprecationHeader(response));
    });
    exports.axiosGet = axiosGet;
    var axiosPost = (url, data, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return axios_1.default.post(url, data, addSdkVersionHeader(config)).then((response) => checkForDeprecationHeader(response));
    });
    exports.axiosPost = axiosPost;
    var axiosPut = (url, data, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return axios_1.default.put(url, data, addSdkVersionHeader(config)).then((response) => checkForDeprecationHeader(response));
    });
    exports.axiosPut = axiosPut;
    var axiosDelete = (url, config) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return axios_1.default.delete(url, addSdkVersionHeader(config)).then((response) => checkForDeprecationHeader(response));
    });
    exports.axiosDelete = axiosDelete;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/service.js
var require_service = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/service.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessagesService = exports.getConversationHashService = exports.authUpdateUserService = exports.createUserService = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers3();
    var crypto_1 = require_crypto4();
    var populateIUser_1 = require_populateIUser();
    var axiosUtil_1 = require_axiosUtil();
    var createUserService = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { wallet, publicKey = "", encryptedPrivateKey = "", env = constants_1.default.ENV.PROD, origin } = options || {};
      let { user } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v2/users/`;
      if ((0, helpers_1.isValidNFTCAIP)(user)) {
        const epoch = Math.floor(Date.now() / 1e3);
        if (user.split(":").length !== 6) {
          user = `${user}:${epoch}`;
        }
      }
      const data = {
        caip10: (0, helpers_1.walletToPCAIP10)(user),
        did: (0, helpers_1.walletToPCAIP10)(user),
        publicKey,
        encryptedPrivateKey
      };
      const hash = (0, helpers_1.generateHash)(data);
      const signatureObj = yield (0, crypto_1.getEip191Signature)(wallet, hash, "v2");
      const body = Object.assign(Object.assign(Object.assign({}, data), { origin }), signatureObj);
      return (0, axiosUtil_1.axiosPost)(requestUrl, body).then((response) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (response.data)
          response.data.publicKey = yield (0, helpers_1.verifyProfileKeys)(response.data.encryptedPrivateKey, response.data.publicKey, response.data.did, response.data.wallets, response.data.verificationProof);
        return (0, populateIUser_1.populateDeprecatedUser)(response.data);
      })).catch((err) => {
        throw Error(`[Push SDK] - API ${requestUrl}: ${err}`);
      });
    });
    exports.createUserService = createUserService;
    var authUpdateUserService = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { user, wallet, publicKey = "", encryptedPrivateKey = "", env = constants_1.default.ENV.PROD } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v2/users/${(0, helpers_1.walletToPCAIP10)(user)}/auth`;
      const data = {
        caip10: (0, helpers_1.walletToPCAIP10)(user),
        did: (0, helpers_1.walletToPCAIP10)(user),
        publicKey,
        encryptedPrivateKey
      };
      const hash = (0, helpers_1.generateHash)(data);
      const signatureObj = yield (0, crypto_1.getEip191Signature)(wallet, hash, "v2");
      const _a = Object.assign(Object.assign({}, data), signatureObj), { did } = _a, body = tslib_1.__rest(_a, ["did"]);
      return (0, axiosUtil_1.axiosPut)(requestUrl, body).then((response) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (response.data)
          response.data.publicKey = yield (0, helpers_1.verifyProfileKeys)(response.data.encryptedPrivateKey, response.data.publicKey, response.data.did, response.data.wallets, response.data.verificationProof);
        return (0, populateIUser_1.populateDeprecatedUser)(response.data);
      })).catch((err) => {
        throw Error(`[Push SDK] - API ${requestUrl}: ${err}`);
      });
    });
    exports.authUpdateUserService = authUpdateUserService;
    var getConversationHashService = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { conversationId, account, env = constants_1.default.ENV.PROD } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v1/chat/users/${(0, helpers_1.walletToPCAIP10)(account)}/conversations/${conversationId}/hash`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        return response.data;
      }).catch((err) => {
        throw new Error(err);
      });
    });
    exports.getConversationHashService = getConversationHashService;
    var getMessagesService = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { threadhash, limit, env = constants_1.default.ENV.PROD } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/chat/conversationhash/${threadhash}`;
      const queryObj = {
        fetchLimit: limit
      };
      const requestUrl = `${apiEndpoint}?${(0, helpers_1.getQueryParams)(queryObj)}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        return response.data;
      }).catch((err) => {
        throw new Error(err);
      });
    });
    exports.getMessagesService = getMessagesService;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert4 = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils9 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto3();
    var _assert_js_1 = require_assert4();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert4();
    var utils_js_1 = require_utils9();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha2565 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils9();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac3 = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert4();
    var utils_js_1 = require_utils9();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/utils.js
var require_utils10 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitMask = void 0;
    exports.isBytes = isBytes;
    exports.abytes = abytes;
    exports.bytesToHex = bytesToHex;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.hexToBytes = hexToBytes;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.concatBytes = concatBytes;
    exports.equalBytes = equalBytes;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/modular.js
var require_modular2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils10();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/curve.js
var require_curve2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = wNAF;
    exports.validateBasic = validateBasic;
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils10();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = void 0;
    exports.weierstrassPoints = weierstrassPoints;
    exports.weierstrass = weierstrass;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve2();
    var mod = require_modular2();
    var ut = require_utils10();
    var utils_js_1 = require_utils10();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var hmac_1 = require_hmac3();
    var utils_1 = require_utils9();
    var weierstrass_js_1 = require_weierstrass2();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve2 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils10();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@ethereumjs/util/node_modules/@noble/curves/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha2565();
    var utils_1 = require_utils9();
    var _shortw_utils_js_1 = require_shortw_utils2();
    var hash_to_curve_js_1 = require_hash_to_curve2();
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils10();
    var weierstrass_js_1 = require_weierstrass2();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js
var require_secp256k13 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/secp256k1.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = void 0;
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.secp256k1;
    } });
  }
});

// node_modules/@ethereumjs/util/dist/constants.js
var require_constants3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/constants.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    var secp256k1_1 = require_secp256k13();
    exports.MAX_UINT64 = BigInt("0xffffffffffffffff");
    exports.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
    exports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;
    exports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);
    exports.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, "hex");
    exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([128]);
    exports.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
  }
});

// node_modules/@ethereumjs/util/dist/units.js
var require_units = __commonJS({
  "node_modules/@ethereumjs/util/dist/units.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GWEI_TO_WEI = void 0;
    exports.GWEI_TO_WEI = BigInt(1e9);
  }
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@ethereumjs/rlp/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RLP = exports.utils = exports.decode = exports.encode = void 0;
    function encode(input) {
      if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for (let i = 0; i < input.length; i++) {
          const encoded = encode(input[i]);
          output.push(encoded);
          outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
      }
      const inputBuf = toBytes(input);
      if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
      }
      return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
    }
    exports.encode = encode;
    function safeSlice(input, start, end) {
      if (end > input.length) {
        throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
      }
      return input.slice(start, end);
    }
    function decodeLength(v) {
      if (v[0] === 0) {
        throw new Error("invalid RLP: extra zeros");
      }
      return parseHexByte(bytesToHex(v));
    }
    function encodeLength(len, offset) {
      if (len < 56) {
        return Uint8Array.from([len + offset]);
      }
      const hexLength = numberToHex(len);
      const lLength = hexLength.length / 2;
      const firstByte = numberToHex(offset + 55 + lLength);
      return Uint8Array.from(hexToBytes(firstByte + hexLength));
    }
    function decode(input, stream = false) {
      if (typeof input === "undefined" || input === null || input.length === 0) {
        return Uint8Array.from([]);
      }
      const inputBytes = toBytes(input);
      const decoded = _decode(inputBytes);
      if (stream) {
        return decoded;
      }
      if (decoded.remainder.length !== 0) {
        throw new Error("invalid RLP: remainder must be zero");
      }
      return decoded.data;
    }
    exports.decode = decode;
    function _decode(input) {
      let length, llength, data, innerRemainder, d;
      const decoded = [];
      const firstByte = input[0];
      if (firstByte <= 127) {
        return {
          data: input.slice(0, 1),
          remainder: input.slice(1)
        };
      } else if (firstByte <= 183) {
        length = firstByte - 127;
        if (firstByte === 128) {
          data = Uint8Array.from([]);
        } else {
          data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 128) {
          throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
        }
        return {
          data,
          remainder: input.slice(length)
        };
      } else if (firstByte <= 191) {
        llength = firstByte - 182;
        if (input.length - 1 < llength) {
          throw new Error("invalid RLP: not enough bytes for string length");
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
          throw new Error("invalid RLP: expected string length to be greater than 55");
        }
        data = safeSlice(input, llength, length + llength);
        return {
          data,
          remainder: input.slice(length + llength)
        };
      } else if (firstByte <= 247) {
        length = firstByte - 191;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(length)
        };
      } else {
        llength = firstByte - 246;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
          throw new Error("invalid RLP: encoded list too short");
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
          throw new Error("invalid RLP: total length is larger than the data");
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
          d = _decode(innerRemainder);
          decoded.push(d.data);
          innerRemainder = d.remainder;
        }
        return {
          data: decoded,
          remainder: input.slice(totalLength)
        };
      }
    }
    var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
      }
      return hex;
    }
    function parseHexByte(hexByte) {
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte))
        throw new Error("Invalid byte sequence");
      return byte;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
      }
      return array;
    }
    function concatBytes(...arrays) {
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function utf8ToBytes(utf) {
      return new TextEncoder().encode(utf);
    }
    function numberToHex(integer) {
      if (integer < 0) {
        throw new Error("Invalid integer as argument, must be unsigned!");
      }
      const hex = integer.toString(16);
      return hex.length % 2 ? `0${hex}` : hex;
    }
    function padToEven(a) {
      return a.length % 2 ? `0${a}` : a;
    }
    function isHexPrefixed(str) {
      return str.length >= 2 && str[0] === "0" && str[1] === "x";
    }
    function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    }
    function toBytes(v) {
      if (v instanceof Uint8Array) {
        return v;
      }
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
      }
      if (typeof v === "number" || typeof v === "bigint") {
        if (!v) {
          return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
      }
      if (v === null || v === void 0) {
        return Uint8Array.from([]);
      }
      throw new Error("toBytes: received unsupported type " + typeof v);
    }
    exports.utils = {
      bytesToHex,
      concatBytes,
      hexToBytes,
      utf8ToBytes
    };
    exports.RLP = { encode, decode };
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u642 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha33 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert4();
    var _u64_js_1 = require_u642();
    var utils_js_1 = require_utils9();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js
var require_utils11 = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.hexToBytes = hexToBytes;
    exports.equalsBytes = equalsBytes;
    exports.wrapHash = wrapHash;
    var _assert_1 = __importDefault(require_assert4());
    var utils_1 = require_utils9();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils9();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js
var require_keccak = __commonJS({
  "node_modules/@ethereumjs/util/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha33();
    var utils_js_1 = require_utils11();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/@ethereumjs/util/dist/internal.js
var require_internal = __commonJS({
  "node_modules/@ethereumjs/util/dist/internal.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;
    function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
      }
      return str[0] === "0" && str[1] === "x";
    }
    exports.isHexPrefixed = isHexPrefixed;
    var stripHexPrefix = (str) => {
      if (typeof str !== "string")
        throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
    exports.stripHexPrefix = stripHexPrefix;
    function padToEven(value) {
      let a = value;
      if (typeof a !== "string") {
        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
      }
      if (a.length % 2)
        a = `0${a}`;
      return a;
    }
    exports.padToEven = padToEven;
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);
      }
      return Buffer.byteLength(str, "utf8");
    }
    exports.getBinarySize = getBinarySize;
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);
      }
      if (Array.isArray(subset) !== true) {
        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);
      }
      return subset[some === true ? "some" : "every"]((value) => superset.indexOf(value) >= 0);
    }
    exports.arrayContainsArray = arrayContainsArray;
    function toAscii(hex) {
      let str = "";
      let i = 0;
      const l = hex.length;
      if (hex.substring(0, 2) === "0x")
        i = 2;
      for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    exports.toAscii = toAscii;
    function fromUtf8(stringValue) {
      const str = Buffer.from(stringValue, "utf8");
      return `0x${padToEven(str.toString("hex")).replace(/^0+|0+$/g, "")}`;
    }
    exports.fromUtf8 = fromUtf8;
    function fromAscii(stringValue) {
      let hex = "";
      for (let i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
      }
      return `0x${hex}`;
    }
    exports.fromAscii = fromAscii;
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);
      }
      if (typeof key !== "string") {
        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);
      }
      const result = [];
      for (let i = 0; i < params.length; i++) {
        let value = params[i][key];
        if (allowEmpty === true && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);
        }
        result.push(value);
      }
      return result;
    }
    exports.getKeys = getKeys;
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
        return false;
      if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
        return false;
      return true;
    }
    exports.isHexString = isHexString;
  }
});

// node_modules/@ethereumjs/util/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/@ethereumjs/util/dist/helpers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;
    var internal_1 = require_internal();
    var assertIsHexString = function(input) {
      if (!(0, internal_1.isHexString)(input)) {
        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsHexString = assertIsHexString;
    var assertIsBuffer = function(input) {
      if (!Buffer.isBuffer(input)) {
        const msg = `This method only supports Buffer but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsBuffer = assertIsBuffer;
    var assertIsArray = function(input) {
      if (!Array.isArray(input)) {
        const msg = `This method only supports number arrays but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsArray = assertIsArray;
    var assertIsString = function(input) {
      if (typeof input !== "string") {
        const msg = `This method only supports strings but input was: ${input}`;
        throw new Error(msg);
      }
    };
    exports.assertIsString = assertIsString;
  }
});

// node_modules/@ethereumjs/util/dist/bytes.js
var require_bytes2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/bytes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var intToHex = function(i) {
      if (!Number.isSafeInteger(i) || i < 0) {
        throw new Error(`Received an invalid integer type: ${i}`);
      }
      return `0x${i.toString(16)}`;
    };
    exports.intToHex = intToHex;
    var intToBuffer = function(i) {
      const hex = (0, exports.intToHex)(i);
      return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), "hex");
    };
    exports.intToBuffer = intToBuffer;
    var zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.zeros = zeros;
    var setLength = function(msg, length, right) {
      const buf = (0, exports.zeros)(length);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    var setLengthLeft = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, false);
    };
    exports.setLengthLeft = setLengthLeft;
    var setLengthRight = function(msg, length) {
      (0, helpers_1.assertIsBuffer)(msg);
      return setLength(msg, length, true);
    };
    exports.setLengthRight = setLengthRight;
    var stripZeros = function(a) {
      let first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    var unpadBuffer = function(a) {
      (0, helpers_1.assertIsBuffer)(a);
      return stripZeros(a);
    };
    exports.unpadBuffer = unpadBuffer;
    var unpadArray = function(a) {
      (0, helpers_1.assertIsArray)(a);
      return stripZeros(a);
    };
    exports.unpadArray = unpadArray;
    var unpadHexString = function(a) {
      (0, helpers_1.assertIsHexString)(a);
      a = (0, internal_1.stripHexPrefix)(a);
      return "0x" + stripZeros(a);
    };
    exports.unpadHexString = unpadHexString;
    var toBuffer = function(v) {
      if (v === null || v === void 0) {
        return Buffer.allocUnsafe(0);
      }
      if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
      }
      if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
      }
      if (typeof v === "string") {
        if (!(0, internal_1.isHexString)(v)) {
          throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), "hex");
      }
      if (typeof v === "number") {
        return (0, exports.intToBuffer)(v);
      }
      if (typeof v === "bigint") {
        if (v < BigInt(0)) {
          throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);
        }
        let n = v.toString(16);
        if (n.length % 2)
          n = "0" + n;
        return Buffer.from(n, "hex");
      }
      if (v.toArray) {
        return Buffer.from(v.toArray());
      }
      if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
      }
      throw new Error("invalid type");
    };
    exports.toBuffer = toBuffer;
    var bufferToHex = function(buf) {
      buf = (0, exports.toBuffer)(buf);
      return "0x" + buf.toString("hex");
    };
    exports.bufferToHex = bufferToHex;
    function bufferToBigInt(buf) {
      const hex = (0, exports.bufferToHex)(buf);
      if (hex === "0x") {
        return BigInt(0);
      }
      return BigInt(hex);
    }
    exports.bufferToBigInt = bufferToBigInt;
    function bigIntToBuffer(num) {
      return (0, exports.toBuffer)("0x" + num.toString(16));
    }
    exports.bigIntToBuffer = bigIntToBuffer;
    var bufferToInt = function(buf) {
      const res = Number(bufferToBigInt(buf));
      if (!Number.isSafeInteger(res))
        throw new Error("Number exceeds 53 bits");
      return res;
    };
    exports.bufferToInt = bufferToInt;
    var fromSigned = function(num) {
      return BigInt.asIntN(256, bufferToBigInt(num));
    };
    exports.fromSigned = fromSigned;
    var toUnsigned = function(num) {
      return bigIntToBuffer(BigInt.asUintN(256, num));
    };
    exports.toUnsigned = toUnsigned;
    var addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return (0, internal_1.isHexPrefixed)(str) ? str : "0x" + str;
    };
    exports.addHexPrefix = addHexPrefix;
    function short(buffer, maxLength = 50) {
      const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString("hex") : buffer;
      if (bufferStr.length <= maxLength) {
        return bufferStr;
      }
      return bufferStr.slice(0, maxLength) + "…";
    }
    exports.short = short;
    var toUtf8 = function(hex) {
      const zerosRegexp = /^(00)+|(00)+$/g;
      hex = (0, internal_1.stripHexPrefix)(hex);
      if (hex.length % 2 !== 0) {
        throw new Error("Invalid non-even hex string input for toUtf8() provided");
      }
      const bufferVal = Buffer.from(hex.replace(zerosRegexp, ""), "hex");
      return bufferVal.toString("utf8");
    };
    exports.toUtf8 = toUtf8;
    var baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return `0x${ba.toString("hex")}`;
      } else if (ba instanceof Array) {
        const array = [];
        for (let i = 0; i < ba.length; i++) {
          array.push((0, exports.baToJSON)(ba[i]));
        }
        return array;
      }
    };
    exports.baToJSON = baToJSON;
    var validateNoLeadingZeroes = function(values) {
      for (const [k, v] of Object.entries(values)) {
        if (v !== void 0 && v.length > 0 && v[0] === 0) {
          throw new Error(`${k} cannot have leading zeroes, received: ${v.toString("hex")}`);
        }
      }
    };
    exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
    function arrToBufArr(arr) {
      if (!Array.isArray(arr)) {
        return Buffer.from(arr);
      }
      return arr.map((a) => arrToBufArr(a));
    }
    exports.arrToBufArr = arrToBufArr;
    function bufArrToArr(arr) {
      if (!Array.isArray(arr)) {
        return Uint8Array.from(arr ?? []);
      }
      return arr.map((a) => bufArrToArr(a));
    }
    exports.bufArrToArr = bufArrToArr;
    var bigIntToHex = (num) => {
      return "0x" + num.toString(16);
    };
    exports.bigIntToHex = bigIntToHex;
    function bigIntToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)(bigIntToBuffer(value));
    }
    exports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;
    function intToUnpaddedBuffer(value) {
      return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));
    }
    exports.intToUnpaddedBuffer = intToUnpaddedBuffer;
  }
});

// node_modules/@ethereumjs/util/dist/account.js
var require_account2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/account.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
    var rlp_1 = require_dist4();
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k13();
    var utils_1 = require_utils11();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers();
    var internal_1 = require_internal();
    var _0n = BigInt(0);
    var Account = class _Account {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating an Account from varying data types.
       */
      constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL) {
        this.nonce = nonce;
        this.balance = balance;
        this.storageRoot = storageRoot;
        this.codeHash = codeHash;
        this._validate();
      }
      static fromAccountData(accountData) {
        const { nonce, balance, storageRoot, codeHash } = accountData;
        return new _Account(nonce !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : void 0, balance !== void 0 ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : void 0, storageRoot !== void 0 ? (0, bytes_1.toBuffer)(storageRoot) : void 0, codeHash !== void 0 ? (0, bytes_1.toBuffer)(codeHash) : void 0);
      }
      static fromRlpSerializedAccount(serialized) {
        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized account input. Must be array");
        }
        return this.fromValuesArray(values);
      }
      static fromValuesArray(values) {
        const [nonce, balance, storageRoot, codeHash] = values;
        return new _Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);
      }
      _validate() {
        if (this.nonce < _0n) {
          throw new Error("nonce must be greater than zero");
        }
        if (this.balance < _0n) {
          throw new Error("balance must be greater than zero");
        }
        if (this.storageRoot.length !== 32) {
          throw new Error("storageRoot must have a length of 32");
        }
        if (this.codeHash.length !== 32) {
          throw new Error("codeHash must have a length of 32");
        }
      }
      /**
       * Returns a Buffer Array of the raw Buffers for the account, in order.
       */
      raw() {
        return [
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),
          this.storageRoot,
          this.codeHash
        ];
      }
      /**
       * Returns the RLP serialization of the account as a `Buffer`.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));
      }
      /**
       * Returns a `Boolean` determining if the account is a contract.
       */
      isContract() {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
      /**
       * Returns a `Boolean` determining if the account is empty complying to the definition of
       * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
       * "An account is considered empty when it has no code and zero nonce and zero balance."
       */
      isEmpty() {
        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);
      }
    };
    exports.Account = Account;
    var isValidAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
    };
    exports.isValidAddress = isValidAddress;
    var toChecksumAddress = function(hexAddress, eip1191ChainId) {
      (0, helpers_1.assertIsHexString)(hexAddress);
      const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();
      let prefix = "";
      if (eip1191ChainId !== void 0) {
        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));
        prefix = chainId.toString() + "0x";
      }
      const buf = Buffer.from(prefix + address, "utf8");
      const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));
      let ret = "0x";
      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.toChecksumAddress = toChecksumAddress;
    var isValidChecksumAddress = function(hexAddress, eip1191ChainId) {
      return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;
    };
    exports.isValidChecksumAddress = isValidChecksumAddress;
    var generateAddress = function(from, nonce) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(nonce);
      if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, null])))).slice(-20);
      }
      return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([from, nonce])))).slice(-20);
    };
    exports.generateAddress = generateAddress;
    var generateAddress2 = function(from, salt, initCode) {
      (0, helpers_1.assertIsBuffer)(from);
      (0, helpers_1.assertIsBuffer)(salt);
      (0, helpers_1.assertIsBuffer)(initCode);
      if (from.length !== 20) {
        throw new Error("Expected from to be of length 20");
      }
      if (salt.length !== 32) {
        throw new Error("Expected salt to be of length 32");
      }
      const address = (0, keccak_1.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), from, salt, (0, keccak_1.keccak256)(initCode)]));
      return (0, bytes_1.toBuffer)(address).slice(-20);
    };
    exports.generateAddress2 = generateAddress2;
    var isValidPrivate = function(privateKey) {
      return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);
    };
    exports.isValidPrivate = isValidPrivate;
    var isValidPublic = function(publicKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length === 64) {
        try {
          secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), publicKey]));
          return true;
        } catch (e) {
          return false;
        }
      }
      if (!sanitize) {
        return false;
      }
      try {
        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
        return true;
      } catch (e) {
        return false;
      }
    };
    exports.isValidPublic = isValidPublic;
    var pubToAddress = function(pubKey, sanitize = false) {
      (0, helpers_1.assertIsBuffer)(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));
      }
      if (pubKey.length !== 64) {
        throw new Error("Expected pubKey to be of length 64");
      }
      return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);
    };
    exports.pubToAddress = pubToAddress;
    exports.publicToAddress = exports.pubToAddress;
    var privateToPublic = function(privateKey) {
      (0, helpers_1.assertIsBuffer)(privateKey);
      return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));
    };
    exports.privateToPublic = privateToPublic;
    var privateToAddress = function(privateKey) {
      return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
    };
    exports.privateToAddress = privateToAddress;
    var importPublic = function(publicKey) {
      (0, helpers_1.assertIsBuffer)(publicKey);
      if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));
      }
      return publicKey;
    };
    exports.importPublic = importPublic;
    var zeroAddress = function() {
      const addressLength = 20;
      const addr = (0, bytes_1.zeros)(addressLength);
      return (0, bytes_1.bufferToHex)(addr);
    };
    exports.zeroAddress = zeroAddress;
    var isZeroAddress = function(hexAddress) {
      try {
        (0, helpers_1.assertIsString)(hexAddress);
      } catch (e) {
        return false;
      }
      const zeroAddr = (0, exports.zeroAddress)();
      return zeroAddr === hexAddress;
    };
    exports.isZeroAddress = isZeroAddress;
    function accountBodyFromSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash
      ];
    }
    exports.accountBodyFromSlim = accountBodyFromSlim;
    var emptyUint8Arr = new Uint8Array(0);
    function accountBodyToSlim(body) {
      const [nonce, balance, storageRoot, codeHash] = body;
      return [
        nonce,
        balance,
        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,
        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash
      ];
    }
    exports.accountBodyToSlim = accountBodyToSlim;
    function accountBodyToRLP(body, couldBeSlim = true) {
      const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;
      return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));
    }
    exports.accountBodyToRLP = accountBodyToRLP;
  }
});

// node_modules/@ethereumjs/util/dist/address.js
var require_address3 = __commonJS({
  "node_modules/@ethereumjs/util/dist/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address = void 0;
    var account_1 = require_account2();
    var bytes_1 = require_bytes2();
    var Address = class _Address {
      constructor(buf) {
        if (buf.length !== 20) {
          throw new Error("Invalid address length");
        }
        this.buf = buf;
      }
      /**
       * Returns the zero address.
       */
      static zero() {
        return new _Address((0, bytes_1.zeros)(20));
      }
      /**
       * Returns an Address object from a hex-encoded string.
       * @param str - Hex-encoded address
       */
      static fromString(str) {
        if (!(0, account_1.isValidAddress)(str)) {
          throw new Error("Invalid address");
        }
        return new _Address((0, bytes_1.toBuffer)(str));
      }
      /**
       * Returns an address for a given public key.
       * @param pubKey The two points of an uncompressed key
       */
      static fromPublicKey(pubKey) {
        if (!Buffer.isBuffer(pubKey)) {
          throw new Error("Public key should be Buffer");
        }
        const buf = (0, account_1.pubToAddress)(pubKey);
        return new _Address(buf);
      }
      /**
       * Returns an address for a given private key.
       * @param privateKey A private key must be 256 bits wide
       */
      static fromPrivateKey(privateKey) {
        if (!Buffer.isBuffer(privateKey)) {
          throw new Error("Private key should be Buffer");
        }
        const buf = (0, account_1.privateToAddress)(privateKey);
        return new _Address(buf);
      }
      /**
       * Generates an address for a newly created contract.
       * @param from The address which is creating this new address
       * @param nonce The nonce of the from account
       */
      static generate(from, nonce) {
        if (typeof nonce !== "bigint") {
          throw new Error("Expected nonce to be a bigint");
        }
        return new _Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));
      }
      /**
       * Generates an address for a contract created using CREATE2.
       * @param from The address which is creating this new address
       * @param salt A salt
       * @param initCode The init code of the contract being created
       */
      static generate2(from, salt, initCode) {
        if (!Buffer.isBuffer(salt)) {
          throw new Error("Expected salt to be a Buffer");
        }
        if (!Buffer.isBuffer(initCode)) {
          throw new Error("Expected initCode to be a Buffer");
        }
        return new _Address((0, account_1.generateAddress2)(from.buf, salt, initCode));
      }
      /**
       * Is address equal to another.
       */
      equals(address) {
        return this.buf.equals(address.buf);
      }
      /**
       * Is address zero.
       */
      isZero() {
        return this.equals(_Address.zero());
      }
      /**
       * True if address is in the address range defined
       * by EIP-1352
       */
      isPrecompileOrSystemAddress() {
        const address = (0, bytes_1.bufferToBigInt)(this.buf);
        const rangeMin = BigInt(0);
        const rangeMax = BigInt("0xffff");
        return address >= rangeMin && address <= rangeMax;
      }
      /**
       * Returns hex encoding of address.
       */
      toString() {
        return "0x" + this.buf.toString("hex");
      }
      /**
       * Returns Buffer representation of address.
       */
      toBuffer() {
        return Buffer.from(this.buf);
      }
    };
    exports.Address = Address;
  }
});

// node_modules/@ethereumjs/util/dist/types.js
var require_types = __commonJS({
  "node_modules/@ethereumjs/util/dist/types.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toType = exports.TypeOutput = void 0;
    var bytes_1 = require_bytes2();
    var internal_1 = require_internal();
    var TypeOutput;
    (function(TypeOutput2) {
      TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
      TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
      TypeOutput2[TypeOutput2["Buffer"] = 2] = "Buffer";
      TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
    })(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
    function toType(input, outputType) {
      if (input === null) {
        return null;
      }
      if (input === void 0) {
        return void 0;
      }
      if (typeof input === "string" && !(0, internal_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
      } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      }
      const output = (0, bytes_1.toBuffer)(input);
      switch (outputType) {
        case TypeOutput.Buffer:
          return output;
        case TypeOutput.BigInt:
          return (0, bytes_1.bufferToBigInt)(output);
        case TypeOutput.Number: {
          const bigInt = (0, bytes_1.bufferToBigInt)(output);
          if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          }
          return Number(bigInt);
        }
        case TypeOutput.PrefixedHexString:
          return (0, bytes_1.bufferToHex)(output);
        default:
          throw new Error("unknown outputType");
      }
    }
    exports.toType = toType;
  }
});

// node_modules/@ethereumjs/util/dist/withdrawal.js
var require_withdrawal = __commonJS({
  "node_modules/@ethereumjs/util/dist/withdrawal.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Withdrawal = void 0;
    var address_1 = require_address3();
    var bytes_1 = require_bytes2();
    var types_1 = require_types();
    var Withdrawal = class _Withdrawal {
      /**
       * This constructor assigns and validates the values.
       * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
       * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
       */
      constructor(index, validatorIndex, address, amount) {
        this.index = index;
        this.validatorIndex = validatorIndex;
        this.address = address;
        this.amount = amount;
      }
      static fromWithdrawalData(withdrawalData) {
        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;
        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);
        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);
        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));
        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);
        return new _Withdrawal(index, validatorIndex, address, amount);
      }
      static fromValuesArray(withdrawalArray) {
        if (withdrawalArray.length !== 4) {
          throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);
        }
        const [index, validatorIndex, address, amount] = withdrawalArray;
        return _Withdrawal.fromWithdrawalData({ index, validatorIndex, address, amount });
      }
      /**
       * Convert a withdrawal to a buffer array
       * @param withdrawal the withdrawal to convert
       * @returns buffer array of the withdrawal
       */
      static toBufferArray(withdrawal) {
        const { index, validatorIndex, address, amount } = withdrawal;
        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);
        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);
        let addressBuffer;
        if (address instanceof address_1.Address) {
          addressBuffer = address.buf;
        } else {
          addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);
        }
        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);
        return [indexBuffer, validatorIndexBuffer, addressBuffer, amountBuffer];
      }
      raw() {
        return _Withdrawal.toBufferArray(this);
      }
      toValue() {
        return {
          index: this.index,
          validatorIndex: this.validatorIndex,
          address: this.address.buf,
          amount: this.amount
        };
      }
      toJSON() {
        return {
          index: (0, bytes_1.bigIntToHex)(this.index),
          validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),
          address: "0x" + this.address.buf.toString("hex"),
          amount: (0, bytes_1.bigIntToHex)(this.amount)
        };
      }
    };
    exports.Withdrawal = Withdrawal;
  }
});

// node_modules/@ethereumjs/util/dist/signature.js
var require_signature2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/signature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var keccak_1 = require_keccak();
    var secp256k1_1 = require_secp256k13();
    var bytes_1 = require_bytes2();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers();
    function ecsign(msgHash, privateKey, chainId) {
      const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);
      const buf = sig.toCompactRawBytes();
      const r = Buffer.from(buf.slice(0, 32));
      const s = Buffer.from(buf.slice(32, 64));
      const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
      return { r, s, v };
    }
    exports.ecsign = ecsign;
    function calculateSigRecovery(v, chainId) {
      if (v === BigInt(0) || v === BigInt(1))
        return v;
      if (chainId === void 0) {
        return v - BigInt(27);
      }
      return v - (chainId * BigInt(2) + BigInt(35));
    }
    function isValidSigRecovery(recovery) {
      return recovery === BigInt(0) || recovery === BigInt(1);
    }
    var ecrecover = function(msgHash, v, r, s, chainId) {
      const signature = Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32)], 64);
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
      const senderPubKey = sig.recoverPublicKey(msgHash);
      return Buffer.from(senderPubKey.toRawBytes(false).slice(1));
    };
    exports.ecrecover = ecrecover;
    var toRpcSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(s, 32), (0, bytes_1.toBuffer)(v)]));
    };
    exports.toRpcSig = toRpcSig;
    var toCompactSig = function(v, r, s, chainId) {
      const recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      let ss = s;
      if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {
        ss = Buffer.from(s);
        ss[0] |= 128;
      }
      return (0, bytes_1.bufferToHex)(Buffer.concat([(0, bytes_1.setLengthLeft)(r, 32), (0, bytes_1.setLengthLeft)(ss, 32)]));
    };
    exports.toCompactSig = toCompactSig;
    var fromRpcSig = function(sig) {
      const buf = (0, bytes_1.toBuffer)(sig);
      let r;
      let s;
      let v;
      if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));
      } else if (buf.length === 64) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);
        s[0] &= 127;
      } else {
        throw new Error("Invalid signature length");
      }
      if (v < 27) {
        v = v + BigInt(27);
      }
      return {
        v,
        r,
        s
      };
    };
    exports.fromRpcSig = fromRpcSig;
    var isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      const rBigInt = (0, bytes_1.bufferToBigInt)(r);
      const sBigInt = (0, bytes_1.bufferToBigInt)(s);
      if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {
        return false;
      }
      if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {
        return false;
      }
      return true;
    };
    exports.isValidSignature = isValidSignature;
    var hashPersonalMessage = function(message) {
      (0, helpers_1.assertIsBuffer)(message);
      const prefix = Buffer.from(`Ethereum Signed Message:
${message.length}`, "utf-8");
      return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([prefix, message])));
    };
    exports.hashPersonalMessage = hashPersonalMessage;
  }
});

// node_modules/@ethereumjs/util/dist/encoding.js
var require_encoding2 = __commonJS({
  "node_modules/@ethereumjs/util/dist/encoding.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;
    var hasTerminator = (nibbles) => {
      return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;
    };
    exports.hasTerminator = hasTerminator;
    var nibblesToBytes = (nibbles, bytes) => {
      for (let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2) {
        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];
      }
    };
    exports.nibblesToBytes = nibblesToBytes;
    var nibblesToCompactBytes = (nibbles) => {
      let terminator = 0;
      if ((0, exports.hasTerminator)(nibbles)) {
        terminator = 1;
        nibbles = nibbles.subarray(0, nibbles.length - 1);
      }
      const buf = new Uint8Array(nibbles.length / 2 + 1);
      buf[0] = terminator << 5;
      if ((nibbles.length & 1) === 1) {
        buf[0] |= 1 << 4;
        buf[0] |= nibbles[0];
        nibbles = nibbles.subarray(1);
      }
      (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));
      return buf;
    };
    exports.nibblesToCompactBytes = nibblesToCompactBytes;
    var bytesToNibbles = (str) => {
      const l = str.length * 2 + 1;
      const nibbles = new Uint8Array(l);
      for (let i = 0; i < str.length; i++) {
        const b = str[i];
        nibbles[i * 2] = b / 16;
        nibbles[i * 2 + 1] = b % 16;
      }
      nibbles[l - 1] = 16;
      return nibbles;
    };
    exports.bytesToNibbles = bytesToNibbles;
    var compactBytesToNibbles = (compact) => {
      if (compact.length === 0) {
        return compact;
      }
      let base = (0, exports.bytesToNibbles)(compact);
      if (base[0] < 2) {
        base = base.subarray(0, base.length - 1);
      }
      const chop = 2 - (base[0] & 1);
      return base.subarray(chop);
    };
    exports.compactBytesToNibbles = compactBytesToNibbles;
  }
});

// node_modules/@ethereumjs/util/dist/asyncEventEmitter.js
var require_asyncEventEmitter = __commonJS({
  "node_modules/@ethereumjs/util/dist/asyncEventEmitter.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncEventEmitter = void 0;
    var events_1 = require_events();
    async function runInSeries(context, tasks, data) {
      let error;
      for await (const task of tasks) {
        try {
          if (task.length < 2) {
            task.call(context, data);
          } else {
            await new Promise((resolve, reject) => {
              task.call(context, data, (error2) => {
                if (error2) {
                  reject(error2);
                } else {
                  resolve();
                }
              });
            });
          }
        } catch (e) {
          error = e;
        }
      }
      if (error) {
        throw error;
      }
    }
    var AsyncEventEmitter = class extends events_1.EventEmitter {
      emit(event, ...args) {
        let [data, callback] = args;
        const self2 = this;
        let listeners = self2._events[event] ?? [];
        if (callback === void 0 && typeof data === "function") {
          callback = data;
          data = void 0;
        }
        if (event === "newListener" || event === "removeListener") {
          data = {
            event: data,
            fn: callback
          };
          callback = void 0;
        }
        listeners = Array.isArray(listeners) ? listeners : [listeners];
        runInSeries(self2, listeners.slice(), data).then(callback).catch(callback);
        return self2.listenerCount(event) > 0;
      }
      once(event, listener) {
        const self2 = this;
        let g;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (listener.length >= 2) {
          g = function(e, next) {
            self2.removeListener(event, g);
            void listener(e, next);
          };
        } else {
          g = function(e) {
            self2.removeListener(event, g);
            void listener(e, g);
          };
        }
        self2.on(event, g);
        return self2;
      }
      first(event, listener) {
        let listeners = this._events[event] ?? [];
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        listeners.unshift(listener);
        return this;
      }
      before(event, target, listener) {
        return this.beforeOrAfter(event, target, listener);
      }
      after(event, target, listener) {
        return this.beforeOrAfter(event, target, listener, "after");
      }
      beforeOrAfter(event, target, listener, beforeOrAfter) {
        let listeners = this._events[event] ?? [];
        let i;
        let index;
        const add = beforeOrAfter === "after" ? 1 : 0;
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
        if (typeof target !== "function") {
          throw new TypeError("target must be a function");
        }
        if (!Array.isArray(listeners)) {
          ;
          this._events[event] = listeners = [listeners];
        }
        index = listeners.length;
        for (i = listeners.length; i--; ) {
          if (listeners[i] === target) {
            index = i + add;
            break;
          }
        }
        listeners.splice(index, 0, listener);
        return this;
      }
      on(event, listener) {
        return super.on(event, listener);
      }
      addListener(event, listener) {
        return super.addListener(event, listener);
      }
      prependListener(event, listener) {
        return super.prependListener(event, listener);
      }
      prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
      }
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      removeListener(event, listener) {
        return super.removeListener(event, listener);
      }
      eventNames() {
        return super.eventNames();
      }
      listeners(event) {
        return super.listeners(event);
      }
      listenerCount(event) {
        return super.listenerCount(event);
      }
      getMaxListeners() {
        return super.getMaxListeners();
      }
      setMaxListeners(maxListeners) {
        return super.setMaxListeners(maxListeners);
      }
    };
    exports.AsyncEventEmitter = AsyncEventEmitter;
  }
});

// node_modules/@ethereumjs/util/dist/lock.js
var require_lock = __commonJS({
  "node_modules/@ethereumjs/util/dist/lock.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lock = void 0;
    var Lock = class {
      constructor() {
        this.permits = 1;
        this.promiseResolverQueue = [];
      }
      /**
       * Returns a promise used to wait for a permit to become available. This method should be awaited on.
       * @returns  A promise that gets resolved when execution is allowed to proceed.
       */
      async acquire() {
        if (this.permits > 0) {
          this.permits -= 1;
          return Promise.resolve(true);
        }
        return new Promise((resolver) => this.promiseResolverQueue.push(resolver));
      }
      /**
       * Increases the number of permits by one. If there are other functions waiting, one of them will
       * continue to execute in a future iteration of the event loop.
       */
      release() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          console.warn("Lock.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          const nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      }
    };
    exports.Lock = Lock;
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants4 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/browserify-zlib/lib/binding.js
var require_binding = __commonJS({
  "node_modules/browserify-zlib/lib/binding.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var assert = require_assert();
    var Zstream = require_zstream();
    var zlib_deflate = require_deflate();
    var zlib_inflate = require_inflate();
    var constants = require_constants4();
    for (key in constants) {
      exports[key] = constants[key];
    }
    var key;
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert(this.init_done, "close before init");
      assert(this.mode <= exports.UNZIP);
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert.equal(arguments.length, 8);
      assert(this.init_done, "write before init");
      assert(this.mode !== exports.NONE, "already finalized");
      assert.equal(false, this.write_in_progress, "write already in progress");
      assert.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports.GUNZIP;
              } else {
                this.mode = exports.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports.Z_DATA_ERROR) {
              this.err = exports.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert(level >= -1 && level <= 9, "invalid compression level");
      assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports.Z_NO_FLUSH;
      this.err = exports.Z_OK;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports.Zlib = Zlib;
  }
});

// node_modules/browserify-zlib/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/browserify-zlib/lib/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var Buffer2 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
    var Transform = require_stream_browserify().Transform;
    var binding = require_binding();
    var util = require_util();
    var assert = require_assert().ok;
    var kMaxLength = (init_dist(), __toCommonJS(dist_exports)).kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = 16 * 1024;
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding);
    for (bk = 0; bk < bkeys.length; bk++) {
      bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports, bkey, {
          enumerable: true,
          value: binding[bkey],
          writable: false
        });
      }
    }
    var bkey;
    var bk;
    var codes = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes);
    for (ck = 0; ck < ckeys.length; ck++) {
      ckey = ckeys[ck];
      codes[codes[ckey]] = ckey;
    }
    var ckey;
    var ck;
    Object.defineProperty(exports, "codes", {
      enumerable: true,
      value: Object.freeze(codes),
      writable: false
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") buffer = Buffer2.from(buffer);
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
    }
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno) {
        _close(self2);
        self2._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self2.emit("error", error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: function() {
          return !_this._handle;
        },
        configurable: true,
        enumerable: true
      });
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          assert(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback) process.nextTick(callback);
      } else if (ws.ending) {
        if (callback) this.once("end", callback);
      } else if (ws.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback) process.nextTick(callback);
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
      if (!this._handle) return cb(new Error("zlib binding closed"));
      if (last) flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on("error", function(er) {
          error = er;
        });
        assert(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  }
});

// node_modules/micro-ftch/index.js
var require_micro_ftch = __commonJS({
  "node_modules/micro-ftch/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStatusCodeError = exports.InvalidCertError = void 0;
    var DEFAULT_OPT = Object.freeze({
      redirect: true,
      expectStatusCode: 200,
      headers: {},
      full: false,
      keepAlive: true,
      cors: false,
      referrer: false,
      sslAllowSelfSigned: false,
      _redirectCount: 0
    });
    var InvalidCertError = class extends Error {
      constructor(msg, fingerprint256) {
        super(msg);
        this.fingerprint256 = fingerprint256;
      }
    };
    exports.InvalidCertError = InvalidCertError;
    var InvalidStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`Request Failed. Status Code: ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    exports.InvalidStatusCodeError = InvalidStatusCodeError;
    function detectType(b, type) {
      if (!type || type === "text" || type === "json") {
        try {
          let text = new TextDecoder("utf8", { fatal: true }).decode(b);
          if (type === "text")
            return text;
          try {
            return JSON.parse(text);
          } catch (err) {
            if (type === "json")
              throw err;
            return text;
          }
        } catch (err) {
          if (type === "text" || type === "json")
            throw err;
        }
      }
      return b;
    }
    var agents = {};
    function fetchNode(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const http = require_stream_http();
      const https = require_https_browserify();
      const zlib = require_lib2();
      const { promisify } = require_util();
      const { resolve: urlResolve } = (init_url(), __toCommonJS(url_exports));
      const isSecure = !!/^https/.test(url);
      let opts = {
        method: options.method || "GET",
        headers: { "Accept-Encoding": "gzip, deflate, br" }
      };
      const compactFP = (s) => s.replace(/:| /g, "").toLowerCase();
      if (options.keepAlive) {
        const agentOpt = {
          keepAlive: true,
          keepAliveMsecs: 30 * 1e3,
          maxFreeSockets: 1024,
          maxCachedSessions: 1024
        };
        const agentKey = [
          isSecure,
          isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort()
        ].join();
        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));
      }
      if (options.type === "json")
        opts.headers["Content-Type"] = "application/json";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      opts.headers = { ...opts.headers, ...options.headers };
      if (options.sslAllowSelfSigned)
        opts.rejectUnauthorized = false;
      const handleRes = async (res) => {
        const status = res.statusCode;
        if (options.redirect && 300 <= status && status < 400 && res.headers["location"]) {
          if (options._redirectCount == 10)
            throw new Error("Request failed. Too much redirects.");
          options._redirectCount += 1;
          return await fetchNode(urlResolve(url, res.headers["location"]), options);
        }
        if (options.expectStatusCode && status !== options.expectStatusCode) {
          res.resume();
          throw new InvalidStatusCodeError(status);
        }
        let buf = [];
        for await (const chunk of res)
          buf.push(chunk);
        let bytes = Buffer.concat(buf);
        const encoding = res.headers["content-encoding"];
        if (encoding === "br")
          bytes = await promisify(zlib.brotliDecompress)(bytes);
        if (encoding === "gzip" || encoding === "deflate")
          bytes = await promisify(zlib.unzip)(bytes);
        const body = detectType(bytes, options.type);
        if (options.full)
          return { headers: res.headers, status, body };
        return body;
      };
      return new Promise((resolve, reject) => {
        const handleError = async (err) => {
          if (err && err.code === "DEPTH_ZERO_SELF_SIGNED_CERT") {
            try {
              await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });
            } catch (e) {
              if (e && e.fingerprint256) {
                err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);
              }
            }
          }
          reject(err);
        };
        const req = (isSecure ? https : http).request(url, opts, (res) => {
          res.on("error", handleError);
          (async () => {
            try {
              resolve(await handleRes(res));
            } catch (error) {
              reject(error);
            }
          })();
        });
        req.on("error", handleError);
        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));
        const mfetchSecureConnect = (socket) => {
          const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || "");
          if (!fp256 && socket.isSessionReused())
            return;
          if (pinned.includes(fp256))
            return;
          req.emit("error", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));
          return req.abort();
        };
        if (options.sslPinnedCertificates) {
          req.on("socket", (socket) => {
            const hasListeners = socket.listeners("secureConnect").map((i) => (i.name || "").replace("bound ", "")).includes("mfetchSecureConnect");
            if (hasListeners)
              return;
            socket.on("secureConnect", mfetchSecureConnect.bind(null, socket));
          });
        }
        if (options.keepAlive)
          req.setNoDelay(true);
        if (opts.body)
          req.write(opts.body);
        req.end();
      });
    }
    var SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((i) => i.toLowerCase()));
    var FORBIDDEN_HEADERS = new Set([
      "Accept-Charset",
      "Accept-Encoding",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Connection",
      "Content-Length",
      "Cookie",
      "Cookie2",
      "Date",
      "DNT",
      "Expect",
      "Host",
      "Keep-Alive",
      "Origin",
      "Referer",
      "TE",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Via"
    ].map((i) => i.toLowerCase()));
    async function fetchBrowser(url, _options) {
      let options = { ...DEFAULT_OPT, ..._options };
      const headers = new Headers();
      if (options.type === "json")
        headers.set("Content-Type", "application/json");
      let parsed = new URL(url);
      if (parsed.username) {
        const auth = btoa(`${parsed.username}:${parsed.password}`);
        headers.set("Authorization", `Basic ${auth}`);
        parsed.username = "";
        parsed.password = "";
      }
      url = "" + parsed;
      for (let k in options.headers) {
        const name = k.toLowerCase();
        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name))
          headers.set(k, options.headers[k]);
      }
      let opts = { headers, redirect: options.redirect ? "follow" : "manual" };
      if (!options.referrer)
        opts.referrerPolicy = "no-referrer";
      if (options.cors)
        opts.mode = "cors";
      if (options.data) {
        if (!options.method)
          opts.method = "POST";
        opts.body = options.type === "json" ? JSON.stringify(options.data) : options.data;
      }
      const res = await fetch(url, opts);
      if (options.expectStatusCode && res.status !== options.expectStatusCode)
        throw new InvalidStatusCodeError(res.status);
      const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);
      if (options.full)
        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };
      return body;
    }
    var IS_NODE = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
    function fetchUrl(url, options) {
      const fn = IS_NODE ? fetchNode : fetchBrowser;
      return fn(url, options);
    }
    exports.default = fetchUrl;
  }
});

// node_modules/@ethereumjs/util/dist/provider.js
var require_provider = __commonJS({
  "node_modules/@ethereumjs/util/dist/provider.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProvider = exports.fetchFromProvider = void 0;
    var micro_ftch_1 = require_micro_ftch();
    var fetchFromProvider = async (url, params) => {
      const res = await (0, micro_ftch_1.default)(url, {
        headers: {
          "content-type": "application/json"
        },
        type: "json",
        data: {
          method: params.method,
          params: params.params,
          jsonrpc: "2.0",
          id: 1
        }
      });
      return res.result;
    };
    exports.fetchFromProvider = fetchFromProvider;
    var getProvider = (provider) => {
      if (typeof provider === "string") {
        return provider;
      } else if (provider?.connection?.url !== void 0) {
        return provider.connection.url;
      } else {
        throw new Error("Must provide valid provider URL or Web3Provider");
      }
    };
    exports.getProvider = getProvider;
  }
});

// node_modules/@ethereumjs/util/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@ethereumjs/util/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;
    __exportStar(require_constants3(), exports);
    __exportStar(require_units(), exports);
    __exportStar(require_account2(), exports);
    __exportStar(require_address3(), exports);
    __exportStar(require_withdrawal(), exports);
    __exportStar(require_signature2(), exports);
    __exportStar(require_bytes2(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_encoding2(), exports);
    __exportStar(require_asyncEventEmitter(), exports);
    var internal_1 = require_internal();
    Object.defineProperty(exports, "arrayContainsArray", { enumerable: true, get: function() {
      return internal_1.arrayContainsArray;
    } });
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return internal_1.fromAscii;
    } });
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return internal_1.fromUtf8;
    } });
    Object.defineProperty(exports, "getBinarySize", { enumerable: true, get: function() {
      return internal_1.getBinarySize;
    } });
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return internal_1.getKeys;
    } });
    Object.defineProperty(exports, "isHexPrefixed", { enumerable: true, get: function() {
      return internal_1.isHexPrefixed;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return internal_1.isHexString;
    } });
    Object.defineProperty(exports, "padToEven", { enumerable: true, get: function() {
      return internal_1.padToEven;
    } });
    Object.defineProperty(exports, "stripHexPrefix", { enumerable: true, get: function() {
      return internal_1.stripHexPrefix;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return internal_1.toAscii;
    } });
    __exportStar(require_lock(), exports);
    __exportStar(require_provider(), exports);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/utils.js
var require_utils12 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberToBuffer = exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
    var util_1 = require_dist5();
    var ethjs_util_1 = require_lib();
    function padWithZeroes(hexString, targetLength) {
      if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
      }
      if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
      }
      return String.prototype.padStart.call(hexString, targetLength, "0");
    }
    exports.padWithZeroes = padWithZeroes;
    function isNullish(value) {
      return value === null || value === void 0;
    }
    exports.isNullish = isNullish;
    function legacyToBuffer(value) {
      return typeof value === "string" && !(0, ethjs_util_1.isHexString)(value) ? Buffer.from(value) : (0, util_1.toBuffer)(value);
    }
    exports.legacyToBuffer = legacyToBuffer;
    function concatSig(v, r, s) {
      const rSig = (0, util_1.fromSigned)(r);
      const sSig = (0, util_1.fromSigned)(s);
      const vSig = (0, util_1.bufferToInt)(v);
      const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString("hex"), 64);
      const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString("hex"), 64);
      const vStr = (0, ethjs_util_1.stripHexPrefix)((0, ethjs_util_1.intToHex)(vSig));
      return (0, util_1.addHexPrefix)(rStr.concat(sStr, vStr));
    }
    exports.concatSig = concatSig;
    function recoverPublicKey(messageHash, signature) {
      const sigParams = (0, util_1.fromRpcSig)(signature);
      return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function normalize(input) {
      if (!input) {
        return void 0;
      }
      if (typeof input === "number") {
        if (input < 0) {
          return "0x";
        }
        const buffer = (0, util_1.toBuffer)(input);
        input = (0, util_1.bufferToHex)(buffer);
      }
      if (typeof input !== "string") {
        let msg = "eth-sig-util.normalize() requires hex string or integer input.";
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
      }
      return (0, util_1.addHexPrefix)(input.toLowerCase());
    }
    exports.normalize = normalize;
    function numberToBuffer(num) {
      const hexVal = num.toString(16);
      const prepend = hexVal.length % 2 ? "0" : "";
      return Buffer.from(prepend + hexVal, "hex");
    }
    exports.numberToBuffer = numberToBuffer;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/personal-sign.js
var require_personal_sign = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/personal-sign.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
    var util_1 = require_dist5();
    var utils_1 = require_utils12();
    function personalSign({ privateKey, data }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const message = (0, utils_1.legacyToBuffer)(data);
      const msgHash = (0, util_1.hashPersonalMessage)(message);
      const sig = (0, util_1.ecsign)(msgHash, privateKey);
      const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
      return serialized;
    }
    exports.personalSign = personalSign;
    function recoverPersonalSignature({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      const senderHex = (0, util_1.bufferToHex)(sender);
      return senderHex;
    }
    exports.recoverPersonalSignature = recoverPersonalSignature;
    function extractPublicKey({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      return `0x${publicKey.toString("hex")}`;
    }
    exports.extractPublicKey = extractPublicKey;
    function getPublicKeyFor(message, signature) {
      const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));
      return (0, utils_1.recoverPublicKey)(messageHash, signature);
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/ethereum-cryptography/utils.js
var require_utils13 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/ethereum-cryptography/utils.js"(exports, module) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.hexToBytes = hexToBytes;
    exports.equalsBytes = equalsBytes;
    exports.wrapHash = wrapHash;
    var _assert_1 = __importDefault(require_assert4());
    var utils_1 = require_utils9();
    var assertBool = _assert_1.default.bool;
    exports.assertBool = assertBool;
    var assertBytes = _assert_1.default.bytes;
    exports.assertBytes = assertBytes;
    var utils_2 = require_utils9();
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return utils_2.bytesToHex;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_2.concatBytes;
    } });
    Object.defineProperty(exports, "createView", { enumerable: true, get: function() {
      return utils_2.createView;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_2.utf8ToBytes;
    } });
    function bytesToUtf8(data) {
      if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
      }
      return new TextDecoder().decode(data);
    }
    function hexToBytes(data) {
      const sliced = data.startsWith("0x") ? data.substring(2) : data;
      return (0, utils_1.hexToBytes)(sliced);
    }
    function equalsBytes(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    function wrapHash(hash) {
      return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
      };
    }
    exports.crypto = (() => {
      const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
      const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
      return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
        web: webCrypto
      };
    })();
  }
});

// node_modules/@pushprotocol/restapi/node_modules/ethereum-cryptography/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/ethereum-cryptography/keccak.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
    var sha3_1 = require_sha33();
    var utils_js_1 = require_utils13();
    exports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
    exports.keccak256 = (() => {
      const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
      k.create = sha3_1.keccak_256.create;
      return k;
    })();
    exports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
    exports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js
var require_ethereumjs_abi_utils = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEncode = exports.parseNumber = exports.solidityPack = void 0;
    var util_1 = require_dist5();
    var bn_js_1 = __importDefault(require_bn());
    var ethjs_util_1 = require_lib();
    var utils_1 = require_utils12();
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      const ret = [];
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        ret.push(solidityHexValue(type, value, null));
      }
      return Buffer.concat(ret);
    }
    exports.solidityPack = solidityPack;
    function isArray(type) {
      return type.endsWith("]");
    }
    function parseTypeArray(type) {
      const tmp = type.match(/(.*)\[(.*?)\]$/u);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseTypeN(type) {
      const match = /^\D+(\d+)$/u.exec(type);
      if (match === null) {
        throw new Error(`Invalid parseTypeN input "${type}".`);
      }
      return parseInt(match[1], 10);
    }
    function parseNumber(arg) {
      const type = typeof arg;
      if (type === "string") {
        if ((0, util_1.isHexPrefixed)(arg)) {
          return new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(arg), 16);
        }
        return new bn_js_1.default(arg, 10);
      } else if (type === "number") {
        return new bn_js_1.default(arg);
      } else if (arg && Object.prototype.hasOwnProperty.call(arg, "toArray") || bn_js_1.default.isBN(arg)) {
        return arg;
      }
      throw new Error("Argument is not a number");
    }
    exports.parseNumber = parseNumber;
    function solidityHexValue(type, value, bitsize) {
      if (isArray(type)) {
        const subType = type.replace(/\[.*?\]/u, "");
        if (!isArray(subType)) {
          const arraySize = parseTypeArray(type);
          if (arraySize !== "dynamic" && arraySize !== 0 && arraySize !== null && value.length > arraySize) {
            throw new Error(`Elements exceed array size: ${arraySize}`);
          }
        }
        const arrayValues = value.map((v) => solidityHexValue(subType, v, 256));
        return Buffer.concat(arrayValues);
      } else if (type === "bytes") {
        return value;
      } else if (type === "string") {
        return Buffer.from(value, "utf8");
      } else if (type === "bool") {
        bitsize = bitsize || 8;
        const padding = Array(bitsize / 4).join("0");
        return Buffer.from(value ? `${padding}1` : `${padding}0`, "hex");
      } else if (type === "address") {
        let bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return (0, util_1.setLengthLeft)((0, util_1.toBuffer)(value), bytesize);
      } else if (type.startsWith("bytes")) {
        const size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof value === "number") {
          value = (0, utils_1.normalize)(value);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(value), size);
      } else if (type.startsWith("uint")) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        const num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type.startsWith("int")) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        const num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      }
      throw new Error(`Unsupported or invalid type: ${JSON.stringify(type)}`);
    }
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return `int256${name.slice(3)}`;
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return `uint256${name.slice(4)}`;
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return `fixed128x128${name.slice(5)}`;
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return `ufixed128x128${name.slice(6)}`;
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function rawEncode(types, values) {
      const output = [];
      const data = [];
      let headLength = 0;
      types.forEach((type) => {
        if (isArray(type)) {
          const size = parseTypeArray(type);
          if (size !== "dynamic" && size !== null) {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        const cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    exports.rawEncode = rawEncode;
    function encodeSingle(type, arg) {
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        const size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && size !== null && arg.length > size) {
          throw new Error(`Elements exceed array size: ${size}`);
        }
        const ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (const i in arg) {
          if (Object.prototype.hasOwnProperty.call(arg, i)) {
            ret.push(encodeSingle(type, arg[i]));
          }
        }
        if (size === "dynamic") {
          const length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = Buffer.from(arg);
        let ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, (0, util_1.zeros)(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        const size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        const nArg = typeof arg === "number" ? (0, utils_1.normalize)(arg) : arg;
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(nArg), 32);
      } else if (type.startsWith("uint")) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        const num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        if (num.isNeg()) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        const num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        const size = parseTypeNxM(type);
        const num = parseNumber(arg);
        if (num.isNeg()) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      } else if (type.startsWith("fixed")) {
        const size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      }
      throw new Error(`Unsupported or invalid type: ${JSON.stringify(type)}`);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function parseTypeNxM(type) {
      const match = /^\D+(\d+)x(\d+)$/u.exec(type);
      if (match === null || match.length < 1) {
        throw new Error(`Invalid parseTypeNxM input "${type}".`);
      }
      return [parseInt(match[1], 10), parseInt(match[2], 10)];
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js
var require_sign_typed_data = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
    var util_1 = require_dist5();
    var keccak_1 = require_keccak2();
    var ethjs_util_1 = require_lib();
    var ethereumjs_abi_utils_1 = require_ethereumjs_abi_utils();
    var utils_1 = require_utils12();
    var SignTypedDataVersion;
    (function(SignTypedDataVersion2) {
      SignTypedDataVersion2["V1"] = "V1";
      SignTypedDataVersion2["V3"] = "V3";
      SignTypedDataVersion2["V4"] = "V4";
    })(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
    exports.TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    function validateVersion(version, allowedVersions) {
      if (!Object.keys(SignTypedDataVersion).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
      } else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(", ")}`);
      }
    }
    function encodeField(types, name, type, value, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      if (types[type] !== void 0) {
        return [
          "bytes32",
          // TODO: return Buffer, remove string from return type
          version === SignTypedDataVersion.V4 && value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version)))
        ];
      }
      if (value === void 0) {
        throw new Error(`missing value for field ${name} of type ${type}`);
      }
      if (type === "bytes") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else if ((0, ethjs_util_1.isHexString)(value)) {
          const prepend = value.length % 2 ? "0" : "";
          value = Buffer.from(prepend + value.slice(2), "hex");
        } else {
          value = Buffer.from(value, "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type === "string") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else {
          value = Buffer.from(value !== null && value !== void 0 ? value : "", "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type.endsWith("]")) {
        if (version === SignTypedDataVersion.V3) {
          throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
        }
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
          "bytes32",
          (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.rawEncode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))))
        ];
      }
      return [type, value];
    }
    function encodeData(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const encodedTypes = ["bytes32"];
      const encodedValues = [hashType(primaryType, types)];
      for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion.V3 && data[field.name] === void 0) {
          continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, ethereumjs_abi_utils_1.rawEncode)(encodedTypes, encodedValues);
    }
    function encodeType(primaryType, types) {
      let result = "";
      const unsortedDeps = findTypeDependencies(primaryType, types);
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        const children = types[type];
        if (!children) {
          throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies(primaryType, types, results = /* @__PURE__ */ new Set()) {
      if (typeof primaryType !== "string") {
        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);
      }
      const match = primaryType.match(/^\w*/u);
      [primaryType] = match;
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
      }
      return results;
    }
    function hashStruct(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const encoded = encodeData(primaryType, data, types, version);
      const hashed = (0, keccak_1.keccak256)(encoded);
      const buf = (0, util_1.arrToBufArr)(hashed);
      return buf;
    }
    function hashType(primaryType, types) {
      const encodedHashType = Buffer.from(encodeType(primaryType, types), "utf-8");
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));
    }
    function sanitizeData(data) {
      const sanitizedData = {};
      for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
          sanitizedData[key] = data[key];
        }
      }
      if ("types" in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
      }
      return sanitizedData;
    }
    function eip712DomainHash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const sanitizedData = sanitizeData(typedData);
      const { domain } = sanitizedData;
      const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };
      return hashStruct("EIP712Domain", domain, domainType, version);
    }
    function eip712Hash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
      const sanitizedData = sanitizeData(typedData);
      const parts = [Buffer.from("1901", "hex")];
      parts.push(eip712DomainHash(typedData, version));
      if (sanitizedData.primaryType !== "EIP712Domain") {
        parts.push(hashStruct(
          // TODO: Validate that this is a string, so this type cast can be removed.
          sanitizedData.primaryType,
          sanitizedData.message,
          sanitizedData.types,
          version
        ));
      }
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(Buffer.concat(parts)));
    }
    exports.TypedDataUtils = {
      encodeData,
      encodeType,
      findTypeDependencies,
      hashStruct,
      hashType,
      sanitizeData,
      eip712Hash,
      eip712DomainHash
    };
    function typedSignatureHash(typedData) {
      const hashBuffer = _typedSignatureHash(typedData);
      return (0, util_1.bufferToHex)(hashBuffer);
    }
    exports.typedSignatureHash = typedSignatureHash;
    function _typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !("length" in typedData) || !typedData.length) {
        throw error;
      }
      const data = typedData.map(function(e) {
        if (e.type !== "bytes") {
          return e.value;
        }
        return (0, utils_1.legacyToBuffer)(e.value);
      });
      const types = typedData.map(function(e) {
        return e.type;
      });
      const schema = typedData.map(function(e) {
        if (!e.name) {
          throw error;
        }
        return `${e.type} ${e.name}`;
      });
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(["bytes32", "bytes32"], [
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(new Array(typedData.length).fill("string"), schema)),
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(types, data))
      ])));
    }
    function signTypedData({ privateKey, data, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing private key parameter");
      }
      const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const sig = (0, util_1.ecsign)(messageHash, privateKey);
      return (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
    }
    exports.signTypedData = signTypedData;
    function recoverTypedSignature({ data, signature, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const publicKey = (0, utils_1.recoverPublicKey)(messageHash, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      return (0, util_1.bufferToHex)(sender);
    }
    exports.recoverTypedSignature = recoverTypedSignature;
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/encryption.js
var require_encryption = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/encryption.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
    var nacl = __importStar(require_nacl_fast());
    var naclUtil = __importStar(require_nacl_util());
    var utils_1 = require_utils12();
    function encrypt({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      switch (version) {
        case "x25519-xsalsa20-poly1305": {
          if (typeof data !== "string") {
            throw new Error("Message data must be given as a string");
          }
          const ephemeralKeyPair = nacl.box.keyPair();
          let pubKeyUInt8Array;
          try {
            pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
          } catch (err) {
            throw new Error("Bad public key");
          }
          const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
          const nonce = nacl.randomBytes(nacl.box.nonceLength);
          const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
          const output = {
            version: "x25519-xsalsa20-poly1305",
            nonce: naclUtil.encodeBase64(nonce),
            ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
            ciphertext: naclUtil.encodeBase64(encryptedMessage)
          };
          return output;
        }
        default:
          throw new Error("Encryption type/version not supported");
      }
    }
    exports.encrypt = encrypt;
    function encryptSafely({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      const DEFAULT_PADDING_LENGTH = 2 ** 11;
      const NACL_EXTRA_BYTES = 16;
      if (typeof data === "object" && data && "toJSON" in data) {
        throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
      }
      const dataWithPadding = {
        data,
        padding: ""
      };
      const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), "utf-8");
      const modVal = dataLength % DEFAULT_PADDING_LENGTH;
      let padLength = 0;
      if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES;
      }
      dataWithPadding.padding = "0".repeat(padLength);
      const paddedMessage = JSON.stringify(dataWithPadding);
      return encrypt({ publicKey, data: paddedMessage, version });
    }
    exports.encryptSafely = encryptSafely;
    function decrypt({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      switch (encryptedData.version) {
        case "x25519-xsalsa20-poly1305": {
          const receiverPrivateKeyUint8Array = naclDecodeHex(privateKey);
          const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;
          const nonce = naclUtil.decodeBase64(encryptedData.nonce);
          const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
          const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
          const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);
          try {
            if (!decryptedMessage) {
              throw new Error();
            }
            const output = naclUtil.encodeUTF8(decryptedMessage);
            if (!output) {
              throw new Error();
            }
            return output;
          } catch (err) {
            if (err && typeof err.message === "string" && err.message.length) {
              throw new Error(`Decryption failed: ${err.message}`);
            }
            throw new Error(`Decryption failed.`);
          }
        }
        default:
          throw new Error("Encryption type/version not supported.");
      }
    }
    exports.decrypt = decrypt;
    function decryptSafely({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));
      return dataWithPadding.data;
    }
    exports.decryptSafely = decryptSafely;
    function getEncryptionPublicKey(privateKey) {
      const privateKeyUint8Array = naclDecodeHex(privateKey);
      const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
      return naclUtil.encodeBase64(encryptionPublicKey);
    }
    exports.getEncryptionPublicKey = getEncryptionPublicKey;
    function naclDecodeHex(msgHex) {
      const msgBase64 = Buffer.from(msgHex, "hex").toString("base64");
      return naclUtil.decodeBase64(msgBase64);
    }
  }
});

// node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@pushprotocol/restapi/node_modules/@metamask/eth-sig-util/dist/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.concatSig = void 0;
    __exportStar(require_personal_sign(), exports);
    __exportStar(require_sign_typed_data(), exports);
    __exportStar(require_encryption(), exports);
    var utils_1 = require_utils12();
    Object.defineProperty(exports, "concatSig", { enumerable: true, get: function() {
      return utils_1.concatSig;
    } });
    Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
      return utils_1.normalize;
    } });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/signature.js
var require_signature3 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/signature.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyProfileSignature = exports.getTypedData = exports.getTypeInformation = exports.getDomainInformation = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var eth_sig_util_1 = require_dist6();
    var viem = require_cjs2();
    var getDomainInformation = (chainId) => {
      const chatVerifyingContract = "0x0000000000000000000000000000000000000000";
      return {
        name: "PUSH CHAT ID",
        chainId,
        verifyingContract: chatVerifyingContract
      };
    };
    exports.getDomainInformation = getDomainInformation;
    var getTypeInformation = () => {
      return {
        Data: [{ name: "data", type: "string" }]
      };
    };
    exports.getTypeInformation = getTypeInformation;
    var getTypedData = (signedData, chainId, version) => {
      const message = { data: signedData };
      const typeInformation = (0, exports.getTypeInformation)();
      const domainInformation = (0, exports.getDomainInformation)(chainId);
      const primaryType = "Data";
      let types;
      let domain = {};
      if (version === "V1") {
        types = {
          EIP712Domain: [],
          Data: typeInformation.Data
        };
      } else {
        types = {
          EIP712Domain: [
            { name: "name", type: "string" },
            { name: "chainId", type: "uint256" },
            { name: "verifyingContract", type: "address" }
          ],
          Data: typeInformation.Data
        };
        domain = domainInformation;
      }
      return {
        types,
        primaryType,
        domain,
        message
      };
    };
    exports.getTypedData = getTypedData;
    var verifyProfileSignature = (verificationProof, signedData, address) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const SIG_TYPE_V2 = "eip712v2";
      const SIG_TYPE_V3 = "eip191";
      const SIG_TYPE_V4 = "eip191v2";
      let chainId = null;
      let signature;
      const sigType = verificationProof.split(":")[0];
      if (sigType !== SIG_TYPE_V2 && sigType !== SIG_TYPE_V3 && sigType !== SIG_TYPE_V4 || verificationProof.split(":").length > 3) {
        return false;
      }
      if (verificationProof.split(":").length === 2) {
        signature = verificationProof.split(":")[1];
      } else {
        chainId = parseInt(verificationProof.split(":")[1]);
        signature = verificationProof.split(":")[2];
      }
      if (sigType === SIG_TYPE_V2) {
        try {
          const typedData = (0, exports.getTypedData)(signedData, chainId, "V2");
          const recoveredAddress = (0, eth_sig_util_1.recoverTypedSignature)({
            data: typedData,
            signature,
            version: eth_sig_util_1.SignTypedDataVersion.V4
          });
          if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
            return true;
          } else
            return false;
        } catch (err) {
          const typedData = (0, exports.getTypedData)(signedData, chainId, "V1");
          const recoveredAddress = (0, eth_sig_util_1.recoverTypedSignature)({
            data: typedData,
            signature,
            version: eth_sig_util_1.SignTypedDataVersion.V4
          });
          if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
            return true;
          } else
            return false;
        }
      } else {
        try {
          const recoveredAddress = yield viem.recoverAddress({
            hash: viem.hashMessage(signedData),
            signature
          });
          if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
            return true;
          } else
            return false;
        } catch (err) {
          return false;
        }
      }
    });
    exports.verifyProfileSignature = verifyProfileSignature;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/getEncryptedSecret.js
var require_getEncryptedSecret = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/getEncryptedSecret.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptedSecret = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers3();
    var getEncryptedSecret = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { sessionKey, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (sessionKey === void 0 || sessionKey === null) {
          throw new Error("sessionKey is required");
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/encryptedsecret/sessionKey/${sessionKey}`;
        return axios_1.default.get(requestUrl).then((response) => {
          return response.data.encryptedSecret;
        }).catch((err) => {
          var _a, _b;
          if ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data)
            throw new Error((_b = err === null || err === void 0 ? void 0 : err.response) === null || _b === void 0 ? void 0 : _b.data);
          throw new Error(err);
        });
      } catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.getEncryptedSecret.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.getEncryptedSecret.name} -: ${err}`);
      }
    });
    exports.getEncryptedSecret = getEncryptedSecret;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/errors/httpStatus.js
var require_httpStatus = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/errors/httpStatus.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpStatus = void 0;
    var HttpStatus;
    (function(HttpStatus2) {
      HttpStatus2[HttpStatus2["BadRequest"] = 400] = "BadRequest";
      HttpStatus2[HttpStatus2["NotFound"] = 404] = "NotFound";
      HttpStatus2[HttpStatus2["Forbidden"] = 403] = "Forbidden";
      HttpStatus2[HttpStatus2["InternalError"] = 500] = "InternalError";
    })(HttpStatus = exports.HttpStatus || (exports.HttpStatus = {}));
  }
});

// node_modules/@pushprotocol/restapi/src/lib/errors/validationError.js
var require_validationError = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/errors/validationError.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleError = exports.isErrorWithResponseV2 = exports.isErrorWithResponse = exports.ValidationError = void 0;
    var httpStatus_1 = require_httpStatus();
    var ValidationError = class extends Error {
      constructor(status, errorCode, message, details) {
        super(message);
        this.name = "ValidationError";
        this.status = status;
        this.errorCode = errorCode;
        this.details = details;
      }
      format() {
        return {
          status: this.status,
          errorCode: this.errorCode,
          message: this.message,
          details: this.details,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    exports.ValidationError = ValidationError;
    function isErrorWithResponse(error) {
      return typeof error === "object" && error !== null && "response" in error && typeof error.response === "object" && error.response !== null && "status" in error.response && "data" in error.response && typeof error.response.data === "object" && "status" in error.response.data && "errorCode" in error.response.data && "message" in error.response.data && "details" in error.response.data && "timestamp" in error.response.data;
    }
    exports.isErrorWithResponse = isErrorWithResponse;
    function isErrorWithResponseV2(error) {
      return typeof error === "object" && error !== null && "response" in error && typeof error.response === "object" && error.response !== null && "status" in error.response && "data" in error.response && typeof error.response.data === "object" && "error" in error.response.data && "message" in error.response.data && "validation" in error.response.data;
    }
    exports.isErrorWithResponseV2 = isErrorWithResponseV2;
    function handleError(error, context) {
      var _a, _b, _c;
      let status = httpStatus_1.HttpStatus.InternalError;
      let errorCode = "00000000000";
      let message = "An unexpected error occurred. Please contact support or try again later.";
      let details = "";
      if (isErrorWithResponse(error)) {
        status = ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) || httpStatus_1.HttpStatus.InternalError;
        if ((_b = error.response) === null || _b === void 0 ? void 0 : _b.data) {
          const errData = error.response.data;
          errorCode = errData.errorCode || errorCode;
          message = errData.message || message;
          details = errData.details || JSON.stringify(errData);
        }
      } else if (isErrorWithResponseV2(error)) {
        status = ((_c = error.response) === null || _c === void 0 ? void 0 : _c.status) || httpStatus_1.HttpStatus.InternalError;
        const errData = error.response.data;
        message = errData.message || message;
        details = errData.validation || JSON.stringify(errData);
      } else if (error instanceof Error) {
        message = error.message;
        details = error.stack || "";
      }
      const validationError = new ValidationError(status, errorCode, message, details);
      const logPrefix = `[Error - API ${context}]`;
      console.error(`${logPrefix} ${JSON.stringify(validationError.format(), null, 2)}`);
      return validationError;
    }
    exports.handleError = handleError;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroup.js
var require_getGroup = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroup.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroup = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var axiosUtil_1 = require_axiosUtil();
    var validationError_1 = require_validationError();
    var getGroup = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, env = constants_1.default.ENV.PROD } = options || {};
      try {
        if (chatId == null || chatId.length == 0) {
          throw new Error(`chatId cannot be null or empty`);
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}`;
        const response = yield (0, axiosUtil_1.axiosGet)(requestUrl);
        return response.data;
      } catch (err) {
        throw (0, validationError_1.handleError)(err, exports.getGroup.name);
      }
    });
    exports.getGroup = getGroup;
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/cache.js
var require_cache2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/cache.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cache = void 0;
    var lru_cache_1 = require_commonjs();
    exports.cache = new lru_cache_1.LRUCache({
      max: 200,
      maxSize: 500 * 1024,
      sizeCalculation: (value, key) => {
        return typeof value === "string" ? value.length : new TextEncoder().encode(JSON.stringify(value)).length;
      },
      ttl: 1e3 * 60 * 5,
      allowStale: false
    });
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/ipfs.js
var require_ipfs = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/ipfs.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCID = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var validationError_1 = require_validationError();
    var helpers_1 = require_helpers3();
    var axiosUtil_1 = require_axiosUtil();
    function getCID(cid, options) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { env = constants_1.default.ENV.PROD } = options || {};
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/ipfs/${cid}`;
        try {
          const response = yield (0, axiosUtil_1.axiosGet)(apiEndpoint);
          const message = response.data;
          return message;
        } catch (err) {
          throw (0, validationError_1.handleError)(err, getCID.name);
        }
      });
    }
    exports.getCID = getCID;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/crypto.js
var require_crypto4 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptAndVerifyMessage = exports.getDecryptedPrivateKey = exports.getEip712Signature = exports.getEip191Signature = exports.getEncryptedRequestCore = exports.getEncryptedRequest = exports.decryptFeeds = exports.signMessageWithPGPCore = exports.signMessageWithPGP = exports.encryptAndSignCore = exports.encryptAndSign = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PGP = require_pgp();
    var AES = require_aes2();
    var CryptoJS = require_crypto_js();
    var user_1 = require_user2();
    var helpers_1 = require_helpers3();
    var user_2 = require_user2();
    var service_1 = require_service();
    var constants_1 = require_constants2();
    var signature_1 = require_signature3();
    var aes_1 = require_aes2();
    var getEncryptedSecret_1 = require_getEncryptedSecret();
    var getGroup_1 = require_getGroup();
    var cache_1 = require_cache2();
    var ipfs_1 = require_ipfs();
    var SIG_TYPE_V2 = "eip712v2";
    var encryptAndSign = ({ plainText, keys, privateKeyArmored, secretKey }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.encryptAndSignCore)({
        plainText,
        keys,
        privateKeyArmored,
        secretKey,
        pgpHelper: PGP.PGPHelper
      });
    });
    exports.encryptAndSign = encryptAndSign;
    var encryptAndSignCore = ({ plainText, keys, privateKeyArmored, secretKey, pgpHelper }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const cipherText = AES.aesEncrypt({ plainText, secretKey });
      const encryptedSecret = yield pgpHelper.pgpEncrypt({
        plainText: secretKey,
        keys
      });
      const signature = yield pgpHelper.sign({
        message: cipherText,
        signingKey: privateKeyArmored
      });
      return {
        cipherText,
        encryptedSecret,
        signature,
        sigType: "pgp",
        encType: "pgp"
      };
    });
    exports.encryptAndSignCore = encryptAndSignCore;
    var signMessageWithPGP = ({ message, privateKeyArmored }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.signMessageWithPGPCore)({
        message,
        privateKeyArmored,
        pgpHelper: PGP.PGPHelper
      });
    });
    exports.signMessageWithPGP = signMessageWithPGP;
    var signMessageWithPGPCore = ({ message, privateKeyArmored, pgpHelper }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const signature = yield pgpHelper.sign({
        message,
        signingKey: privateKeyArmored
      });
      return {
        signature,
        sigType: "pgp"
      };
    });
    exports.signMessageWithPGPCore = signMessageWithPGPCore;
    var decryptFeeds = ({ feeds, connectedUser, pgpPrivateKey, env = constants_1.default.ENV.PROD, pgpHelper }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const validateAndDecryptFeed = (feed) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (!pgpPrivateKey) {
          throw new Error("Decrypted private key is necessary");
        }
        if (feed.msg.encType !== "PlainText") {
          const senderCAIP10 = feed.msg.fromCAIP10;
          const isSenderConnectedUser = senderCAIP10 === connectedUser.wallets.split(",")[0];
          let publicKey;
          if (!isSenderConnectedUser) {
            const cacheKey = `pgpPubKey-${senderCAIP10}`;
            if (cache_1.cache.has(cacheKey)) {
              publicKey = cache_1.cache.get(cacheKey);
            } else {
              const otherPeer = yield (0, user_2.get)({ account: senderCAIP10, env });
              cache_1.cache.set(cacheKey, otherPeer.publicKey);
              publicKey = otherPeer.publicKey;
            }
          } else {
            publicKey = connectedUser.publicKey;
          }
          feed.msg = yield (0, exports.decryptAndVerifyMessage)(feed.msg, publicKey, pgpPrivateKey, env, pgpHelper);
        }
      });
      for (const feed of feeds) {
        yield validateAndDecryptFeed(feed);
      }
      return feeds;
    });
    exports.decryptFeeds = decryptFeeds;
    var getEncryptedRequest = (receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.getEncryptedRequestCore)(receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey, PGP.PGPHelper);
    });
    exports.getEncryptedRequest = getEncryptedRequest;
    var getEncryptedRequestCore = (receiverAddress, senderCreatedUser, message, isGroup, env, group, secretKey, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      if (!isGroup) {
        const receiverCreatedUser = yield (0, user_1.get)({
          account: receiverAddress,
          env
        });
        if (!(receiverCreatedUser === null || receiverCreatedUser === void 0 ? void 0 : receiverCreatedUser.publicKey)) {
          if (!(0, helpers_1.isValidPushCAIP)(receiverAddress)) {
            throw new Error(`Invalid receiver address!`);
          }
          yield (0, service_1.createUserService)({
            user: receiverAddress,
            publicKey: "",
            encryptedPrivateKey: "",
            env
          });
          const { signature } = yield (0, exports.signMessageWithPGPCore)({
            message,
            privateKeyArmored: senderCreatedUser.privateKey,
            pgpHelper
          });
          return {
            message,
            encryptionType: "PlainText",
            aesEncryptedSecret: "",
            signature
          };
        } else {
          if (!receiverCreatedUser.publicKey.includes("-----BEGIN PGP PUBLIC KEY BLOCK-----")) {
            const { signature } = yield (0, exports.signMessageWithPGPCore)({
              message,
              privateKeyArmored: senderCreatedUser.privateKey,
              pgpHelper
            });
            return {
              message,
              encryptionType: "PlainText",
              aesEncryptedSecret: "",
              signature
            };
          } else {
            const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSignCore)({
              plainText: message,
              keys: [receiverCreatedUser.publicKey, senderCreatedUser.publicKey],
              privateKeyArmored: senderCreatedUser.privateKey,
              secretKey,
              pgpHelper
            });
            return {
              message: cipherText,
              encryptionType: "pgp",
              aesEncryptedSecret: encryptedSecret,
              signature
            };
          }
        }
      } else if (group) {
        if (group.isPublic) {
          const { signature } = yield (0, exports.signMessageWithPGPCore)({
            message,
            privateKeyArmored: senderCreatedUser.privateKey,
            pgpHelper
          });
          return {
            message,
            encryptionType: "PlainText",
            aesEncryptedSecret: "",
            signature
          };
        } else {
          if (group.sessionKey && group.encryptedSecret) {
            const cipherText = AES.aesEncrypt({
              plainText: message,
              secretKey
            });
            const signature = yield pgpHelper.sign({
              message: cipherText,
              signingKey: senderCreatedUser.privateKey
            });
            return {
              message: cipherText,
              encryptionType: "pgpv1:group",
              aesEncryptedSecret: null,
              signature
            };
          } else {
            const groupWithMembers = yield (0, getGroup_1.getGroup)({
              chatId: group.chatId,
              env
            });
            const publicKeys = groupWithMembers.members.map((member) => member.publicKey);
            const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSignCore)({
              plainText: message,
              keys: publicKeys,
              privateKeyArmored: senderCreatedUser.privateKey,
              secretKey,
              pgpHelper
            });
            return {
              message: cipherText,
              encryptionType: "pgp",
              aesEncryptedSecret: encryptedSecret,
              signature
            };
          }
        }
      } else {
        throw new Error("Unable to find Group Data");
      }
    });
    exports.getEncryptedRequestCore = getEncryptedRequestCore;
    var getEip191Signature = (wallet, message, version = "v1") => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn("This method is deprecated. Provide signer in the function");
        return { signature: "xyz", sigType: "a" };
      }
      const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
      const pushSigner = new helpers_1.Signer(_signer);
      const signature = yield pushSigner.signMessage(message);
      const sigType = version === "v1" ? "eip191" : "eip191v2";
      return { verificationProof: `${sigType}:${signature}` };
    });
    exports.getEip191Signature = getEip191Signature;
    var getEip712Signature = (wallet, hash, isDomainEmpty) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn("This method is deprecated. Provide signer in the function");
        return { signature: "xyz", sigType: "a" };
      }
      const typeInformation = (0, signature_1.getTypeInformation)();
      const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
      const pushSigner = new helpers_1.Signer(_signer);
      let chainId;
      try {
        chainId = yield pushSigner.getChainId();
      } catch (err) {
        chainId = 1;
      }
      const domain = (0, signature_1.getDomainInformation)(chainId);
      const signedMessage = yield pushSigner.signTypedData(isDomainEmpty ? {} : domain, typeInformation, { data: hash }, "Data");
      const verificationProof = isDomainEmpty ? `${SIG_TYPE_V2}:${signedMessage}` : `${SIG_TYPE_V2}:${chainId}:${signedMessage}`;
      return { verificationProof };
    });
    exports.getEip712Signature = getEip712Signature;
    function getDecryptedPrivateKey(wallet, user, address, env) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let decryptedPrivateKey;
        if (wallet.signer) {
          decryptedPrivateKey = yield (0, helpers_1.decryptPGPKey)({
            signer: wallet.signer,
            encryptedPGPPrivateKey: user.encryptedPrivateKey,
            env
          });
        } else {
          decryptedPrivateKey = yield (0, helpers_1.decryptWithWalletRPCMethod)(user.encryptedPrivateKey, address);
        }
        return decryptedPrivateKey;
      });
    }
    exports.getDecryptedPrivateKey = getDecryptedPrivateKey;
    var decryptAndVerifyMessage = (message, pgpPublicKey, pgpPrivateKey, env, pgpHelper = PGP.PGPHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      if (message.verificationProof && message.verificationProof.split(":")[0] === "pgpv2") {
        const bodyToBeHashed = {
          fromDID: message.fromDID,
          toDID: message.fromDID,
          fromCAIP10: message.fromCAIP10,
          toCAIP10: message.toCAIP10,
          messageObj: message.messageObj,
          messageType: message.messageType,
          encType: message.encType,
          encryptedSecret: message.encryptedSecret
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = message.verificationProof.split(":")[1];
        yield pgpHelper.verifySignature({
          messageContent: hash,
          signatureArmored: signature,
          publicKeyArmored: pgpPublicKey
        });
      } else if (message.verificationProof && message.verificationProof.split(":")[0] === "pgpv3") {
        const bodyToBeHashed = {
          fromDID: message.fromDID,
          toDID: message.fromDID,
          fromCAIP10: message.fromCAIP10,
          toCAIP10: message.toCAIP10,
          messageObj: message.messageObj,
          messageType: message.messageType,
          encType: message.encType,
          sessionKey: message.sessionKey,
          encryptedSecret: message.encryptedSecret
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = message.verificationProof.split(":")[1];
        yield pgpHelper.verifySignature({
          messageContent: hash,
          signatureArmored: signature,
          publicKeyArmored: pgpPublicKey
        });
      } else {
        if (message.link == null) {
          const bodyToBeHashed = {
            fromDID: message.fromDID,
            toDID: message.toDID,
            messageContent: message.messageContent,
            messageType: message.messageType
          };
          const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
          try {
            yield pgpHelper.verifySignature({
              messageContent: hash,
              signatureArmored: message.signature,
              publicKeyArmored: pgpPublicKey
            });
          } catch (err) {
            yield pgpHelper.verifySignature({
              messageContent: message.messageContent,
              signatureArmored: message.signature,
              publicKeyArmored: pgpPublicKey
            });
          }
        } else {
          yield pgpHelper.verifySignature({
            messageContent: message.messageContent,
            signatureArmored: message.signature,
            publicKeyArmored: pgpPublicKey
          });
        }
      }
      const decryptedMessage = Object.assign({}, message);
      try {
        let decryptedSecret;
        if (message.encType === "pgpv1:group") {
          const cacheKey = `sessionKey-${message.sessionKey}`;
          if (cache_1.cache.has(cacheKey)) {
            decryptedSecret = cache_1.cache.get(cacheKey);
          } else {
            const encryptedSecret = yield (0, getEncryptedSecret_1.getEncryptedSecret)({
              sessionKey: message.sessionKey,
              env
            });
            decryptedSecret = yield pgpHelper.pgpDecrypt({
              cipherText: encryptedSecret,
              toPrivateKeyArmored: pgpPrivateKey
            });
            cache_1.cache.set(cacheKey, decryptedSecret);
          }
        } else {
          decryptedSecret = yield pgpHelper.pgpDecrypt({
            cipherText: message.encryptedSecret,
            toPrivateKeyArmored: pgpPrivateKey
          });
        }
        decryptedMessage.messageContent = (0, aes_1.aesDecrypt)({
          cipherText: message.messageContent,
          secretKey: decryptedSecret
        });
        if (message.messageObj) {
          const decryptedMessageObj = (0, aes_1.aesDecrypt)({
            cipherText: message.messageObj,
            secretKey: decryptedSecret
          });
          try {
            decryptedMessage.messageObj = JSON.parse(decryptedMessageObj);
          } catch (err) {
            decryptedMessage.messageObj = decryptedMessageObj;
          }
          try {
            if (decryptedMessage.messageObj.reference) {
              const reference = decryptedMessage.messageObj.reference;
              if (reference && reference.split(":").length === 1) {
                const message2 = yield (0, ipfs_1.getCID)(reference, { env });
                decryptedMessage.messageObj.reference = message2.cid;
              }
            }
          } catch (err) {
          }
        }
      } catch (err) {
        decryptedMessage.messageContent = decryptedMessage.messageObj = "Unable to Decrypt Message";
      }
      return decryptedMessage;
    });
    exports.decryptAndVerifyMessage = decryptAndVerifyMessage;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/inbox.js
var require_inbox = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/inbox.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addDeprecatedInfoToMessages = exports.addDeprecatedInfo = exports.decryptConversation = exports.getTrendingSpaceInboxLists = exports.getSpaceInboxLists = exports.getInboxLists = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var PGP = require_pgp();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers3();
    var user_1 = require_user2();
    var ipfs_1 = require_ipfs();
    var crypto_1 = require_crypto4();
    var cache_1 = require_cache2();
    var getInboxLists = (options, pgpHelper = PGP.PGPHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { lists: feeds, user, toDecrypt, pgpPrivateKey, env = constants_1.default.ENV.PROD } = options || {};
      if (toDecrypt) {
        const connectedUser = yield (0, user_1.get)({
          account: (0, helpers_1.pCAIP10ToWallet)(user),
          env
        });
        return (0, crypto_1.decryptFeeds)({
          feeds,
          connectedUser,
          pgpPrivateKey,
          pgpHelper,
          env
        });
      }
      return feeds;
    });
    exports.getInboxLists = getInboxLists;
    var getSpaceInboxLists = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { lists, user, toDecrypt, pgpPrivateKey, env = constants_1.default.ENV.PROD } = options || {};
      const connectedUser = yield (0, user_1.get)({ account: (0, helpers_1.pCAIP10ToWallet)(user), env });
      const feeds = [];
      for (const list of lists) {
        let message;
        if (list.threadhash !== null) {
          message = yield (0, ipfs_1.getCID)(list.threadhash, { env });
        } else {
          message = {
            encType: "PlainText",
            encryptedSecret: "",
            fromCAIP10: "",
            fromDID: "",
            link: "",
            messageContent: "",
            messageType: "",
            sigType: "",
            signature: "",
            toCAIP10: "",
            toDID: ""
          };
        }
        feeds.push(Object.assign(Object.assign({}, list), { msg: message, spaceInformation: list.spaceInformation }));
      }
      if (toDecrypt)
        return (0, crypto_1.decryptFeeds)({
          feeds,
          connectedUser,
          pgpPrivateKey,
          pgpHelper: PGP.PGPHelper,
          env
        });
      return feeds;
    });
    exports.getSpaceInboxLists = getSpaceInboxLists;
    var getTrendingSpaceInboxLists = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { lists, env = constants_1.default.ENV.PROD } = options || {};
      const feeds = [];
      for (const list of lists) {
        let message;
        if (list.threadhash !== null) {
          message = yield (0, ipfs_1.getCID)(list.threadhash, { env });
        } else {
          message = {
            encType: "PlainText",
            encryptedSecret: "",
            fromCAIP10: "",
            fromDID: "",
            link: "",
            messageContent: "",
            messageType: "",
            sigType: "",
            signature: "",
            toCAIP10: "",
            toDID: ""
          };
        }
        feeds.push(Object.assign(Object.assign({}, list), { msg: message, spaceInformation: list.spaceInformation }));
      }
      return feeds;
    });
    exports.getTrendingSpaceInboxLists = getTrendingSpaceInboxLists;
    var decryptConversation = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { messages, connectedUser, pgpPrivateKey, pgpHelper = PGP.PGPHelper, env = constants_1.default.ENV.PROD } = options || {};
      let signatureValidationPubliKey;
      for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        if (message.encType !== "PlainText") {
          if (
            // legacy messages ( no way to know if they are decrypted or not )
            message.messageObj === void 0 || // new messages ( if messageObj is string then it is not decrypted )
            typeof message.messageObj === "string"
          ) {
            if (!pgpPrivateKey) {
              throw Error("Decrypted private key is necessary");
            }
            if (message.fromCAIP10 !== connectedUser.wallets.split(",")[0]) {
              const cacheKey = `pgpPubKey-${message.fromCAIP10}`;
              if (cache_1.cache.has(cacheKey)) {
                signatureValidationPubliKey = cache_1.cache.get(cacheKey);
              } else {
                const otherPeer = yield (0, user_1.get)({
                  account: message.fromCAIP10,
                  env
                });
                cache_1.cache.set(cacheKey, otherPeer.publicKey);
                signatureValidationPubliKey = otherPeer.publicKey;
              }
            } else {
              signatureValidationPubliKey = connectedUser.publicKey;
            }
            messages[i] = yield (0, crypto_1.decryptAndVerifyMessage)(message, signatureValidationPubliKey, pgpPrivateKey, env, pgpHelper);
          }
        }
      }
      return messages;
    });
    exports.decryptConversation = decryptConversation;
    exports.addDeprecatedInfo = /* @__PURE__ */ (() => {
      const latestDIDs = {};
      return (chats) => {
        chats.forEach((chat) => {
          if ((0, helpers_1.isValidNFTCAIP)(chat.did)) {
            const didWithoutTimestamp = chat.did.split(":").slice(0, 5).join(":");
            const timestamp = chat.did.split(":")[5];
            if (!latestDIDs[didWithoutTimestamp] || timestamp > latestDIDs[didWithoutTimestamp].split(":")[5]) {
              latestDIDs[didWithoutTimestamp] = chat.did;
            }
          }
        });
        chats.forEach((chat) => {
          if ((0, helpers_1.isValidNFTCAIP)(chat.did)) {
            const didWithoutTimestamp = chat.did.split(":").slice(0, 5).join(":");
            if (latestDIDs[didWithoutTimestamp] !== chat.did) {
              chat["deprecated"] = true;
              chat["deprecatedCode"] = "NFT Owner Changed";
            }
          }
        });
        return chats;
      };
    })();
    exports.addDeprecatedInfoToMessages = /* @__PURE__ */ (() => {
      const latestDIDs = {};
      return (chats) => {
        chats.forEach((chat) => {
          if ((0, helpers_1.isValidNFTCAIP)(chat.fromDID)) {
            const didWithoutTimestamp = chat.fromDID.split(":").slice(0, 5).join(":");
            const timestamp = chat.fromDID.split(":")[5];
            if (!latestDIDs[didWithoutTimestamp] || timestamp > latestDIDs[didWithoutTimestamp].split(":")[5]) {
              latestDIDs[didWithoutTimestamp] = chat.fromDID;
            }
          }
        });
        chats.forEach((chat) => {
          if ((0, helpers_1.isValidNFTCAIP)(chat.fromDID)) {
            const didWithoutTimestamp = chat.fromDID.split(":").slice(0, 5).join(":");
            if (latestDIDs[didWithoutTimestamp] !== chat.fromDID) {
              chat["deprecated"] = true;
              chat["deprecatedCode"] = "NFT Owner Changed";
            }
          }
        });
        return chats;
      };
    })();
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMembers.js
var require_getGroupMembers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMembers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupMembers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var validationError_1 = require_validationError();
    var getGroupMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, page = 1, limit = 20, env = constants_1.default.ENV.PROD, pending, role } = options;
      try {
        if (!chatId) {
          throw new Error("Chat ID is required.");
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        let requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}/members?pageNumber=${page}&pageSize=${limit}`;
        if (pending !== void 0) {
          requestUrl += `&pending=${pending}`;
        }
        if (role) {
          requestUrl += `&role=${encodeURIComponent(role)}`;
        }
        const response = yield axios_1.default.get(requestUrl);
        return response.data.members;
      } catch (error) {
        throw (0, validationError_1.handleError)(error, exports.getGroupMembers.name);
      }
    });
    exports.getGroupMembers = getGroupMembers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMemberCount.js
var require_getGroupMemberCount = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getGroupMemberCount.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroupMemberCount = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var axios_1 = require_axios();
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var validationError_1 = require_validationError();
    var getGroupMemberCount = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, env = constants_1.default.ENV.PROD } = options;
      try {
        if (!chatId) {
          throw new Error("Chat ID is required.");
        }
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}/members/count`;
        const response = yield axios_1.default.get(requestUrl);
        const { totalMembersCount } = response.data;
        return totalMembersCount;
      } catch (error) {
        throw (0, validationError_1.handleError)(error, exports.getGroupMemberCount.name);
      }
    });
    exports.getGroupMemberCount = getGroupMemberCount;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/getAllGroupMembers.js
var require_getAllGroupMembers = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/getAllGroupMembers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllGroupMembers = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var getGroupMembers_1 = require_getGroupMembers();
    var getGroupMemberCount_1 = require_getGroupMemberCount();
    var getAllGroupMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { chatId, env } = options;
      const count = yield (0, getGroupMemberCount_1.getGroupMemberCount)({ chatId, env });
      const overallCount = count.overallCount;
      const limit = 5e3;
      const totalPages = Math.ceil(overallCount / limit);
      const pageNumbers = Array.from({ length: totalPages }, (_, i) => i + 1);
      const groupMembers = [];
      const memberFetchPromises = pageNumbers.map((page) => (0, getGroupMembers_1.getGroupMembers)({ chatId, env, page, limit }));
      const membersResults = yield Promise.all(memberFetchPromises);
      membersResults.forEach((result) => {
        if (result.length > 0) {
          groupMembers.push(...result);
        }
      });
      return groupMembers;
    });
    exports.getAllGroupMembers = getAllGroupMembers;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/pushapi/pushAPITypes.js
var require_pushAPITypes = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/pushapi/pushAPITypes.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpaceListType = exports.ChatListType = void 0;
    var ChatListType;
    (function(ChatListType2) {
      ChatListType2["CHATS"] = "CHATS";
      ChatListType2["REQUESTS"] = "REQUESTS";
    })(ChatListType = exports.ChatListType || (exports.ChatListType = {}));
    var SpaceListType;
    (function(SpaceListType2) {
      SpaceListType2["SPACES"] = "SPACES";
      SpaceListType2["REQUESTS"] = "REQUESTS";
    })(SpaceListType = exports.SpaceListType || (exports.SpaceListType = {}));
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/payloadHelper.js
var require_payloadHelper = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/payloadHelper.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSpacesMembersList = exports.getMembersList = exports.convertToWalletAddressList = exports.getSpaceAdminsList = exports.getAdminsList = exports.updateGroupPayload = exports.groupAccessToSpaceAccess = exports.convertRulesToSpaceRules = exports.convertSpaceRulesToRules = exports.mapSpaceListTypeToChatListType = exports.spaceDtoToSpaceInfoDto = exports.groupInfoDtoToSpaceInfoDto = exports.groupDtoToSpaceDtoV2 = exports.groupDtoToSpaceDto = exports.createGroupPayload = exports.rejectRequestPayload = exports.sendMessagePayloadCore = exports.sendMessagePayload = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var crypto_1 = require_crypto4();
    var constants_1 = require_constants2();
    var pgp_1 = require_pgp();
    var AES = require_aes2();
    var CryptoJS = require_crypto_js();
    var getAllGroupMembers_1 = require_getAllGroupMembers();
    var pushAPITypes_1 = require_pushAPITypes();
    var sendMessagePayload = (receiverAddress, senderCreatedUser, messageObj, messageContent, messageType, group, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.sendMessagePayloadCore)(receiverAddress, senderCreatedUser, messageObj, messageContent, messageType, group, env, pgp_1.PGPHelper);
    });
    exports.sendMessagePayload = sendMessagePayload;
    var sendMessagePayloadCore = (receiverAddress, senderCreatedUser, messageObj, messageContent, messageType, group, env, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const isGroup = group !== null;
      let secretKey;
      if (isGroup && (group === null || group === void 0 ? void 0 : group.encryptedSecret) && group.sessionKey) {
        secretKey = yield (0, pgp_1.pgpDecrypt)({
          cipherText: group.encryptedSecret,
          toPrivateKeyArmored: senderCreatedUser.privateKey
        });
      } else {
        secretKey = AES.generateRandomSecret(15);
      }
      const { message: encryptedMessageContent, signature: deprecatedSignature } = yield (0, crypto_1.getEncryptedRequestCore)(receiverAddress, senderCreatedUser, messageContent, isGroup, env, group, secretKey, pgpHelper);
      const { message: encryptedMessageObj, encryptionType, aesEncryptedSecret } = yield (0, crypto_1.getEncryptedRequestCore)(receiverAddress, senderCreatedUser, JSON.stringify(messageObj), isGroup, env, group, secretKey, pgpHelper);
      const body = {
        fromDID: (0, helpers_1.walletToPCAIP10)(senderCreatedUser.wallets.split(",")[0]),
        toDID: isGroup ? receiverAddress : (0, helpers_1.walletToPCAIP10)(receiverAddress),
        fromCAIP10: (0, helpers_1.walletToPCAIP10)(senderCreatedUser.wallets.split(",")[0]),
        toCAIP10: isGroup ? receiverAddress : (0, helpers_1.walletToPCAIP10)(receiverAddress),
        messageType,
        messageObj: encryptionType === "PlainText" ? messageObj : encryptedMessageObj,
        encType: encryptionType,
        sessionKey: group && !group.isPublic && encryptionType === "pgpv1:group" ? group.sessionKey : null,
        encryptedSecret: aesEncryptedSecret,
        messageContent: encryptedMessageContent,
        signature: deprecatedSignature,
        sigType: "pgpv3"
      };
      const bodyToBeHashed = {
        fromDID: body.fromDID,
        toDID: body.fromDID,
        fromCAIP10: body.fromCAIP10,
        toCAIP10: body.toCAIP10,
        messageObj: body.messageObj,
        messageType: body.messageType,
        encType: body.encType,
        sessionKey: body.sessionKey,
        encryptedSecret: body.encryptedSecret
      };
      const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
      const signature = yield pgpHelper.sign({
        message: hash,
        signingKey: senderCreatedUser.privateKey
      });
      body.verificationProof = `pgpv3:${signature}`;
      return body;
    });
    exports.sendMessagePayloadCore = sendMessagePayloadCore;
    var rejectRequestPayload = (fromDID, toDID, sigType, signature) => {
      const body = {
        fromDID,
        toDID,
        verificationProof: sigType + ":" + signature
      };
      return body;
    };
    exports.rejectRequestPayload = rejectRequestPayload;
    var createGroupPayload = (groupName, members, admins, isPublic, groupCreator, verificationProof, groupDescription, groupImage, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20, meta, groupType, scheduleAt, scheduleEnd, rules) => {
      const body = {
        groupName,
        groupDescription,
        members,
        groupImage,
        admins,
        isPublic,
        contractAddressNFT,
        numberOfNFTs,
        contractAddressERC20,
        numberOfERC20,
        groupCreator,
        verificationProof,
        meta,
        groupType,
        scheduleAt,
        scheduleEnd,
        rules
      };
      return body;
    };
    exports.createGroupPayload = createGroupPayload;
    var groupDtoToSpaceDto = (groupDto) => {
      var _a;
      const spaceDto = {
        members: groupDto.members.map((member) => ({
          wallet: member.wallet,
          publicKey: member.publicKey,
          isSpeaker: member.isAdmin,
          image: member.image
        })),
        pendingMembers: groupDto.pendingMembers.map((pendingMember) => ({
          wallet: pendingMember.wallet,
          publicKey: pendingMember.publicKey,
          isSpeaker: pendingMember.isAdmin,
          image: pendingMember.image
        })),
        contractAddressERC20: groupDto.contractAddressERC20,
        numberOfERC20: groupDto.numberOfERC20,
        contractAddressNFT: groupDto.contractAddressNFT,
        numberOfNFTTokens: groupDto.numberOfNFTTokens,
        verificationProof: groupDto.verificationProof,
        spaceImage: groupDto.groupImage,
        spaceName: groupDto.groupName,
        isPublic: groupDto.isPublic,
        spaceDescription: groupDto.groupDescription,
        spaceCreator: groupDto.groupCreator,
        spaceId: groupDto.chatId,
        scheduleAt: groupDto.scheduleAt,
        scheduleEnd: groupDto.scheduleEnd,
        status: (_a = groupDto.status) !== null && _a !== void 0 ? _a : null,
        meta: groupDto.meta
      };
      if (groupDto.rules) {
        spaceDto.rules = {
          entry: groupDto.rules.entry
        };
      }
      return spaceDto;
    };
    exports.groupDtoToSpaceDto = groupDtoToSpaceDto;
    var groupDtoToSpaceDtoV2 = (groupDto, env = constants_1.ENV.PROD) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a;
      const members = yield (0, getAllGroupMembers_1.getAllGroupMembers)({
        chatId: groupDto.chatId,
        env
      });
      const spaceDto = {
        members: members.filter((member) => member.intent).map((member) => {
          var _a2, _b;
          return {
            wallet: member.address,
            publicKey: (_a2 = member.userInfo.publicKey) !== null && _a2 !== void 0 ? _a2 : "",
            isSpeaker: member.role === "admin",
            image: (_b = member.userInfo.profile.picture) !== null && _b !== void 0 ? _b : ""
          };
        }),
        pendingMembers: members.filter((member) => !member.intent).map((pendingMember) => {
          var _a2, _b;
          return {
            wallet: pendingMember.address,
            publicKey: (_a2 = pendingMember.userInfo.publicKey) !== null && _a2 !== void 0 ? _a2 : "",
            isSpeaker: pendingMember.role === "admin",
            image: (_b = pendingMember.userInfo.profile.picture) !== null && _b !== void 0 ? _b : ""
          };
        }),
        contractAddressERC20: null,
        numberOfERC20: 0,
        contractAddressNFT: null,
        numberOfNFTTokens: 0,
        verificationProof: "a",
        spaceImage: groupDto.groupImage,
        spaceName: groupDto.groupName,
        isPublic: groupDto.isPublic,
        spaceDescription: groupDto.groupDescription,
        spaceCreator: groupDto.groupCreator,
        spaceId: groupDto.chatId,
        scheduleAt: groupDto.scheduleAt,
        scheduleEnd: groupDto.scheduleEnd,
        status: (_a = groupDto.status) !== null && _a !== void 0 ? _a : null,
        meta: groupDto.meta
      };
      if (groupDto.rules) {
        spaceDto.rules = {
          entry: groupDto.rules.entry
        };
      }
      return spaceDto;
    });
    exports.groupDtoToSpaceDtoV2 = groupDtoToSpaceDtoV2;
    var groupInfoDtoToSpaceInfoDto = (groupInfoDto) => {
      var _a, _b, _c, _d, _e;
      const spaceInfoDto = {
        spaceName: groupInfoDto.groupName,
        spaceImage: groupInfoDto.groupImage,
        spaceDescription: groupInfoDto.groupDescription,
        isPublic: groupInfoDto.isPublic,
        spaceCreator: groupInfoDto.groupCreator,
        spaceId: groupInfoDto.chatId,
        scheduleAt: groupInfoDto.scheduleAt,
        scheduleEnd: groupInfoDto.scheduleEnd,
        status: (_a = groupInfoDto.status) !== null && _a !== void 0 ? _a : null,
        rules: (_b = groupInfoDto.rules) !== null && _b !== void 0 ? _b : null,
        meta: (_c = groupInfoDto.meta) !== null && _c !== void 0 ? _c : null,
        sessionKey: (_d = groupInfoDto.sessionKey) !== null && _d !== void 0 ? _d : null,
        encryptedSecret: (_e = groupInfoDto.encryptedSecret) !== null && _e !== void 0 ? _e : null
      };
      return spaceInfoDto;
    };
    exports.groupInfoDtoToSpaceInfoDto = groupInfoDtoToSpaceInfoDto;
    var spaceDtoToSpaceInfoDto = (spaceDto) => {
      return {
        spaceName: spaceDto.spaceName,
        spaceImage: spaceDto.spaceImage,
        spaceDescription: spaceDto.spaceDescription,
        isPublic: spaceDto.isPublic,
        spaceCreator: spaceDto.spaceCreator,
        spaceId: spaceDto.spaceId,
        scheduleAt: spaceDto.scheduleAt,
        scheduleEnd: spaceDto.scheduleEnd,
        status: spaceDto.status,
        rules: spaceDto.rules,
        meta: spaceDto.meta,
        sessionKey: null,
        encryptedSecret: null,
        inviteeDetails: spaceDto.inviteeDetails
      };
    };
    exports.spaceDtoToSpaceInfoDto = spaceDtoToSpaceInfoDto;
    var mapSpaceListTypeToChatListType = (type) => {
      switch (type) {
        case pushAPITypes_1.SpaceListType.SPACES:
          return pushAPITypes_1.ChatListType.CHATS;
        case pushAPITypes_1.SpaceListType.REQUESTS:
          return pushAPITypes_1.ChatListType.REQUESTS;
        default:
          throw new Error(`Unsupported SpaceListType: ${type}`);
      }
    };
    exports.mapSpaceListTypeToChatListType = mapSpaceListTypeToChatListType;
    var convertSpaceRulesToRules = (spaceRules) => {
      return {
        entry: spaceRules.entry,
        chat: void 0
      };
    };
    exports.convertSpaceRulesToRules = convertSpaceRulesToRules;
    var convertRulesToSpaceRules = (rules) => {
      return {
        entry: rules.entry
      };
    };
    exports.convertRulesToSpaceRules = convertRulesToSpaceRules;
    var groupAccessToSpaceAccess = (group) => {
      const spaceAccess = {
        entry: group.entry
      };
      if (group.rules) {
        spaceAccess.rules = (0, exports.convertRulesToSpaceRules)(group.rules);
      }
      return spaceAccess;
    };
    exports.groupAccessToSpaceAccess = groupAccessToSpaceAccess;
    var updateGroupPayload = (groupName, members, admins, address, verificationProof, encryptedSecret, groupDescription, groupImage, scheduleAt, scheduleEnd, status, meta, rules) => {
      const body = Object.assign(Object.assign({ groupName, groupImage, groupDescription, members, admins, address, verificationProof, encryptedSecret, scheduleAt, scheduleEnd, status }, meta !== void 0 && { meta }), rules !== void 0 && { rules });
      return body;
    };
    exports.updateGroupPayload = updateGroupPayload;
    var getAdminsList = (members, pendingMembers) => {
      const adminsFromMembers = members ? (0, exports.convertToWalletAddressList)(members.filter((admin) => admin.isAdmin)) : [];
      const adminsFromPendingMembers = pendingMembers ? (0, exports.convertToWalletAddressList)(pendingMembers.filter((admin) => admin.isAdmin)) : [];
      const adminList = [...adminsFromMembers, ...adminsFromPendingMembers];
      return adminList;
    };
    exports.getAdminsList = getAdminsList;
    var getSpaceAdminsList = (members, pendingMembers) => {
      const adminsFromMembers = members ? (0, exports.convertToWalletAddressList)(members.filter((admin) => admin.isSpeaker)) : [];
      const adminsFromPendingMembers = pendingMembers ? (0, exports.convertToWalletAddressList)(pendingMembers.filter((admin) => admin.isSpeaker)) : [];
      const adminList = [...adminsFromMembers, ...adminsFromPendingMembers];
      return adminList;
    };
    exports.getSpaceAdminsList = getSpaceAdminsList;
    var convertToWalletAddressList = (memberList) => {
      return memberList ? memberList.map((member) => member.wallet) : [];
    };
    exports.convertToWalletAddressList = convertToWalletAddressList;
    var getMembersList = (members, pendingMembers) => {
      const allMembers = [...members || [], ...pendingMembers || []];
      return (0, exports.convertToWalletAddressList)(allMembers);
    };
    exports.getMembersList = getMembersList;
    var getSpacesMembersList = (members, pendingMembers) => {
      const allMembers = [...members || [], ...pendingMembers || []];
      return (0, exports.convertToWalletAddressList)(allMembers);
    };
    exports.getSpacesMembersList = getSpacesMembersList;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/validator.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateGroupMemberUpdateOptions = exports.updateGroupRequestValidator = exports.validateScheduleDates = exports.createSpaceRequestValidator = exports.createGroupRequestValidator = void 0;
    var helpers_1 = require_helpers3();
    var createGroupRequestValidator = (groupName, members, admins, groupDescription, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20) => {
      if (groupName == null || groupName.length == 0) {
        throw new Error(`groupName cannot be null or empty`);
      }
      if (groupName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
      }
      if (groupDescription && groupDescription.length > 150) {
        throw new Error(`groupDescription cannot be more than 150 characters`);
      }
      if (members == null) {
        throw new Error(`members cannot be null`);
      }
      for (let i = 0; i < members.length; i++) {
        if (members[i] && !(0, helpers_1.isValidPushCAIP)(members[i])) {
          throw new Error(`Invalid member address!`);
        }
      }
      if (admins == null) {
        throw new Error(`admins cannot be null`);
      }
      for (let i = 0; i < admins.length; i++) {
        if (!(0, helpers_1.isValidPushCAIP)(admins[i])) {
          throw new Error(`Invalid admin address!`);
        }
      }
      if (contractAddressNFT != null && (contractAddressNFT === null || contractAddressNFT === void 0 ? void 0 : contractAddressNFT.length) > 0 && !(0, helpers_1.isValidFullCAIP10)(contractAddressNFT)) {
        throw new Error(`Invalid contractAddressNFT address!`);
      }
      if (numberOfNFTs != null && numberOfNFTs < 0) {
        throw new Error(`numberOfNFTs cannot be negative number`);
      }
      if (contractAddressERC20 != null && (contractAddressERC20 === null || contractAddressERC20 === void 0 ? void 0 : contractAddressERC20.length) > 0 && !(0, helpers_1.isValidFullCAIP10)(contractAddressERC20)) {
        throw new Error(`Invalid contractAddressERC20 address!`);
      }
      if (numberOfERC20 != null && numberOfERC20 < 0) {
        throw new Error(`numberOfERC20 cannot be negative number`);
      }
    };
    exports.createGroupRequestValidator = createGroupRequestValidator;
    var createSpaceRequestValidator = (spaceName, spaceDescription, members, admins, contractAddressNFT, numberOfNFTs, contractAddressERC20, numberOfERC20) => {
      if (spaceName == null || spaceName.length == 0) {
        throw new Error(`spaceName cannot be null or empty`);
      }
      if (spaceName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
      }
      if (spaceDescription && spaceDescription.length > 150) {
        throw new Error(`spaceDescription cannot be more than 150 characters`);
      }
      if (members == null) {
        throw new Error(`members cannot be null`);
      }
      for (let i = 0; i < members.length; i++) {
        if (members[i] && !(0, helpers_1.isValidPushCAIP)(members[i])) {
          throw new Error(`Invalid member address!`);
        }
      }
      if (admins == null) {
        throw new Error(`admins cannot be null`);
      }
      for (let i = 0; i < admins.length; i++) {
        if (!(0, helpers_1.isValidPushCAIP)(admins[i])) {
          throw new Error(`Invalid admin address!`);
        }
      }
      if (contractAddressNFT != null && (contractAddressNFT === null || contractAddressNFT === void 0 ? void 0 : contractAddressNFT.length) > 0 && !(0, helpers_1.isValidFullCAIP10)(contractAddressNFT)) {
        throw new Error(`Invalid contractAddressNFT address!`);
      }
      if (numberOfNFTs != null && numberOfNFTs < 0) {
        throw new Error(`numberOfNFTs cannot be negative number`);
      }
      if (contractAddressERC20 != null && (contractAddressERC20 === null || contractAddressERC20 === void 0 ? void 0 : contractAddressERC20.length) > 0 && !(0, helpers_1.isValidFullCAIP10)(contractAddressERC20)) {
        throw new Error(`Invalid contractAddressERC20 address!`);
      }
      if (numberOfERC20 != null && numberOfERC20 < 0) {
        throw new Error(`numberOfERC20 cannot be negative number`);
      }
    };
    exports.createSpaceRequestValidator = createSpaceRequestValidator;
    var validateScheduleDates = (scheduleAt, scheduleEnd) => {
      if (scheduleAt) {
        const start = new Date(scheduleAt);
        const now = /* @__PURE__ */ new Date();
        if (start < now) {
          throw new Error("Schedule start time must be in the future.");
        }
        if (scheduleEnd) {
          const end = new Date(scheduleEnd);
          if (end < now) {
            throw new Error("Schedule end time must be in the future.");
          }
          if (start >= end) {
            throw new Error("Schedule start time must be earlier than end time.");
          }
        }
      }
    };
    exports.validateScheduleDates = validateScheduleDates;
    var updateGroupRequestValidator = (chatId, groupName, members, admins, address, groupDescription) => {
      if (chatId == null || chatId.length == 0) {
        throw new Error(`chatId cannot be null or empty`);
      }
      if (groupName == null || groupName.length == 0) {
        throw new Error(`groupName cannot be null or empty`);
      }
      if (groupName != null && groupName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
      }
      if (groupDescription && groupDescription != null && groupDescription.length > 150) {
        throw new Error(`groupDescription cannot be more than 150 characters`);
      }
      if (members != null && members.length > 0) {
        for (let i = 0; i < members.length; i++) {
          if (!(0, helpers_1.isValidPushCAIP)(members[i])) {
            throw new Error(`Invalid member address in members list!`);
          }
        }
      }
      if (admins != null && admins.length > 0) {
        for (let i = 0; i < admins.length; i++) {
          if (!(0, helpers_1.isValidPushCAIP)(admins[i])) {
            throw new Error(`Invalid member address in admins list!`);
          }
        }
      }
      if (address != null && !(0, helpers_1.isValidPushCAIP)(address)) {
        throw new Error(`Invalid address field!`);
      }
    };
    exports.updateGroupRequestValidator = updateGroupRequestValidator;
    var validateGroupMemberUpdateOptions = (options) => {
      const { chatId, upsert, remove } = options;
      if (!chatId || chatId.trim().length === 0) {
        throw new Error("Chat ID cannot be null or empty.");
      }
      const allowedRoles = ["members", "admins"];
      Object.keys(upsert).forEach((role) => {
        if (!allowedRoles.includes(role)) {
          throw new Error(`Invalid role: ${role}. Allowed roles are ${allowedRoles.join(", ")}.`);
        }
        if (upsert[role] && upsert[role].length > 1e3) {
          throw new Error(`${role} array cannot have more than 1000 addresses.`);
        }
        upsert[role].forEach((address) => {
          if (!(0, helpers_1.isValidPushCAIP)(address)) {
            throw new Error(`Invalid address found in ${role} list.`);
          }
        });
      });
      if (remove && remove.length > 1e3) {
        throw new Error("Remove array cannot have more than 1000 addresses.");
      }
      remove.forEach((address) => {
        if (!(0, helpers_1.isValidPushCAIP)(address)) {
          throw new Error("Invalid address found in remove list.");
        }
      });
    };
    exports.validateGroupMemberUpdateOptions = validateGroupMemberUpdateOptions;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/group.js
var require_group = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/group.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGroup = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var axiosUtil_1 = require_axiosUtil();
    var getGroup = (options, chatId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { env = constants_1.default.ENV.PROD } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v1/chat/groups/${chatId}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        return response.data;
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
        throw Error(`[Push SDK] - API ${requestUrl}: ${err}`);
      });
    });
    exports.getGroup = getGroup;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/chat/helpers/index.js
var require_helpers2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/chat/helpers/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_aes2(), exports);
    tslib_1.__exportStar(require_pgp(), exports);
    tslib_1.__exportStar(require_user(), exports);
    tslib_1.__exportStar(require_crypto4(), exports);
    tslib_1.__exportStar(require_service(), exports);
    tslib_1.__exportStar(require_inbox(), exports);
    tslib_1.__exportStar(require_payloadHelper(), exports);
    tslib_1.__exportStar(require_validator(), exports);
    tslib_1.__exportStar(require_group(), exports);
    tslib_1.__exportStar(require_wallet2(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/progressHook.js
var require_progressHook = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/progressHook.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var PROGRESSHOOK = {
      /**
       * PUSH-CREATE PROGRESSHOOKS
       */
      "PUSH-CREATE-01": {
        progressId: "PUSH-CREATE-01",
        progressTitle: "Generating Secure Profile Signature",
        progressInfo: "This step is only done for first time users and might take a few seconds. PGP keys are getting generated to provide you with secure yet seamless web3 communication",
        level: "INFO"
      },
      /**
       * @deprecated
       */
      "PUSH-CREATE-02": {
        progressId: "PUSH-CREATE-02",
        progressTitle: "Signing Generated Profile",
        progressInfo: "This step is only done for first time users. Please sign the message to continue.",
        level: "INFO"
      },
      "PUSH-CREATE-03": {
        progressId: "PUSH-CREATE-03",
        progressTitle: "Encrypting Generated Profile",
        progressInfo: "Encrypting your keys. Please sign the message to continue.",
        level: "INFO"
      },
      "PUSH-CREATE-04": {
        progressId: "PUSH-CREATE-04",
        progressTitle: "Syncing Generated Profile",
        progressInfo: "Please sign the message to continue. Great job! You are almost fully onboarded to Push Protocol!",
        level: "INFO"
      },
      "PUSH-CREATE-05": {
        progressId: "PUSH-CREATE-05",
        progressTitle: "Setup Complete",
        progressInfo: "",
        level: "SUCCESS"
      },
      /**
       * PUSH-UPGRADE PROGRESSHOOKS
       */
      /**
       * @deprecated
       */
      "PUSH-UPGRADE-01": {
        progressId: "PUSH-UPGRADE-01",
        progressTitle: "Generating New Profile Signature",
        progressInfo: "Trying to Upgrade Push Keys to latest version. Please sign the message to continue.",
        level: "INFO"
      },
      "PUSH-UPGRADE-02": {
        progressId: "PUSH-UPGRADE-02",
        progressTitle: "Decrypting Old Profile",
        progressInfo: "Trying to Upgrade Push Keys to latest version. Please sign the message to continue.",
        level: "INFO"
      },
      /**
       * @deprecated
       */
      "PUSH-UPGRADE-03": {
        progressId: "PUSH-UPGRADE-03",
        progressTitle: "Generating Encrypted New Profile",
        progressInfo: "Trying to Upgrade Push Keys to latest version. Encrypting Push Keys with latest version. Please sign the message to continue.",
        level: "INFO"
      },
      /**
       * @deprecated
       */
      "PUSH-UPGRADE-04": {
        progressId: "PUSH-UPGRADE-04",
        progressTitle: "Syncing New Profile",
        progressInfo: "Please sign the message to continue. Upgraded keys are almost ready!",
        level: "INFO"
      },
      "PUSH-UPGRADE-05": {
        progressId: "PUSH-UPGRADE-05",
        progressTitle: "Upgrade Completed, Welcome to Push Protocol",
        progressInfo: "",
        level: "SUCCESS"
      },
      /**
       * PUSH-DECRYPT PROGRESSHOOKS
       */
      "PUSH-DECRYPT-01": {
        progressId: "PUSH-DECRYPT-01",
        progressTitle: "Decrypting Profile",
        progressInfo: "Please sign the transaction to decrypt profile",
        level: "INFO"
      },
      "PUSH-DECRYPT-02": {
        progressId: "PUSH-DECRYPT-02",
        progressTitle: "Push Profile Unlocked",
        progressInfo: "Unlocking push profile",
        level: "SUCCESS"
      },
      /**
       * PUSH-AUTH-UPDATE PROGRESSHOOKS
       */
      "PUSH-AUTH-UPDATE-01": (pgpEncryptionVersion) => {
        return {
          progressId: "PUSH-AUTH-UPDATE-01",
          progressTitle: "Generating New Profile Signature",
          progressInfo: `Trying to Update Push Keys to ${pgpEncryptionVersion} version. Please sign the message to continue.`,
          level: "INFO"
        };
      },
      "PUSH-AUTH-UPDATE-02": (pgpEncryptionVersion) => {
        return {
          progressId: "PUSH-AUTH-UPDATE-02",
          progressTitle: "Generating New Encrypted Profile",
          progressInfo: `Encrypting Push Keys with ${pgpEncryptionVersion} version. Please sign the message to continue.`,
          level: "INFO"
        };
      },
      "PUSH-AUTH-UPDATE-03": {
        progressId: "PUSH-AUTH-UPDATE-03",
        progressTitle: "Syncing Updated Profile",
        progressInfo: "Please sign the message to continue. Updated keys are almost ready!",
        level: "INFO"
      },
      "PUSH-AUTH-UPDATE-04": {
        progressId: "PUSH-AUTH-UPDATE-04",
        progressTitle: "Update Completed, Welcome to Push Protocol",
        progressInfo: "",
        level: "SUCCESS"
      },
      "PUSH-AUTH-UPDATE-05": {
        progressId: "PUSH-AUTH-UPDATE-05",
        progressTitle: "Generating New Profile Signature",
        progressInfo: `Trying to Update Push Profile creds. Please sign the message to continue.`,
        level: "INFO"
      },
      "PUSH-AUTH-UPDATE-06": {
        progressId: "PUSH-AUTH-UPDATE-06",
        progressTitle: "Generating New Profile Signature",
        progressInfo: `Encrypting Push Keys with new creds. Please sign the message to continue.`,
        level: "INFO"
      },
      /**
       * PUSH-DECRYPT-AUTH PROGRESSHOOKS
       */
      "PUSH-DECRYPT-AUTH-01": {
        progressId: "PUSH-DECRYPT-AUTH-01",
        progressTitle: "Decrypting Profile Creds",
        progressInfo: "Please sign the transaction to decrypt profile creds.",
        level: "INFO"
      },
      "PUSH-DECRYPT-AUTH-02": {
        progressId: "PUSH-DECRYPT-AUTH-02",
        progressTitle: "Push Profile Creds Unlocked",
        progressInfo: "Unlocking push profile creds.",
        level: "SUCCESS"
      },
      /**
       * PUSH-PROFILE-UPDATE PROGRESSHOOKS
       */
      "PUSH-PROFILE-UPDATE-01": {
        progressId: "PUSH-PROFILE-UPDATE-01",
        progressTitle: "Syncing Updated Profile",
        progressInfo: "Steady lads, your profile is getting a new look!",
        level: "INFO"
      },
      "PUSH-PROFILE-UPDATE-02": {
        progressId: "PUSH-PROFILE-UPDATE-02",
        progressTitle: "Profile Update Completed, Welcome to Push Protocol",
        progressInfo: "",
        level: "SUCCESS"
      },
      /**
       * PUSH_CHANNEL_CREATE PROGRESSHOOKS
       */
      "PUSH-CHANNEL-CREATE-01": {
        progressId: "PUSH-CHANNEL-CREATE-01",
        progressTitle: "Uploading data to IPFS",
        progressInfo: "The channel’s data is getting uploaded to IPFS",
        level: "INFO"
      },
      "PUSH-CHANNEL-CREATE-02": {
        progressId: "PUSH-CHANNEL-CREATE-02",
        progressTitle: "Approving PUSH tokens",
        progressInfo: "Gives approval to Push Core contract to spend 50 PUSH",
        level: "INFO"
      },
      "PUSH-CHANNEL-CREATE-03": {
        progressId: "PUSH-CHANNEL-CREATE-03",
        progressTitle: "Channel is getting created",
        progressInfo: "Calls Push Core contract to create your channel",
        level: "INFO"
      },
      "PUSH-CHANNEL-CREATE-04": {
        progressId: "PUSH-CHANNEL-CREATE-04",
        progressTitle: "Channel creation is done, Welcome to Push Ecosystem",
        progressInfo: "Channel creation is completed",
        level: "SUCCESS"
      },
      /**
       * PUSH_CHANNEL_UPDATE PROGRESSHOOKS
       */
      "PUSH-CHANNEL-UPDATE-01": {
        progressId: "PUSH-CHANNEL-UPDATE-01",
        progressTitle: "Uploading new data to IPFS",
        progressInfo: "The channel’s new data is getting uploaded to IPFS",
        level: "INFO"
      },
      "PUSH-CHANNEL-UPDATE-02": {
        progressId: "PUSH-CHANNEL-UPDATE-02",
        progressTitle: "Approving PUSH tokens",
        progressInfo: "Gives approval to Push Core contract to spend 50 PUSH",
        level: "INFO"
      },
      "PUSH-CHANNEL-UPDATE-03": {
        progressId: "PUSH-CHANNEL-UPDATE-03",
        progressTitle: "Channel is getting updated",
        progressInfo: "Calls Push Core contract to update your channel details",
        level: "INFO"
      },
      "PUSH-CHANNEL-UPDATE-04": {
        progressId: "PUSH-CHANNEL-UPDATE-04",
        progressTitle: "Channel is updated with new data",
        progressInfo: "Channel is successfully updated",
        level: "SUCCESS"
      },
      /**
       * PUSH-ERROR PROGRESSHOOKS
       */
      "PUSH-ERROR-00": (functionName, err) => {
        return {
          progressId: "PUSH-ERROR-00",
          progressTitle: "Non Specific Error",
          progressInfo: `[Push SDK] - API  - Error - API ${functionName}() -: ${err}`,
          level: "ERROR"
        };
      },
      "PUSH-ERROR-01": (err) => {
        return {
          progressId: "PUSH-ERROR-01",
          progressTitle: "Upgrade Profile Failed",
          progressInfo: `[Push SDK] - API  - Error - API decryptPgpKey() -: ${err}`,
          level: "WARN"
        };
      },
      "PUSH-ERROR-02": (name, err) => {
        return {
          progressId: "PUSH-ERROR-02",
          progressTitle: "Transaction failed",
          progressInfo: `[Push SDK] - Contract  - Error - ${name} -: ${err}`,
          level: "ERROR"
        };
      }
    };
    exports.default = PROGRESSHOOK;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getUser.js
var require_getUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var address_1 = require_address4();
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var populateIUser_1 = require_populateIUser();
    var axiosUtil_1 = require_axiosUtil();
    var get = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { account, env = constants_1.default.ENV.PROD } = options || {};
      if (!(0, address_1.isValidPushCAIP)(account)) {
        throw new Error(`Invalid address!`);
      }
      const caip10 = (0, address_1.walletToPCAIP10)(account);
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v2/users/?caip10=${caip10}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (response.data) {
          response.data.publicKey = yield (0, helpers_1.verifyProfileKeys)(response.data.encryptedPrivateKey, response.data.publicKey, response.data.did, response.data.wallets, response.data.verificationProof);
        }
        return (0, populateIUser_1.populateDeprecatedUser)(response.data);
      })).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
        throw Error(`[Push SDK] - API ${requestUrl}: ${err}`);
      });
    });
    exports.get = get;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/auth.updateUser.js
var require_auth_updateUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/auth.updateUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authUpdate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var helpers_2 = require_helpers3();
    var progressHook_1 = require_progressHook();
    var getUser_1 = require_getUser();
    var ENCRYPTION_TYPE_VERSION;
    (function(ENCRYPTION_TYPE_VERSION2) {
      ENCRYPTION_TYPE_VERSION2["x25519-xsalsa20-poly1305"] = "PGP_V1";
      ENCRYPTION_TYPE_VERSION2["aes256GcmHkdfSha256"] = "PGP_V2";
      ENCRYPTION_TYPE_VERSION2["eip191-aes256-gcm-hkdf-sha256"] = "PGP_V3";
      ENCRYPTION_TYPE_VERSION2["pgpv1:nft"] = "NFTPGP_V1";
    })(ENCRYPTION_TYPE_VERSION || (ENCRYPTION_TYPE_VERSION = {}));
    var authUpdate = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a;
      const { pgpPrivateKey, pgpEncryptionVersion, signer, pgpPublicKey, account = null, env = constants_1.default.ENV.PROD, additionalMeta, progressHook } = options || {};
      try {
        const wallet = (0, helpers_1.getWallet)({ account, signer });
        const address = yield (0, helpers_1.getAccountAddress)(wallet);
        const updatingCreds = pgpEncryptionVersion === constants_1.default.ENCRYPTION_TYPE.NFTPGP_V1 ? true : false;
        if (!(0, helpers_2.isValidPushCAIP)(address)) {
          throw new Error(`Invalid address!`);
        }
        const caip10 = (0, helpers_2.walletToPCAIP10)(address);
        const user = yield (0, getUser_1.get)({ account: caip10, env });
        if (!user || !user.encryptedPrivateKey) {
          throw new Error("User not Found!");
        }
        updatingCreds ? progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-05"]) : progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-01"](ENCRYPTION_TYPE_VERSION[pgpEncryptionVersion]));
        const signedPublicKey = yield (0, helpers_2.preparePGPPublicKey)(pgpEncryptionVersion, pgpPublicKey, wallet);
        updatingCreds ? progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-06"]) : progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-02"](ENCRYPTION_TYPE_VERSION[pgpEncryptionVersion]));
        const encryptedPgpPrivateKey = yield (0, helpers_2.encryptPGPKey)(pgpEncryptionVersion, pgpPrivateKey, wallet, additionalMeta);
        if (pgpEncryptionVersion === constants_1.ENCRYPTION_TYPE.NFTPGP_V1) {
          const encryptedPassword = yield (0, helpers_2.encryptPGPKey)(constants_1.ENCRYPTION_TYPE.PGP_V3, (_a = additionalMeta === null || additionalMeta === void 0 ? void 0 : additionalMeta.NFTPGP_V1) === null || _a === void 0 ? void 0 : _a.password, wallet, additionalMeta);
          encryptedPgpPrivateKey.encryptedPassword = encryptedPassword;
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-03"]);
        const body = {
          user: user.did,
          wallet,
          publicKey: signedPublicKey,
          encryptedPrivateKey: JSON.stringify(encryptedPgpPrivateKey),
          env
        };
        const updatedUser = yield (0, helpers_1.authUpdateUserService)(body);
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-AUTH-UPDATE-04"]);
        return updatedUser;
      } catch (err) {
        const errorProgressHook = progressHook_1.default["PUSH-ERROR-00"];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.authUpdate.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.authUpdate.name} -: ${err}`);
      }
    });
    exports.authUpdate = authUpdate;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/profile.updateUser.js
var require_profile_updateUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/profile.updateUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.profileUpdateCore = exports.profileUpdate = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var CryptoJS = require_crypto_js();
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var helpers_2 = require_helpers3();
    var getUser_1 = require_getUser();
    var populateIUser_1 = require_populateIUser();
    var progressHook_1 = require_progressHook();
    var axiosUtil_1 = require_axiosUtil();
    var profileUpdate = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return (0, exports.profileUpdateCore)(options, helpers_1.PGPHelper);
    });
    exports.profileUpdate = profileUpdate;
    var profileUpdateCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { pgpPrivateKey, account, profile, env = constants_1.default.ENV.PROD, progressHook } = options || {};
      try {
        if (!(0, helpers_2.isValidPushCAIP)(account)) {
          throw new Error(`Invalid account!`);
        }
        const user = yield (0, getUser_1.get)({ account, env });
        if (!user || !user.did) {
          throw new Error("User not Found!");
        }
        let blockedUsersList = null;
        if (profile.blockedUsersList) {
          for (const element of profile.blockedUsersList) {
            if (!(0, helpers_2.isValidPushCAIP)(element)) {
              throw new Error("Invalid address in the blockedUsersList: " + element);
            }
          }
          const convertedBlockedListUsersPromise = profile.blockedUsersList.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (0, helpers_2.convertToValidDID)(each, env);
          }));
          blockedUsersList = yield Promise.all(convertedBlockedListUsersPromise);
          blockedUsersList = Array.from(new Set(blockedUsersList));
        }
        const updatedProfile = {
          name: profile.name ? profile.name : user.profile.name,
          desc: profile.desc ? profile.desc : user.profile.desc,
          picture: profile.picture ? profile.picture : user.profile.picture,
          // If profile.blockedUsersList is empty no users in block list
          blockedUsersList: profile.blockedUsersList ? blockedUsersList : []
        };
        const hash = CryptoJS.SHA256(JSON.stringify(updatedProfile)).toString();
        const signature = yield pgpHelper.sign({
          message: hash,
          signingKey: pgpPrivateKey
        });
        const sigType = "pgpv2";
        const verificationProof = `${sigType}:${signature}`;
        const body = Object.assign(Object.assign({}, updatedProfile), { verificationProof });
        const API_BASE_URL = (0, helpers_2.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v2/users/${user.did}/profile`;
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-PROFILE-UPDATE-01"]);
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        if (response.data)
          response.data.publicKey = yield (0, helpers_2.verifyProfileKeys)(response.data.encryptedPrivateKey, response.data.publicKey, response.data.did, response.data.wallets, response.data.verificationProof);
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-PROFILE-UPDATE-02"]);
        return (0, populateIUser_1.populateDeprecatedUser)(response.data);
      } catch (err) {
        const errorProgressHook = progressHook_1.default["PUSH-ERROR-00"];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.profileUpdate.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.profileUpdate.name} -: ${err}`);
      }
    });
    exports.profileUpdateCore = profileUpdateCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/createUser.js
var require_createUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/createUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUserCore = exports.create = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var helpers_2 = require_helpers3();
    var progressHook_1 = require_progressHook();
    var create = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return yield (0, exports.createUserCore)(options, helpers_1.PGPHelper);
    });
    exports.create = create;
    var createUserCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a, _b;
      const passPrefix = "$0Pc";
      const { env = constants_1.default.ENV.PROD, account = null, signer = null, version = constants_1.default.ENC_TYPE_V3, additionalMeta = {
        NFTPGP_V1: {
          password: passPrefix + (0, helpers_1.generateRandomSecret)(10)
        }
      }, progressHook, origin } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_1.getWallet)({ account, signer });
        const address = yield (0, helpers_1.getAccountAddress)(wallet);
        if (!(0, helpers_2.isValidPushCAIP)(address)) {
          throw new Error(`Invalid address!`);
        }
        if ((_a = additionalMeta === null || additionalMeta === void 0 ? void 0 : additionalMeta.NFTPGP_V1) === null || _a === void 0 ? void 0 : _a.password) {
          (0, helpers_2.validatePssword)(additionalMeta.NFTPGP_V1.password);
        }
        const caip10 = (0, helpers_2.walletToPCAIP10)(address);
        let encryptionType = version;
        if ((0, helpers_2.isValidNFTCAIP)(caip10)) {
          encryptionType = constants_1.default.ENC_TYPE_V4;
        } else {
          if (!signer)
            encryptionType = constants_1.default.ENC_TYPE_V1;
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-01"]);
        const keyPairs = yield pgpHelper.generateKeyPair();
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-02"]);
        const publicKey = yield (0, helpers_2.preparePGPPublicKey)(encryptionType, keyPairs.publicKeyArmored, wallet);
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-03"]);
        const encryptedPrivateKey = yield (0, helpers_2.encryptPGPKey)(encryptionType, keyPairs.privateKeyArmored, wallet, additionalMeta);
        if (encryptionType === constants_1.default.ENC_TYPE_V4) {
          const encryptedPassword = yield (0, helpers_2.encryptPGPKey)(constants_1.default.ENC_TYPE_V3, (_b = additionalMeta.NFTPGP_V1) === null || _b === void 0 ? void 0 : _b.password, wallet, additionalMeta);
          encryptedPrivateKey.encryptedPassword = encryptedPassword;
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-04"]);
        const body = {
          user: caip10,
          wallet,
          publicKey,
          encryptedPrivateKey: JSON.stringify(encryptedPrivateKey),
          env,
          origin
        };
        const createdUser = yield (0, helpers_1.createUserService)(body);
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-CREATE-05"]);
        createdUser.decryptedPrivateKey = keyPairs.privateKeyArmored;
        return createdUser;
      } catch (err) {
        const errorProgressHook = progressHook_1.default["PUSH-ERROR-00"];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.create.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.create.name} -: ${err}`);
      }
    });
    exports.createUserCore = createUserCore;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/parseAPI.js
var require_parseAPI = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/parseAPI.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseApiResponse = void 0;
    function parseApiResponse(response) {
      return response.map((apiNotification) => {
        const { payload: { data: { acta: cta = "", amsg: bigMessage = "", asub = "", icon = "", url = "", sid = "", app = "", aimg = "", secret = "" }, notification }, source } = apiNotification;
        return {
          cta,
          title: asub || "",
          message: bigMessage || notification.body || "",
          icon,
          url,
          sid,
          app,
          image: aimg,
          blockchain: source,
          notification,
          secret
        };
      });
    }
    exports.parseApiResponse = parseApiResponse;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/index.js
var require_utils14 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_parseAPI(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getFeeds.js
var require_getFeeds = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getFeeds.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeeds = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var utils_1 = require_utils14();
    var axiosUtil_1 = require_axiosUtil();
    var getFeeds = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { user, env = constants_1.default.ENV.PROD, page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, spam = false, raw = false } = options || {};
      const _user = yield (0, helpers_1.getCAIPAddress)(env, user, "User");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/users/${_user}/feeds`;
      const queryObj = {
        page,
        limit: (0, helpers_1.getLimit)(limit),
        spam
      };
      const requestUrl = `${apiEndpoint}?${(0, helpers_1.getQueryParams)(queryObj)}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        var _a, _b;
        if (raw) {
          return ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.feeds) || [];
        }
        return (0, utils_1.parseApiResponse)((_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.feeds) || [];
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getFeeds = getFeeds;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/parseSettings.js
var require_parseSettings = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/parseSettings.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSettings = void 0;
    var parseSettings = (settings) => {
      var _a, _b;
      let settingsObj;
      try {
        settingsObj = JSON.parse(settings);
      } catch (error) {
        settingsObj = settings;
      }
      const parsedSettings = [];
      for (let i = 0; i < settingsObj.length; i++) {
        const setting = settingsObj[i];
        if (setting.type == 1) {
          parsedSettings.push(Object.assign({ type: setting.type, description: setting.description }, setting.user ? {
            userPreferance: {
              value: setting.user,
              enabled: setting.user
            }
          } : { default: setting.default }));
        } else if (setting.type == 2) {
          parsedSettings.push(Object.assign({ type: setting.type, description: setting.description, data: {
            upper: setting.upperLimit,
            lower: setting.lowerLimit,
            ticker: (_a = setting.ticker) !== null && _a !== void 0 ? _a : 1
          } }, setting.user ? {
            userPreferance: {
              value: setting.user,
              enabled: setting.enabled
            }
          } : { default: setting.default }));
        } else if (setting.type == 3) {
          parsedSettings.push(Object.assign({ type: setting.type, description: setting.description, data: {
            upper: setting.upperLimit,
            lower: setting.lowerLimit,
            ticker: (_b = setting.ticker) !== null && _b !== void 0 ? _b : 1
          } }, setting.user ? {
            userPreferance: {
              value: setting.user,
              enabled: setting.enabled
            }
          } : { default: setting.default }));
        }
      }
      return parsedSettings;
    };
    exports.parseSettings = parseSettings;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/utils/pasreSubscriptionAPI.js
var require_pasreSubscriptionAPI = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/utils/pasreSubscriptionAPI.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSubscriptionsApiResponse = void 0;
    var parseSettings_1 = require_parseSettings();
    function parseSubscriptionsApiResponse(response) {
      return response.map((apisubscription) => {
        return {
          channel: apisubscription.channel,
          user_settings: apisubscription.user_settings ? (0, parseSettings_1.parseSettings)(apisubscription.user_settings) : null
        };
      });
    }
    exports.parseSubscriptionsApiResponse = parseSubscriptionsApiResponse;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getSubscriptions.js
var require_getSubscriptions = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getSubscriptions.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSubscriptions = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var axiosUtil_1 = require_axiosUtil();
    var pasreSubscriptionAPI_1 = require_pasreSubscriptionAPI();
    var getSubscriptions = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { user, env = constants_1.default.ENV.PROD, channel = null, raw = true } = options || {};
      const _user = yield (0, helpers_1.getCAIPAddress)(env, user, "User");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/users/${_user}/subscriptions`;
      const query = channel ? (0, helpers_1.getQueryParams)({
        channel
      }) : "";
      const requestUrl = `${apiEndpoint}?${query}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        var _a, _b;
        if (raw) {
          return ((_a = response.data) === null || _a === void 0 ? void 0 : _a.subscriptions) || [];
        } else {
          return (0, pasreSubscriptionAPI_1.parseSubscriptionsApiResponse)(((_b = response.data) === null || _b === void 0 ? void 0 : _b.subscriptions) || []);
        }
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getSubscriptions = getSubscriptions;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getDelegations.js
var require_getDelegations = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getDelegations.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDelegations = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var axiosUtil_1 = require_axiosUtil();
    var getDelegations = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { user, env = constants_1.default.ENV.PROD } = options || {};
      const _user = yield (0, helpers_1.getCAIPAddress)(env, user, "User");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const apiEndpoint = `${API_BASE_URL}/v1/users/${_user}/delegations`;
      const requestUrl = `${apiEndpoint}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        var _a;
        return ((_a = response.data) === null || _a === void 0 ? void 0 : _a.delegations) || [];
      }).catch((err) => {
        console.error(`[EPNS-SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getDelegations = getDelegations;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getUsersBatch.js
var require_getUsersBatch = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getUsersBatch.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBatch = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var address_1 = require_address4();
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var populateIUser_1 = require_populateIUser();
    var axiosUtil_1 = require_axiosUtil();
    var getBatch = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { env = constants_1.default.ENV.PROD, userIds } = options || {};
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      const requestUrl = `${API_BASE_URL}/v2/users/batch`;
      const MAX_USER_IDS_LENGTH = 100;
      if (userIds.length > MAX_USER_IDS_LENGTH) {
        throw new Error(`Too many user IDs. Maximum allowed: ${MAX_USER_IDS_LENGTH}`);
      }
      for (let i = 0; i < userIds.length; i++) {
        if (!(0, address_1.isValidPushCAIP)(userIds[i])) {
          throw new Error(`Invalid user address!`);
        }
      }
      const pcaipUserIds = userIds.map(address_1.walletToPCAIP10);
      const requestBody = { userIds: pcaipUserIds };
      return (0, axiosUtil_1.axiosPost)(requestUrl, requestBody).then((response) => {
        response.data.users.forEach((user, index) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
          response.data.users[index].publicKey = yield (0, helpers_1.verifyProfileKeys)(user.encryptedPrivateKey, user.publicKey, user.did, user.caip10, user.verificationProof);
          response.data.users[index] = (0, populateIUser_1.populateDeprecatedUser)(response.data.users[index]);
        }));
        return response.data;
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
        throw Error(`[Push SDK] - API ${requestUrl}: ${err}`);
      });
    });
    exports.getBatch = getBatch;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/upgradeUser.js
var require_upgradeUser = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/upgradeUser.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.upgrade = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var helpers_2 = require_helpers3();
    var auth_updateUser_1 = require_auth_updateUser();
    var getUser_1 = require_getUser();
    var progressHook_1 = require_progressHook();
    var upgrade = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { env = constants_1.default.ENV.PROD, account = null, signer, additionalMeta, progressHook } = options || {};
      try {
        const wallet = (0, helpers_1.getWallet)({ account, signer });
        const address = yield (0, helpers_1.getAccountAddress)(wallet);
        if (!(0, helpers_2.isValidPushCAIP)(address)) {
          throw new Error(`Invalid address!`);
        }
        const user = yield (0, getUser_1.get)({ account: address, env });
        if (!user || !user.encryptedPrivateKey) {
          throw new Error("User Not Found!");
        }
        const recommendedPgpEncryptionVersion = constants_1.default.ENCRYPTION_TYPE.PGP_V3;
        const { version } = JSON.parse(user.encryptedPrivateKey);
        if (version === recommendedPgpEncryptionVersion || version === constants_1.default.ENCRYPTION_TYPE.NFTPGP_V1) {
          return user;
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPGRADE-02"]);
        const pgpPrivateKey = yield (0, helpers_2.decryptPGPKey)({
          encryptedPGPPrivateKey: user.encryptedPrivateKey,
          signer,
          env,
          toUpgrade: false,
          additionalMeta
        });
        const upgradedUser = yield (0, auth_updateUser_1.authUpdate)({
          pgpPrivateKey,
          pgpEncryptionVersion: recommendedPgpEncryptionVersion,
          signer,
          pgpPublicKey: user.publicKey,
          account: user.did,
          env,
          additionalMeta,
          progressHook
        });
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-UPGRADE-05"]);
        return upgradedUser;
      } catch (err) {
        const errorProgressHook = progressHook_1.default["PUSH-ERROR-00"];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.upgrade.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.upgrade.name} -: ${err}`);
      }
    });
    exports.upgrade = upgrade;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/decryptAuth.js
var require_decryptAuth = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/decryptAuth.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptAuth = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers3();
    var progressHook_1 = require_progressHook();
    var decryptAuth = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a;
      const { account, signer, env = constants_1.default.ENV.PROD, additionalMeta, progressHook } = options || {};
      try {
        if (!(0, helpers_1.isValidNFTCAIP)(account)) {
          return null;
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-DECRYPT-AUTH-01"]);
        const password = yield (0, helpers_1.decryptPGPKey)({
          encryptedPGPPrivateKey: (_a = additionalMeta === null || additionalMeta === void 0 ? void 0 : additionalMeta.NFTPGP_V1) === null || _a === void 0 ? void 0 : _a.encryptedPassword,
          signer,
          account,
          env
        });
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-DECRYPT-AUTH-02"]);
        return password;
      } catch (err) {
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-ERROR-00"](exports.decryptAuth.name, err));
        throw Error(`[Push SDK] - API  - Error - API ${exports.decryptAuth.name} -: ${err}`);
      }
    });
    exports.decryptAuth = decryptAuth;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/createUserWithProfile.js
var require_createUserWithProfile = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/createUserWithProfile.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUserWithProfile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var createUser_1 = require_createUser();
    var profile_updateUser_1 = require_profile_updateUser();
    var helpers_1 = require_helpers3();
    var createUserWithProfile = (userOptions) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      try {
        let user = yield (0, createUser_1.create)(userOptions);
        if (userOptions.profile) {
          const pk = yield (0, helpers_1.decryptPGPKey)({
            account: user.did,
            encryptedPGPPrivateKey: user.encryptedPrivateKey,
            env: userOptions.env,
            signer: userOptions.signer
          });
          user = yield (0, profile_updateUser_1.profileUpdate)({
            account: user.did,
            env: userOptions.env,
            pgpPrivateKey: pk,
            profile: userOptions.profile
          });
        }
        return user;
      } catch (err) {
        throw new Error(`[Push SDK] - Error in createUserWithProfile -: ${err}`);
      }
    });
    exports.createUserWithProfile = createUserWithProfile;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/getFeedsPerChannel.js
var require_getFeedsPerChannel = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/getFeedsPerChannel.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeedsPerChannel = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers3();
    var constants_1 = require_constants2();
    var utils_1 = require_utils14();
    var axiosUtil_1 = require_axiosUtil();
    var getFeedsPerChannel = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const { user, env = constants_1.default.ENV.PROD, page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, spam = false, raw = false, channels = [] } = options || {};
      const _user = yield (0, helpers_1.getCAIPAddress)(env, user, "User");
      const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
      if (channels.length == 0) {
        throw new Error("channels cannot be empty");
      }
      const _channel = yield (0, helpers_1.getCAIPAddress)(env, channels[0], "Channel");
      const apiEndpoint = `${API_BASE_URL}/v1/users/${_user}/channels/${_channel}/feeds`;
      const queryObj = {
        page,
        limit: (0, helpers_1.getLimit)(limit),
        spam
      };
      const requestUrl = `${apiEndpoint}?${(0, helpers_1.getQueryParams)(queryObj)}`;
      return (0, axiosUtil_1.axiosGet)(requestUrl).then((response) => {
        var _a, _b;
        if (raw) {
          return ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.feeds) || [];
        }
        return (0, utils_1.parseApiResponse)((_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.feeds) || [];
      }).catch((err) => {
        console.error(`[Push SDK] - API ${requestUrl}: `, err);
      });
    });
    exports.getFeedsPerChannel = getFeedsPerChannel;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/user/index.js
var require_user2 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/user/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.profile = exports.auth = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var auth_updateUser_1 = require_auth_updateUser();
    var profile_updateUser_1 = require_profile_updateUser();
    tslib_1.__exportStar(require_createUser(), exports);
    tslib_1.__exportStar(require_getFeeds(), exports);
    tslib_1.__exportStar(require_getSubscriptions(), exports);
    tslib_1.__exportStar(require_getUser(), exports);
    tslib_1.__exportStar(require_getDelegations(), exports);
    tslib_1.__exportStar(require_getUsersBatch(), exports);
    tslib_1.__exportStar(require_upgradeUser(), exports);
    tslib_1.__exportStar(require_decryptAuth(), exports);
    tslib_1.__exportStar(require_createUserWithProfile(), exports);
    tslib_1.__exportStar(require_getFeedsPerChannel(), exports);
    exports.auth = {
      update: auth_updateUser_1.authUpdate
    };
    exports.profile = {
      update: profile_updateUser_1.profileUpdate,
      updateCore: profile_updateUser_1.profileUpdateCore
    };
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/address.js
var require_address4 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/address.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pCAIP10ToWallet = exports.walletToPCAIP10 = exports.getCAIPWithChainId = exports.getCAIPAddress = exports.getFallbackETHCAIPAddress = exports.getCAIPDetails = exports.validateCAIP = exports.isValidFullCAIP10 = exports.convertToValidDID = exports.isValidPushCAIP = exports.isValidEOACAIP = exports.isValidNFTCAIP = exports.isValidSCWCAIP = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var viem = require_cjs2();
    var constants_1 = require_constants2();
    var user_1 = require_user2();
    var isValidSCWCAIP = (wallet) => {
      try {
        const walletComponent = wallet.split(":");
        return walletComponent.length === 4 && walletComponent[0] === "scw" && walletComponent[1] === "eip155" && !isNaN(Number(walletComponent[2])) && Number(walletComponent[2]) > 0 && viem.isAddress(walletComponent[3]);
      } catch (err) {
        return false;
      }
    };
    exports.isValidSCWCAIP = isValidSCWCAIP;
    var isValidNFTCAIP = (wallet) => {
      try {
        const walletComponent = wallet.split(":");
        return (walletComponent.length === 5 || walletComponent.length === 6) && walletComponent[0].toLowerCase() === "nft" && !isNaN(Number(walletComponent[4])) && Number(walletComponent[4]) > 0 && !isNaN(Number(walletComponent[2])) && Number(walletComponent[2]) > 0 && viem.isAddress(walletComponent[3]) && walletComponent[1] === "eip155";
      } catch (err) {
        return false;
      }
    };
    exports.isValidNFTCAIP = isValidNFTCAIP;
    var isValidEOACAIP = (wallet) => {
      try {
        const walletComponent = wallet.split(":");
        if (walletComponent.length === 3) {
          return walletComponent[0] === "eip155" && !isNaN(Number(walletComponent[1])) && Number(walletComponent[1]) > 0 && viem.isAddress(walletComponent[2]);
        }
        if (walletComponent.length === 2) {
          return walletComponent[0] === "eip155" && viem.isAddress(walletComponent[1]);
        }
        return false;
      } catch (err) {
        return false;
      }
    };
    exports.isValidEOACAIP = isValidEOACAIP;
    var isValidPushCAIP = (wallet) => {
      return (0, exports.isValidEOACAIP)(wallet) || (0, exports.isValidSCWCAIP)(wallet) || (0, exports.isValidNFTCAIP)(wallet) || viem.isAddress(wallet);
    };
    exports.isValidPushCAIP = isValidPushCAIP;
    var convertToValidDID = (wallet, env = constants_1.ENV.STAGING, chainId, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      if (!(0, exports.isValidPushCAIP)(wallet))
        return wallet;
      if ((0, exports.isValidEOACAIP)(wallet) || (0, exports.isValidSCWCAIP)(wallet) || (0, exports.isValidNFTCAIP)(wallet) && wallet.split(":").length === 6)
        return wallet;
      if ((0, exports.isValidNFTCAIP)(wallet)) {
        const user = yield (0, user_1.get)({ account: wallet, env });
        if (user && user.did)
          return user.did;
        const epoch = Math.floor(Date.now() / 1e3);
        return `${wallet}:${epoch}`;
      }
      if (provider) {
        try {
        } catch (err) {
        }
      }
      return chainId ? `eip155:${chainId}:${wallet}` : `eip155:${wallet}`;
    });
    exports.convertToValidDID = convertToValidDID;
    var isValidFullCAIP10 = (wallet) => {
      const walletComponent = wallet.split(":");
      if (isNaN(Number(walletComponent[1])))
        return false;
      return walletComponent[0] === "eip155" && !isNaN(Number(walletComponent[1])) && Number(walletComponent[1]) > 0 && viem.isAddress(walletComponent[2]);
    };
    exports.isValidFullCAIP10 = isValidFullCAIP10;
    var AddressValidators = {
      // Ethereum
      eip155: ({ address }) => {
        return (0, exports.isValidPushCAIP)(address);
      }
      // Add other chains here
    };
    function validateCAIP(addressInCAIP) {
      const [blockchain, networkId, address] = addressInCAIP.split(":");
      if (!blockchain)
        return false;
      if (!networkId)
        return false;
      if (!address)
        return false;
      if ((0, exports.isValidNFTCAIP)(addressInCAIP))
        return true;
      const validatorFn = AddressValidators[blockchain];
      return validatorFn({ address });
    }
    exports.validateCAIP = validateCAIP;
    function getCAIPDetails(addressInCAIP) {
      if (validateCAIP(addressInCAIP)) {
        const [blockchain, networkId, address] = addressInCAIP.split(":");
        return {
          blockchain,
          networkId,
          address
        };
      }
      return null;
    }
    exports.getCAIPDetails = getCAIPDetails;
    function getFallbackETHCAIPAddress(env, address) {
      let chainId = 1;
      if (env === constants_1.default.ENV.DEV || env === constants_1.default.ENV.STAGING || env === constants_1.default.ENV.LOCAL) {
        chainId = 11155111;
      }
      return `eip155:${chainId}:${address}`;
    }
    exports.getFallbackETHCAIPAddress = getFallbackETHCAIPAddress;
    function getCAIPAddress(env, address, msg) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, exports.isValidNFTCAIP)(address)) {
          return yield (0, exports.convertToValidDID)(address, env);
        }
        if (validateCAIP(address)) {
          return address;
        } else {
          if ((0, exports.isValidPushCAIP)(address)) {
            return getFallbackETHCAIPAddress(env, address);
          } else {
            throw Error(`Invalid Address! ${msg} 
 Address: ${address}`);
          }
        }
      });
    }
    exports.getCAIPAddress = getCAIPAddress;
    var getCAIPWithChainId = (address, chainId, msg) => {
      if ((0, exports.isValidPushCAIP)(address)) {
        if (!address.includes("eip155:"))
          return `eip155:${chainId}:${address}`;
        else
          return address;
      } else {
        throw Error(`Invalid Address! ${msg} 
 Address: ${address}`);
      }
    };
    exports.getCAIPWithChainId = getCAIPWithChainId;
    var walletToPCAIP10 = (account) => {
      if ((0, exports.isValidNFTCAIP)(account) || account.includes("eip155:")) {
        return account;
      }
      return "eip155:" + account;
    };
    exports.walletToPCAIP10 = walletToPCAIP10;
    var pCAIP10ToWallet = (wallet) => {
      if ((0, exports.isValidNFTCAIP)(wallet))
        return wallet;
      wallet = wallet.replace("eip155:", "");
      return wallet;
    };
    exports.pCAIP10ToWallet = pCAIP10ToWallet;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/api.js
var require_api = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/api.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLimit = exports.getQueryParams = void 0;
    var constants_1 = require_constants2();
    function getQueryParams(obj) {
      return Object.keys(obj).map((key) => {
        return `${key}=${encodeURIComponent(obj[key])}`;
      }).join("&");
    }
    exports.getQueryParams = getQueryParams;
    function getLimit(passedLimit) {
      if (!passedLimit)
        return constants_1.default.PAGINATION.LIMIT;
      return passedLimit;
    }
    exports.getLimit = getLimit;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/signer.js
var require_signer = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/signer.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signer = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Signer = class {
      constructor(signer) {
        this.signer = signer;
      }
      /**
       * Determine if the signer is a Viem signer
       */
      isViemSigner(signer) {
        return typeof signer.signTypedData === "function" && typeof signer.getChainId === "function" && signer.signMessage.length === 1 && // Checking if the function takes one argument
        signer.signTypedData.length === 1;
      }
      signMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if ("signMessage" in this.signer && typeof this.signer.signMessage === "function") {
            if (this.isViemSigner(this.signer)) {
              return this.signer.signMessage({
                message,
                account: this.signer.account
              });
            } else {
              return this.signer.signMessage(message);
            }
          } else {
            throw new Error("Signer does not support signMessage");
          }
        });
      }
      signTypedData(domain, types, value, primaryType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.isViemSigner(this.signer)) {
            return this.signer.signTypedData({
              domain,
              types,
              primaryType,
              message: value,
              account: this.signer.account
            });
          } else if ("_signTypedData" in this.signer) {
            return this.signer._signTypedData(domain, types, value);
          } else if ("signTypedData" in this.signer) {
            return this.signer.signTypedData(domain, types, value);
          } else {
            throw new Error("Signer does not support signTypedData");
          }
        });
      }
      getAddress() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.isViemSigner(this.signer)) {
            return (_a = this.signer.account["address"]) !== null && _a !== void 0 ? _a : "";
          } else {
            return yield this.signer.getAddress();
          }
        });
      }
      getChainId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          if (this.isViemSigner(this.signer)) {
            return this.signer.getChainId();
          } else if ("provider" in this.signer && this.signer.provider) {
            const network = yield this.signer.provider.getNetwork();
            return Number(network.chainId);
          } else {
            return 1;
          }
        });
      }
    };
    exports.Signer = Signer;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/crypto.js
var require_crypto5 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/crypto.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validatePssword = exports.verifyProfileKeys = exports.preparePGPPublicKey = exports.encryptPGPKey = exports.decryptV2 = exports.encryptV2 = exports.stringToHex = exports.hexToBytes = exports.generateHash = exports.decryptPGPKey = exports.decryptWithWalletRPCMethod = exports.encryptV1 = exports.getPublicKey = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var metamaskSigUtil = require_dist6();
    var eth_sig_util_1 = require_dist6();
    var CryptoJS = require_crypto_js();
    var helpers_1 = require_helpers2();
    var constants_1 = require_constants2();
    var address_1 = require_address4();
    var signature_1 = require_signature3();
    var upgradeUser_1 = require_upgradeUser();
    var progressHook_1 = require_progressHook();
    var signer_1 = require_signer();
    var viem = require_cjs2();
    var chains_1 = require_chains();
    var KDFSaltSize = 32;
    var AESGCMNonceSize = 12;
    var crypto2;
    if (typeof window !== "undefined" && window.crypto) {
      crypto2 = window.crypto;
    } else if (typeof __require !== "undefined") {
      try {
        crypto2 = require_crypto_browserify().webcrypto;
      } catch (e) {
        throw new Error("Unable To load crypto");
      }
    }
    var getPublicKey = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _a;
      const { account, signer } = options || {};
      const pushSigner = signer ? new signer_1.Signer(signer) : void 0;
      const address = account || (yield pushSigner === null || pushSigner === void 0 ? void 0 : pushSigner.getAddress()) || "";
      const metamaskProvider = viem.createWalletClient({
        chain: chains_1.mainnet,
        transport: viem.custom(window.ethereum)
      });
      const web3Provider = ((_a = signer === null || signer === void 0 ? void 0 : signer.provider) === null || _a === void 0 ? void 0 : _a.provider) || metamaskProvider;
      const keyB64 = yield web3Provider.request({
        method: "eth_getEncryptionPublicKey",
        params: [address]
      });
      return keyB64;
    });
    exports.getPublicKey = getPublicKey;
    var encryptV1 = (text, encryptionPublicKey, version) => {
      const encryptedSecret = metamaskSigUtil.encrypt({
        publicKey: encryptionPublicKey,
        data: text,
        version
      });
      return encryptedSecret;
    };
    exports.encryptV1 = encryptV1;
    var decryptWithWalletRPCMethod = (encryptedPGPPrivateKey, account) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      console.warn("decryptWithWalletRPCMethod method is DEPRECATED. Use decryptPGPKey method with signer!");
      return yield (0, exports.decryptPGPKey)({
        encryptedPGPPrivateKey,
        account
      });
    });
    exports.decryptWithWalletRPCMethod = decryptWithWalletRPCMethod;
    var decryptPGPKey = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _b, _c, _d;
      const { encryptedPGPPrivateKey, account = null, signer = null, env = constants_1.default.ENV.PROD, toUpgrade = true, additionalMeta = null, progressHook } = options || {};
      try {
        if (account == null && signer == null) {
          throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_1.getWallet)({ account, signer });
        const address = yield (0, helpers_1.getAccountAddress)(wallet);
        if (!(0, address_1.isValidPushCAIP)(address)) {
          throw new Error(`Invalid address!`);
        }
        const { version: encryptionType } = JSON.parse(encryptedPGPPrivateKey);
        let privateKey;
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-DECRYPT-01"]);
        switch (encryptionType) {
          case constants_1.default.ENC_TYPE_V1: {
            if ((_b = wallet === null || wallet === void 0 ? void 0 : wallet.signer) === null || _b === void 0 ? void 0 : _b.privateKey) {
              privateKey = (0, eth_sig_util_1.decrypt)({
                encryptedData: JSON.parse(encryptedPGPPrivateKey),
                privateKey: (_c = wallet === null || wallet === void 0 ? void 0 : wallet.signer) === null || _c === void 0 ? void 0 : _c.privateKey.substring(2)
              });
            } else {
              const metamaskProvider = viem.createWalletClient({
                chain: chains_1.mainnet,
                transport: viem.custom(window.ethereum)
              });
              const web3Provider = ((_d = signer === null || signer === void 0 ? void 0 : signer.provider) === null || _d === void 0 ? void 0 : _d.provider) || metamaskProvider;
              privateKey = yield web3Provider.request({
                method: "eth_decrypt",
                params: [encryptedPGPPrivateKey, address]
              });
            }
            break;
          }
          case constants_1.default.ENC_TYPE_V2: {
            if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
              throw new Error("Cannot Decrypt this encryption version without signer!");
            }
            const { preKey: input } = JSON.parse(encryptedPGPPrivateKey);
            const enableProfileMessage = "Enable Push Chat Profile \n" + input;
            let encodedPrivateKey;
            try {
              const { verificationProof: secret } = yield (0, helpers_1.getEip712Signature)(wallet, enableProfileMessage, true);
              encodedPrivateKey = yield (0, exports.decryptV2)(JSON.parse(encryptedPGPPrivateKey), (0, exports.hexToBytes)(secret || ""));
            } catch (err) {
              const { verificationProof: secret } = yield (0, helpers_1.getEip712Signature)(wallet, enableProfileMessage, false);
              encodedPrivateKey = yield (0, exports.decryptV2)(JSON.parse(encryptedPGPPrivateKey), (0, exports.hexToBytes)(secret || ""));
            }
            const dec = new TextDecoder();
            privateKey = dec.decode(encodedPrivateKey);
            break;
          }
          case constants_1.default.ENC_TYPE_V3: {
            if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
              throw new Error("Cannot Decrypt this encryption version without signer!");
            }
            const { preKey: input } = JSON.parse(encryptedPGPPrivateKey);
            const enableProfileMessage = "Enable Push Profile \n" + input;
            const { verificationProof: secret } = yield (0, helpers_1.getEip191Signature)(wallet, enableProfileMessage);
            const encodedPrivateKey = yield (0, exports.decryptV2)(JSON.parse(encryptedPGPPrivateKey), (0, exports.hexToBytes)(secret || ""));
            const dec = new TextDecoder();
            privateKey = dec.decode(encodedPrivateKey);
            break;
          }
          case constants_1.default.ENC_TYPE_V4: {
            let password = null;
            if (additionalMeta === null || additionalMeta === void 0 ? void 0 : additionalMeta.NFTPGP_V1) {
              password = additionalMeta.NFTPGP_V1.password;
            } else {
              if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
                throw new Error("Cannot Decrypt this encryption version without signer!");
              }
              const { encryptedPassword } = JSON.parse(encryptedPGPPrivateKey);
              password = yield (0, exports.decryptPGPKey)({
                encryptedPGPPrivateKey: JSON.stringify(encryptedPassword),
                signer,
                env
              });
            }
            const encodedPrivateKey = yield (0, exports.decryptV2)(JSON.parse(encryptedPGPPrivateKey), (0, exports.hexToBytes)((0, exports.stringToHex)(password)));
            const dec = new TextDecoder();
            privateKey = dec.decode(encodedPrivateKey);
            break;
          }
          default:
            throw new Error("Invalid Encryption Type");
        }
        if (signer && toUpgrade && encryptionType !== constants_1.default.ENC_TYPE_V4) {
          try {
            yield (0, upgradeUser_1.upgrade)({ env, account: address, signer, progressHook });
          } catch (err) {
            const errorProgressHook = progressHook_1.default["PUSH-ERROR-01"];
            progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(err));
          }
        }
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default["PUSH-DECRYPT-02"]);
        return privateKey;
      } catch (err) {
        const errorProgressHook = progressHook_1.default["PUSH-ERROR-00"];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.decryptPGPKey.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.decryptPGPKey.name} -: ${err}`);
      }
    });
    exports.decryptPGPKey = decryptPGPKey;
    var generateHash = (message) => {
      const hash = CryptoJS.SHA256(JSON.stringify(message)).toString(CryptoJS.enc.Hex);
      return hash;
    };
    exports.generateHash = generateHash;
    var getRandomValues = (array) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      return crypto2.getRandomValues(array);
    });
    var bytesToHex = (bytes) => {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    };
    var hexToBytes = (hex) => {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
      }
      return bytes;
    };
    exports.hexToBytes = hexToBytes;
    var stringToHex = (str) => {
      let hex = "";
      for (let i = 0; i < str.length; i++) {
        hex += str.charCodeAt(i).toString(16).padStart(2, "0");
      }
      return hex;
    };
    exports.stringToHex = stringToHex;
    var hkdf = (secret, salt) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const key = yield crypto2.subtle.importKey("raw", secret, "HKDF", false, [
        "deriveKey"
      ]);
      return crypto2.subtle.deriveKey({ name: "HKDF", hash: "SHA-256", salt, info: new ArrayBuffer(0) }, key, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
    });
    var encryptV2 = (data, secret, additionalData) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const salt = crypto2.getRandomValues(new Uint8Array(KDFSaltSize));
      const nonce = crypto2.getRandomValues(new Uint8Array(AESGCMNonceSize));
      const key = yield hkdf(secret, salt);
      const aesGcmParams = {
        name: "AES-GCM",
        iv: nonce
      };
      if (additionalData) {
        aesGcmParams.additionalData = additionalData;
      }
      const encrypted = yield crypto2.subtle.encrypt(aesGcmParams, key, data);
      return {
        ciphertext: bytesToHex(new Uint8Array(encrypted)),
        salt: bytesToHex(salt),
        nonce: bytesToHex(nonce)
      };
    });
    exports.encryptV2 = encryptV2;
    var decryptV2 = (encryptedData, secret, additionalData) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const key = yield hkdf(secret, (0, exports.hexToBytes)(encryptedData.salt));
      const aesGcmParams = {
        name: "AES-GCM",
        iv: (0, exports.hexToBytes)(encryptedData.nonce)
      };
      if (additionalData) {
        aesGcmParams.additionalData = additionalData;
      }
      const decrypted = yield crypto2.subtle.decrypt(aesGcmParams, key, (0, exports.hexToBytes)(encryptedData.ciphertext));
      return new Uint8Array(decrypted);
    });
    exports.decryptV2 = decryptV2;
    var encryptPGPKey = (encryptionType, privateKey, wallet, additionalMeta) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      var _e, _f, _g;
      let encryptedPrivateKey;
      switch (encryptionType) {
        case constants_1.default.ENC_TYPE_V1: {
          let walletPublicKey;
          if ((_e = wallet === null || wallet === void 0 ? void 0 : wallet.signer) === null || _e === void 0 ? void 0 : _e.privateKey) {
            walletPublicKey = (0, eth_sig_util_1.getEncryptionPublicKey)((_f = wallet === null || wallet === void 0 ? void 0 : wallet.signer) === null || _f === void 0 ? void 0 : _f.privateKey.substring(2));
          } else {
            walletPublicKey = yield (0, exports.getPublicKey)(wallet);
          }
          encryptedPrivateKey = (0, exports.encryptV1)(privateKey, walletPublicKey, encryptionType);
          break;
        }
        case constants_1.default.ENC_TYPE_V2: {
          const input = bytesToHex(yield getRandomValues(new Uint8Array(32)));
          const enableProfileMessage = "Enable Push Chat Profile \n" + input;
          const { verificationProof: secret } = yield (0, helpers_1.getEip712Signature)(wallet, enableProfileMessage, true);
          const enc = new TextEncoder();
          const encodedPrivateKey = enc.encode(privateKey);
          encryptedPrivateKey = yield (0, exports.encryptV2)(encodedPrivateKey, (0, exports.hexToBytes)(secret || ""));
          encryptedPrivateKey.version = constants_1.default.ENC_TYPE_V2;
          encryptedPrivateKey.preKey = input;
          break;
        }
        case constants_1.default.ENC_TYPE_V3: {
          const input = bytesToHex(yield getRandomValues(new Uint8Array(32)));
          const enableProfileMessage = "Enable Push Profile \n" + input;
          const { verificationProof: secret } = yield (0, helpers_1.getEip191Signature)(wallet, enableProfileMessage);
          const enc = new TextEncoder();
          const encodedPrivateKey = enc.encode(privateKey);
          encryptedPrivateKey = yield (0, exports.encryptV2)(encodedPrivateKey, (0, exports.hexToBytes)(secret || ""));
          encryptedPrivateKey.version = constants_1.default.ENC_TYPE_V3;
          encryptedPrivateKey.preKey = input;
          break;
        }
        case constants_1.default.ENC_TYPE_V4: {
          if (!((_g = additionalMeta === null || additionalMeta === void 0 ? void 0 : additionalMeta.NFTPGP_V1) === null || _g === void 0 ? void 0 : _g.password)) {
            throw new Error("Password is required!");
          }
          const enc = new TextEncoder();
          const encodedPrivateKey = enc.encode(privateKey);
          encryptedPrivateKey = yield (0, exports.encryptV2)(encodedPrivateKey, (0, exports.hexToBytes)((0, exports.stringToHex)(additionalMeta.NFTPGP_V1.password)));
          encryptedPrivateKey.version = constants_1.default.ENC_TYPE_V4;
          encryptedPrivateKey.preKey = "";
          break;
        }
        default:
          throw new Error("Invalid Encryption Type");
      }
      return encryptedPrivateKey;
    });
    exports.encryptPGPKey = encryptPGPKey;
    var preparePGPPublicKey = (encryptionType, publicKey, wallet) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      let chatPublicKey;
      switch (encryptionType) {
        case constants_1.default.ENC_TYPE_V1: {
          chatPublicKey = publicKey;
          break;
        }
        case constants_1.default.ENC_TYPE_V2:
        case constants_1.default.ENC_TYPE_V3:
        case constants_1.default.ENC_TYPE_V4: {
          const verificationProof = "DEPRECATED";
          chatPublicKey = JSON.stringify({
            key: publicKey,
            signature: verificationProof
          });
          break;
        }
        default:
          throw new Error("Invalid Encryption Type");
      }
      return chatPublicKey;
    });
    exports.preparePGPPublicKey = preparePGPPublicKey;
    var verifyProfileKeys = (encryptedPrivateKey, publicKey, did, caip10, verificationProof) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      let parsedPublicKey;
      try {
        parsedPublicKey = JSON.parse(publicKey).key;
        if (parsedPublicKey === void 0) {
          throw new Error("Invalid Public Key");
        }
      } catch (err) {
        parsedPublicKey = publicKey;
      }
      try {
        if (publicKey && publicKey.length > 0 && verificationProof && // Allow pgp sig validation after eip191v2 only
        verificationProof.split(":")[0] === "eip191v2") {
          const data = {
            caip10,
            did,
            publicKey,
            encryptedPrivateKey
          };
          if ((0, address_1.isValidNFTCAIP)(did)) {
            const keyToRemove = "owner";
            const parsedEncryptedPrivateKey = JSON.parse(encryptedPrivateKey);
            if (keyToRemove in parsedEncryptedPrivateKey) {
              delete parsedEncryptedPrivateKey[keyToRemove];
            }
            data.encryptedPrivateKey = JSON.stringify(parsedEncryptedPrivateKey);
          }
          const signedData = (0, exports.generateHash)(data);
          const isValidSig = yield (0, signature_1.verifyProfileSignature)(verificationProof, signedData, (0, address_1.isValidNFTCAIP)(did) ? (0, address_1.pCAIP10ToWallet)(JSON.parse(encryptedPrivateKey).owner) : (0, address_1.pCAIP10ToWallet)(did));
          if (isValidSig) {
            return parsedPublicKey;
          } else {
            throw new Error("Invalid Signature");
          }
        }
        return parsedPublicKey;
      } catch (err) {
        console.warn(`Cannot Verify keys for DID : ${did} !!!`);
        return parsedPublicKey;
      }
    });
    exports.verifyProfileKeys = verifyProfileKeys;
    var validatePssword = (password) => {
      if (password.length < 8) {
        throw new Error("Password must be at least 8 characters long!");
      }
      if (!/[A-Z]/.test(password)) {
        throw new Error("Password must contain at least one uppercase letter!");
      }
      if (!/[a-z]/.test(password)) {
        throw new Error("Password must contain at least one lowercase letter!");
      }
      if (!/\d/.test(password)) {
        throw new Error("Password must contain at least one digit!");
      }
      if (!/[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?]/.test(password)) {
        throw new Error("Password must contain at least one special character!");
      }
    };
    exports.validatePssword = validatePssword;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/helpers/index.js
var require_helpers3 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/helpers/index.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_config2(), exports);
    tslib_1.__exportStar(require_address4(), exports);
    tslib_1.__exportStar(require_api(), exports);
    tslib_1.__exportStar(require_crypto5(), exports);
    tslib_1.__exportStar(require_signer(), exports);
  }
});

// node_modules/@pushprotocol/restapi/src/lib/payloads/helpers.js
var require_helpers4 = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/payloads/helpers.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCAIPFormat = exports.getSource = exports.getPayloadIdentity = exports.getVerificationProof = exports.getRecipientFieldForAPIPayload = exports.getRecipients = exports.getPayloadForAPIInput = exports.getUUID = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var uuid_1 = require_commonjs_browser();
    var helpers_1 = require_helpers3();
    var CryptoJS = require_crypto_js();
    var constants_1 = require_constants();
    var helpers_2 = require_helpers2();
    function getUUID() {
      return (0, uuid_1.v4)();
    }
    exports.getUUID = getUUID;
    function getPayloadForAPIInput(inputOptions, recipients) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
      if ((inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) && (inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload)) {
        return {
          notification: {
            title: (_a = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) === null || _a === void 0 ? void 0 : _a.title,
            body: (_b = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) === null || _b === void 0 ? void 0 : _b.body
          },
          data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ acta: ((_c = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _c === void 0 ? void 0 : _c.cta) || "", aimg: ((_d = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _d === void 0 ? void 0 : _d.img) || "", amsg: ((_e = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _e === void 0 ? void 0 : _e.body) || "", asub: ((_f = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _f === void 0 ? void 0 : _f.title) || "", type: ((_g = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.type) === null || _g === void 0 ? void 0 : _g.toString()) || "" }, (inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.expiry) && { etime: inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.expiry }), ((_h = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _h === void 0 ? void 0 : _h.etime) && {
            etime: (_j = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _j === void 0 ? void 0 : _j.etime
          }), (inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.hidden) && { hidden: inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.hidden }), ((_k = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _k === void 0 ? void 0 : _k.hidden) && {
            hidden: (_l = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _l === void 0 ? void 0 : _l.hidden
          }), ((_m = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _m === void 0 ? void 0 : _m.silent) && {
            silent: (_o = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _o === void 0 ? void 0 : _o.silent
          }), ((_p = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _p === void 0 ? void 0 : _p.sectype) && {
            sectype: (_q = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _q === void 0 ? void 0 : _q.sectype
          }), ((_r = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _r === void 0 ? void 0 : _r.metadata) && {
            metadata: (_s = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _s === void 0 ? void 0 : _s.metadata
          }), ((_t = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _t === void 0 ? void 0 : _t.additionalMeta) && {
            additionalMeta: (_u = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _u === void 0 ? void 0 : _u.additionalMeta
          }), ((_v = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _v === void 0 ? void 0 : _v.index) && {
            index: (_w = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _w === void 0 ? void 0 : _w.index
          }),
          recipients
        };
      }
      return null;
    }
    exports.getPayloadForAPIInput = getPayloadForAPIInput;
    function getRecipients({ env, notificationType, channel, recipients, secretType }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let addressInCAIP = "";
        if (secretType) {
          let secret = "";
          if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED) {
            if (typeof recipients === "string") {
              addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, recipients, "Recipient");
              secret = "";
              return {
                [addressInCAIP]: secret
              };
            }
          } else if (notificationType === constants_1.NOTIFICATION_TYPE.SUBSET) {
            if (Array.isArray(recipients)) {
              const recipientObject = recipients.reduce((_recipients, _rAddress) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, _rAddress, "Recipient");
                secret = "";
                return Object.assign(Object.assign({}, _recipients), { [addressInCAIP]: secret });
              }), {});
              return recipientObject;
            }
          }
        } else {
          if (notificationType === constants_1.NOTIFICATION_TYPE.BROADCAST) {
            return yield (0, helpers_1.getCAIPAddress)(env, channel, "Recipient");
          } else if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED) {
            if (typeof recipients === "string") {
              return yield (0, helpers_1.getCAIPAddress)(env, recipients, "Recipient");
            }
          } else if (notificationType === constants_1.NOTIFICATION_TYPE.SUBSET) {
            if (Array.isArray(recipients)) {
              if (Array.isArray(recipients)) {
                const recipientObject = {};
                recipients.map((_rAddress) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                  addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, _rAddress, "Recipient");
                  recipientObject[addressInCAIP] = null;
                }));
                return recipientObject;
              }
            }
          }
        }
        return recipients;
      });
    }
    exports.getRecipients = getRecipients;
    function getRecipientFieldForAPIPayload({ env, notificationType, recipients, channel }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED && typeof recipients === "string") {
          return yield (0, helpers_1.getCAIPAddress)(env, recipients, "Recipient");
        }
        return yield (0, helpers_1.getCAIPAddress)(env, channel, "Recipient");
      });
    }
    exports.getRecipientFieldForAPIPayload = getRecipientFieldForAPIPayload;
    function getVerificationProof({ senderType, signer, chainId, notificationType, identityType, verifyingContract, payload, ipfsHash, graph = {}, uuid, chatId, wallet, pgpPrivateKey, env, rules }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let message = null;
        let verificationProof = null;
        switch (identityType) {
          case constants_1.IDENTITY_TYPE.MINIMAL: {
            message = {
              data: `${identityType}+${notificationType}+${payload.notification.title}+${payload.notification.body}`
            };
            break;
          }
          case constants_1.IDENTITY_TYPE.IPFS: {
            message = {
              data: `1+${ipfsHash}`
            };
            break;
          }
          case constants_1.IDENTITY_TYPE.DIRECT_PAYLOAD: {
            const payloadJSON = JSON.stringify(payload);
            message = {
              data: `2+${payloadJSON}`
            };
            break;
          }
          case constants_1.IDENTITY_TYPE.SUBGRAPH: {
            message = {
              data: `3+graph:${graph === null || graph === void 0 ? void 0 : graph.id}+${graph === null || graph === void 0 ? void 0 : graph.counter}`
            };
            break;
          }
          default: {
            throw new Error("Invalid IdentityType");
          }
        }
        switch (senderType) {
          case 0: {
            const type = {
              Data: [{ name: "data", type: "string" }]
            };
            const domain = {
              name: "EPNS COMM V1",
              chainId,
              verifyingContract
            };
            const pushSigner = new helpers_1.Signer(signer);
            const signature = yield pushSigner.signTypedData(domain, type, message, "Data");
            verificationProof = `eip712v2:${signature}::uid::${uuid}`;
            break;
          }
          case 1: {
            const hash = CryptoJS.SHA256(JSON.stringify(message)).toString();
            const signature = yield (0, helpers_2.sign)({
              message: hash,
              signingKey: pgpPrivateKey
            });
            verificationProof = `pgpv2:${signature}:meta:${chatId}::uid::${uuid}`;
            break;
          }
          default: {
            throw new Error("Invalid SenderType");
          }
        }
        return verificationProof;
      });
    }
    exports.getVerificationProof = getVerificationProof;
    function getPayloadIdentity({ identityType, payload, notificationType, ipfsHash, graph = {} }) {
      if (identityType === constants_1.IDENTITY_TYPE.MINIMAL) {
        return `0+${notificationType}+${payload.notification.title}+${payload.notification.body}`;
      } else if (identityType === constants_1.IDENTITY_TYPE.IPFS) {
        return `1+${ipfsHash}`;
      } else if (identityType === constants_1.IDENTITY_TYPE.DIRECT_PAYLOAD) {
        const payloadJSON = JSON.stringify(payload);
        return `2+${payloadJSON}`;
      } else if (identityType === constants_1.IDENTITY_TYPE.SUBGRAPH) {
        return `3+graph:${graph === null || graph === void 0 ? void 0 : graph.id}+${graph === null || graph === void 0 ? void 0 : graph.counter}`;
      }
      return null;
    }
    exports.getPayloadIdentity = getPayloadIdentity;
    function getSource(chainId, identityType, senderType) {
      if (senderType === 1) {
        return constants_1.SOURCE_TYPES.PUSH_VIDEO;
      }
      if (identityType === constants_1.IDENTITY_TYPE.SUBGRAPH) {
        return constants_1.SOURCE_TYPES.THE_GRAPH;
      }
      return constants_1.CHAIN_ID_TO_SOURCE[chainId];
    }
    exports.getSource = getSource;
    function getCAIPFormat(chainId, address) {
      if (constants_1.SUPPORTED_CHAINS.includes(chainId)) {
        return `eip155:${chainId}:${address}`;
      }
      return address;
    }
    exports.getCAIPFormat = getCAIPFormat;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/payloads/sendNotifications.js
var require_sendNotifications = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/payloads/sendNotifications.js"(exports) {
    "use strict";
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendNotification = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var helpers_1 = require_helpers4();
    var helpers_2 = require_helpers3();
    var constants_1 = require_constants();
    var constants_2 = require_constants2();
    var axiosUtil_1 = require_axiosUtil();
    function validateOptions(options) {
      var _a, _b;
      if (!(options === null || options === void 0 ? void 0 : options.channel)) {
        throw '[Push SDK] - Error - sendNotification() - "channel" is mandatory!';
      }
      if (!(0, helpers_2.isValidPushCAIP)(options.channel)) {
        throw '[Push SDK] - Error - sendNotification() - "channel" is invalid!';
      }
      if (options.senderType === 0 && options.signer === void 0) {
        throw '[Push SDK] - Error - sendNotification() - "signer" is mandatory!';
      }
      if (options.senderType === 1 && options.pgpPrivateKey === void 0) {
        throw '[Push SDK] - Error - sendNotification() - "pgpPrivateKey" is mandatory!';
      }
      if ((options === null || options === void 0 ? void 0 : options.identityType) === constants_1.IDENTITY_TYPE.DIRECT_PAYLOAD || (options === null || options === void 0 ? void 0 : options.identityType) === constants_1.IDENTITY_TYPE.MINIMAL) {
        if (!options.notification) {
          throw '[Push SDK] - Error - sendNotification() - "notification" mandatory for Identity Type: Direct Payload, Minimal!';
        }
        if (!options.payload) {
          throw '[Push SDK] - Error - sendNotification() - "payload" mandatory for Identity Type: Direct Payload, Minimal!';
        }
      }
      const isAdditionalMetaPayload = (_a = options.payload) === null || _a === void 0 ? void 0 : _a.additionalMeta;
      const isVideoOrSpaceType = typeof ((_b = options.payload) === null || _b === void 0 ? void 0 : _b.additionalMeta) === "object" && (options.payload.additionalMeta.type === `${constants_1.VIDEO_CALL_TYPE.PUSH_VIDEO}+1` || options.payload.additionalMeta.type === `${constants_1.VIDEO_CALL_TYPE.PUSH_SPACE}+1`);
      if (isAdditionalMetaPayload && isVideoOrSpaceType && !options.chatId && !options.rules) {
        throw new Error("[Push SDK] - Error - sendNotification() - Either chatId or rules object is required to send a additional meta notification for video or spaces");
      }
    }
    function checkSimulateNotification(payloadOptions) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          const { channelFound, channelorAlias, recipient, type, env, senderType } = payloadOptions || {};
          if (senderType === 1 || channelFound)
            return false;
          const convertedRecipient = typeof recipient == "string" && (recipient === null || recipient === void 0 ? void 0 : recipient.split(":").length) == 3 ? recipient.split(":")[2] : recipient;
          return channelorAlias == convertedRecipient && type == constants_1.NOTIFICATION_TYPE.TARGETTED;
        } catch (e) {
          return true;
        }
      });
    }
    function sendNotification(options) {
      var _a;
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
          const {
            /*
              senderType = 0 for channel notification (default)
              senderType = 1 for chat notification
            */
            senderType = 0,
            signer,
            type,
            identityType,
            payload,
            recipients,
            channel,
            graph,
            ipfsHash,
            env = constants_2.ENV.PROD,
            chatId,
            rules,
            pgpPrivateKey,
            channelFound = true
          } = options || {};
          validateOptions(options);
          if (payload && payload.additionalMeta && typeof payload.additionalMeta === "object" && !payload.additionalMeta.domain) {
            payload.additionalMeta.domain = constants_1.DEFAULT_DOMAIN;
          }
          const _channelAddress = yield (0, helpers_2.getCAIPAddress)(env, channel, "Channel");
          const channelCAIPDetails = (0, helpers_2.getCAIPDetails)(_channelAddress);
          if (!channelCAIPDetails)
            throw Error("Invalid Channel CAIP!");
          const uuid = (0, helpers_1.getUUID)();
          const chainId = parseInt(channelCAIPDetails.networkId, 10);
          const API_BASE_URL = (0, helpers_2.getAPIBaseUrls)(env);
          let COMMUNICATOR_CONTRACT = "";
          if (senderType === 0) {
            const { EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_2.getConfig)(env, channelCAIPDetails);
            COMMUNICATOR_CONTRACT = EPNS_COMMUNICATOR_CONTRACT;
          }
          const _recipients = yield (0, helpers_1.getRecipients)({
            env,
            notificationType: type,
            channel: _channelAddress,
            recipients,
            secretType: payload === null || payload === void 0 ? void 0 : payload.sectype
          });
          const notificationPayload = (0, helpers_1.getPayloadForAPIInput)(options, _recipients);
          const verificationProof = yield (0, helpers_1.getVerificationProof)({
            senderType,
            signer,
            chainId,
            identityType,
            notificationType: type,
            verifyingContract: COMMUNICATOR_CONTRACT,
            payload: notificationPayload,
            graph,
            ipfsHash,
            uuid,
            // for the pgpv2 verfication proof
            chatId: (_a = rules === null || rules === void 0 ? void 0 : rules.access.data.chatId) !== null && _a !== void 0 ? _a : chatId,
            pgpPrivateKey
          });
          const identity = (0, helpers_1.getPayloadIdentity)({
            identityType,
            payload: notificationPayload,
            notificationType: type,
            graph,
            ipfsHash
          });
          const source = (yield checkSimulateNotification({
            channelFound,
            channelorAlias: options.channel,
            recipient: options.recipients,
            type: options.type,
            env: options.env,
            senderType: options.senderType
          })) ? constants_1.SOURCE_TYPES.SIMULATE : (0, helpers_1.getSource)(chainId, identityType, senderType);
          const apiPayload = Object.assign({
            verificationProof,
            identity,
            sender: senderType === 1 && !(0, helpers_2.isValidNFTCAIP)(_channelAddress) ? `${channelCAIPDetails === null || channelCAIPDetails === void 0 ? void 0 : channelCAIPDetails.blockchain}:${channelCAIPDetails === null || channelCAIPDetails === void 0 ? void 0 : channelCAIPDetails.address}` : _channelAddress,
            source,
            /** note this recipient key has a different expectation from the BE API, see the funciton for more */
            recipient: yield (0, helpers_1.getRecipientFieldForAPIPayload)({
              env,
              notificationType: type,
              recipients: recipients || "",
              channel: _channelAddress
            })
          }, rules || chatId ? {
            rules: rules !== null && rules !== void 0 ? rules : {
              access: {
                data: { chatId },
                type: constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT
              }
            }
          } : {});
          const requestURL = `${API_BASE_URL}/v1/payloads/`;
          return yield (0, axiosUtil_1.axiosPost)(requestURL, apiPayload, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        } catch (err) {
          console.error("[Push SDK] - Error - sendNotification() - ", JSON.stringify(err));
          throw err;
        }
      });
    }
    exports.sendNotification = sendNotification;
  }
});

// node_modules/@pushprotocol/restapi/src/lib/payloads/index.js
var require_payloads = __commonJS({
  "node_modules/@pushprotocol/restapi/src/lib/payloads/index.js"(exports) {
    var import_dist7 = __toESM(require_dist());
    var import_dist8 = __toESM(require_dist2());
    var import_dist9 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPACE_DISCONNECT_TYPE = exports.SPACE_ACCEPT_REQUEST_TYPE = exports.SPACE_REQUEST_TYPE = exports.ADDITIONAL_META_TYPE = exports.IDENTITY_TYPE = exports.NOTIFICATION_TYPE = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_sendNotifications(), exports);
    var constants_1 = require_constants();
    Object.defineProperty(exports, "NOTIFICATION_TYPE", { enumerable: true, get: function() {
      return constants_1.NOTIFICATION_TYPE;
    } });
    Object.defineProperty(exports, "IDENTITY_TYPE", { enumerable: true, get: function() {
      return constants_1.IDENTITY_TYPE;
    } });
    Object.defineProperty(exports, "ADDITIONAL_META_TYPE", { enumerable: true, get: function() {
      return constants_1.ADDITIONAL_META_TYPE;
    } });
    Object.defineProperty(exports, "SPACE_REQUEST_TYPE", { enumerable: true, get: function() {
      return constants_1.SPACE_REQUEST_TYPE;
    } });
    Object.defineProperty(exports, "SPACE_ACCEPT_REQUEST_TYPE", { enumerable: true, get: function() {
      return constants_1.SPACE_ACCEPT_REQUEST_TYPE;
    } });
    Object.defineProperty(exports, "SPACE_DISCONNECT_TYPE", { enumerable: true, get: function() {
      return constants_1.SPACE_DISCONNECT_TYPE;
    } });
  }
});

export {
  require_constants2 as require_constants,
  require_cjs2 as require_cjs,
  require_config,
  require_crypto_js,
  require_aes2 as require_aes,
  require_axiosUtil,
  require_validationError,
  require_getGroup,
  require_cache2 as require_cache,
  require_getGroupMembers,
  require_getGroupMemberCount,
  require_pushAPITypes,
  require_payloadHelper,
  require_helpers2 as require_helpers,
  require_progressHook,
  require_utils14 as require_utils,
  require_parseSettings,
  require_user2 as require_user,
  require_crypto5 as require_crypto,
  require_helpers3 as require_helpers2,
  require_commonjs_browser,
  require_payloads
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-NYB2LBDY.js.map

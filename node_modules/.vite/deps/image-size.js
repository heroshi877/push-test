import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'

globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
globalThis.global = globalThis.global || __global_polyfill
globalThis.process = globalThis.process || __process_polyfill

import {
  empty_exports,
  init_empty,
  require_path_browserify
} from "./chunk-5RXKYDAW.js";
import {
  require_events
} from "./chunk-LPS2SYRB.js";
import {
  require_inherits_browser
} from "./chunk-FI2GMLQC.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-O6J7OYVY.js";

// node_modules/queue/index.js
var require_queue = __commonJS({
  "node_modules/queue/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var EventEmitter = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits(Queue, EventEmitter);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end) {
      this.jobs = this.jobs.slice(begin, end);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done.call(this);
        }
        return;
      }
      var self = this;
      var job = this.jobs.shift();
      var once = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.timeout || this.timeout;
      function next(err, result) {
        if (once && self.session === session) {
          once = false;
          self.pending--;
          if (timeoutId !== null) {
            delete self.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err) {
            self.emit("error", err, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self.emit("success", result, job);
          }
          if (self.session === session) {
            if (self.pending === 0 && self.jobs.length === 0) {
              done.call(self);
            } else if (self.running) {
              self.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self.listeners("timeout").length > 0) {
            self.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err) {
          return next(err || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done.call(this, err);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self = this;
      this.on("error", onerror);
      this.on("end", onend);
      function onerror(err) {
        self.end(err);
      }
      function onend(err) {
        self.removeListener("error", onerror);
        self.removeListener("end", onend);
        cb(err, this.results);
      }
    }
    function done(err) {
      this.session++;
      this.running = false;
      this.emit("end", err);
    }
  }
});

// node_modules/image-size/dist/types/bmp.js
var require_bmp = __commonJS({
  "node_modules/image-size/dist/types/bmp.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BMP = void 0;
    exports.BMP = {
      validate(buffer) {
        return "BM" === buffer.toString("ascii", 0, 2);
      },
      calculate(buffer) {
        return {
          height: Math.abs(buffer.readInt32LE(22)),
          width: buffer.readUInt32LE(18)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/ico.js
var require_ico = __commonJS({
  "node_modules/image-size/dist/types/ico.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICO = void 0;
    var TYPE_ICON = 1;
    var SIZE_HEADER = 2 + 2 + 2;
    var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
    function getSizeFromOffset(buffer, offset) {
      const value = buffer.readUInt8(offset);
      return value === 0 ? 256 : value;
    }
    function getImageSize(buffer, imageIndex) {
      const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
      return {
        height: getSizeFromOffset(buffer, offset + 1),
        width: getSizeFromOffset(buffer, offset)
      };
    }
    exports.ICO = {
      validate(buffer) {
        if (buffer.readUInt16LE(0) !== 0) {
          return false;
        }
        return buffer.readUInt16LE(2) === TYPE_ICON;
      },
      calculate(buffer) {
        const nbImages = buffer.readUInt16LE(4);
        const imageSize = getImageSize(buffer, 0);
        if (nbImages === 1) {
          return imageSize;
        }
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
          imgs.push(getImageSize(buffer, imageIndex));
        }
        const result = {
          height: imageSize.height,
          images: imgs,
          width: imageSize.width
        };
        return result;
      }
    };
  }
});

// node_modules/image-size/dist/types/cur.js
var require_cur = __commonJS({
  "node_modules/image-size/dist/types/cur.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CUR = void 0;
    var ico_1 = require_ico();
    var TYPE_CURSOR = 2;
    exports.CUR = {
      validate(buffer) {
        if (buffer.readUInt16LE(0) !== 0) {
          return false;
        }
        return buffer.readUInt16LE(2) === TYPE_CURSOR;
      },
      calculate(buffer) {
        return ico_1.ICO.calculate(buffer);
      }
    };
  }
});

// node_modules/image-size/dist/types/dds.js
var require_dds = __commonJS({
  "node_modules/image-size/dist/types/dds.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DDS = void 0;
    exports.DDS = {
      validate(buffer) {
        return buffer.readUInt32LE(0) === 542327876;
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(12),
          width: buffer.readUInt32LE(16)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/gif.js
var require_gif = __commonJS({
  "node_modules/image-size/dist/types/gif.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GIF = void 0;
    var gifRegexp = /^GIF8[79]a/;
    exports.GIF = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 6);
        return gifRegexp.test(signature);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt16LE(8),
          width: buffer.readUInt16LE(6)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/icns.js
var require_icns = __commonJS({
  "node_modules/image-size/dist/types/icns.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICNS = void 0;
    var SIZE_HEADER = 4 + 4;
    var FILE_LENGTH_OFFSET = 4;
    var ENTRY_LENGTH_OFFSET = 4;
    var ICON_TYPE_SIZE = {
      ICON: 32,
      "ICN#": 32,
      // m => 16 x 16
      "icm#": 16,
      icm4: 16,
      icm8: 16,
      // s => 16 x 16
      "ics#": 16,
      ics4: 16,
      ics8: 16,
      is32: 16,
      s8mk: 16,
      icp4: 16,
      // l => 32 x 32
      icl4: 32,
      icl8: 32,
      il32: 32,
      l8mk: 32,
      icp5: 32,
      ic11: 32,
      // h => 48 x 48
      ich4: 48,
      ich8: 48,
      ih32: 48,
      h8mk: 48,
      // . => 64 x 64
      icp6: 64,
      ic12: 32,
      // t => 128 x 128
      it32: 128,
      t8mk: 128,
      ic07: 128,
      // . => 256 x 256
      ic08: 256,
      ic13: 256,
      // . => 512 x 512
      ic09: 512,
      ic14: 512,
      // . => 1024 x 1024
      ic10: 1024
    };
    function readImageHeader(buffer, imageOffset) {
      const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
      return [
        buffer.toString("ascii", imageOffset, imageLengthOffset),
        buffer.readUInt32BE(imageLengthOffset)
      ];
    }
    function getImageSize(type) {
      const size = ICON_TYPE_SIZE[type];
      return { width: size, height: size, type };
    }
    exports.ICNS = {
      validate(buffer) {
        return "icns" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        const bufferLength = buffer.length;
        const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(buffer, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength) {
          return imageSize;
        }
        const result = {
          height: imageSize.height,
          images: [imageSize],
          width: imageSize.width
        };
        while (imageOffset < fileLength && imageOffset < bufferLength) {
          imageHeader = readImageHeader(buffer, imageOffset);
          imageSize = getImageSize(imageHeader[0]);
          imageOffset += imageHeader[1];
          result.images.push(imageSize);
        }
        return result;
      }
    };
  }
});

// node_modules/image-size/dist/types/j2c.js
var require_j2c = __commonJS({
  "node_modules/image-size/dist/types/j2c.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.J2C = void 0;
    exports.J2C = {
      validate(buffer) {
        return buffer.toString("hex", 0, 4) === "ff4fff51";
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(12),
          width: buffer.readUInt32BE(8)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/jp2.js
var require_jp2 = __commonJS({
  "node_modules/image-size/dist/types/jp2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JP2 = void 0;
    var BoxTypes = {
      ftyp: "66747970",
      ihdr: "69686472",
      jp2h: "6a703268",
      jp__: "6a502020",
      rreq: "72726571",
      xml_: "786d6c20"
    };
    var calculateRREQLength = (box) => {
      const unit = box.readUInt8(0);
      let offset = 1 + 2 * unit;
      const numStdFlags = box.readUInt16BE(offset);
      const flagsLength = numStdFlags * (2 + unit);
      offset = offset + 2 + flagsLength;
      const numVendorFeatures = box.readUInt16BE(offset);
      const featuresLength = numVendorFeatures * (16 + unit);
      return offset + 2 + featuresLength;
    };
    var parseIHDR = (box) => {
      return {
        height: box.readUInt32BE(4),
        width: box.readUInt32BE(8)
      };
    };
    exports.JP2 = {
      validate(buffer) {
        const signature = buffer.toString("hex", 4, 8);
        const signatureLength = buffer.readUInt32BE(0);
        if (signature !== BoxTypes.jp__ || signatureLength < 1) {
          return false;
        }
        const ftypeBoxStart = signatureLength + 4;
        const ftypBoxLength = buffer.readUInt32BE(signatureLength);
        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);
        return ftypBox.toString("hex", 0, 4) === BoxTypes.ftyp;
      },
      calculate(buffer) {
        const signatureLength = buffer.readUInt32BE(0);
        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);
        let offset = signatureLength + 4 + ftypBoxLength;
        const nextBoxType = buffer.toString("hex", offset, offset + 4);
        switch (nextBoxType) {
          case BoxTypes.rreq:
            const MAGIC = 4;
            offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          case BoxTypes.jp2h:
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          default:
            throw new TypeError("Unsupported header found: " + buffer.toString("ascii", offset, offset + 4));
        }
      }
    };
  }
});

// node_modules/image-size/dist/readUInt.js
var require_readUInt = __commonJS({
  "node_modules/image-size/dist/readUInt.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readUInt = void 0;
    function readUInt(buffer, bits, offset, isBigEndian) {
      offset = offset || 0;
      const endian = isBigEndian ? "BE" : "LE";
      const methodName = "readUInt" + bits + endian;
      return buffer[methodName].call(buffer, offset);
    }
    exports.readUInt = readUInt;
  }
});

// node_modules/image-size/dist/types/jpg.js
var require_jpg = __commonJS({
  "node_modules/image-size/dist/types/jpg.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JPG = void 0;
    var readUInt_1 = require_readUInt();
    var EXIF_MARKER = "45786966";
    var APP1_DATA_SIZE_BYTES = 2;
    var EXIF_HEADER_BYTES = 6;
    var TIFF_BYTE_ALIGN_BYTES = 2;
    var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
    var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
    var IDF_ENTRY_BYTES = 12;
    var NUM_DIRECTORY_ENTRIES_BYTES = 2;
    function isEXIF(buffer) {
      return buffer.toString("hex", 2, 6) === EXIF_MARKER;
    }
    function extractSize(buffer, index) {
      return {
        height: buffer.readUInt16BE(index),
        width: buffer.readUInt16BE(index + 2)
      };
    }
    function extractOrientation(exifBlock, isBigEndian) {
      const idfOffset = 8;
      const offset = EXIF_HEADER_BYTES + idfOffset;
      const idfDirectoryEntries = readUInt_1.readUInt(exifBlock, 16, offset, isBigEndian);
      for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        if (start > exifBlock.length) {
          return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = readUInt_1.readUInt(block, 16, 0, isBigEndian);
        if (tagNumber === 274) {
          const dataFormat = readUInt_1.readUInt(block, 16, 2, isBigEndian);
          if (dataFormat !== 3) {
            return;
          }
          const numberOfComponents = readUInt_1.readUInt(block, 32, 4, isBigEndian);
          if (numberOfComponents !== 1) {
            return;
          }
          return readUInt_1.readUInt(block, 16, 8, isBigEndian);
        }
      }
    }
    function validateExifBlock(buffer, index) {
      const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index);
      const byteAlign = exifBlock.toString("hex", EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
      const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
      const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
      if (isBigEndian || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian);
      }
    }
    function validateBuffer(buffer, index) {
      if (index > buffer.length) {
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
      }
      if (buffer[index] !== 255) {
        throw new TypeError("Invalid JPG, marker table corrupted");
      }
    }
    exports.JPG = {
      validate(buffer) {
        const SOIMarker = buffer.toString("hex", 0, 2);
        return "ffd8" === SOIMarker;
      },
      calculate(buffer) {
        buffer = buffer.slice(4);
        let orientation;
        let next;
        while (buffer.length) {
          const i = buffer.readUInt16BE(0);
          if (isEXIF(buffer)) {
            orientation = validateExifBlock(buffer, i);
          }
          validateBuffer(buffer, i);
          next = buffer[i + 1];
          if (next === 192 || next === 193 || next === 194) {
            const size = extractSize(buffer, i + 5);
            if (!orientation) {
              return size;
            }
            return {
              height: size.height,
              orientation,
              width: size.width
            };
          }
          buffer = buffer.slice(i + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
    };
  }
});

// node_modules/image-size/dist/types/ktx.js
var require_ktx = __commonJS({
  "node_modules/image-size/dist/types/ktx.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KTX = void 0;
    var SIGNATURE = "KTX 11";
    exports.KTX = {
      validate(buffer) {
        return SIGNATURE === buffer.toString("ascii", 1, 7);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(40),
          width: buffer.readUInt32LE(36)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/png.js
var require_png = __commonJS({
  "node_modules/image-size/dist/types/png.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNG = void 0;
    var pngSignature = "PNG\r\n\n";
    var pngImageHeaderChunkName = "IHDR";
    var pngFriedChunkName = "CgBI";
    exports.PNG = {
      validate(buffer) {
        if (pngSignature === buffer.toString("ascii", 1, 8)) {
          let chunkName = buffer.toString("ascii", 12, 16);
          if (chunkName === pngFriedChunkName) {
            chunkName = buffer.toString("ascii", 28, 32);
          }
          if (chunkName !== pngImageHeaderChunkName) {
            throw new TypeError("Invalid PNG");
          }
          return true;
        }
        return false;
      },
      calculate(buffer) {
        if (buffer.toString("ascii", 12, 16) === pngFriedChunkName) {
          return {
            height: buffer.readUInt32BE(36),
            width: buffer.readUInt32BE(32)
          };
        }
        return {
          height: buffer.readUInt32BE(20),
          width: buffer.readUInt32BE(16)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/pnm.js
var require_pnm = __commonJS({
  "node_modules/image-size/dist/types/pnm.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PNM = void 0;
    var PNMTypes = {
      P1: "pbm/ascii",
      P2: "pgm/ascii",
      P3: "ppm/ascii",
      P4: "pbm",
      P5: "pgm",
      P6: "ppm",
      P7: "pam",
      PF: "pfm"
    };
    var Signatures = Object.keys(PNMTypes);
    var handlers = {
      default: (lines) => {
        let dimensions = [];
        while (lines.length > 0) {
          const line = lines.shift();
          if (line[0] === "#") {
            continue;
          }
          dimensions = line.split(" ");
          break;
        }
        if (dimensions.length === 2) {
          return {
            height: parseInt(dimensions[1], 10),
            width: parseInt(dimensions[0], 10)
          };
        } else {
          throw new TypeError("Invalid PNM");
        }
      },
      pam: (lines) => {
        const size = {};
        while (lines.length > 0) {
          const line = lines.shift();
          if (line.length > 16 || line.charCodeAt(0) > 128) {
            continue;
          }
          const [key, value] = line.split(" ");
          if (key && value) {
            size[key.toLowerCase()] = parseInt(value, 10);
          }
          if (size.height && size.width) {
            break;
          }
        }
        if (size.height && size.width) {
          return {
            height: size.height,
            width: size.width
          };
        } else {
          throw new TypeError("Invalid PAM");
        }
      }
    };
    exports.PNM = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        return Signatures.includes(signature);
      },
      calculate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        const type = PNMTypes[signature];
        const lines = buffer.toString("ascii", 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
      }
    };
  }
});

// node_modules/image-size/dist/types/psd.js
var require_psd = __commonJS({
  "node_modules/image-size/dist/types/psd.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PSD = void 0;
    exports.PSD = {
      validate(buffer) {
        return "8BPS" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(14),
          width: buffer.readUInt32BE(18)
        };
      }
    };
  }
});

// node_modules/image-size/dist/types/svg.js
var require_svg = __commonJS({
  "node_modules/image-size/dist/types/svg.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SVG = void 0;
    var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
    var extractorRegExps = {
      height: /\sheight=(['"])([^%]+?)\1/,
      root: svgReg,
      viewbox: /\sviewBox=(['"])(.+?)\1/,
      width: /\swidth=(['"])([^%]+?)\1/
    };
    var INCH_CM = 2.54;
    var units = {
      cm: 96 / INCH_CM,
      em: 16,
      ex: 8,
      m: 96 / INCH_CM * 100,
      mm: 96 / INCH_CM / 10,
      pc: 96 / 72 / 12,
      pt: 96 / 72
    };
    function parseLength(len) {
      const m = /([0-9.]+)([a-z]*)/.exec(len);
      if (!m) {
        return void 0;
      }
      return Math.round(parseFloat(m[1]) * (units[m[2]] || 1));
    }
    function parseViewbox(viewbox) {
      const bounds = viewbox.split(" ");
      return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2])
      };
    }
    function parseAttributes(root) {
      const width = root.match(extractorRegExps.width);
      const height = root.match(extractorRegExps.height);
      const viewbox = root.match(extractorRegExps.viewbox);
      return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width && parseLength(width[2])
      };
    }
    function calculateByDimensions(attrs) {
      return {
        height: attrs.height,
        width: attrs.width
      };
    }
    function calculateByViewbox(attrs, viewbox) {
      const ratio = viewbox.width / viewbox.height;
      if (attrs.width) {
        return {
          height: Math.floor(attrs.width / ratio),
          width: attrs.width
        };
      }
      if (attrs.height) {
        return {
          height: attrs.height,
          width: Math.floor(attrs.height * ratio)
        };
      }
      return {
        height: viewbox.height,
        width: viewbox.width
      };
    }
    exports.SVG = {
      validate(buffer) {
        const str = String(buffer);
        return svgReg.test(str);
      },
      calculate(buffer) {
        const root = buffer.toString("utf8").match(extractorRegExps.root);
        if (root) {
          const attrs = parseAttributes(root[0]);
          if (attrs.width && attrs.height) {
            return calculateByDimensions(attrs);
          }
          if (attrs.viewbox) {
            return calculateByViewbox(attrs, attrs.viewbox);
          }
        }
        throw new TypeError("Invalid SVG");
      }
    };
  }
});

// node_modules/image-size/dist/types/tiff.js
var require_tiff = __commonJS({
  "node_modules/image-size/dist/types/tiff.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TIFF = void 0;
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var readUInt_1 = require_readUInt();
    function readIFD(buffer, filepath, isBigEndian) {
      const ifdOffset = readUInt_1.readUInt(buffer, 32, 4, isBigEndian);
      let bufferSize = 1024;
      const fileSize = fs.statSync(filepath).size;
      if (ifdOffset + bufferSize > fileSize) {
        bufferSize = fileSize - ifdOffset - 10;
      }
      const endBuffer = Buffer.alloc(bufferSize);
      const descriptor = fs.openSync(filepath, "r");
      fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
      fs.closeSync(descriptor);
      return endBuffer.slice(2);
    }
    function readValue(buffer, isBigEndian) {
      const low = readUInt_1.readUInt(buffer, 16, 8, isBigEndian);
      const high = readUInt_1.readUInt(buffer, 16, 10, isBigEndian);
      return (high << 16) + low;
    }
    function nextTag(buffer) {
      if (buffer.length > 24) {
        return buffer.slice(12);
      }
    }
    function extractTags(buffer, isBigEndian) {
      const tags = {};
      let temp = buffer;
      while (temp && temp.length) {
        const code = readUInt_1.readUInt(temp, 16, 0, isBigEndian);
        const type = readUInt_1.readUInt(temp, 16, 2, isBigEndian);
        const length = readUInt_1.readUInt(temp, 32, 4, isBigEndian);
        if (code === 0) {
          break;
        } else {
          if (length === 1 && (type === 3 || type === 4)) {
            tags[code] = readValue(temp, isBigEndian);
          }
          temp = nextTag(temp);
        }
      }
      return tags;
    }
    function determineEndianness(buffer) {
      const signature = buffer.toString("ascii", 0, 2);
      if ("II" === signature) {
        return "LE";
      } else if ("MM" === signature) {
        return "BE";
      }
    }
    var signatures = [
      // '492049', // currently not supported
      "49492a00",
      "4d4d002a"
    ];
    exports.TIFF = {
      validate(buffer) {
        return signatures.includes(buffer.toString("hex", 0, 4));
      },
      calculate(buffer, filepath) {
        if (!filepath) {
          throw new TypeError("Tiff doesn't support buffer");
        }
        const isBigEndian = determineEndianness(buffer) === "BE";
        const ifdBuffer = readIFD(buffer, filepath, isBigEndian);
        const tags = extractTags(ifdBuffer, isBigEndian);
        const width = tags[256];
        const height = tags[257];
        if (!width || !height) {
          throw new TypeError("Invalid Tiff. Missing tags");
        }
        return { height, width };
      }
    };
  }
});

// node_modules/image-size/dist/types/webp.js
var require_webp = __commonJS({
  "node_modules/image-size/dist/types/webp.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WEBP = void 0;
    function calculateExtended(buffer) {
      return {
        height: 1 + buffer.readUIntLE(7, 3),
        width: 1 + buffer.readUIntLE(4, 3)
      };
    }
    function calculateLossless(buffer) {
      return {
        height: 1 + ((buffer[4] & 15) << 10 | buffer[3] << 2 | (buffer[2] & 192) >> 6),
        width: 1 + ((buffer[2] & 63) << 8 | buffer[1])
      };
    }
    function calculateLossy(buffer) {
      return {
        height: buffer.readInt16LE(8) & 16383,
        width: buffer.readInt16LE(6) & 16383
      };
    }
    exports.WEBP = {
      validate(buffer) {
        const riffHeader = "RIFF" === buffer.toString("ascii", 0, 4);
        const webpHeader = "WEBP" === buffer.toString("ascii", 8, 12);
        const vp8Header = "VP8" === buffer.toString("ascii", 12, 15);
        return riffHeader && webpHeader && vp8Header;
      },
      calculate(buffer) {
        const chunkHeader = buffer.toString("ascii", 12, 16);
        buffer = buffer.slice(20, 30);
        if (chunkHeader === "VP8X") {
          const extendedHeader = buffer[0];
          const validStart = (extendedHeader & 192) === 0;
          const validEnd = (extendedHeader & 1) === 0;
          if (validStart && validEnd) {
            return calculateExtended(buffer);
          } else {
            throw new TypeError("Invalid WebP");
          }
        }
        if (chunkHeader === "VP8 " && buffer[0] !== 47) {
          return calculateLossy(buffer);
        }
        const signature = buffer.toString("hex", 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
          return calculateLossless(buffer);
        }
        throw new TypeError("Invalid WebP");
      }
    };
  }
});

// node_modules/image-size/dist/types.js
var require_types = __commonJS({
  "node_modules/image-size/dist/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typeHandlers = void 0;
    var bmp_1 = require_bmp();
    var cur_1 = require_cur();
    var dds_1 = require_dds();
    var gif_1 = require_gif();
    var icns_1 = require_icns();
    var ico_1 = require_ico();
    var j2c_1 = require_j2c();
    var jp2_1 = require_jp2();
    var jpg_1 = require_jpg();
    var ktx_1 = require_ktx();
    var png_1 = require_png();
    var pnm_1 = require_pnm();
    var psd_1 = require_psd();
    var svg_1 = require_svg();
    var tiff_1 = require_tiff();
    var webp_1 = require_webp();
    exports.typeHandlers = {
      bmp: bmp_1.BMP,
      cur: cur_1.CUR,
      dds: dds_1.DDS,
      gif: gif_1.GIF,
      icns: icns_1.ICNS,
      ico: ico_1.ICO,
      j2c: j2c_1.J2C,
      jp2: jp2_1.JP2,
      jpg: jpg_1.JPG,
      ktx: ktx_1.KTX,
      png: png_1.PNG,
      pnm: pnm_1.PNM,
      psd: psd_1.PSD,
      svg: svg_1.SVG,
      tiff: tiff_1.TIFF,
      webp: webp_1.WEBP
    };
  }
});

// node_modules/image-size/dist/detector.js
var require_detector = __commonJS({
  "node_modules/image-size/dist/detector.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detector = void 0;
    var types_1 = require_types();
    var keys = Object.keys(types_1.typeHandlers);
    var firstBytes = {
      56: "psd",
      66: "bmp",
      68: "dds",
      71: "gif",
      73: "tiff",
      77: "tiff",
      82: "webp",
      105: "icns",
      137: "png",
      255: "jpg"
    };
    function detector(buffer) {
      const byte = buffer[0];
      if (byte in firstBytes) {
        const type = firstBytes[byte];
        if (types_1.typeHandlers[type].validate(buffer)) {
          return type;
        }
      }
      const finder = (key) => types_1.typeHandlers[key].validate(buffer);
      return keys.find(finder);
    }
    exports.detector = detector;
  }
});

// node_modules/image-size/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/image-size/dist/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = exports.setConcurrency = exports.imageSize = void 0;
    var fs = (init_empty(), __toCommonJS(empty_exports));
    var path = require_path_browserify();
    var queue_1 = require_queue();
    var types_1 = require_types();
    var detector_1 = require_detector();
    var MaxBufferSize = 512 * 1024;
    var queue = new queue_1.default({ concurrency: 100, autostart: true });
    function lookup(buffer, filepath) {
      const type = detector_1.detector(buffer);
      if (type && type in types_1.typeHandlers) {
        const size = types_1.typeHandlers[type].calculate(buffer, filepath);
        if (size !== void 0) {
          size.type = type;
          return size;
        }
      }
      throw new TypeError("unsupported file type: " + type + " (file: " + filepath + ")");
    }
    function asyncFileToBuffer(filepath) {
      return __awaiter(this, void 0, void 0, function* () {
        const handle = yield fs.promises.open(filepath, "r");
        const { size } = yield handle.stat();
        if (size <= 0) {
          yield handle.close();
          throw new Error("Empty file");
        }
        const bufferSize = Math.min(size, MaxBufferSize);
        const buffer = Buffer.alloc(bufferSize);
        yield handle.read(buffer, 0, bufferSize, 0);
        yield handle.close();
        return buffer;
      });
    }
    function syncFileToBuffer(filepath) {
      const descriptor = fs.openSync(filepath, "r");
      const { size } = fs.fstatSync(descriptor);
      if (size <= 0) {
        fs.closeSync(descriptor);
        throw new Error("Empty file");
      }
      const bufferSize = Math.min(size, MaxBufferSize);
      const buffer = Buffer.alloc(bufferSize);
      fs.readSync(descriptor, buffer, 0, bufferSize, 0);
      fs.closeSync(descriptor);
      return buffer;
    }
    module.exports = exports = imageSize;
    exports.default = imageSize;
    function imageSize(input, callback) {
      if (Buffer.isBuffer(input)) {
        return lookup(input);
      }
      if (typeof input !== "string") {
        throw new TypeError("invalid invocation");
      }
      const filepath = path.resolve(input);
      if (typeof callback === "function") {
        queue.push(() => asyncFileToBuffer(filepath).then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));
      } else {
        const buffer = syncFileToBuffer(filepath);
        return lookup(buffer, filepath);
      }
    }
    exports.imageSize = imageSize;
    exports.setConcurrency = (c) => {
      queue.concurrency = c;
    };
    exports.types = Object.keys(types_1.typeHandlers);
  }
});
export default require_dist4();
//# sourceMappingURL=image-size.js.map

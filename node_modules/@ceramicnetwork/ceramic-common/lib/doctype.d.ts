/// <reference types="node" />
import CID from 'cids';
import { EventEmitter } from "events";
import type { Context } from "./context";
import DocID from '@ceramicnetwork/docid';
export declare enum SignatureStatus {
    GENESIS = 0,
    PARTIAL = 1,
    SIGNED = 2
}
export declare enum AnchorStatus {
    NOT_REQUESTED = 0,
    PENDING = 1,
    PROCESSING = 2,
    ANCHORED = 3,
    FAILED = 4
}
export interface AnchorRecord {
    prev: CID;
    proof: CID;
    path: string;
}
export interface AnchorProof {
    chainId: string;
    blockNumber: number;
    blockTimestamp: number;
    txHash: CID;
    root: CID;
}
export interface DocMetadata {
    controllers: Array<string>;
    schema?: string;
    tags?: Array<string>;
    isUnique?: boolean;
    [index: string]: any;
}
export interface DocParams {
    metadata?: DocMetadata;
    [index: string]: any;
}
export interface DocNext {
    content?: any;
    controllers?: Array<string>;
    metadata?: DocMetadata;
}
export interface DocState {
    doctype: string;
    content: any;
    next?: DocNext;
    metadata: DocMetadata;
    signature: SignatureStatus;
    anchorStatus: AnchorStatus;
    anchorScheduledFor?: number;
    anchorProof?: AnchorProof;
    log: Array<CID>;
}
export interface DocOpts {
    applyOnly?: boolean;
    skipWait?: boolean;
}
export declare abstract class Doctype extends EventEmitter {
    private _state;
    private _context;
    constructor(_state: DocState, _context: Context);
    get id(): DocID;
    get doctype(): string;
    get content(): any;
    get metadata(): DocMetadata;
    get controllers(): Array<string>;
    get head(): CID;
    get state(): DocState;
    set state(state: DocState);
    set context(context: Context);
    get context(): Context;
    abstract change(params: DocParams, opts?: DocOpts): Promise<void>;
}
export declare function DoctypeStatic<T>(): <U extends T>(constructor: U) => any;
export interface DoctypeConstructor<T extends Doctype> {
    new (state: DocState, context: Context): T;
    makeGenesis(params: DocParams, context?: Context, opts?: DocOpts): Promise<Record<string, any>>;
}
export interface DoctypeHandler<T extends Doctype> {
    name: string;
    doctype: DoctypeConstructor<T>;
    applyRecord(record: any, cid: CID, context: Context, state?: DocState): Promise<DocState>;
}
//# sourceMappingURL=doctype.d.ts.map